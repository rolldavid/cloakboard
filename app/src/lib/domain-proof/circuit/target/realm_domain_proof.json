{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"8679633988558496103","abi":{"parameters":[{"name":"partial_data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":640,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"partial_hash","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"full_data_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"jwt_pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"public"},{"name":"jwt_pubkey_redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"sub_bytes","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"account_address","type":{"kind":"field"},"visibility":"private"},{"name":"domain","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"account_commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"819864067177566446":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"},"1366570298883875465":{"error_kind":"string","string":"char before domain is not '@'"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2707472466662157409":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"3069463366184932666":{"error_kind":"string","string":"domain mismatch"},"4888263087975742338":{"error_kind":"string","string":"sub mismatch"},"5624732299715428208":{"error_kind":"string","string":"incorrect value for claim"},"5814456561209054291":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"5899151545213940874":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"6787038721954133095":{"error_kind":"string","string":"sub length mismatch"},"7287311796025951795":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"7688826323084302732":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"9752593157046867219":{"error_kind":"string","string":"haystack length of size 0 not supported"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"11544899148041293964":{"error_kind":"string","string":"partial_data length is too long"},"12087256528359734805":{"error_kind":"string","string":"needle length of size 0 not supported"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13760842493235367146":{"error_kind":"string","string":"invalid nullifier"},"14034844536132599094":{"error_kind":"string","string":"invalid account commitment"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17568106868988118403":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"18287357528562917927":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"}}},"bytecode":"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","debug_symbols":"7P3d0uy6cp6J3ss6HgcEMvHnW+nY4VC71R2KUEgdtrxPHLr3XUiQ71NjzvWxWKyabu8O+cB6NDW+TDILSBKJF8n/8bf/4x//9//+f/3nf/qX//Nf/9vf/tP/9j/+9r//13/653/+p//rP//zv/6Xf/i3f/rXf3n81//xt23+f3U8/sew9OtBSZRFJnJREVVRE3XR2KltmyiJsshELiqiKgofeVIXjYPSJgofNin+wh+U4/9aJiVRFtlBFldQJ8Xftgd5/G2flERZZCIXFVEVhb0xqYvGQWUTJVEWmciPqypFVEW65tJF46C6iZIofLR///W3NEdDSvN/9+3xvyYTuWj69DSpHhSx8zwp/tsj7smmJ/dJSZRFpn/noiLCShN10TgofpVF4cMe95DXPRRdbxW1g+JX9zIp/l3VlQc1UReNg9Z9Vd1X1X1V3VfVfbXjvsp23NeiJuqicVDc16IkyqKwMuMeY6fMuMeIKTMSMWLKjHGMmEUuKqIqaqIukuUYMYuSKItM5KIiqqJ2UAt7M/YtibLIRGFvRrIVURU1UReNg/omSqLwUR8jxGKEzOjkOvbo7FREVdREXTQOmtHZKYmySD6qfFT5qPJR5aPKx7zr3Lb9DnNL+x3mZvsd7pREWWQiFxVRFTVRF8nHkI8hH0M+hnwM+RjyMcLHHEmjibpo7JS3TRR/WybFv6uT4t89MmdOmyiJ4lrGJBO5qIjmtfRt0ryWniZNHz1Pmj7645rzfD7slETTR5/XN3Nc7vP6souKqIqaqIvGQRY+5r1ZEmWRieI+5vVZEVVR+JgxsC4aB/kmSqIsMpGLiqiK5MPlw+WjyEeRjyIfMXv6jH3MlDFjHzNlzKuPmbIoi0zkoiKqoibqonFQk48mH00+mnw0+Wjy0cLH/M1bE3XROChm3qKwMsdGzKMxf9+YR6NNGgfFPFoUVzUjFPNokYlcFFc14zfnkW0zfnMe2TbH7pxHts1rnvMoyOY82ilNskl5kk8ykYuKqIqaqIvCx+PeLG2iJMqi8NEmuSh89ElVFD7GpC6aPtLjLm3OwZ2SKItM5KIiqqIm6iL5MPkw+TD5MPkw+TD5MPkw+TD5MPlw+XD5cPlw+XD5cPlw+XD5cPlw+SjyUeSjyEeRjyIfRT6KfBT5KPJR5KPKR5WPKh9VPqp8VPmo8lHlo8pHlY8mH00+mnw0+Wjy0eSjyUeTjyYfTT66fHT56PLR5aPLR5ePLh9dPrp8dPkY8jHkY8jHkI8hH0M+hnwM+RjyMQ4fvm2iJMoiE7moiKqoibpIPpJ8JPlI8pHkI8lHko8kH0k+knxonrvmuWueu+a5a5675rlrnrvmuWueu+a5a5675rlrnrvmua+5+sinvuZlnhQ5rE5yURGFX5vURF00DlrzMiiJsshELioi+SjyUeSjyEeVjyofaw76pPjbMin+tk0aB635FpREWWQiFxVRFTWRfDT56PLR5aPLR5ePNbf6pPjbx9PAYx7l+RvFPFqURSZyURFVURN10dipbJsoibLIRC4qorD3GDkl5kfOk+JvfZKJXFREVdREXTQOivmxKInkI8tHlo8sH1k+snzE/Mhl0jgo5seiJMqisFcnxd+2SfG3j9+oxPNtURLNv7UZoZhHi1xURPP6ZjWnxDya9ZoS82jWa0rMo1mvKTGPFiVR+JjXF/NoVmlKzKNFRVRFTdRF46CYR7MKUmIeLcoiE4WPPqmIqqiJumgcFPNtURJlkYnko8lHk48mH00+mnzE3JrVoRLPrVmVKTG3FjVRF42DYr4tSqIsMpGL5GPIx5CPIR/j8FG3TRQ+8qQsMlFYeYyDGk+hWSuqMctm3abGLFtkoriqMqmIqqiJumgcFLNsURJlkYnkI8tHlo8sH1k+snzEjJoVoRozalaEarxFLmqiLhoHxSxblERhb0wykYuKqIqaqB8U82hWk2rMmVlNqjFnFjVRF42DYs4sSqKwN3/BmDOLXBQ+5q8ac2ZRE4WP+UvH/JjVnxrzY5GJiiiszGjErAiKJ07pk5IorMz77frbNcb7XuHeyUQuKqIqaqJ5zfWocAdFhXunJMoiE7moiKqoibpIPpJ8JPlI8pHkI2ZFjUp4EVVR2LO9/v14ed/r34/X/UkuKqIqaqK4vlknj9EeFM+URUmURSZyURFVURPJh8mHy4fLh8uHy0fMitr2WvxOVRT2+l5jt3rU2B8LmL2yvlMVNVEXjYNiVixKoml51vBazIpFLiqiKmoHxVNjVv1azIBZ92nxhFhURFXURF00Dor5MWtzLebHoiwKH3McxApoURGFj3lH8dSYtbkWT41FSWSi+IsZ55gzi+KqHhHv2/EXPcZ9CWqiLhoHxbhflERZNP3OCl+Pcb+oiKqoibpoHBRPg0VJlEXykeUjy0eWjywfWT5ifsy6Y4/5sSiJwl6eFH9rkyJWY9I4KMb9oiTKori+MslFRVRFTdRF46B451qURFkkH0U+inwU+SjyUeQjZsqsbfaYKYuSKOy1SfG3c5TEc2HWXnvMhUVJlEUmclERVdG0PGuRPebHonFQzI9FSZRF096Yv1a8Qc2KYY+5EBRzYVESZZGJXBT25i8dM2VRE4WPec3xdJk04umyKHyUSWGvTiqiKuoHxZyZFcgRc2ZRXFWfpL9Y435MyiITuejhzWdVcsxxv1MTddE4aI77nZIoi0zkIvkw+TD5MPkw+XD58PCRJmWRicJenhR/+4j4iHE/K64jxv2iLDKRi+L65q9QqqiJumgcVDdREmWRiVwkH1U+qnxU+ajy0eSjhY/5q7YsMlHYm+Ogxd/OcdDjb+cI61lkotgtmH8RO0mLqih2sMJKF42DRtibURsmclERzaua1Zkx58JOXTR2StucDD6LNw9M4HQzCzkPnH5mVeSBDhawgg3sezAeOIRpAxOYQQMdLGAF4y7mLtiWNzCBGYy7KIEOFrCCcRc1sINDGFNwFl0eGN7icmISzrLLA6e3HPGNabhjASs4veWIekzFHYcwJuOO01uOnyWm444GOljAuk/OBzawg0NYNjCBGTTQwQL2PammLWZnjv8a03NHAx2M640fK6bojg3sYEQnXMQ03TG8xS8UEzXHLxQzdUcHC1jB44n5wA4OYTzadkxgBg10sIBxFwuHcGxgAuMuYkTFbN/RwQLOu7AYUTHjd+zg9GahNok5P4tFD5zeZrXogdPbLA090EAHCxjeSmADOziEMednieiBCcyggQ6W/Q0upfXaubCBHRzC9eq5MIEZNNDBeLeO643ZPUtVKXQpB2bQwLjeHljACjYwojMChzBm9y4Mmt6WHihm944GOljAWFYtYw3s4BDGw3nHBGbQQAfnXYQqKaQbBw5hPJB3jLuIoMac39FAB+MuYkTFnN+xgeEtfpaY86EHCuGLhyAolC/uEd+Y8zsa6GB4ixuKOb9jAzs4vYVGKAQiByYwgwZGzOLSY87vWMEGdnAI4wV4xwRm0MBY8i2MSlfoq2J2h6gpx+zeMYMGRpGmBRawgg3s4BCmDUxgBmfUQ68U8pEDG9jBiPocGiEhOTCBGYy78EAHCxjeQpoWT/TQLoWUxEtcWTzRZ3UrhZjkwARmMLyNQAcLWMHpbdZ1UohKDhzCmPM7JjBiFpe+6pELHSxgBRvYwSEsG5jAeRc1BkE8u3esYAPjLuIXijm/MOb8jgnMoIEOFrCCsR+yNINhNy4yZveOGQy78cPG7N6xgBWMu1h24y7il4/ZXeOHjdkdWS7H7N5xegvJWI7ZHZqxkKkcWMAKNrCDQxjP+R2ntxY3H8/5HQ10MLzFsI/n/I4NPDaW0lKyBIZsxUMmFroVj+dbCFcOLGDYXbLMoT9bm3E5MP5t2I15vGMDOziEMY93TGAGTS7WFtzCAlawgR0Mb/PXDEHKgQkMbyNwxmFWktISpSwLhjfDm+HN8LZ27gLX1t3CBBKzeErPylQKKcqBDZwx6+vfDuHa9o7rXfveCzNooIMFrGADu3DtdcdvHDO2L7GwgQ7GXax/G3ZjwGhnPO1SlIVDuDbHFyYwgwY6GNFZ2MEhjBm74/yNewzamLE7Ghh3EeMsZuyO8VvE0IgZu2MHhzBm7I4JzGB4i6DGjB0xuGLGjviNY8aO+GFjxu7YweltLBX2BiZwepsFqxS6lAMdLGD8QjmwgR0cwiVPWZjADBroYNvVeikEKT4LXikUKTvGnN8x7qIFZtBAB+MuemDEbAQ+vJVZi0ohTSlbyLXnnN9xzvmyxZXNOV9iFRrylAMNdLCAFWxgB8Nb3LFvYAIzGN5KoIMFrLvEMYX6ZccSdiNmJYEZDLsRqBLXG4GSKvSxDIh/GzGrBjpYwAo2sINDuKSg4WJpQRdmcHpLCx0s4PQWhaXQupQ1jObsLlEs8sZddLx1vHW8hSJ7RwcLWMEmXBLsCPWcxyUtzKCBcRcR9VHACjYw7iJ+ljmPS9SCQhRTItOGKqZEqSdkMQdOb1HUCWFMiedFKGMOrGADOziEcx4fmMDwFgcZkoEOFjC8xXGF1MAOjl1JnkJQc2DYLYEOFjDsrn8b1zsDFdKYJcMPbUyJakeJWbhjAzs4hDELd0xgBk0uQpy9YwHD2zq00MAOTm9ROgn5TInSSehnSpROQkCzGyt4K3greAsZ944N7OAQhry7pX//9TefxyviJaLMEk28Q+zURF00DlrXa7ucdacsMtH8zWaRJl4ddqqiJuqicVDdREmURSaSjyofVT6qfFT5qPLR5KPJR5OPJh9NPpp8NPlo8hEZZ1aX4nViUd9ESZRFJnJREVVRE8lHl48hH0M+hnwM+RjyMeRjyMeQjyEf4/ARbw47hY+2y1l3Ch99l7PuNH3MylO8M+zURF00Doo8syiJsshELpKPJB9JPiK/zCJWvDwsyuEj73LWncKH7XLWncKH73LWncJH3eWsO3VR+Gi7nHWn8NF3OetO4WPKJ+NtYVERVVETddE4KDLUoiTS7xEvCYtcVI5fZs3zvstjd9Lv4fo9in6Pot+j6Pco+j1irpZtF7buNL3NItB6F1jURNPbrMmsF4GgmI2LprdZhYm3gJ1M5KLw4bvYdacm6qJxUMzGRUmURSaKvy27nHX9tzWPxi5nLbPcsx7fi6qoibpo7LSe3IuSKItM5KIiqqIm6iL5WPPIdtnrTllk+3hez2o/ZK87HWN8PagXddE4aM2justed4rra7tgdae4y74LVncyUdzl2EWsO1XRvIJZvFpP6UXjoJgBi6aPmnZh604mclERVVETddE4KJ5gs4IUz9L9v0UMyi5JLVOcFZLUnbLIRC4qoiqKKyi7JHWncVDMikVJlEUmclERVZF8NPlo8tHlo8tHl4+YFbPEVeIZtSh8tF26uiiePbPoFaLTneL/OnbR6U5dNK9gVsFCdLpTEs0raGkXne7koiKaPtohSd2pi8ZBMSsWJVEWmchF8be2C0zXf4vnwixehcB0pypqoi4aB8WsWJREWWQi+TD5MPkw+TD5MPmI0T7XISEmLfM9uq53uPi/joPWO1xQXEvbpaY7mchFRVRFTdRF46CYH4vko8pHlY8qH1U+qnxU+ajyUeUj5sesvYUkdacsMpGLiqiKmqiLxkFdPrp8dPno8tHlo8tHzI9ZEKzxDreoi8ZB8Q63aP5tT7t0tcySXUhXyyyRhXR1pySa1zIrViFd3clFRRTXUnfpapnFqpCulllpCulqmYWmkK7ulETTx1zqhnS1jEO6ulMRVVETddE4KJ4fsz4VLR52yiITRUz7LnHdqYrCh+0S153GQTHfZvkjJK47ZZGJXFREVdREXTQOcvlw+XD5cPlw+XD5iNk461ghbC2j7cLWMkLi6qIiqqIm6qJxUMy8RUmURfJR5aPKR5WPKh9VPubMq9she90pibLIRG1S2oWtdcu7sLVuvgtbdzKRTyq7sHWnKmqiPqnuYte6tV3sWmftKsSudZaY2sgiE00fs3zU5nyrs3oUUtidmqiLxk59zsGdkmj6mIWnPufgTi4qovDhu4x2p/BRdhntohQ+DhntTuGj7TLanVxURFXURF00DsqbKInkI8tHlo8sH1k+snxk+cjyYfJh8mHyYfJh8mHyYfJh8mHyYfLh8uHy4fLh8uHy4fLh8uHy4fLh8lHko8hHkY8iH0U+inwU+SjyUeSjyEeVjyofVT6qfFT5qPJR5aPKR5WPKh9NPpp8NPlo8tHko8lHk48mH00+mnx0+ejy0eWjy0eXjy4fXT66fHT56PIx5GPIx5CPIR9DPoZ8DPkY8jHkYxw+xraJkiiLTOSiIqqiJuoi+UjykeRD83xong/N86F5PjTPh+b50DwfmudD83xong/N86F5PjTPh+b5WHO17zLfOmvOY81L22W+O3XR9JsPme9OSZRFJnJREVVRE3WRfBT5KPJR5KPIR5GPmIOzNB4y3zqL2SHzrbMSHTLfnUzkoiKqoibqonFQzLdF8tHko8lHk48mH00+Ym7NkncIfuuseIfgt86Cdwh+dyqiKmqiLhoHxTxalERZJB9DPoZ8DPkY8jEOH0vvW5fSMGbIEhLGFLGlAq5gAzs4hDFPdkxgBg10EG8JbwlvCW8JbxlvMWWiIh963wMNdLCAYTeUp/HgC11jaHirLZGvgQ6GhQhfzLIdG9jBuN6Ib8y0EPyFhreG4C80vNWXstdAB6c3l4a3ujS8B3ZwCGPOuTS8B2YwvMUdx7zbsYAVDG8hsI1n4o5DGLPUpfc9MIMGOljACuKt4q3ireGt4a3hLaanLxVwWJCGd8d4+rk0vAdm0EAHC1jBBuKt423gbeBt4G3gLeawS9l7YD0whLt1KQ3j6VaWnDf+rP3aJboHVnBeZFl63w4OYUzeHROYQQMdLGAF8ZbwlvCW8ZbxlvEW07QsXW5YCIljvLMujJfWHROYQQMdDLshIY3Ju2MDOziEMXl3TGAYi/jGLAydYGhtd4xZuGMCM2igg2F3yW4r2MDpLSSDocDdMWbhjtNbKPdCa1vr0uUWsIIdDGMRqJhkO86LDC1dSGkPDGNLjIuFmC2huAz164EVbGAHhzBmy45xFxGSmC07GuhgASvYwA6OA0Mpe2ACM2iggwWsYHgL9WBMsh2HMKbT0hTGxFkywJg4S5UYE2fHDg5hTJwd5/U2aWIPNNDBAlawgR0cwphkO+LN8GZ4M7wZ3gxvMclCUxia2AOHMJ6Foc8InWsNgUHoXOvSQMYk23EIY5LtmMAMGuhguIhIxiTbsYEdHMKYZDuG3fjlYzqFvDCaqh3YwSGMmbVjAjM47YZAMcStBxZwegv1YIhbD+zg9BZCwpCx1hDxhYz1QAcrGH8Wv0XMwh3nRYbYLvSo+79dcyjEgWsOLUxgBg10sIBxDS2wgR0cwnhQ7ZjADBroYAHxlvCW8JbwlvGW8RbzbWn/Yr7t6GDYXXLTaWEpAmMOLVVizKEdDXSwgPN6h/SoB3ZwCONBNaRHPTCDBjpYQLw53hxvjreCt4K3mHohWwyhyYEOht2lJg0LSzcaFkIvGTNrRwcLWMEGdnAIY76FvDA0JAdm0EAHCxh2lyw0LMQPGzNrRwMdLGAFG/iw20LXGEqRHefUOzBNXBLSDBroEyUsbaFVDHHIgePAEIUcGH8m3eiBdWLI3zb+LObQru8sYAUbGI7br10LumPewARm0EAHC1jBBuIt483wZngzvBneLLyFitIKWMGwGxrIOYfaEjN6WIg7dgcLWMEGzutdwsc5h3acc+jABGbQQAcLWMEG4q3greKt4q3ireKthrcYBLWAFQy7MXZaWIix08LCknoWsIKxZ7H+rINDGJt5OyYwg+EigtodLGAFG9jBIYz5tmMCM4i3gbeBtxHeYsDELNyxHxg6krZrQaeFXQAaFtqvXep5YBPOR11bCtH5UGu7qNPBaQH5ZkO+2ZBvtqXDjAmZJd88cF7Z0jXGhFy6xpiQURkJUeeBBaxgAzs4hDEhd0xgBvFmeDO8Gd4Mb4Y3w5vjzfHmeHO8Od4cb443x5vjzfFW8FbwVvBW8FbwVvBW8FbwVvBW8FbxVvFW8VbxVvFW8VbxVvFW8Vbx1vDW8Nbw1vDW8Nbw1vDW8Nbw1vDW8dbx1vHW8dbx1vHW8dbx1vHW8TbwNvA28DbwNvA28DbwFnM+iochnGlx5jmUMy0qhiGdaVEQDO3MgRk0MOz2wLAws0Z0Y9v/a0z0KB5GP7YDOziEMdGjjhg92Y7/mkEDHSwg3jLeMt5iokd9MrQzLaqLIZ45MIPhzQMdLGAFGxjeSuAQxkTfMbxFqGOiR8krOrq1vZv+9BbVpOjp1qIWFE3dDmxgB4cwJvqOCcxgeIvLiYkeFaIQ5LSoEIUip0V9JyQ5B3YwvMXPHRM9Kjl1TfT1XzNo4LQbpZ6Q4RzYwWk3qjOhummx5AqJTYv6TuhpWhR1QlCzY0zIHROYQQMdLGCVi5iQO3YwvEWgYkLumMDwFuGLCRlllmgr11aD/8FdDLwNvA28xYQMDIXOgQnMoIHxaB6B0+76isBcmx44hPHAXh8XmGvTAzM47UY5pCW9CLT1GF9YwbAb1xDzeMcEZjDslkAHC1jBuIsa2MHwNkMdmpwWdY0Q5RyYQQMdjNeZcBHzeMcGdnAIYx7vmMAMGhh3Eb9FzNgdOziEMWOjXhJfgDkwgwbOu4jSSQh5Dqzg9BYFldDytKiBhJinRZEk1DwtiiQh5zkwgwaGt4h6PJp3rGADw1v8LDGPF8ajeccEZjBiFvcWj+YdC1jBBnZwCCMT7JjADMbKJ6ITsztqICH42TFm944JjOuNHytm944OFnBeb1RRQvhz4PQWq/yQ/rSoP4T258AEZtBAP+oPSwC0YwUb2MEhTBuYwAzOu4jCR6h+DmxgB+Mu5ogK5c+BCcxg3EW4iDm/YwHDWw0Mby0wvPXA8DbjGxqgAxOYwYe3HlWJ0AEdWMAKtokpsINDOOf8gQnMR6VsCYJ2dLCAFWxgB4ewbGACo9YWg6DE9S7s4BDWDYzrjR9rzu4DDXQwohM/Vq1geItfqIa3+IXqELYNTGAGo/C80MECVrCBHRzC2AvdMYFxFzFgegEr2MC4ixhRfQjHBiYw7iJG1DDQwekt0kpogHqUDEIE1KMqESqgHvWHkAEtDB3QgQmc3qJAEVKgAx0sYHgrgQ3s4BCmDYyYpcAMGuhgASvYwA4OYdSgd4xK+sLYU4vbzHG9NbCDQ2gbqM3SwWbpYLN0sFm65EQ7VrCBHdTWbOiHelQwQkB0oIMFjKj3wAZ2cAhL3MUITGAGp7d4eQotUY/SSfQW7FEvieaCPeolITE6sINDGHM+qighPTowgwaGtxgPMed3rGADOxgxi4uMIvWOCcyggQ4WsIIN7MIedxGDoGfQQAfjLuIXijm/YwM7OIQx53dMYAYNDO1MhDpmd0iPQpt04NgxR4fCPg/i5lAsHZhBA+ddzIpWDh1TnxWtHDqmPr3l0DH1uVzPoWM6cHqbK/ccOqY+V+45dEwHZtBABwtYwQaGtxY4hHkDExjeeqCBDoYKKS49MsGOYTdiFnPeIyRzzh+YwWnXI1Dx7N7/LGRngTGPPcIX83hHBwtYwQZ2cAiXHjBcLEHgwgwa6GABw1v8mjGPd+xgeIuQxDz2+GEr3ireKt4q3irelo5wYQM7SMziKe3xczcDHYyYxW/cKhh21z/o4BDGU3rHBGbQQAcLGHbj544Z6zGMYsbumMC4i7ihJS+M323pCxcWsIIN7OA4cImXdkzgjM6UNOUQLx1YwQbO33jmsxzipR1jxu4476KE3ZixO87fYj4sc4iXDixgBRvYwSGMGTsfdTnES31WfXKIl/qs+uToL9hn1SdHf8EDCxjeemADOxje5g8QQqcDE5jBEAcvdLCAFWxgB4dw6fQXJjBOe0R8Y87XhRVs4LyLGlGPOb8wnt07JnDeRY2gxrO7RlDj2V0jqPHsrhHUmPM7hreIZMz5GjGLOb8w5vyOCcyggQ4WMLzFzceze8cODmG8r7cYnvG+vmMG40hL3HE8u3ecdlvEbM75A4ewh934t/GUbhGoOK0WH8AL1VSP7z2GaurABGbQQAcLWMEmF3G+bcdxYKimenxeMlRTB2YwvNXA8Lb+LLz1wIqxBnYQb3HWbccEZtBAB9t+SC+HlqrHRytDS7VjzOMd512sfxvzeEcDHZx3EV+7DC1V3z9tOX/N9W3LmMfrU5UxjxfGPI7PUYaWqve4yJjHOxroYAEr2MAOhreIb6ywd0xgBsPbCHSwgHU/2Zijv+COMWPjE5QhoOojQrJOm8a9reOmCzs4ryy+DBkCqgMTGHYjkjE340uQeZ06DQvr2OlCvFW8Vbyto6eB6+zpwgRmMO4ifqF4Hu/YwA4OYczNHROYQVN04r16R2IW79U7hre4nHiv3jG8xQ8bs3vHBIa3+DVjdu8Y3uInjNm948PbiE9fRs/AAzs4Js7LCT3XiBwVeq4xixk59FzrekPPdaCDBaxgAzs4hPHs3nHO48hyodwas16SQ7l1YAXjLkpgB4cwPlA+6yU5lFtj1ipyKLcONDC89cDwNgKnt1mKyKHnOrCD01uKS48PWe+YwAxObymCGh+z3rGAFWxgB4cwPmm9YwLnbKkLw25EMj5wvWMDw25EMr57vTA+mr5j2I1IxkewU0QyvoK9o4PhLSIZH8JOEcn4Ena8P0T3oAOHMD6GnSOS8TXsHTNo4PQWb68hAzuwgg3s4BDGp7J3TGAGZ4aJd7noHDTi5TRaBx3YwbAbkYzPY++YwLAbkexxF2G3O1jA8BaR7OEtItnDW0SyD+HYwPAWkRwZNNDB6S3Wx9FN6MAGdnAcGB2FDkxgBi3w33/9rcxGVWsUrwE0B/FOXTQOmiN4pyTKIhO5qIjkw+XD5cPlo8hHkY8iH3PQ7uN7/m09BueiOTZ3SqL5t+0YmDu5qIjm9Y1jUO7URQ8fa0xHV73tGJA7ZZGJHvb2ITr/Nh+jbh89SZRF82/bMeJ2KqIqaqIuGgdFvzwNtZ2yaFoZx4BhvDBcogizPqiaj8Gyk4uKqIoeVxWlmtWz0oOmj3lvq2NlDUqi6aMFmchFRTR99KAm6qJx0OogH5REWWQiFxWRfGT5yPKR5cPkw+QjPu41gkzkB63PrwQ9vEXlJpSGO7WD4qMNEcno8ByRjAbPEb/o77yoibpoHLR6OwdNe3EF0Sd2kYlcVERV1ET9oHj7ivtYDSKDqqiJumgcFNLARfN1Lu5y9WoLmi8QcfXR52NREVVRE81xv/52HBTjflG8MgZlkYlcVERV1ERdNHZaPaYWJVEWmchFRVRF094cOat31AgykYuKKGoBQU3UReOgdR45KImyyEQuKiL5yPKR5SPLh8mHyUeULXLQ/AsLmn8xs0CI+3aKInlQFpnIRUVURU3UReOgdWYrSD6KfBT5KPJR5KPIR5GPIh9FPqp8VPmo8lHlo8pHlY8qH1U+qnxU+Wjy0eSjyUeTjyYfTT6afDT5aPLR5CPqjzUotraC4nRFUBN10ThonTAJSqIsMpGLiij01UFN1EVjpyW8W5REWWQiFxVRFTVRF8lHko8kH6HtSUGhxQ2KvemgcVDMskVJlEUmCrVcUBFVURN10TgodvZrUBJlkYlcVERV1ERdNA5y+XD5cPlw+XD5cPlw+XD5WBq8oHHQUuAFhSgpKItM5KIiqqIm6qJxUKh4FslHlY8qH1U+loAnqIqaqItCajEptDuLkiiLTOSiIor996DYLA3qonFQVCdi1K1Nv6AsMlHsJwUVURXF1kpQF42DoiYRv0cUH+J3i9rDoiKqoih4BkXNKmjsFJq8nZIoi6LkEOSiIqqiJoqqQNA4KG2iJIrVbZCJXFREVRQrs6BxUJQYFmWRiaY9CyqiKmqiLhoHRWVh0fThQVlkoumjBRVRFTVRF42Dop6wKInmaidqQ6HAO9DBAlawgR0cwliVRaEpdHkHZtBABwtYwQZ2cAgr3ireKt4q3ireKt5iNRfVsNDlHdjBIWwbmMAMGuhgAfHW8Nbw1vDW8dbx1sNuDJgeFmJ0jPi3JTCuoQY6WMC4hhgEo4H9wFDVpSiXhX4uRbks9HMpCmOhn0tRlAr9XIqaU+jnUiy+Qz+345yTKRbioZ87MIMGTm+xGA9V3YEVbGB4i+tNQ5g3MIHhLW4oG+hgAcNb3HFuYAeH0DYwgRmcdmOVH/q5AxvYwSGMmkkUAkI0d6CBDhawgg3s4BDGNN0RbwVvBW8FbwVvMU2jbhECuwM7OIQxTXdMYBiLsRPzbcf4sxg7Md92TGAGDXSwgHGRMbhivu3YwfAWIyrmW5RGQimXog4SXbNSFEKibVaK+kco5VKUM0Ipd+C0G6WNUMrtGHNzx2k3Kh6hlDvQQAcLWMEGhre4izEODKXcgQnMoIHhLQV2cAiTMkGo31KUY0L9dmBYaIEFrGBc77LQwSGMGRsFkGiNdWDU8bZAAx0sR2IKpdyBTWjKiKGJS1E7CU3cgQY6GGXIHBh1SAuMQqQHdnAIV71zYXiL6KyK50IDw1tEZxU9F1YwvEV0Vt1zYXiLe1uVz4UJnN6i8BJKuQMdjJJo3GZM3iiqhFIuhdwhlHIpNA6hlEtRhQilXIoyRCjlUlQaQimXatiNZ+yO01ss9UMpd2AFG9jBIYw5v2MCMxh24xeK2R1FhNDEHdjBsBv3FvM4lrWhiTvQwSKMGbtjArEQMzbWw9GV68ACxpVFzGLG7tjBuLJHJC3Ub2kuLC3Ub2muLC3Ub2kuLS3Ub2num1mo3w6MgrQHVrCBHRzCeB7vmMAMGhh2S2ADOziE69BpUBJlkYlcVERV1ET9oJi+c+FoIW9Lc2VmIW870MECVrCBHYyL7xNj+u6YwAwa6GABKxh246eNibpjAqfdHj94TMkeP3hMvh53HJNvYUy+Hj94TL4dM2iggwWsYAP38ptFj639EmKW9fjp48na45eNJ+uOBaxgAzs4hPFk7fELxpN1xwyGt/hVYkaue48ZuWMFw25EOubpjgnM4F4stRC37VREVdREXTR2ClnbTkkUl7lwXuZcbFqI2g5sYAeHMCbijgmcFz/XoRaitgMdLGAFG9jBIYzH7I629g8s1GtpLAyzFljBBnYwzM5hEuq1AxMYN1EC4yZqoIMFDG8tMLz1wFm33yIiNoS+gQnMYGyqxV3GN4G2uLf4JtCOFZybY1vckHdwCEt4ixsqCcyggQ4WsIIN7GB4i0DFN4F2TGtbx9bndReZKIxG7GoDOxhGI6JruzEi2uKyYsCuDccIwpy6B3ZwCGMjcscEZtDAGYQUFxk7jynuMbZbUtzYiH8bFzkcLGAFw0LcxejgODBEagcmMIMG+nENIVI7sIIN7OAQpg1MYAbLEepo+JXTwrA7Ajs4hPGprR0TmEED513MFaKFSO3ACk5vc21lIVLLc6FmIVLbcU7XA6e3ueKyEKnluV6yEKnluRyyEKkdWMAKNjC8Rahjuua4+ZiuOyYwvMUNxXTd0cECTm8W9xbTdcfY1IvbjOm6cE3X+LM1XRdm0EAHC1jBBnbhnJjZInxzZh5o4LQbH94KQVu2CGrM2B0b2MG4ixhGIRrYMYEZDG8R9eZgAcNb/BYxuy2iHrN7xyGM2b1jeIvbjNntEeqY3R7xjdkdz42QueXIRiFzO3B687ih2HZdGNqCMBDagkUmip89qIiqqIm6aNdIWOjYdkqiLIprLIEVbGAHhzDm+Y4JjIjUQAMdLGAFGxjeWuAQxuzfMbz1wAwa6GAsNIKqqIm6aBxkmyiJssgOigk3F0wW4psDOziEMeF2TGAGDXSwgHgreCt4K3ireKt4iwlX4zeKqVXjLmI+1QhrzKcdE5j1b2M+7ehgASuIi5hPOw5hzKdAXwNpBCYwg9PxXJhbaFkOLGAFG9jB6Xiu5y0ULQcmMBRDOdBABwsY3iywgR0cwnhg7FiEke5nIcGig1aeCgyLDloHFrCCDezgEMY4KxHUGGc7ZtBABwsY3lpgAzs4hDHOZrXDQvqS43U/tC8HVrCBMR7iZ1njbKGBMYziZ1kDJjCy7o4FjH8bP0sk1R37gSEgybF8CwXJgQWsYAM7OIQxUndMYAbxlvCW8JbwlvCW8JbwlvGW8ZbxlvGW8ZbxlvGW8ZbxlvFmeDO8Gd4Mb4Y3w5vhzfBmeDO8Od4cb443x5vjzfHmeHO8Od4cbwVvBW8FbwVvBW8FbwVvBW8FbwVvFW8VbxVvFW8VbxVvFW8VbxVvFW8Nbw1vDW8Nbw1vDW8Nbw1vDW8Nbx1vHW8dbx1vHW8dbx1vHW8dbx1vA28DbwNvA28DbwNvA28DbwNvQ95CI3NgAjNooIMFrGADO4g3ckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySSWXVHJJJZdUckkll1RySd1zyb//+lsNlfvxgpqP19N8vJzm49U068VUr6V6KeUF+AC9/OrVVy++eu3VS+9h2Q/L6yct85uoE+r80OiENr8GekA+4HidLcfLbDleZcvxIluO19gig8crbD1eYNfvUh8xaRGTI4aaZ5plmmOaYZpfml2aW5pZzCv9Ovpt9MtoFJAF9aMdoF9fv/1hWTNI80ezR3NHM0fzRrNGc0YzRvNFs0VzRTNF80SzRHNEM0TzQ7NDc0MzQ/NCs0JzQjNC80GzQXNBM0HzQLNAc0AzQM9SPUn1HNVTVM9QPUH1/NTTU89OPTn13NRTU89MPTH1vNTTUs9KPSn1nNRTUs9IPSH1fNTTUc9GPRn1XEx6LCY9FZMeiknPxKRHYtITMemBmPQ8THocJj0Nkx6GSc/CpEdh0pMw6UGY9BxMegwmPQWTHoJJz8CkiZk0M5OmZtLcTJqcSbMzaXomzc+kCZo0Q5OmaNIcTZqkSbM0aZomzdOkiZo0U5OmatJcTZqsSbM1abomzdekCZs0Y5OmbNKcTZq0SbM2adomzdukiZs0c5OmbtLcTZq8SbM3afomzd+kCZw0g5OmcNIcTprESbM4aRonzeOkiZw0k5OmctJcTprMSbM5aTonzeekCZ00o5OmdNKcTprUSbM6aVonzeukiZ00s5OmdtLcTprcSbM7aXonze+kCZ6Gnsp9PoHWG/QsnawX6EVJlEUmOsoq6915URU1UReNndZr86KjnrJemheZ6CimrDfmRVXUREchZb0tB0V+WJRERaS/WLUb3z9zHFWR9ba6qIuOmsl6VV2URFl01EvWa+qiIqqiJuqio1KyXlAXJVEWhY++fwQ5iiTr1XPROGgVd8b+EeSolewvmNv+meOdjprJ/pqY9o8W79RF8e/y/lnincJyfoyksU4xRq00TglGrXTROChqpYuSKItM5KIiqn/77vnI0On8Os49rlOMmyiJsiiUCkEuKqIqis3WX8f5SB3e5ewuR3c5ucvBXc7t7hQ7Xb+Oc4/rGG0MjF/HucdFJpp/G9cS6WlRFTVRF42DIj0tmj7WMdosMtG0sk4xbvvZxTjtuFPeTzHGsdrQ8MWp2p2KqIqaqO+nGNf5yHWKcTtOMcb5yDhdF+cjF9lxTjHORy4qoipqx3nBOB+5aOgU4yZKoiwykYuKqH7tfGSc9IvzkYvK88nGdYpxzoV1YnHOhZ26zjPm4xRjnHa0X8dpx4hfnHZc1EVDpxg3UTpOMc4ZsM4fzhmwk4uKqIqaqIvG8wnIdYox+lHENUc7ikVdNHSKcRMlUT5OMcZ30OMu4zvocfXrSPqv43zkoibqotix+7Wfj9wpifJx/nB9B/3XcT5yURFVURN10dApxk2UvnA+cp2FjHNdmx3nFDcXFVEVteO84Ppe66/9LOR+inETJVEWmchFRVS/cj6yHqcY47Tj/BXWacc4uxinHRfl4yTdasAY5KIiqqIm6qKhU4ybKP0/dD6yHScC14eyfh1nHOP3jTOOi0zkoiKqoibqonFQnHFclI7Tf3GWapGJXFREVdREXTQOiu7Hi+Sjy0eXjy4fXT66fKzvjfzazzjGicB1xjHGc5xxXFREVdREXTSO831xxnFREmWRiVxUjnN2ccZxURN10TgozjguSqIsMpGL5CPJR5KPJB9JPrJ8ZPnI8hH60DhtFvrQRUVUj/N4q7n5r+Ms5KJx0Ops/us4C7koi0zkoiKSD5MPkw+TjzgLGWfb4izkoiwykR+n+uIs5KIqaqIuGgfFWchF6TgRuPqg/trPQu7konKc+Vs9UH/tZyF36qJxnP6LPk2Lkigfp/+iSdMiF5XjRODqk/ZrP/e4KLqkLUqifJwIjGaJEZfolbioiKqoifp+0m+dewxaXZl+HeceF2WR7Wf+4tzjTkVURW0/6RfnHncaB0UHlkVJZPtJv7p6rvzazz3u1ERdNI5TfavHyq/93ONOWWQiFxVRPU7/zfm7UxeN4yxfnHtclERZZCIXFVEVxeGJdWiyg0MYGtIdE5hBAx2Moxpx2G4d1VjYwA4O4TrAsTCBGTTQQbwZ3gxvhjfDm+MtVmTrsN06JLnQQAcLWMEGdnAI1yHJhXgreCt4K3greCt4W8chY8Csg48xOtYRxzgRuA4zxtm/dZgxcB1mXBjXEINgHWZcaGB4i5O664BiHMENWXecCFwHFNM6oDgtxInAFrLuWMiuY4s7ziuLRW0LWfeODezg9JbWscUNTGAGw9s6zOhgASsY3uKG4lDGjuPA+MjAgeFtnYHMoIEOFrCCTRiq73XKL1TfO2bQQAensXXuLqbpjh0cwpimOyYwgwY6WEC8ZbxlvMU0XYf4YprumMAMGuhg2J2jJL4WcGBYiI22dfBxoYEOFrCCDYzrjfNx6+Bj4Dr4uDC8xdm/dfAxzv6tg4/xy6+Dj/G7xdRbZ/+iXrIO/MXUWxgHNdYpvziosWMGp911ci8OauxYwAo2sINDGJN3nf2LybtjBg10sIDhLX6LmMc7JtCOOR9fC1gH/uJrAQeGhXVesoEdjOsNC+sM5MIExvVGfNcZyIVRV4tQx+TdsYLtSEHrDOSOSkzrtOPGacd1tC+m6Y4FrGCU7OJkWRzZWGf/4sjGOtoXk3fHBGYwvHEycscChjdORu7YwfDGycgdw9vTyciFBk5vhZORO1Zweltn/2Ier7N/MY/X2b+Yx+vsX8zjdfYv5vE6+xfzeJ39i3m8DvzF43bH0KKuU5QN7OAQxpzfMYEZNNDBsBu/UMzuWHqvk5ELV210Ydhd5xrDQoyHmMc7VrAJ17nGhQZiYZ1rXCcjK9jAuLJ1XnII17nGhXFlEcmYsbGEjC8AxNm/HF8AiLN/+2nH6Jm5TjvuOL3Fam+ddtxxCGNK75jADBroYAHD7joZOYQxj3dM4LHmjYORO7moiKqoibpoHCf+Ys37dPQxzoito49xRmwdfVxYwQZ2cAjX0ceFcfFxRmwdfVxooIMFrGADuzAm6jrlFxN1RwOn3XX2L6bkOngXk69z2nHHaWEd14vJt6ODBaxgAzs4hFFGWmS6hJhl6+xfPFnXyb14su7YwA4OYcy9HRMYNxG/YDxZd3QwvMWvEjNyPwLZwC5cRyAj0usI5EIDHSzHSb5aRU3UReOgKOAuSqIsMlFc5sLYRYmfMybijkMYE3HHBGbQwHnxcUZvHX3csYIN7OAQxvTcMYEZLPvZvzj8uM7+xenHdbQvjj8eOA4MscSBYTb0TvGU3dHAuIk47rUORsZprnUwcmEDw1sc7FoHI+OkWmyLbjoYeWAGDXQwDvLoYOR+yi/UEzt2cBbU1ym/EFDsmMDwFjcUu687OljACjawg0MYG7M7hrd1SDKDdpzzm/N8pyIKo+vc5BCuY5ELw2hEdB2AjIiuo45x9i/2YNdxvdiEXRi7sDsmMIMGOljAGYR19i+2atfZv9gyXGf/QuawjvaFziFxgjFxgjFxgnEd+IvNxB0TmEEDHSxg1TWs044LOziE67TjwgRyF+u040IHm0IdOoe0MOxG1NcZyIUJzKCBDhZw3kWc8lsnI3fs4PS2DlWtg1FxWmqdjFqYweltnf0L/cI6+xcChnWeLxQMOzawg0MY03Wd/Yvpuk75xXTd0cDwts5AFrCCDZze1oG/mK4LY7quA38xXXfMxwBf5yU3zkvuWMAKNrCDQ7im68Jpd53yC9XEjgWcdtfZvxBOrKN9MWN3HMKYsTvGXcTRvlBP7Gigg+Etor5ORi5sYHiL32KdjIyox+zeMYEZDG+cjFxn/2J2r7N/MbvX2b+QP60Df6F/2jHEOesw4wbGqP51HIxcVETxs/86TkUu6qJx0KEn2E9ELsoiE7kornEdl+zgEMY83zGBGTQwIhLhXeceF1awgR0cwqVXil9lCZYWZjC8xU8Rs3/HAlYwFhq/9jORO+3akHUmcqckyiITuagclCRBXkcUF+YNTCAi52yggwWsYAPxhpjakFMbgmp7klQjqrYlLYyzf3bol838kESbeQYNdP5tASvYwA7iomxgArOwH2I0W1KUHR089Gi2unXv2MAODuHYwEOVZqtn944GHsI0s1HACjbwkJqZjUOdZr5tYAIdbMJI9+vs31Kwxcm9VMEGdnAI8wYmMOzGIb5soIMFrGADw1sc7ctDaBuYwPAWZ/+WCi6O9lkDOziES7sap/zWOFtYwEOetp9g3NHABsa/jQN/ZQjrJuSMk3PGyTnj5Jxxcs44OWecnDNOzhkn54yTc8bJOePknHFyzjg5Z5ycM07OGSfnjJNzxsk54+SccXLOODlnnJwzTs4ZJ+eMU+GMU+GMU+GM03+clzwQb/9xXnJHvP3Heckd8fYf5yV3zKCBDnIy6T/OSy78/6fzkv8+D+5McXhUJNJ+8CLtxy7SfugiHYcqjuMTx+GJ4+jEfnDC9mMTth+asP3IhO+HI8p+DKLshyDKfgSi7Acgyn78If7nLGPOy0u7dl1a8yyt+f+ievbYkwra1yz7d3wWjb/9fT37Uqdn0U969qVYr6Lf9OxLk77aa/16rWff16TrOz5Lux7JdenUN9HvevalSTfRPT370qlvIvTs00rc0cyLS7E+R82uXd+kXU/SpGfRaz27/Tr07PFrhZ497i307EuxvomS1OlZ9JOefSnWpTX/X07PvhTrWSQ9+5wfu3bdpVgvIunZ52jftesm7bpLp15Er/XsS7u+SX+eRB/o2ecY37XrLp16Eb2jZ1/a9STtepYm3UQv9exLp75aUP36k559159La/6/lJ69S7uepE7PIvv7evZdsS6t+f9SenaXdr39bdeux9d7QrEeevalXZcO3KQD/19Tzx6K9dCkx9d7QpNepDovUp0Xqc6LVOdFqvMi1XmV6vy1sn2pv6sU4VWK8CrVeZXqvEp13qQ6/wuV7fnQpPdjB359vSfGaZfqvEt1Hl/vWfrzTZREh+o8Xrh3clERVVETHYrwpWxf+nMpwjcpwjcpwjepzjepzv8fULaH3jmU7Yu6SIrwLNV5luo8S3WepTrPUp1nqc6/qGwP1XQo2xcVURVJdW5SnZtU5y7VeSjbF2WRifzQpMfnhEMhHd8KX9REUp3Hh8KX/nwTJVE+9OehbF/konLoz0PZvqiJujTpUp2v74D/OlTsi1xUDk16leq8SnUeyvZFQ0r0TSTVeZPqPJTti1xURFKdx4dGF3XRkCZdqvMu1Xl8Y3SRiVwk/fn6qOivQ8W+9OebKIkO1fnSsy9yURFVURN10ZD+fBMlkVTnm1Tnm1Tnm1Tnm1TnoWxf1EW/KdsPITqS84TkPCE5T0jOQ7KzYwX/KHAPuXdCBJ4RgWck5xnJeUZynpGc/08TuIe+2hCBGyJwQ3JuSM4NybkjOf+fIXAPu/ZLovUYHesbPkuTHtewNOkZNDCuIQbBkrIvrGB4W5r0sBCa9FDRLU16qOiWJj1UdEuTHuKdJUQP8c6OSM5DvLOrzzcwgUjOl8B9oYMFRHK+BO4LOziEQ5LzXeC+MIMGSnK+C9wXVrCBHRx/kyZ9+9tvUvalM9+QnMfG4I4VbCCS84TkPCE5T0jOE5LzhOQ8ITn/lsA9pMsZyXlGcr4E7gsr2P72u5Tdfkm0vhDJuSE5NyTnhuR8fc5n4RAugfvCuN6lSc+ggeEt9NVL4B5K6iVwD830ErjH7xZTb9ekh6h6adIzGKLquIsonuxYQCTnBcl5QXJekJwvgfvCBGYQyXlFcl6RnC+B+8IGdjC8xW+x9OsLHdQ5lPU5nyVEj8m7Y1hY6vMNTGBc71K1G+hgXG/EdwncF0b1K0Idk3fHIVwf4FpC9ARmUOdxdil73FBM0x07OP4mTXoU1pYmPSpr9usQuC/J+RK4L3SwgOEthN1L4L6wg+Ftqc83MIHhLaTLS+C+MLyFinkJ3BdWMCTnoW2OebzjEMY83jXpITmPe4t5vDTpMY+XJn0J3ONylsB96eJD4L4U8FFjXHY7iOTckJwbknNDcm5Izg3J+RK4L/y7AvclZV+a9LAbd7Gk7AsNDLtxb47kfBVFFw7hKoteE62vT5xHdNY3zpcQfQPjypYmPYMGxpVFJNeXziN8MWOXJj1m7BJqx4xdQvSYsbsmHcl5Q3LekJw3JOcNyXlDcr4E7gv/rsC9IzlfUvaFBjoo1XmX6rxLdd6lOu9D+vNNlER/T9kelxmjchyS8/3bPjsiOd+QnK9v+yzMoIFIzjck5xuS8w3J+YbkfAnclxB9A58E7mE35MpLyr6wgqG1Xpr00HCHVDgm35JdL9H6QiTnGcn5krIvRHKekZwvgfvCBP4ucK+Lqi5hKdlDk25Izg3JuSM5dyTnMfd2NNDBuIlQny+B+8IGhrf4VZbAfQnRUekXVPoFyfmSsi+sYAOlOi9SnVepzqtU51Wq8yrVeXXR31O2x2VKxn4I0ZGcNyTnDcl5TMQdC1hBJOcNyXlDct6RnHck5x3J+RK4L/z7Avd+aNKXkn1p0iU535XsCzNoYJiNYRJP2R0rGDcRP/0SuMePvATuS4i+geFtadLDW2h5NyTnG5Lz2PTdsYINjK2o0KTHpu+uPt/ABMZ2lP2SwH2hg0jOE5LzhOQ8ITlPSM4zkvMlcF94InAPTfNSzC6sh/58zvOdujTpYXRp0jNoYBiNiBpCaZe0donWd006knNHcu5Izh3JeWg/dmzgHwXucZFLyh73uETrcWMFyfkSrS/1+QYmEMl5RXJekZxXJOdL4L6wgR1Ect6QnDck5w3JeUNy3pCcN+7i7wvcY0dx16SH3YVIzjuS847kvCM5D43Gjg3sYEh0l/p8AxMYKt0Y/qHRCHXuErjvWMBQA8ePtQTu8WMNSc53gftSn29gAjMY3kJbuwTuIZ1dAveFFURyvgTuC4dwCdwXhnx6adIzGPLp0DTHdN0RyXlCcp6QnCck5wnJeUZyvqbrwr8vcA8ReEieQ42xYwdjo20GdUnZdyF6AjNoIJLzJXBfWMEGhreI+hK4LyH6Boa3pUlHcr4E7gsdLGB4i9uM2b006TG7lyY9ZveuSQ+BddxmKLt2DBVu3FAou3aMUf3rULIv6iKpzqtU51Wq8yrVeZXqvEp1Hglg0d9Rtjck5w3JeUNy3pCcxzzfsYAVRHLekJw3JOdL4L4wgRkMb/GrLF3ywgIiOV8C94UdHML1vcxfu759pywykYuKqIr+rGxf3+DZNemIwBMi8ITkPCE5T0jOE5Lz/xkC97C7NOnowZe6KdTnS920sIJIzg3J+bOqHcm5Izl3XCx108K/K3BfAynU52sgLWwgkvOG5LwjOY+BtGMGDQxZdqjPl8B9YQWRnC+B+8IhXAL3hZKc7wL3hQY6iBD9WbQe1xCa9A3J+YbkPCE5T0jOl5R9oYEOIjlPSM4TkvMlcF84hEvgvhDJ+RK4LzTQwfAWmvSM5Hzp1xcmMIMI0dc4W9iFjhB9DZiFVbjksk+i9aVJz6AJEaU6olRHlOqIUh1RqiNKdUSp/yFwP/A/BO4L/0PgvvA/BO4L/0PgvvA/BO4L/18qcJ+i77w06Y/S85SYr/8xJSpTGP63/zTL9VOEMf+lHf9ybn6vzdJ/f/z3f/7X//IP//ZP//ov//nf/us//uP8J8d/+G9/+0//2//42//9D//1H//l3/72n/7lv//zP//62//3H/75v8c/+m//9z/8S/zPf/uH//r4vz4s/uO//B+P//kw+H/+0z//46R//8Vfbz//6eOVzva/fqDLQEnXLcwF1G7B+i0LBQtt+9TCsBsWfJsVhLDgm92JQ58VkTDw2PjV36f229/Xn/++znVA/H1t5cbfN/2QLW23/v4IYcs/+j+5/zHrWvH3j93CO38/X6LX37fx09+n9LOBR93Wj1t4cH26iX71ItJcYx825pdpGQj59wuxswvprepCHjvht4zkEMQsI49qVr9pxJ+MVL9n5DGnZMQ93zQyy26HkWI/Guk/G8lRIwobj4LaU0TKZROPwuzQD9weD0UZqW/YaPw0Dx73bFjHhtefbJzGtFTdy9TI/hTTfGIkh0Bij2l6+m1/v46Z3H4e7+NpvI/n8f6GkfmBDd2MPT8G/mDkJIc99nZ0IY/9o58GyKmJ0Lrs92L1lom+6Sp6KndM5KRs/MgD/rGJPD424XbPxDANr+3eVeSEidxuXkX+2ET7+Cqupa/zWeJPTwV/HhnvTLW6OXljK/eMtMJToZ3M1zMjrQ8yaR/3bqeNpPnWxlMqfcPIY29pKA8+trTLPSPDKkZ+jomfGCkaZ/X5Pa5fv4rHbrhu5bEHfu9WUnoy8tjA/fFW2smt5H7YeNR46k834yfPydq0uqjt+b36nXjE9taRCWu6F4+ai4xUv23En4zUu0YMI7XdNEI6e+xm95+MlLOJN0hoDy7t1jtMr3oPmprEn95hyuljP2Sg+3P/8ULDMCn9HSvtyUofN61kkuv2mDp3rRCW7bGt96OVup39yqUl/cqPatxNK3V7GvpPP9F7Vtpg7Pf88290ujyz2lie1R8XRec2WAHM7aRbNlyr1TS3V27ZKFrxT75pw+zJht2y0VT6eHBPP9mY6tMfyydV1YcH+s8j5NSGY+NpgfieDU0b/62M8s4Y63ryPbj8uKpqZ6uqOvTIqeOnReaZhcf6pfnTWubnuTv1tD8WdUo7xvrjde3nmL64Et6v5grrnpUUx2h2K8+riQ+s1LtWvFIp8pNxcm6lDCWBR15MN620pztq5jet9C1RctryXSt6CZ58847yVij1bOPmHeX8VHUyz7et9Ccr/aaVojfINI+nf8NKvxuXVp/WXaN/wcrt8TKP+WCl3byWxza3ZuNjc/tmfnnsb+ux/tiT3m5ayVSQHjvQP1sZ5eN1z6gfr3vO78WeImL951E7+uf3Mv7ie3kqWZTnksV7v24t/Lr17jx+vKs9XUu/OV67V1np5e6or0OVrck3c8rYqCo9+LaVumGl3nx6jKy9vMl3r8U37sht3LXydEc+bo6XUTZlyVHuPslGNRbb9e47yyjkt4eV+gUr7e6bz2i5Y6Xd/aUbM2D0m+9PeWvUqbe+9Xsrh6El7qMI8fN+zBs2bq0KPY7V7zYeW5q3bGTtCz24/LyHmdPZMkiZf/Yq+WEZdH4Z/ekyRr11K8aWjlvxezZyerJR7tlgReePVeY9G71jY7Sb12FPNu4NMd8YYjeLKL9dx2Oc3rsOiiju7WS/Pv3VVmrTz1vb09qpvmGiq8j8eMdo90zotaI+Sw/qO09g1gbjt3e+t/KyPT2vrGx3raTtG1bq07X0228D+nU+eKdoKI0efPep1xLvw+05xb/3DrpRN+/PO0XvWulYqTdXgT0aRxy75vnnd4rkJ0uvR9HisNKf1WhvGWlFG/it5O0b9+N3YxuHhncr+e66p8eRi8NKy9+w0m++9XWrepL2xxvO3dVTZvXkd9+p+9N7bK/57rVU3i96vbti6ZVaSm/p5lqjN17b+rOs6AMr5W5cGu8qvd1dm/5m5VlO856Vp6J+fwyYmyv/MTR2HzseN+NSN6rPdev2DSvj5gx4vJVjxevNuNSyKUvVkn++llTrF3L3mZGv5O7f7+fuLHoUmDpW7r5H1bpp5D54fOFaatq+YuX2HdnTHZ1E93ynr7HTd1KDO9/FZXNgntG6twNLcWeevLq3m9yfdnG3HxeoL3bpC4KdepKzX+zSqyaTT3ejXlzLk7rkrFb14loSuoPmdzUQrT7dUburXqjIwx6v7d+J7u07ehIAtZN1yBtWTqL7QqeSntQuJ29QLxRanWvJ40c10rkRe1KrWroprmL/Z17JuGMktcErbhst3zQyntZm927n8YfenpZm90Sajwor695+U3P6+MP2VKYdXzDi5Qu3c9dIp3Y1xs8S2nS2Mfax1PNh3SnEj3rzXgZilW17foS9I33dLGOk3RThNmbfY1P45pV0yQ8efO9K5p54f9ofvzdcZ99EGRllu3klrC5nl897ySRR4Gz53k/8eNRw3OTx8Po5raXt4/3knNLHG8rnN+OIVJrfla871cnmudw0goq2PYuR3jPy2+3cFNI7r/fNR745XtuTsmRs35g5N485DGpns6njLSN1c5Y82z219eMP2/Z31+ofGOlfuJ27RhKl/ccq8OcMm8tf+fCrkST2y3hW/Lx1L5mkVp+Lmm8ZMarx9Vll9pYRb9yOj3vPrcfCjyspdu8UXX+q/vmtw2e/mXhai9420e6ZoFzXx82zfE/193HzKpC3fcHE2G4dxHvsWKUnKcs9E+xc/fY2844JJGm/va7eNXH3Rp6EJ7duZL7v6iUz/3gj50dfnk6K5Gw/H4l+YYQDgbncPJyd+pORbfuCkXKrElaeNjWfSgnjqoHoL7l+ld923C4bMD+G+O+bzdcNqNpkY3xmwDe7Y8ClTvxdsXbZQNHWWsm3bqGoblfsVhCL3i+K24dXcNOAlsT1NznkGwbyZwaob9dxay6gi+vbvblgUj/Ofn8/vUqczefEWfofH7+n8h7kuunO3z9tkd3yX5+kGjf+3rr2kaw/C2K37Q9Pmn72MyQZsecdrfeMKJQPbHeNdIw8r93fMuKqpM8ebz8bmd38f148HBdSniv66Q0TVT/Nb0ca3zKh0971+WnzjonmOp/1/MR7xwSVqv50jvfPJk4OapsWUr8NsPdMkCvKTRM6U/nc/uNNE/65CRpi+V0T+e89wt/6UetxFY9C800T0nY9Vw3fM6Gp+rxw+ZOJ0+letC05G7n9PN17O5toEjQ/kHiM8Y4NrScfWG7aUHeo6k/7tG/ZcF4tiv18HSN9nP7OTFxMf6cmrqW/MxMX09+ZiYvp7+yw1cX0d27iUvo7NXEt/Z2b8M9NXEp/5yYupb/TH/Va+js1cS39nZq4lv7OZnsrGwewn94A/zDbbaunJXX2k+cn3e5ZmZ9nUTk8PQ30D6w8Nch600p7Ks0/tbd4z0riON/8uMZNK+ZPLf9Kv5XVW9WxnQfee7o0ToI/8OZ10MyhPW+NvWOjc367b0+9GP8Y1VRP9wjo7PRgv2kl03rgwe2uFep9j42Cdi8qWSuoB960QXmpP9eX3rMhXUj3u/dStbL/TWr8x6ieNQ689g5yauLaO8i5iUvvIKcmrr2DnJq49g5iuX/6DvLCxJV3kHMTl95BXpjwz01ceQd5YeLKO8j5j3rpHeTcxKV3kHMTn7+D9KaTBQ+8+UzoUiE/MN2zMVSd7+PkueKnFcHCfoeXn9dgr6ywl/7gdNcKm4NexnbTytNhiwePW7Edm064jefWx+/Z6E02er9pQ0+nkdK9cTKyps1jxJz8wv0LUT23Mj+2zJt3GT+WL16Z6U8v8M9nNd4zM2gsOz/we9tMemq5l+tXruYDM5zwnt9mvVchGqb378dG98+/djlfT7BfYb8dQXzrjixtT2bSd8ycXM2LyaTjU8NOFn31K0m3fiXp1q8k3frXJ11e54f9/GAN2eTP4//pAMmDb1vhfh6c7lp56ulb6nbTSkVgndvJaDmdjJcTeKlfSeAvzFxN4OdmLifwF2auJvA3ruYDMxcT+KvkezVrvmHmdtZ09aIcz5LcP469Nr6RNV9YuZg1X1i5mDXPrXwlaxbJnkaxHzdzrPs3suYLKxez5gsrF7PmuZWLWfNFbHkilfbziOvf+JXPrVzPvC/MXM2852YuZ94XZq5m3jeu5gMzVzPvqZnrmfcNM7czL01VR7Wf59L4SuYdX8m84yuZd/z1mbcqUY368wLft29k3ldWrmXeV1auZd4XVi5m3lfXgtj8we0LVp77XL55R/npAx827lppfJGn9rtxYa9hWik3x399amlXf94ce8fK7ezy1InRq9+2wumVj6xsT1bGXStPma52u2sFuaS3LX3Dyv1f+tmK3X0nuzin37ByMqdfvR9em9OvrFyb06+sXJzT7Stzun1lTrevzOn2lTndvjKn21fmdPvKnG5fmdPtK3P6RY3r4py+buVsTr+olF2c0y+sXJzTL6xcnNPnddWrc/oNK3a3xnt1Tr+6lvQVK9fm9AsrF+f0CysX5/QbVu7/0tfm9Pm6JunQ60h2dzP36sj1r4xc/8rI9a+MXP/KyPWvjFz/ysj1r4xc/8tHbu8Iwnq/K83QkHuY+1mQeSqj0hOkPpfY/qAy8Xpi4pqA6YWJKwKmcxOXBEwvTPjnJq4ImF6Y+FjA1FSrbKeqtDMTfBQ83ZXXSUzaSr1pAoVeuauBovd6t37vBEnnZO1j2vrHNp47Dr5nQ5/SfmC9aaNIE+Y9fWzj9r08qVlPbLzS91JMfHD/hpVyT1nbnoZ7+1mpf91Gu6vTz099KXPut62kJyvjrpXyZOX+HdGs3M5+5Rdqf7YGzPLtMwN8/sDs51Ncr6yUJyvl9rXwqVCzZretpCcr/g0r/efcNNLHLyNnX+C6+DJybuLSy8ipiWsvI+cm/HMTl15Gzk18fKLr2svIuYlLLyPnJi69jFw9snj3ZeSxFlNvh+dvp7zzkPjNRr73AK+mJUy1tt20MbiOmy8BlWb+9e6Rlt9seP08pndtPB8RPrFx2lfgUgKMTl+fJcAXJq4kwHMTlxLgCxP+uYkrCfCFiY9P9F9MgKcmriXAUxPXEuDFlhXlblMA12vlA+92I3k2ku52I7HGKG+3O7SMp0Y55e7t0ObF8zeMmH8hsLeNPPWKcfv5ds5aKF3pEHnWDIzvn+bydB/j9/5F0Wzq51Tc+ajX86bIOza6ElB9/p74WzaGjjrX8fSJpfdsaKzX8dS+9z0bPGbHcx3ljzbO2l5zJr48f/j0LRt87eCB/Z6Npl6opZV78WibKvVt83rThq6jPfdof88Gz4bnT6/+0cbZZ6+u/i6nNi7+Lqc2vvC71E7/tbH5vfFB180H3hzrQy9iD2w3bWTFdOT2+XXctqEx9sCbc67qsfDAdjMH6ZjWIx3dHOsXf9tTGxd/23Mb137by9dx28a13/Z87n/jt1XbiPqsaH4vF0rP+XhP/nnuV/88F57auJgLT21czIWnNi6O9VMbF8f6uY1rY/3yddy2cW2sn/+2n4/1lp7G6bj57pD1FZ8H3nu3bJRw2vNqbFzu8/nYLdEXRErrdyxUUz/l2n6e962fzZUrHUlOTVzrSHJu4lJHklMT1zqSnJq41pGk9I839F+YuFRC6h9v6L8w4Z+buFRC6h9v6J//qJc6kpybuNSR5NzEpY4kZ3O9qbVxbr3eyRZ8ACb37ecn2jh707jWU/KFjUs9JV/YuNRT8tzGtZ6ScbTqw+w5Ps+e4/PsOT7PnuPj7Fm3j7PnCxNXsue5iUvZ84UJ/9zElez5wsSl7Dk+z57j8+w5Ps6ep7P9Yk/Jev61hos9Jc+tXO0p+Y6VnxVNr6xc6yn5wsrFnpIvrFzsKXn+O1/rKXlu41pPyRc2LvWUPLVxsadkzacfDr7YU/KFlYs9JV9ZudZT8jwq13pKntu41lPyhY1LPSXPbVzrKRnffv7sHeTUxLV3kHMTl95BTk1cewc5NXHxHcQ+VkG9MHHpHcQ+VkG9MOGfm7j0DmIfq6DOf9RL7yDnJi69g5yb+Pwd5GJPyXMb13pKntu41lOy+olk53K7iFdWrrWLeGXlWruIF1Yutos4je3FnpIvbFzqKfnCxqWekuc2rvWUrKV8IarnVi43xnll5mJjnBdmrjbGeWXmYmOcd67mAzMXG+Ocj5lrPSVrPV9PXOwpeX5Hl3v0vGPm5GpeTKZLPSVr/UrSrV9JuvUrSbf+9Un3Wk/JeqbQu9yj55WVaz16Xlm51qPnhZWLPXrOJ+PlBF7tKwn8hZmrCfzczOUE/sLM1QT+xtV8YOZiAn+VfK9mzTfM3M6a13pKxsby51nzhZWLWfOFlYtZs9e/PGte6ylZzw52XM+aL6xczJovrFzMmudWLmbNF7G91FOyjm/8yudWrmfe8ZVuvi/MXM684yvdfN+5mg/MXM284yvdfN8xczvzXusp2bZvZN5XVq5l3ldWrmXeF1a+knmv9ZRs6RuZ95WVa5n3lZVrmfeFlYuZ90zk0G2TyMHSHZlE107Hw8KPhxdii+jHoicfurftSWD2KK5ftpGGDlGk8VR9LddN5E11/bw9Ncoq12OhGvIDy41oPvYUVYXe+i0LhYJ8SfmWBUkXHxbslgUVTB/Y7t1Fw0L/+C5+FAC1fPphxcZJtueKfv+DjfPTUk8nyMaPYzuPz+fHWT3+UXl3bYCn51Lr9cNOv8XUbv0qtCZ51CDGHQvNdA3PZwPfsSBVgj12Bz68ht82Fd6xwDUkv2OhS8xq3e/MczdV2LyUO3fhFM09pe1TC/nWNWQdwPNc6y0Lel3y3O9dg9793Da7ZUECvYcF/9RCGh/G4beK683f4sdraGefJLqac318nnPL9nnOLemvzbnPMTW79asgIHW79Vbirrzvfut57rSTcq/p02uot/Kd64jKY22VPrWQ6od3UdKtYxAj6RDDyP6pBbuTrXJHXN3buGVB216PmsItC2PjLrZbx0GGNDj5UdD71MKtMfnbb3HPwnMkf7bwYuGTWPg8VXXeWjuxkNyeXg3L3av4afnVzrZweisSe/x8Decr82udm9+wctK5+dX6/lrn5ldWrnVufmXlWufmF9Wgi/1v37Fyu9Z2sf/ty2tJX7Fyqf/tKyvX+t++snKt/+07Vu7/0tf6377a57g2p9+wcjKnX+2WXJvTr6xcm9OvrFyb0y/21i7O6Xes2N19votz+uW1pK9YuTSnX1m5NqdfWbk2p9+xcv+XvjinXyg+Ls7p61bO5vQL3cjFOf3CysU5/cLKxTl9rjK6OqffsGJ3FU9X5/Sra0lfsXJtTr+wcnFOv7BycU6/YeX+L31tTp/v8l37wsILUfLVketfGbn+lZHrXxm5/pWR618Zuf6VketfGbn+l4/ci19YeGHj0hcWzg8VXerp2U+3qy4d53lh4spxnnMTl47zvDDhn5u4cpznhYmPj/Nc6+l5buJST89zE5d6el49r1bungi69oWFcxvXvrBw2cbJFwVe2Lj0hYUXNi59YeGyjdv3cu0LC69Ou177wsI7Vsq9c6YXv7Bw3Ua7e2r94hcWXlq59IWFV1aufWHhlZVrX1h4dfb92hcWXlq59IWFV1aufWHhlZVrX1h4aeXSFxbesdJPclP/+GXk7MttF19Gzk1cehk5NXHtZeTchH9u4tLLyLmJj/ubXHsZOTdx6WXk3MSll5GrDXzuvoxc/MLCdRv53gP84hcWXti49IWFF/dy6QsL1214/Tymd21c+8LCeZO+awnw7HO0FxPguYlLCfDUxLUEeG7CPzdxKQGem/i4Pd7FBNg+T4Dt8wTYPk+A531BXX1/fnuTe6svqE6UtBPZ2rkN5F4PbJ/byDf7pD73OL1tQ4KQB96NqZJoO5GMvWHDPrfhN3vf0+Sq2c8i1Tds+Oc26hficdvG03ypN/tON7ULKO2kt/m5jYwNq5/b8HLTxnPv6i/YuB3Tp3u5b8Nlo9nnv+1tGxstsn4+QvLi+wrXxti5jWtj7LKNkzF2/VsRX7BxMj4u38t9G5fG2OXf9raNa2Ps/Nsq18bYuY1rY+yyjZMxdv07MV+wUf3ze7lv49IYu/zb3rZxaYydHZraXIWw7ekNpthlC4niYHqqx9200McdC5liaX6qlb5hwbsslO2WBT60lUq/FYfCadd67xqqBAaPrYGbFp42F/oNC5Wu4vW5z+n1AyEpsZh+cLs3Kl1K6Qc/yYTeGpdqrffgdHN20LkqPR+peGt0Y+PB7Z6NyuHw7Wln8R0bT124cro3vjIamAc/iT3+YGOcHaEqWe0VSn765scfxtg4O0L1hXGa05MULT0d+nkrHk+iuLvZL/VnG/2eDbpH57z5vTHmpOHNb9qgI/DDxnbLBr0Hnve/H4vr30ZHOTuwX/WVHatP5aOSr2dzkkd5Ojr6p6s4GaNeKoepnp8p+Q0blQNZz0Kvt2y4vsHkz918/2ijnn2Ot9NTuP/8ZHlhoz99j67esvGY9qpO5p+fLS9sqB/no4aV7tko1MFK+zkPnskSc9bv8sB604beh+/bSFKLPHLH3XvRt6DyY9f683vxfvN34betd3/boetoo9y00ceTjZvjdNCjeEs/5uPRTuTsVW3ra7V7FlR4rrl+auHuNUi+87wl8ZaFzif1bmae0ejen+6Nzj6ybIx8b1QM1yN2+M3ROchej8E5btrQhwhGtZvX0U330st204bWn6PX8vl13LSRHq/2ekff0rhtRZs0acupfuFa7lvJfMFjy7V/w8rPNYZXVvjuxWZpu2nF9Mh98O074pT8LLv8HN3RPs3MpxYuZeaLFu5ew6XMfGrh48z8+CUp/zwWMXfHhvPVmwe3u1Y4srWVcneEVWOEVb9t5SkL1D6+YKVtd+dvoyq0tZtv7mnr9Il8lEHu3hHn8B/c220r3NH4+b35kYzzx8WQhxH7uBry4n4Ghdxt1Lu/86jMovFzpeqda7lrJW2okx9Jop38Qv2sIOE8wLLXcWJmfJjvX5i4kvAvm7h9FVdS/gsTV3L+y18l0+vV2+0fl35OD+72FTMj3zfzdDx2Ownv6akeijXWc/k5p+TT8aovnzyG7naSmE5v6On82m8fNf7jRD4tYDUJubw/L5vyHy7FztZetbD04m62P9k4U54Xjhg8f3XwAyvN71qpHJqoqd62oqOBqd6/o2oNK1+Jbr9tpdEuueVx24q+UpXasLtWOtfS81esPFUe/mjlfA7x4XkfTz2X/zSH3M/2WY3vBro9NaVK/ic75Tx5s4/kT5q3v2PntDe2ZNCPzainHLXZW1fTnnZx2tNu49+5mrPPmna9bvRe+tnVnPxQj/U/3cfHeNYFlPfMGGb601L3TTMjqwPYlp7b7f7RTDnt+0Dj4JTNfhQ7vDJTnvaontsv/tnM2TC2yjB+7BX5yU1dN2N23wwN3ms5u5p2pibRO1U6eVqfX0m0G96v5LdDgX+6kvH5leTTiZ05tNZ9uzle/mBm3DTjTwuJR+2nfMWM+W0zHH/zrbe7sRlUGj+6GpZqH1yNDzZcffysTn9lplOs+MhMKd8wM5wQj59lYi/MFGfcPBLg3eRZNoQGJaW7P3h9esF6FB62r5g5m+Gt/LW55lHf4pPKfbPbN1S+Yqb7k5nSv2KmnZjp218c3vH0renhd+dSHU8rleeS0Ltmnq/mvpn+pPYb/e5cahvvwW1r6fZNjfoFM/1JIdaTt9tm1LHhweNuguiZJ8Jj8XQybsZfPIK7ZeJi9e7jv7s0EqmXdGLmfLXSn0oqj7XCyWrlxZeHL65WRvnKMuOFmauLnnMzl1cro39ltXJu5upqJW3bN1Yr75g5Wa28NHNttZI2+3RavriSq6uV+IDWhwni9Ie+vj54w8zZG/mpmesv9i+u5uqL/bmZy2/kL8w8vZH35t8w88HVXH6xPzVz/cX+3MzlF/tTM9df7N8wc/Jin852Dr4xLa+/2L8wU75i5vKL/RtmTl7sU7a/OLyXX+xfmLn6Yv/G1dw3c/nF/tTM9Rf7Fzd19cX+1Mz1F/sXZq6+2J+bufpin+wvHsHXX+zPzXzpxb4aO9rV72+u8PmvB/vZ5sr1ItjpI/d8z8gTBzr87HKSn31IpFU+Xrjln9cryU+aymdr+oiHPWk0xx/fPP189c/m4PN3dv5k5Gz8XhT+pLPgXhT+vLgd9O5pPH827x0jeZMAIqfnL4T9yUj7Rkz6XxyTnPQT5/zcAri/N/SfXqGfjyD+eeiffafr8c5xJIbHor3dtZJNCoj8pMR404opeffnxoZvWqmuO6rN71pptAZt3e5a6ZXOxk/H7/5o5fS0GGfWSv/xtNjjOs62jzmP2NOzUuZPN3Oy9/Z43z6MNE/+s5GzRny96RjxI+3ne0bGptX52J4VrH8ycrrh+9vZ8JLvmmE6TzN2/2qoC2W7bYZ2tFNcePumzNKTiOLsas5ajLeng+utPn2qrL5lpdPX9sG3rSCja8+fbqtvBaZUBJv1bBa0s1eF5BzPez4+/sdrOf/ghfGJxfzcXO7PZs4kQFt7UtU+5YbyjpGnn6g/n++9beT5+NF9I+2uET4A38d9I/mrRsZTfeA9I4NeHsPv/sRDKuM0ng9UvWNkflxcRfRnpf6bV6IK2Wi3r4SPKD6XVd8zknRa5zGNxxeMuN01Mp5eKu9eSeaTjL91S3nzSvIXjLQvXEl2Dh8/VbP+bOR0QbZRj61bbTeTdd2QX9fHmv+2meeruW8m8X2Wx95N/dnMqB/vtJxfSeYbLzXbdveGjNenan43Lo8lN0Wx/LTJ9+aTubenfdRx+6acV5bqo941U56a/5TbIW7Gq0+z/vNbS7zJfroOz2cba5fX4ec35PqW74PH3dew0XjJHc9ftH/TTE8NM8+9ND64mvtmOvsbY2w/m8ln3079RoIYQ+v5B9ebNzQf93osPfZC610zTW/Lj538bHfNdJ1HePDdq3ks5ZFrttHy7asZfMF4pNshfvom9DZO1iM5jb90zDzGJJ9kTs+bEn+6kpy+kKpy/otT1eNJ9PSOaOnu6J2fhZGZ6um+GX8yc/9qeMlLzz3F//wrtdPVgF7zZrm53VzYdz5Ckkf6sbHT42LOzjRsT2WcLT91iXnU596zU596NTyXDv9kx04LDS0/xdjv26mkiPT84bq3ryeVr1xP49vvc9fvvh3F+cHPBfA/2jmvSNLZfrTyc1Uo28lI9qpr8drK3UvpWtiOnk/GsZ2Ov/F8Av35VOOf4uun305r9Np/Puv251/p/GrYgE/PD+837Tz+H6e2n9faH9mp9+249geiL+VtOwVZVqqnWefcTnu6r/Yk73rTzuPlnfLxNu7byU/V7Oc++u/b6U92+m07hcOouZT2HTv9fnzak163jf4VO7/tgL9n53e12HZ7npaEPKA8FwXetZOpbZfnzj5/tlO+sHecyxf2jl/ckT1FxvrZCDx7SFy+o5r+8jsadLWpm93OXY/aXMZOt+/YGbfnQnXOBz7ekW/P8Vo2NGwln13P2f5XK3w9o+TtO1fj9b4dai+1jPt2KoKvB4+vXE9N25fs3L6v7pIkPbax7mfSx3Y7YsFkt0dzZ+Nm9gwoH9jp2Km3n1g9bdhJ+SxrnH9N6iuz4ver8fvRyciB+3MP2o/s9Ns5tT99DfOxr3rfzlNPhu733+MeG7qoIWu+fz3VEGc+HzR52w4HEHpLt98He3vatG73s+rvdsr9+LTOeG73399/s9PT7XnRNvae29ZuX8/IvOeOfP+pM/i04IPLdt8OWX5Yv/30Go6Uabh9YIe+9cPH7fE8CodPRrk/30dlm3LU++vj8ZQ3HnbqV+y0++vsR6n+ScHwwXhu9OYf/fZ6/bGrgXpg61u/W3oaanYzxjgTjV020u4ZSdv21I31t+2eD8z0fNdMzk89c/22GUu0LjS3u2YGW4RpS9tNM7Pt4VNRzm6baU9mRvnK1XxghspV+k2h9J6ZzDJ9qgHumjHOuyXL981waiNZKfev5unrO+VkTp3KiIveUVo5m1HnRvRC0H7rrPiWkcoXbetJVCyf7nomFG3PErA/2jgTtGXKrr9JYN66jo3rsB+v40VAtCH3KAimk6ieac0zjeiz/2hkO1WasKv9rANNf4zH2SFPV8ot/vNlPIycBOSqWv3UyFW1up1tVF1XZJudKgYuqqDP7+jibpedfc718m7X+aVc3O0yq1/Z7TJrX9jtenU1V3e7zu1c3+16x069b+fybtcLO5d3u17YubzbdW7n+m7XCzuXd7te2rm42/XCzuXdrnfs9Pvxubzb9Yad092uczvXd7te2Lm82/XCzuXdLitfUGjGTtSne0Mv7ujybpd9Y//OvrF/9+KOLu92ndu5vtv1jp1xey5c3+16Yefybpedfcf7cl3/navxet/O1d2uF3Yu73a9cT2nu11v2bl9X9d3u87tXN/tenE9l3e7Xtq5uNv1ws7l3S4762j5pVlxfbfrhZ3Lu13v2Om3c+r13a5Xo/nqbtcLO5d3u17Yubzb9crO1d2uF3Yu73a9Y6fcj8/l3a437Jzudr3IYpd3u87tXN/temHn8m7XKztXd7te2Lm82/XKztXdrhd2Lu92vbBzebfr1fVc3e16w067v86+vtv1ys7V3a5TO2/sdp2Xni7udr1hpN0zcn236x0zPd81c3W364WZq7tdL8yU/PTVvPtXU9PTB++s3zXT+tP34bbbv1SjjPsw075iJt0OcX/6AF9v5bYZnue/H4r7wMz9UXx1l/TczOVd0ldmLu6SvnM1H5i5uEv6wszVXdIXZq7ukr4yc3GX9OXVXNolPdsAe2oUOZ6aMv9hA+zMwuB41G9j9w0LWtrPdtcfW2g3LOTEKdnU/ZYFvZLnvH16DXct1MZd2B0L1nUNz+vSP26I+mlTy4sbon62aXd1Q/TUyNUNUT+v4l/dEHX7Rluo8zu6uCHqZyqsyxui55dycUPUz1pZvrEh6metDi9viL66mqsboud2rm+IvmOn3rdzeUP0hZ3LG6Iv7FzeED23c31D9IWdyxuiL+1c3BB9Yefyhug7dvr9+FzeEH3DzumG6Lmd6xuiL+xc3hB9YefyhqiffnTu4vahn6nnrm4fvrijyxuiftbt4Pod2V9+R5c3RM/tXN8QfcfOuD0Xrm+IvrBzeUPU6/jC1s87V+P1vp2rG6Iv7FzeEH3jek43RN+yc/u+rm+Intu5viH64noub4i+tHNxQ/SFncsbot63v3xWXN8QfWHn8oboO3b67Zx6fUP01Wi+uiH6ws7lDdEXdi5viL6yc3VD9IWdyxui79gp9+NzeUP0DTunG6IvstjlDdFzO9c3RF/Yubwh+srO1Q3RF3Yub4i+snN1Q/SFncsboi/sXN4QfXU9VzdE37DT7q+zr2+IvrJzdUP01M4bG6LnpaeLG6JvGGn3jFzfEH3HTM93zVzdEH1h5uqG6AszVzdEX5i5uiH6wszVDdFXZi5uiL5jJt0O8dUN0VdmLm6IvmPm/ii+uiF6bubyhugrMxc3RN+5mg/MXNwQfWHm6oboCzNXN0Rfmbm4Ifryaj7dEM1O897nWsobW2iV1vaPt/87Foq+CXHbgl5ncqm3thJ7UYfd3/r0/mEjsJz9IFaVca0+d71+ywhnNO25+PemEe3r2G/9X28b+flKzqI6+BrLb+8tf7qM8Y2ojm9EdXwjquOvjKrxmUrb2slYPfvMWc7s39vTJ3XT+KORcjZraFf8/F2ZPxs52W92vhb1qGbUm0b4KORjc9vuGtGJ84+MpM+NuB5X7v1uTIoWH489i/GzkbMPSma+XJt/++J8+6ORs++FVIw89wP4sxE/XSSyFn/qgf6WkbxlmtX72ZV8/HWOF9dBd+TtqSHAn6+j/7XXkXj25udqeHvPiH3DyPa5ESZf/q189EcjZ9tvyXgd96eVyntGnAqL+1eMtLtGeIP2Wm8b0UrHe/rC7dw2Urb0tBX+BSN22wgf/yrP+5B/NHLWq//iHD6/Dr6TWM9mTvPPc8lpluczvfUsp7X6hSzf6heyfPs8u55fx8Usf7aV9o3ruJrlXxixbxjZPjdyNcv38oUsf2rkapa/bqTdNXIxy78wci3LX76d20auZvnLRuy2kYtZfnyeXc+v42KWH/WvzfJ8vzm3cRLU0b8w+U6NXJ181420u0YuTr4XRq5Nvsu3c9vI1cl32YjdNnJt8tWtfTzoz6/j2uSr2/j4Ok4LLoNedCONe1Wbxx77MdAeD1K7a0S/zKNq0j43krftJyOntTCVsR73Mu5U04xqmvWfj4DUVD+vpsXO3qfVtGiu+Gk17dzIxWraCyPXqmmvjKTPjVyspp0buVhNiy+4fVpNi6/JfVpNq/kL66xTI1fXWTV/vM56cR3X1lnVtr/2Oi6us14ZsW8Y2T43cnGdFaK/T1/1zo1cfNV7w0i7a+Taq94rI5de9a7fzm0jF1/1rhux20Yuvur5x+usF9dx8VXP6+e5pHxeTavev5Dlz4xczvLl8+x6fh0Xs3zJf+11XM3yL4zYN4xsnxu5muXPGkFezvKnRq5m+etG2l0jF7P8CyPXsvzl27lt5GqWv2zEbhu5mOXr59n1/DouZvna/9osf7GaVtv2hcl3auTq5LtupN01cnHyvTBybfJdvp3bRq5OvstG7LaRi5OvfVzFenEdFydfTx9fx2nB5WI17dTI1ULYZSM3C2GmvjTmfxBR/n8e/9s//Jd/+q//+Z//9b/8w7/907/+y3+bf9it/u0/jakv6dZEXTQO8u1BcwO6exJlkYl8kk8qoipqoumjlknjoLKJkiiLTOSiIqqiJpKPIh9VPqp8VPmo8lHlo8pHlY8qH1U+qnw0+Wjy0eSjyUeTjyYfTT6afDT5aPLR5aPLR5ePLh9dPrp8dPno8tHlo8vHkI8hH0M+hnwM+RjyMeRjyMeQj3H4GNsmSqIsMpGLiqiKmqiL5CPJR5KPJB9JPlL4qJOKqIrCx5jUoyfNpHFQ3kRJNH1M3cfIJnJREVVRE3XROMg2URLJh8mHyYfJh8mHyYfJh8mHy4fLh8uHy4fLh8uHy4fLh8uHy0eRjyIfRT6KfBT5KPJR5KPIR5GPIh9VPqp8VPmo8lHlo8pHlY8qH1U+qnw0+Wjy0eSjyUeTjyYfTT6afDT5aPLR5aPLR5ePLh9dPrp8dPno8tHlY83zOZ6Hxu7Q2I15vshE8jHkY8jHkI81z8Ny3MfjqfbYbdrABGbQQN9dziNiYAUbeNzQA4cwbWACM2ig75f7wKJriIm/YwM7yL1p8j8wgRk00OVYGeCBFWwg95a5t0gD63qNSBqRNCK5UsFC7s2IpBFJ6+AQOpF0IulE0omkc2/Ova3Hf1yvE0knkk4kC6OkcG+FSBYiWRglhVFSiGQhkoVIFiJZubfKva3XgbjeSiQrkaxEsjJKKvdWiWQlko1R0hgljUg2ItmIZCOSjXtr3Fvrut5GJDuR7ESyM0o699aJZCeSnVHSGSWdSHYiOYjkIJKDexvc22C+DSI5iOQgkoNRQi5JmyKZtgRm0EBFMm0FrGADO6h7S0nzLSVFMqUMGuhgARXJlBrYQY2SlBXJlBOYQQO5N3JJyppvKSuSKXeQSNoGcm9GJI1ImoMFJJJGJI1IGpEklyRySXLNt+RE0omkE0mvIPfmRNKJZGGUFEZJIZKFSBYiWYgkuSSRS1LRfEuFSFYiWYlkZZSQS1IlkpVIVkZJZZRUIlmJZCOSjUiSSxK5JDXNt9SIZCOSjUg2Rgm5JHUi2YlkZ5R0Rkknkp1IdiLZiSS5JJFL0mC+DSI5iOQgkoNRQi5Jg0gOIjkYJUOjJG+KZN4SmEEDHSyg5lveFMm8dVCRzGkDE6hI5mSggwVUJHNqYAcVyUwuyeSSnDXfclYkc3awgBXk3rIimTORtA1MIJE0ImlE0ogkuSSTS7JpvmUjkk4knUh6Brk3J5JOJL2CDSSSTiQLkSxEklySySW5aL7lQiQLkSxEsjBKyCW5EslKJCujpDJKKpGsRLISyUokySWZXJKb5ltuRLIRyUYkG6OEXJIbkWxEsjFKGqOkE8lOJDuR7ESSXJLJJbkz3zqR7ESyE8nBKCGX5EEkB5EcjJLBKBlEchDJQSSHImnkEiOX2Kb5ZqxxbHOwgBVsoCJpmyJpaQMTqEgaaxxLDhawgg3UfDPWOJY3MIEZ5N6yImm5gBVsoCJprHHMiKQRSXKJkUvMNN+MNY4ZkTQiaR3k3pxIOpH0DBpIJFnjmBNJJ5LkEiOXWNF8M9Y4VohkIZKFUUIusUIkC5EsjJLCKGGNY6xxrBLJSiTJJUYusar5ZqxxrBLJSiQbo4RcYo1INiLZGCWNUcIax1jjWCOSjUiSS4xcYp35xhrHOpHsRLIzSsgl1olkJ5KDUTIYJaxxjDWODSI5iCS5xMglNphvrHGceolTL3HqJU4uceolTr3EqZc49RJnjeOscZx6iVMvcXKJk0uceomzxnHqJU69xKmXOLnEqZc49RKnXuLUS5w1jrPGceolTr3EySVOLnHqJc4ax6mXOPUSp17i5BKnXuLUS5x6iVMvcdY4zhrHqZc49RInlzi5xKmXOGscp17i1EuceomTS5x6iVMvceolTr3EWeM4axynXuLUS5xc4uQSp17irHGceolTL3HqJU4uceolTr3EqZc49RJnjeOscZx6iVMvcXKJk0uceomzxnHqJU69xKmXOLnEqZc49RKnXuLUS5w1jrPGceolTr3EySVOLnHqJc4ax6mXOPUSp17i5JJCvaRQLynUSwr1ksIap7DGKdRLCvWSQi4p5JJCvaSwxinUSwr1kkK9pJBLCvWSQr2kUC8p1EsKa5zCGqdQLynUSwq5pJBLCvWSwhqnUC8p1EsK9ZJCLinUSwr1kkK9pFAvKaxxCmucQr2kUC8p5JJCLinUSwprnEK9pFAvKdRLCrmkUC8p1EsK9ZJCvaSwximscQr1kkK9pJBLCrmkUC8prHEK9ZJCvaRQLynkkkK9pFAvKdRLCvWSwhqnsMYp1EsK9ZJCLinkkkK9pLDGKdRLCvWSQr2kkEsK9ZJCvaRQLynUSwprnMIap1AvKdRLCrmkkEsK9ZLCGqdQLynUSwr1kkIuKdRLCvWSQr2kUC+prHEqa5xKvaRSL6nkkkouqdRLKmucSr2kUi+p1EsquaRSL6nUSyr1kkq9pLLGqaxxKvWSSr2kkksquaRSL6mscSr1kkq9pFIvqeSSSr2kUi+p1Esq9ZLKGqeyxqnUSyr1kkouqeSSSr2kssap1Esq9ZJKvaSSSyr1kkq9pFIvqdRLKmucyhqnUi+p1EsquaSSSyr1ksoap1IvqdRLKvWSSi6p1Esq9ZJKvaRSL6mscSprnEq9pFIvqeSSSi6p1Esqa5xKvaRSL6nUSyq5pFIvqdRLKvWSSr2kssaprHEq9ZJKvaSSSyq5pFIvqaxxKvWSSr2kUi+p5JJKvaRSL6nUSyr1ksoap7LGqdRLKvWSRi5p5JJGvaSxxmnUSxr1kka9pJFLGvWSRr2kUS9p1Esaa5zGGqdRL2nUSxq5pJFLGvWSxhqnUS9p1Esa9ZJGLmnUSxr1kka9pFEvaaxxGmucRr2kUS9p5JJGLmnUSxprnEa9pFEvadRLGrmkUS9p1Esa9ZJGvaSxxmmscRr1kka9pJFLGrmkUS9prHEa9ZJGvaRRL2nkkka9pFEvadRLGvWSxhqnscZp1Esa9ZJGLmnkkka9pLHGadRLGvWSRr2kkUsa9ZJGvaRRL2nUSxprnMYap1EvadRLGrmkkUsa9ZLGGqdRL2nUSxr1kkYuadRLGvWSRr2kUS9prHEaa5xGvaRRL2nkkkYuadRLGmucTr2kUy/p1Es6uaRTL+nUSzr1kk69pLPG6axxOvWSTr2kk0s6uaRTL+mscTr1kk69pFMv6eSSTr2kUy/p1Es69ZLOGqezxunUSzr1kk4u6eSSTr2ks8bp1Es69ZJOvaSTSzr1kk69pFMv6dRLOmuczhqnUy/p1Es6uaSTSzr1ks4ap1Mv6dRLOvWSTi7p1Es69ZJOvaRTL+mscTprnE69pFMv6eSSTi7p1Es6a5xOvaRTL+nUSzq5pFMv6dRLOvWSTr2ks8bprHE69ZJOvaSTSzq5pFMv6axxOvWSTr2kUy/p5JJOvaRTL+nUSzr1ks4ap7PG6dRLOvWSTi7p5JJOvaSzxunUSzr1kk69pJNLBvWSQb1kUC8Z1EsGa5zBGmdQLxnUSwa5ZJBLBvWSwRpnUC8Z1EsG9ZJBLhnUSwb1EmSqCZ1qGqxxBmscpKoJrWpCrJpQq6ZBvWSwxhnUSwb1kkG9ZJBLBvWSQb1kUC8Z1EsQriaUqwnpakK7mhCvJtSraVAvGaxxBvWSQb1kUC8Z5JJBvWRQLxnUSwb1EoSsCSVrQsqa0LImxKwJNWsa1EsGa5xBvWRQLxnUSwa5ZFAvGdRLBvWSQb0EYWtC2TqPiYJEklyCujUN6iWDNc6gXjKolwzqJYNcMsglg1yyy1w90EAHCzi99bihyCU7dnAII5fsmMAMGuhgAfE28DbwNg5veeled0xgBg10sIAVbGAH8ZbwlvCW8JbwlvCW8JbwlvCW8JbwlvGW8ZbxlvGW8ZbxlvGW8ZbxlvFmeDO8Gd4Mb4Y3w5vhzfBmeDO8Od4cb443x5vjzfHmeHO8Od4cbwVvBW8FbwVvBW8FbwVvBW8FbwVvFW8VbxVvFW8VbxVvFW8VbxVvFW8Nbw1vDW8Nbw1vDW8Nbw1vDW8Nbx1vHW8dbx1vHW8dbx1vHW8dbx1vA28DbwNvA28DbwNvA28DbwNv5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkkQuSeSSRC5J5JJELknkkqV7nZ+rzUv3uqODccKqBFawgR0cQh2ty0ln63LS4bqcdLouJx2vy6nhreGt4a3hreGt463jreOt463jreOt463jreOt423gbeBt4G3gbeBt4G3gbeBt4E3n7nLWwbucdfIuZx29y1ln73LW4bucdfouZx2/y1nn73LWAbycN7wlvCW8JbwlvCW8JbwlvCW8JbwlvGW8ZbxlvGW8ZbxlvGW8ZbxlvGW8Gd4il8zTgnnpXnc00MHwNgIr2MBj1ZGz6iU5q/aas2qvOatekrPqJTmrXpKz6iU5q/aas2qvGd1rRvea0b1mdK8Z3WtG95pzwVvBW8FbwVvBW8FbxVvFW8VbxVvFW8VbxVvFW8VbxVvDW8Nbw1vDW8Nbw1vDW8Nbw1vDW8dbx1vHW8dbx1vHW8dbx1vHW8fbwNvA28DbwNvA28DbwNvA28Cb9nEyuteM7jWb9oSzaU84m+ol2VQvyaZ6STbVS/LSvcZkQPea0b1mdK/ZtCec0b1mdK956V6XMdVes6n2mk31kmwJbxlvGW+Ze8t4y3jL3Fvm3jL3ptprXrrXdWWql2RTvSSbaq/ZVHvNptprNtVLsqn2mk2112zkEjN+N+d3c343comRS9C95qV7XdfrRNKJpGqv2VR7zVa4t0IkC7+baq/ZVHvNRi4xcomRS4xcYuQSdK956V7X9VYiWYlkJZKqvWar3FslkpVIVkZJY5SQS4xcYuQSI5cYuQTda16613W9jUg2ItmJZGeUdO6tE8lOJDujpDNKyCVGLjFyiZFLjFyC7jUv3eu63kEkB5EcRHIwSgb3Jn1JdtVes6v2ml211+zkEieXOLnEySVOLkH3mpfuNa7XpS/JrtprdtVes6v2ml211+zSl2RX7TW7aq/ZySUufUl21V6zq/aanVzi5BJ0r3npXtf1Sl+SXbXX7Kq9ZlftNTu5xI1IGpFU7TW7aq/ZjUgakTQiaUSSXILuNS/d67peJ5JOJJ1IqvaanVziTiSdSDqjpDBKeC9x3kuc9xLnvcTJJehe89K9rustRLIQyUokK6OEXOKVSFYiWRkllVHCe4nzXuK8lzjvJU4uQfeal+51XW8jko1INiLZGCXkEm9EshPJzijpjBLeS5z3Eue9xHkvcXIJutfsnfk2iOQgkoNIDkYJucQHkRxEcjBKBqOE95LCe0nhvaTwXlLIJehe89K9xvUW6Utykb4kF2nVcpFWLRdySeG9pPBeUqRVy0VatVykL8lF+pJcpC/JRVq1XMgl6F7z0r2u65W+JBfpS3KRVi0XadVyIZcU6UtykVYtF2nVcpFWLRcjkkYkjUgakSSXoHvNhTVOMSJpRNKJpLRquZBLihNJJ5LSquUirVourHEKa5zCGqewxinkEnSveele1/UWIlmIZCGShVFCLimFSFYiWRkllVHCGqewximscQprnEIuQfeal+51XW8jko1INiLZGCXkktKIZCOSjVHSGCWscQprnMIap7DGKeQSdK956V7X9XYi2YlkJ5KdUUIuKYNIDiI5GCWDUcIap7DGKaxxCmucQi5B95qX7jWut0pfkqv0JblKq5artGq5kkuq9CW5SquWK2ucyhqnSl+Sq/QlubLGqaxxKrkE3Wuu6lyUq/QluUpfkqu0arlKq5YruaRKX5KrtGq5SquWq7RqubLGqaxxaiaSRiTJJehe89K9rutljVONSBqRlFYtV3JJpV5SqZdU6iVVWrVcWeNU1jiVekmlXlLJJehe89K9rutljVMLkSxEsjBKyCW1EMlCJAujpDBKWONU1jiVekmlXlLJJehe89K9rutljVMrkaxEsjJKyCW1EclGJBujpDFKWONU1jiVekmlXlLJJehe89K9rutljVM7kexEsjNKyCW1E8lOJDujZDBKWONU1jiVekmlXlLJJehe89K9rutljVOlL8lNWrXcpFXLjVzSpC/JTVq13KRVy01atdxY4zTWOE36ktykVcuNXILuNS/da1xvY43TpC/JjXpJo17SyCWNekmjXtKolzRp1XJjjdNY4zTqJY16SSOXoHvNjXpJY43TqJc06iWNekkjlzTqJY16SaNe0qiXNNY4jTVOo17SqJc0cgm619yolzTWOI16SaNe0qiXNHJJo17SqJc06iWNekljjdNY4zTqJY16SSOXoHvNjXpJY43TqJc06iWNekkjlzTqJY16SaNe0qiXNNY4jTVOo17SqJc0cgm619yolzTWOI16SaNe0qiXNHJJo17SqJc06iWNekljjdNY4zTqJY16SSOXoHvNjXpJY43TqJc06iWNekkjlzTqJZ16Sade0qmXdNY4nTVOp17SqZd0cgm619ypl3TWOJ16Sade0qmXdHJJp17SqZd06iWdeklnjdNZ43TqJZ16SSeXoHvNnXpJZ43TqZd06iWdekknl3TqJZ16Sade0qmXdNY4nTVOp17SqZd0cgm619ypl3TWOJ16Sade0qmXdHJJp17SqZd06iWdeklnjdNZ43TqJZ16SSeXoHvNnXpJZ43TqZd06iWdekknl3TqJZ16Sade0qmXdNY4nTVOp17SqZd0cgm619ypl3TWOJ16Sade0qmXdHJJp17SqZd06iWdeklnjdNZ43TqJZ16SSeXoHvNnXpJZ43TqZd06iWdekknl3TqJZ16Sade0qmXdNY4gzXOoF4yqJcMcgm61zyolwzWOIN6yaBeMqiXDHLJoF4yqJcM6iWDeslgjTNY4wzqJYN6ySCXoHvNg3rJYI0zqJcM6iWDeskglwzqJYN6yaBeMqiX0Ks106w1060106410681o3vNg3rJYI0zqJcM6iWDeskglwzqJYN6yaBeMqiX0Ls107w1070107410781o3vNg3rJYI0zqJcM6iWDeskglwzqJYN6yaBeMqiX0Ms108w1080108410881o3vNg3rJYI0zqJcM6iWDeskglwzqJYN6yaBeMqiX0Nv1sZlKJKmX0N4109810+A1D+olgzXOoF4yqJcM6iWDXEKf10yj10yn1zyol9DrNdPsNdPtNQ/qJUO5xDblEttULzH6vRr9Xm1TvcQ21UtsUy4x+r3apnqJbaqX2KZ6idHv1ej3avR7tU31EtuUS2xTLrFN9RKj36vR79U21UtsU73Etsy9qV5im+oltqleYpvqJUa/V6Pfq9Hv1TYjksa9GfemeonR79Xo92qbEUnVS2wz7s2IpBNJ1UtsU73E6Pdq9Hs1+r3a5kTSuTfn3lQvMfq9Gv1ebStEsjBKCvdWiGQhkoVRUhglhUhWIlmJZCWSlXur3JvqJUa/V6Pfq22VSFZGSePeGpFsRLIxShqjpBHJRiQbkWxEsnFvnXvrzLdOJDuR7ESyM0o699aJZCeSnVEyGCWDSA4iOYjkIJKDexvc22C+DSKpeokl1UssqV5iiVxC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vNfSvNda+SUrjbPyS1Z+iea9lua91sovWfklK79E815rpXFWGmfll2jea2nea2nea638kpXGWfklK79E815L815r5Zes/JKVX6J5r7XSOCuNs/JLNO+1NO+1NO+1Vn7JSuOs/JKVX6J5r6V5r7XyS1Z+ycov0bzXWmmclcZZ+SWa91qa91qa91orv2SlcVZ+ycov0bzX0rzXWvklK79k5Zdo3mutNM5K46z8Es17Lc17Lc17rZVfstI4K79k5Zdo3mtp3mut/JKVX7LySzTvtVYaZ6VxVn6J5r2W5r2W5r3Wyi9ZaZyVX7LySzTvtTTvtVZ+ycovWfklmvda6nst9b2W+l5Lfa+lvtdS32ud/JKTxjn5JSe/RPNeS/Ne6+SXnPySk1+iea+lvtdS32up77XU91rqey31vdbJLzlpnJNfcvJLNO+1NO+1Tn7JyS85+SWa91rqey31vZb6Xkt9r6W+11Lfa538kpPGOfklJ79E815L815L815L817r1/ea/5ar5X3Ll0vepWnpWv7dtKj77uPUffdx6r77OHXffZy67z5O3Xcfp+67j1P33cep++7j1LWytbK1srWytbK1srWyjbKNso2yjbKNso2yjbKNso2yjbKtsq2yrbKtsq2yrbKtsq2yrbKtsp2ynbKdsp2ynbKdsp2ynbKdsn33cfr57uP0893H6ee7j9PPdx+nn+9uXz/f3b5+vrt9/Xx3+/r57vb18yibKZspmymbKZspmymbKZspmymbKZsrmyubK5srmyubK5srmyubK5srWyhbKFsoWyhbKFsoWyhbKFsoWyhbKlsqWypbKlsqWypbKlsqWypbKlspWylbKVspWylbKVspWylbKVspWytbK1srWytbK1srWytbK1srWyvbKNso2yjbKNso2yjbKNso2yjbKNsq2yrbKtsq2yrbKtsq2yrbKtsq2ynbKdsp2ynbKdsp2ynbKdspm7jExCUmLjFxiYlLTFxi4hITl5i4xMQlJi4xcYmJS0xcYuISE5eYuMTEJSYuMXGJiUtMXGLiEhOXmLjExCUmLjFxiYlLTFzy9r3+dwGx377X39K0dC1Dy9SytGwtR8vVUtm+u31t392+tu9uX9t3t6/tu9vX9t3ta/vu9rV9d/vavrt9bd/dvrZStlK2UrZStlK2UrZStlK2UrZStla2VrZWtla2VrZWtla2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EYERgRGBEYERgRGBE4ETgROBE4ETgROBE4ETgROBE0EQQRBBEEEQQRBBEEEQQRBBEEEQQRJBEkESQRJBEkESQRJBEkESQRJBEUERQRFBEUERQRFBEUERQRFBEUETQRNBE0ETQRNBE0ETQRNBE0ETwRDBEMEQwRDBEMEQwRDBEMEQwRDBEsESwRLBEsESwRLBEsESwRLBEsERwRHBEcERwRHBEcERwRHBEcEBwZETj5x45MQjJx458ciJR048cuKRE4+ceOTEIyceOfHIiUdOPHLikROPnHjkxCMnHjnxyIlHTjxy4pETj5x45MQjJx458ciJR048cuKRE4+ceOTEIyceOfHIiUdOPHLikROPnHjkxCMnHjnxyIlHTjxy4pETj5x45MQjJx458ciJR048cuKRE4+ceOTEIyceOfHIiUdOPHLikROPnHjkxCMnHjnxyIlHTjxy4pETj5x45MQjJx458ciJR048cuKRE4+ceOTEIyceOfHIiUdOPHLikROPnHjkxCMnHjnxyIlHTjxy4pETj5x45MQDJ94DTrwHnHi/eyzVb/AimDf4h6DtDYpBM/iHoOMNlsEheDnxLzAGziAYvAjyDV4EL+qXE/8CIjAiMCJwInAicCJwInAicCJwInAicCJwIggiCCIIIggiCCIIIggiCCIIIggiSCJIIkgiSCJIIkgiSCJIIkgiSCIoIigiKCIoIigiKCIoIigiKCIoImgiaCJoImgiaCJoImgiaCJoImgiGCIYIhgiGCIYIhgiGCIYIhgiGCJYIlgiWCJYIlgiWCJYIlgiWCJYIjgiOCI4IjgiOCI4IjgiOCI4Ijgg+N1j+QuMgTMIBkDwu8fyJv3dY/kLhv/NMiACcqKRE42caOREIycaOdHIiUZONHKikRONnGjkRCMnGjnRyIlGTjRyopETjZxo5EQjJxo50ciJRk40cqKRE42caOREIycaOdHIiUZONHKikRONnGjkRCMnGjnRyIlGTjRyopETjZxo5EQjJxo50ciJRk40cqKRE42caOREIycaOdHIiUZONHKikRONnGjkRCMnGjnRyIlGTjRyopETjZxo5EQjJxo50ciJRk40cqKRE42caOREIycaOdHIiUZONHKikRONnGjkRCMnGjnRyIlGTjRyopETnZzo5EQnJzo50cmJTk50cqKTE52c6OREJyc6OdHJiU5O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pI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVj+f+FE9hEHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsfz/wglsYthEHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI7l/xdOYBN1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH8v8LJ7CJYRN1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWM5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajY/n/hRPYRB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcv/L5zAJoZN1LEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwd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sW1i28S2iW0T2ya2TWyb2DaxbWLbxLaJbRPbJrZNbJvYNvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NvHYxGMTj008NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE8cmjk0cmzg2cWzi2MSxiWMTxyaOTRybODZxbOLYxLGJYxPHJo5NHJs4NnFs4tjEsYljE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g2cW3i2sS1iWsT1yauTVybuDZxbeLaxLWJaxPXJq5NXJu4NnFt4trEtYlrE9cmrk1cm7g28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw28drEaxOvTbw2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J47vieN74vieOL4nju+J43vi+J44vieO74nje+L4nji+J47vieN74vieOL4nju+J43vi+J44vieO74nje+L4nji+J47vieN74vieOL4nju+J43vi+J44vieO74nje+L4nji+J47vieN74vieOL4nju+J43vi+J44vieO74nje+L4nji+J47vieN74vieOL4nju+J43vi+J44vieO74nje+L4nji+J47vieN74nh2Hs/O49l5PDuPZ+fx7Dyencez83h2Hs/O49l5PDuPZ+fx7Dyencez83h2Hs/O49l5PDuPZ+fx7Dyendez83p2Xs/O69l5PTt/juXfYlysi+uCO/HHsXzb+DmWn238cSy/l5WXtZcdLxsvWy+7Xsad+DmW38uSO/HHsfxeVl7WXna8bLxsvex6GT34cSw/lxU92EovKy9rLzteNl62Xna9zF1od6HdhXYX2l1od6HdhXYX2l1od6HdheMu+DOW9Wcse9yF4y4cd+G4C74nru+J63vi+p64vieu74nre+L6nri+J67viet74vqeuL4nru+J63vi+p64vieu74nre+L6nri+J67viet74vqeuL4nru+J63vi+p64vieu74nre+L6nri+J67viet74vqeuL4nru+J63vi+p64vieu74nre+L1PfH6nnh9T7y+J17fE6/vidf3xOt74vU98fqeeH1PvL4nXt8Tr++J1/fE63vi9T3x+p54fU+8vide3xOv74nX98Tre+L1PfH6nnh9T7y+J17fE69n5+vZ+Xp2vp6dr2fn69n5ena+np2vZ+fr2fl6dr6ena9n5+vZ+Xp2vp6dr2fn69n5ena+np2vZ+fr2fl6dr6ena9n5+vZ+Xp2vp6d73GC4wTHCcYJ/BnL9Wcs15+xXH/Gcv0Zy/VnLNefsVx/xnL9Gcv1ZyzXn7Fcf8by41h+L/NOXO/E9U5c78T1Tlx7cO3BtQfXHlx7cO3BtQfXHlx7cO3BtQfPHjx34bkLz1147sJzF5678NyF5y48duHHsXyX/TiW77L3J72svKy97HjZeNl62fUyduH5nvh8T3y+Jz7fE5/vic/3xOd74vM98fme+HxPfL4nPt8Tn++Jz/fE53vi8z3x+Z74fE98vic+3xOf74nP98Tne+LzPfH5nvh8T3y+Jz7fE5/vic/3xOd74vM98fme+HxPfL4nPt8Tn++J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O49n5/HsPJ6dx7PzeHYez87j2Xk8O49n5/HsPJ6dx7PzeHYez87j2Xk8O49n5/HsPJ6dx7PzeHYez87j2Xk8O49n5/HsPJ6dx7PzeHYez87j2Xk8O49n5/HsPJ6dx7PzeHYez87j2Xk8O49n5/HsvJ6d17PzenZez87r2Xk9O69n5/XsvJ6d17PzenZez87r2Xk9O69n5/XsvJ6d17PzenZez87r2Xk9O69n5/XsvJ6d17PzenZez87r2Xk9O69n5/XsvJ6d17PzenZez87r2Xk9O69n5/XsvO0utLvQ7kK7C+0utLvg2Xk9O69n5/XsvJ6d17PzenZez87r2Xk9O69n5/XsvJ6d17PzenZez87r2Xk9O69n5/XsvJ6d17PzenZez87r2Xk9O69n510nWCdYJ1gnWCdYJ/DsvJ6d17PzenZez87r2Xk9O69n5/XsvJ6d17PzenZez87r2Xk9O69n5/XsvJ6d17PzenZez87Xs/P17Hw9O1/Pztez8/XsfD07X8/O17Pz9ex8PTtfz87Xs/P17Hw9O1/Pztez8/XsfD07X8/O17Pz9ex8PTtfz87Xs/P17Hw9O1/Pztez8/XsfD07X8/O17Pz9ex8PTtfz87Xs/P17Hw9O1/Pztez8/XsfD07X8/O17Pz9ex8PTtfz87Xs/P17Hw9O1/Pztez8/XsfD07X8/O17Pz9ex8PTtfz87Xs/P17Hw9O1/Pztez8/XsfD07X8/O17Pz9ex8PTtfz87Xs/P17Hw9O1/Pztez8/XsfD07X8/O17Pz9ex8PTtfz87Xs/P17Hw9O1/Pztez8/XsfD07X8/O17Pzfe7Ccxeeu/DchecuPHfBs/Pz7Pw8Oz/Pzs+z8/Ps/Dw7P8/Oz7Pz8+z8PDs/z87Ps/Pz7Pw8Oz/Pzs+z8/Ps/Dw7P8/Oz7Pz8+z8PDs/z87Ps/Pz7Pw8O790gnSCdIJ0gnKCcoJyApv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOKzic8mPpv4bOL7zztX/PnPO/9v8d8uxJ//vPP/FuVl7WXH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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_vectors() {\n        let vector_1 = &[0, 1, 2, 3];\n        let vector_2 = &[0, 1, 2];\n        assert(!vector_1.eq(vector_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_vectors() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a built-in vector except that it\n/// is bounded with a maximum possible length. `BoundedVec` is also not\n/// subject to the same restrictions vectors are (notably, nested vectors are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over vectors when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given vector to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_vector(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_vector(&mut self, vector: [T]) {\n        let new_len = self.len + vector.len();\n        assert(new_len <= MaxLen, \"extend_from_vector out of bounds\");\n        for i in 0..vector.len() {\n            self.storage[self.len + i] = vector[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_vector(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_vector out of bounds\")]\n        fn extend_vector_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_vector(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_vector(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use jwt::JWT;\n\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 640;\nglobal MAX_DOMAIN_LENGTH: u32 = 64;\nglobal MAX_EMAIL_LENGTH: u32 = 128;\nglobal MAX_SUB_LENGTH: u32 = 64;\n\n// Verify JWT RSA-2048/SHA-256 signature and prove email domain membership.\n//\n// Adapted from stealthnote circuit. Instead of ephemeral key binding, we bind\n// to the user's Aztec account address and generate a nullifier for double-join\n// prevention.\nfn main(\n    // JWT data (private, never revealed)\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>,\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    // RSA public key (public, verifier checks this is Google's key)\n    jwt_pubkey_modulus_limbs: pub [u128; 18],\n    // RSA signature + reduction params (private)\n    jwt_pubkey_redc_params_limbs: [u128; 18],\n    jwt_signature_limbs: [u128; 18],\n    // Sub claim for nullifier (private)\n    sub_bytes: BoundedVec<u8, MAX_SUB_LENGTH>,\n    // Account address for commitment (private)\n    account_address: Field,\n    // Public outputs\n    domain: pub BoundedVec<u8, MAX_DOMAIN_LENGTH>,\n    nullifier: pub Field,\n    account_commitment: pub Field,\n) {\n    // 1. Verify JWT RSA-2048/SHA-256 signature using partial hash precomputation\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        jwt_pubkey_modulus_limbs,\n        jwt_pubkey_redc_params_limbs,\n        jwt_signature_limbs,\n    );\n    jwt.verify();\n\n    // 2. Assert email_verified == true\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // 3. Extract email and verify domain matches public input\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n    // Safety: domain_start is verified by the '@' assertion and domain byte checks below\n    let domain_start = unsafe { get_domain_start_index(email) };\n\n    // Verify '@' precedes the domain\n    assert(email.storage()[domain_start - 1] == 64, \"char before domain is not '@'\");\n\n    // Verify domain bytes match\n    for i in 0..MAX_DOMAIN_LENGTH {\n        assert(\n            email.storage()[domain_start + i] == domain.storage()[i],\n            \"domain mismatch\",\n        );\n    }\n\n    // 4. Verify sub claim matches private input (for nullifier binding)\n    let jwt_sub: BoundedVec<u8, MAX_SUB_LENGTH> = jwt.get_claim_string(\"sub\".as_bytes());\n    assert(jwt_sub.len() == sub_bytes.len(), \"sub length mismatch\");\n    for i in 0..MAX_SUB_LENGTH {\n        if (i as u32) < jwt_sub.len() as u32 {\n            assert(jwt_sub.storage()[i] == sub_bytes.storage()[i], \"sub mismatch\");\n        }\n    }\n\n    // 5. Compute and verify nullifier = pedersen(sub_field, domain_field)\n    //    This prevents the same Google user from joining the same domain-gated DAO twice\n    let sub_field = bytes_to_field(sub_bytes.storage(), sub_bytes.len() as u32);\n    let domain_field = bytes_to_field(domain.storage(), domain.len() as u32);\n    let computed_nullifier = std::hash::pedersen_hash([sub_field, domain_field]);\n    assert(nullifier == computed_nullifier, \"invalid nullifier\");\n\n    // 6. Compute and verify account_commitment = pedersen(account_address, domain_field)\n    //    This binds the proof to the user's Aztec identity\n    let computed_commitment = std::hash::pedersen_hash([account_address, domain_field]);\n    assert(account_commitment == computed_commitment, \"invalid account commitment\");\n}\n\n// Convert a byte array to a Field element by treating bytes as a big-endian integer\nfn bytes_to_field<let N: u32>(bytes: [u8; N], len: u32) -> Field {\n    let mut result: Field = 0;\n    for i in 0..N {\n        if i < len {\n            result = result * 256 + bytes[i] as Field;\n        }\n    }\n    result\n}\n\nunconstrained fn get_domain_start_index(email: BoundedVec<u8, MAX_EMAIL_LENGTH>) -> u32 {\n    let mut domain_start_index = 0;\n    for i in 0..MAX_EMAIL_LENGTH {\n        if email.storage()[i] == (\"@\".as_bytes())[0] {\n            domain_start_index = i + 1;\n            break;\n        }\n    }\n    domain_start_index\n}\n","path":"/Users/rolldavid/Documents/Projects/priv_ideas/private-dao/app/src/lib/domain-proof/circuit/src/main.nr"},"52":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/rolldavid/nargo/github.com/saleel/noir-jwt/v0.5.1/src/lib.nr"},"53":{"source":"// Copied form https://raw.githubusercontent.com/zkemail/zkemail.nr/refs/heads/main/lib/src/partial_hash.nr\n// Use dependency one zkemail.nr is updated to bignum 0.6.0\n\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"/Users/rolldavid/nargo/github.com/saleel/noir-jwt/v0.5.1/src/partial_hash.nr"},"55":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"56":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"95":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"96":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"98":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"99":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"100":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"102":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"103":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"110":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"142":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/rolldavid/nargo/github.com/zkpassport/noir_rsa/v0.9.1/src/rsa.nr"},"158":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"159":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/rolldavid/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"}},"expression_width":{"Bounded":{"width":4}}}