{
  "file_map": {
    "101": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "103": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "124": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "126": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/calls_generation/external_functions_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, serialized_args_array_len_quote, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n    let serialized_args_array_len: u32 =\n        unquote!(quote { ($serialized_args_array_len_quote) as u32 });\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        serialized_args_array_len, fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\npub(crate) comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::UtilityCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::UtilityCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\n// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf and EnqueueSelfStatic structs\n\n// Note: Unlike for the call registry, the self-call registry stubs directly perform the call instead of returning a\n// call interface struct.\n// TODO(F-131): This ^ is confusing and should be reflected in the naming.\n\n/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private\n/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).\npub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let args_hash = aztec::hash::hash_args($serialized_args_array_name);\n            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);\n            let returns_hash = self.context.call_private_function_with_args_hash(\n                self.address,\n                selector,\n                args_hash,\n                $is_static\n            );\n            returns_hash.get_preimage()\n        }\n    }\n}\n\n// TODO(F-131): Drop the use of the Call in the following 4 functions - it doesn't make sense to not not\n// perform the call directly using the context. I tried doing this already but it became a lot of pain due to the use of\n// slices and them being illegal to return from unconstrained functions. Makes sense to tackle this when cleaning up the\n// call interface code.\n// Note: Once we get rid of the structs we will be able to merge some of the static and non-static stub functions.\n\n/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)\npub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).call(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)\npub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicStaticCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).view(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicStaticCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue_view(self.context);\n        }\n    }\n}\n\n/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue(self.context);\n        }\n    }\n}\n"
    },
    "129": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr",
      "source": "use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "132": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "136": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/helpers.nr",
      "source": "use crate::macros::{\n    functions::auth_registry::AUTHORIZE_ONCE_REGISTRY,\n    utils::{is_fn_initializer, is_fn_only_self, is_fn_view},\n};\nuse std::meta::ctstring::AsCtString;\n\n/// Gathers all attributes relevant to the function's ABI and returns a quote that can be applied to the newly generated\n/// function. We apply the abi marker attributes instead of the original ones (e.g. abi_view instead of view) to avoid\n/// the relevant attribute's functionality from getting triggered.\npub(crate) comptime fn get_abi_relevant_attributes(f: FunctionDefinition) -> Quoted {\n    let mut attributes = quote {};\n\n    if is_fn_view(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_view] };\n    }\n\n    if is_fn_only_self(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self] };\n    }\n\n    if is_fn_initializer(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_initializer] };\n    }\n\n    attributes\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                self.address,\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        let args_len = f.parameters().len();\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(self.msg_sender().unwrap())) {\n            $fn_call(self.context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n"
    },
    "138": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/private.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, create_message_discovery_call, get_abi_relevant_attributes,\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, fn_has_nophasecheck, is_fn_initializer,\n        is_fn_only_self, is_fn_view, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn generate_private_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n\n    let original_params_quotes = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    let params = quote { inputs: aztec::context::inputs::private_context_inputs::PrivateContextInputs, $original_params_quotes };\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let storage_init = if module_has_storage {\n        // Contract has Storage defined so we initialize it.\n        quote {\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            $args_serialization\n            let args_hash = aztec::hash::hash_args($serialized_args_name);\n            let mut context = aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<&mut aztec::context::private_context::PrivateContext> = CallSelf { address: self_address, context: &mut context };\n            let enqueue_self: EnqueueSelf<&mut aztec::context::private_context::PrivateContext> = EnqueueSelf { address: self_address, context: &mut context };\n            let call_self_static: CallSelfStatic<&mut aztec::context::private_context::PrivateContext> = CallSelfStatic { address: self_address, context: &mut context };\n            let enqueue_self_static: EnqueueSelfStatic<&mut aztec::context::private_context::PrivateContext> = EnqueueSelfStatic { address: self_address, context: &mut context };\n            let internal: CallInternal<&mut aztec::context::private_context::PrivateContext> = CallInternal { context: &mut context };\n            aztec::contract_self::ContractSelf::new_private(&mut context, storage, call_self, enqueue_self, call_self_static, enqueue_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(*self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Phase checks are skipped in functions that request to manually handle phases\n    let initial_phase_store = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote { let within_revertible_phase: bool = self.context.in_revertible_phase(); }\n    };\n\n    let no_phase_change_check = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote {   \n            assert_eq(\n                within_revertible_phase,\n                self.context.in_revertible_phase(),\n                f\"Phase change detected on function with phase check. If this is expected, use #[nophasecheck]\",\n            ); \n        }\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            self.context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { self.context.finish() };\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $initial_phase_store\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let body_quote = body.map(|expr| expr.quoted()).join(quote { });\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $no_phase_change_check\n        $context_finish\n    };\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n        $abi_relevant_attributes\n        fn $fn_name($params) -> return_data aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n            $to_prepend\n            $body_quote\n            $to_append\n        }\n    }\n}\n"
    },
    "139": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n"
    },
    "140": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/utility.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::create_message_discovery_call,\n    utils::module_has_storage,\n};\n\npub(crate) comptime fn generate_utility_external(f: FunctionDefinition) -> Quoted {\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Create utility context\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::utility_context::UtilityContext::new();\n            $storage_init\n            aztec::contract_self::ContractSelf::new_utility(context, storage)\n        };\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $message_discovery_call\n    };\n\n    let original_function_name = f.name();\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let params = f\n        .parameters()\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n    let return_type = f.return_type();\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n        }\n    }\n}\n"
    },
    "146": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, owner: AztecAddress, storage_slot: Field, randomness: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field, owner: AztecAddress) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field, owner: AztecAddress) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, owner: aztec::protocol_types::address::AztecAddress, storage_slot: Field, randomness: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [aztec::protocol_types::traits::ToField::to_field(owner), storage_slot, randomness]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                owner: aztec::protocol_types::address::AztecAddress,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                owner: aztec::protocol_types::address::AztecAddress,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        let i = i as u8;\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n"
    },
    "149": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "150": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "151": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n"
    },
    "152": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "153": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n"
    },
    "154": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "156": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "173": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "185": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "188": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::{note_hash_read::NoteHashRead, PrivateContext},\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_read<Note>(retrieved_note: RetrievedNote<Note>) -> NoteHashRead\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(\n        retrieved_note.owner,\n        retrieved_note.storage_slot,\n        retrieved_note.randomness,\n    );\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        NoteHashRead::new_settled(compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        ))\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        NoteHashRead::new_transient(note_hash, retrieved_note.contract_address)\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(retrieved_note: RetrievedNote<Note>) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_note_hash_read(\n        retrieved_note,\n        compute_note_hash_read(retrieved_note),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_read` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_note_hash_read<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_read: NoteHashRead,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash = compute_siloed_note_hash(\n            note_hash_read.contract_address().unwrap(), // Safe since contract address must be populated for pending note reads.\n            note_hash_read.note_hash(),\n        );\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_read.note_hash()\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification = compute_note_hash_for_nullification(retrieved_note);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(\n        context,\n        retrieved_note.owner,\n        note_hash_for_nullification,\n    );\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "193": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "194": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "195": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "196": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "197": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "202": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "203": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "205": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "207": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            owner,\n            storage_slot,\n            randomness,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _owner: AztecAddress,\n    _storage_slot: Field,\n    _randomness: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _owner: Option<AztecAddress>,\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    owner: Option<AztecAddress>,\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            owner,\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "210": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "211": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "212": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "216": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "226": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::state_variable::StateVariable,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> StateVariable<M + 1, Context> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "228": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "253": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "256": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "257": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "259": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "260": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "263": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "267": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "274": {
      "path": "/Users/rolldavid/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "294": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "353": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "363": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "376": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "377": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "378": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "379": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "386": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "391": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "407": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "409": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "410": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "415": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "419": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "432": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "435": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n// docs:start:uint_note_def\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    /// The number stored in the note.\n    pub value: u128,\n}\n// docs:end:uint_note_def\n\nimpl NoteHash for UintNote {\n    // docs:start:compute_note_hash\n    fn compute_note_hash(\n        self,\n        owner: AztecAddress,\n        storage_slot: Field,\n        randomness: Field,\n    ) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let partial_note = PartialUintNote {\n            commitment: compute_partial_commitment(owner, storage_slot, randomness),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n    // docs:end:compute_note_hash\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        owner: AztecAddress,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        owner: AztecAddress,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = compute_partial_commitment(owner, storage_slot, randomness);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = UintPartialNotePrivateLogContent { public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            owner,\n            storage_slot,\n            randomness,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// Computes a commitment to the private content of a partial UintNote, i.e. the fields that will remain private. All\n/// other note fields will be made public.\n// docs:start:compute_partial_commitment\nfn compute_partial_commitment(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [owner.to_field(), storage_slot, randomness],\n        GENERATOR_INDEX__NOTE_HASH,\n    )\n}\n// docs:end:compute_partial_commitment\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    public_log_tag: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n// docs:start:partial_uint_note_def\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n// docs:end:partial_uint_note_def\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    // docs:start:compute_complete_note_hash\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n    // docs:end:compute_complete_note_hash\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        compute_partial_commitment, PartialUintNote, UintNote, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n        let note = UintNote { value };\n        let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n        let partial_note = PartialUintNote {\n            commitment: compute_partial_commitment(owner, storage_slot, randomness),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n        let note = UintNote { value };\n\n        let commitment = compute_partial_commitment(owner, storage_slot, randomness);\n\n        let private_log_content = UintPartialNotePrivateLogContent { public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // The completion log without the tag should match the note's packed representation.\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n        assert_eq(public_log_without_tag, note.pack());\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "57": {
      "path": "/Users/rolldavid/Documents/Projects/priv_ideas/private-dao/contracts/private_cloak/src/main.nr",
      "source": "pub mod types;\n// pub mod core;       // Contains separate contracts (BaseCloak, CloakRegistry) - must be separate packages\n// pub mod templates;  // Contains GovernorBravoCloak contract - must be separate package\n// pub mod token;      // Contains GovernanceToken, TokenGate contracts - must be separate packages\n// pub mod test;       // Disabled - needs TXE for testing\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract PrivateCloak {\n    // ===== IMPORTS =====\n    use dep::aztec::{\n        keys::getters::get_public_keys,\n        macros::{functions::{initializer, external, internal, view, only_self}, storage::storage},\n        protocol_types::{\n            address::AztecAddress,\n            traits::{Hash, ToField},\n        },\n        state_vars::{Map, PublicImmutable, PublicMutable},\n    };\n    use dep::compressed_string::FieldCompressedString;\n    use crate::types::proposal::{Proposal, VoteTally};\n\n    // ===== STORAGE =====\n    // Following the EasyPrivateVoting pattern - all storage is public\n    // Privacy is achieved through nullifiers that hide who voted\n    #[storage]\n    struct Storage<Context> {\n        // Cloak Configuration (Immutable after init)\n        name: PublicImmutable<FieldCompressedString, Context>,\n        admin: PublicMutable<AztecAddress, Context>,\n        voting_duration: PublicMutable<u32, Context>,\n        quorum_threshold: PublicMutable<u64, Context>,\n\n        // Sponsored Voting Configuration (FPC - Fee Payment Contract)\n        sponsored_fpc_address: PublicMutable<AztecAddress, Context>,\n        sponsored_voting_enabled: PublicMutable<bool, Context>,\n\n        // Membership tracking (public - members and their voting power)\n        member_voting_power: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        member_count: PublicMutable<u64, Context>,\n\n        // Proposals (Public)\n        proposals: Map<Field, PublicMutable<Proposal, Context>, Context>,\n        proposal_count: PublicMutable<u64, Context>,\n\n        // Vote tallies (Public - revealed after voting ends)\n        vote_tallies: Map<Field, PublicMutable<VoteTally, Context>, Context>,\n\n        // ===== TOKEN GATING =====\n        membership_mode: PublicMutable<u8, Context>,\n        token_gate_address: PublicMutable<AztecAddress, Context>,\n        token_address: PublicMutable<AztecAddress, Context>,\n        erc20_token_address_hash: PublicMutable<Field, Context>,\n        erc20_min_balance: PublicMutable<u128, Context>,\n        used_token_nullifiers: Map<Field, PublicMutable<bool, Context>, Context>,\n    }\n\n    // ===== INITIALIZER =====\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        name: str<31>,\n        admin: AztecAddress,\n        voting_duration: u32,\n        quorum_threshold: u64,\n        membership_mode: u8,\n        token_gate_address: AztecAddress,\n        token_address: AztecAddress,\n        erc20_token_address_hash: Field,\n        erc20_min_balance: u128,\n    ) {\n        self.storage.name.initialize(FieldCompressedString::from_string(name));\n        self.storage.admin.write(admin);\n        self.storage.voting_duration.write(voting_duration);\n        self.storage.quorum_threshold.write(quorum_threshold);\n        self.storage.sponsored_fpc_address.write(AztecAddress::zero());\n        self.storage.sponsored_voting_enabled.write(false);\n        self.storage.member_count.write(0);\n        self.storage.proposal_count.write(0);\n        self.storage.membership_mode.write(membership_mode);\n        self.storage.token_gate_address.write(token_gate_address);\n        self.storage.token_address.write(token_address);\n        self.storage.erc20_token_address_hash.write(erc20_token_address_hash);\n        self.storage.erc20_min_balance.write(erc20_min_balance);\n    }\n\n    // ===== PUBLIC FUNCTIONS =====\n\n    /// Adds a new member with voting power (admin only)\n    #[external(\"public\")]\n    fn add_member(new_member: AztecAddress, voting_power: u128) {\n        let caller = self.msg_sender().unwrap();\n        let admin = self.storage.admin.read();\n        assert(caller.eq(admin), \"caller is not admin\");\n\n        // Check if member already exists\n        let existing_power = self.storage.member_voting_power.at(new_member).read();\n        if existing_power == 0 {\n            // New member\n            let count = self.storage.member_count.read();\n            self.storage.member_count.write(count + 1);\n        }\n\n        // Set voting power\n        self.storage.member_voting_power.at(new_member).write(voting_power);\n    }\n\n    /// Remove a member (admin only)\n    #[external(\"public\")]\n    fn remove_member(member: AztecAddress) {\n        let caller = self.msg_sender().unwrap();\n        let admin = self.storage.admin.read();\n        assert(caller.eq(admin), \"caller is not admin\");\n\n        let existing_power = self.storage.member_voting_power.at(member).read();\n        assert(existing_power > 0, \"not a member\");\n\n        self.storage.member_voting_power.at(member).write(0);\n        let count = self.storage.member_count.read();\n        self.storage.member_count.write(count - 1);\n    }\n\n    /// Join with Aztec token proof (mode 2)\n    /// Takes membership_mode and token_address as args since private context\n    /// cannot read public state directly.\n    #[external(\"private\")]\n    fn join_with_aztec_token(membership_mode: u8, token_addr: AztecAddress) {\n        assert(membership_mode == 2, \"not token-gated\");\n        let sender = self.msg_sender().unwrap();\n\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([\n            token_addr.to_field(),\n            secret\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.add_token_member_internal(sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_token_member_internal(member: AztecAddress) {\n        let existing_power = self.storage.member_voting_power.at(member).read();\n        if existing_power == 0 {\n            let count = self.storage.member_count.read();\n            self.storage.member_count.write(count + 1);\n        }\n        self.storage.member_voting_power.at(member).write(1);\n    }\n\n    /// Join with ERC20 proof (mode 3)\n    #[external(\"public\")]\n    fn join_with_erc20_proof(verified_balance: u128, proof_nullifier: Field) {\n        assert(self.storage.membership_mode.read() == 3, \"not erc20-gated\");\n        assert(verified_balance >= self.storage.erc20_min_balance.read(), \"insufficient balance\");\n        assert(!self.storage.used_token_nullifiers.at(proof_nullifier).read(), \"nullifier already used\");\n        self.storage.used_token_nullifiers.at(proof_nullifier).write(true);\n\n        let sender = self.msg_sender().unwrap();\n        let existing_power = self.storage.member_voting_power.at(sender).read();\n        if existing_power == 0 {\n            let count = self.storage.member_count.read();\n            self.storage.member_count.write(count + 1);\n        }\n        self.storage.member_voting_power.at(sender).write(verified_balance);\n    }\n\n    /// Creates a new proposal (anyone can create, but only members can vote)\n    #[external(\"public\")]\n    fn create_proposal(\n        title: FieldCompressedString,\n        description: FieldCompressedString,\n        proposal_type: u8,\n        target_address: AztecAddress,\n        value: u128,\n    ) {\n        let creator = self.msg_sender().unwrap();\n        let proposal_id = self.storage.proposal_count.read();\n        let voting_duration = self.storage.voting_duration.read();\n\n        let proposal = Proposal {\n            id: proposal_id,\n            creator,\n            title,\n            description,\n            proposal_type,\n            target_address,\n            value,\n            start_block: self.context.block_number(),\n            end_block: self.context.block_number() + voting_duration,\n            executed: false,\n        };\n\n        self.storage.proposals.at(proposal_id as Field).write(proposal);\n        self.storage.proposal_count.write(proposal_id + 1);\n        self.storage.vote_tallies.at(proposal_id as Field).write(VoteTally::new());\n    }\n\n    /// Cast a vote on a proposal (private vote using nullifier pattern)\n    /// The vote itself is private - only the tally is revealed\n    #[external(\"private\")]\n    fn cast_vote(proposal_id: Field, vote_choice: bool) {\n        // Compute nullifier to prevent double voting using NSK pattern\n        // This hides WHO voted while still preventing double voting\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([proposal_id, secret]);\n        self.context.push_nullifier(nullifier);\n\n        // Get voting power and add to tally via enqueued public call\n        self.enqueue_self.add_to_tally_internal(\n            proposal_id,\n            vote_choice,\n            sender,\n        );\n    }\n\n    /// Execute a passed proposal\n    #[external(\"public\")]\n    fn execute_proposal(proposal_id: Field) {\n        let proposal = self.storage.proposals.at(proposal_id).read();\n        let tally = self.storage.vote_tallies.at(proposal_id).read();\n        let quorum = self.storage.quorum_threshold.read();\n\n        assert(!proposal.executed, \"already executed\");\n        assert(tally.total_votes >= quorum as u128, \"quorum not met\");\n        assert(tally.yes_votes > tally.no_votes, \"proposal did not pass\");\n\n        // Mark as executed\n        let mut executed_proposal = proposal;\n        executed_proposal.executed = true;\n        self.storage.proposals.at(proposal_id).write(executed_proposal);\n    }\n\n    // ===== ADMIN FUNCTIONS =====\n\n    #[external(\"public\")]\n    fn set_sponsored_fpc(new_fpc_address: AztecAddress) {\n        let caller = self.msg_sender().unwrap();\n        let admin = self.storage.admin.read();\n        assert(caller.eq(admin), \"caller is not admin\");\n        self.storage.sponsored_fpc_address.write(new_fpc_address);\n    }\n\n    #[external(\"public\")]\n    fn set_sponsored_voting_enabled(enabled: bool) {\n        let caller = self.msg_sender().unwrap();\n        let admin = self.storage.admin.read();\n        assert(caller.eq(admin), \"caller is not admin\");\n        self.storage.sponsored_voting_enabled.write(enabled);\n    }\n\n    // ===== INTERNAL PUBLIC FUNCTIONS =====\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_to_tally_internal(\n        proposal_id: Field,\n        vote_choice: bool,\n        voter: AztecAddress,\n    ) {\n        // Verify proposal is still active\n        let proposal = self.storage.proposals.at(proposal_id).read();\n        assert(self.context.block_number() <= proposal.end_block, \"voting ended\");\n\n        // Get voter's voting power\n        let voting_power = self.storage.member_voting_power.at(voter).read();\n        assert(voting_power > 0, \"not a member\");\n\n        // Update tally\n        let mut tally = self.storage.vote_tallies.at(proposal_id).read();\n        if vote_choice {\n            tally.yes_votes += voting_power;\n        } else {\n            tally.no_votes += voting_power;\n        }\n        tally.total_votes += voting_power;\n        self.storage.vote_tallies.at(proposal_id).write(tally);\n    }\n\n    // ===== VIEW FUNCTIONS =====\n\n    #[external(\"public\")]\n    #[view]\n    fn get_name() -> pub FieldCompressedString {\n        self.storage.name.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal(proposal_id: Field) -> pub Proposal {\n        self.storage.proposals.at(proposal_id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_vote_tally(proposal_id: Field) -> pub VoteTally {\n        self.storage.vote_tallies.at(proposal_id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_member_count() -> pub u64 {\n        self.storage.member_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_count() -> pub u64 {\n        self.storage.proposal_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_voting_power(member: AztecAddress) -> pub u128 {\n        self.storage.member_voting_power.at(member).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_sponsored_fpc_address() -> pub AztecAddress {\n        self.storage.sponsored_fpc_address.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn is_sponsored_voting_enabled() -> pub bool {\n        self.storage.sponsored_voting_enabled.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_admin() -> pub AztecAddress {\n        self.storage.admin.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_voting_duration() -> pub u32 {\n        self.storage.voting_duration.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_quorum_threshold() -> pub u64 {\n        self.storage.quorum_threshold.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_membership_mode() -> pub u8 {\n        self.storage.membership_mode.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_token_address() -> pub AztecAddress {\n        self.storage.token_address.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_token_gate_address() -> pub AztecAddress {\n        self.storage.token_gate_address.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_erc20_config() -> pub (Field, u128) {\n        (self.storage.erc20_token_address_hash.read(), self.storage.erc20_min_balance.read())\n    }\n\n    // ===== UTILITY FUNCTIONS =====\n\n    #[external(\"utility\")]\n    unconstrained fn get_tally(proposal_id: Field) -> VoteTally {\n        self.storage.vote_tallies.at(proposal_id).read()\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "84": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "85": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/calls.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata_array};\nuse crate::oracle::execution_cache;\n\n// PrivateCall\n\n#[must_use = \"Your private call needs to be passed into the `self.call(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_private_function(...args))`\"]\npub struct PrivateCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T>\nwhere\n    T: Deserialize,\n{\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_private_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\n// PrivateStaticCall\n\n#[must_use = \"Your private static call needs to be passed into the `self.view(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_private_static_function(...args))`\"]\npub struct PrivateStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_private_static_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\n// PublicCall\n\n#[must_use = \"Your public call needs to be passed into the `self.call(...)`, `self.enqueue(...)` or `self.enqueue_incognito(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_public_function(...args))`\"]\npub struct PublicCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    gas_opts: GasOpts,\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PublicCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub unconstrained fn call(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\n// PublicStaticCall\n\n#[must_use = \"Your public static call needs to be passed into the `self.view(...)`, `self.enqueue_view(...)` or `self.enqueue_view_incognito(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_public_static_function(...args))`\"]\npub struct PublicStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    return_type: T,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, let N: u32, T> PublicStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub unconstrained fn view(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view_incognito(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\n// UtilityCall\n\npub struct UtilityCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> UtilityCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n"
    },
    "92": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/note_hash_read.nr",
      "source": "use protocol_types::address::aztec_address::AztecAddress;\n\npub struct NoteHashRead {\n    note_hash: Field,\n    contract_address: Option<AztecAddress>,\n}\n\nimpl NoteHashRead {\n    pub fn new_transient(note_hash: Field, contract_address: AztecAddress) -> Self {\n        assert(\n            !contract_address.is_zero(),\n            \"Can't read a transient note with a zero contract address\",\n        );\n        Self { note_hash, contract_address: Option::some(contract_address) }\n    }\n\n    pub fn new_settled(note_hash: Field) -> Self {\n        Self { note_hash, contract_address: Option::none() }\n    }\n\n    pub fn note_hash(self) -> Field {\n        self.note_hash\n    }\n\n    pub fn contract_address(self) -> Option<AztecAddress> {\n        self.contract_address\n    }\n}\n"
    },
    "93": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{\n        inputs::PrivateContextInputs, note_hash_read::NoteHashRead, returns_hash::ReturnsHash,\n    },\n    hash::{hash_args, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter, notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, find_first_index, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // Incrementing the side effect counter when ending setup ensures non\n        // ambiguity for the counter where we change phases.\n        self.side_effect_counter += 1;\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardize on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact approach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n        let side_effect = Scoped::new(\n            Counted::new(note_hash, self.next_counter()),\n            contract_address,\n        );\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Asserts that a NoteHashRead has been requested to the kernel by this context.\n    /// Asserts instead of returning a boolean to save on gates.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash read to assert that has been requested.\n    ///\n    pub fn assert_has_been_requested(self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n\n        // Safety: The index is constrained by the checks below.\n        let hinted_index = unsafe {\n            find_first_index(\n                self.note_hash_read_requests.storage(),\n                |r| (r.contract_address == contract_address) & (r.innermost() == note_hash),\n            )\n        };\n        // This assertion is not necessary, since the .get would fail. But it enables us to have a more explicit error message.\n        assert(\n            hinted_index != self.note_hash_read_requests.max_len(),\n            \"Note hash read has not been requested\",\n        );\n\n        let request = self.note_hash_read_requests.get(hinted_index);\n        assert_eq(request.contract_address, contract_address);\n        assert_eq(request.innermost(), note_hash);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    /// * `contract_address` - The contract address that emitted the nullifier\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the nullifier is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(\n        &mut self,\n        nullifier: Field,\n        contract_address: AztecAddress,\n    ) {\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incoming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes) or that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "94": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "96": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "97": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr",
      "source": "use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7504532782847838406": {
            "error_kind": "string",
            "string": "caller is not admin"
          }
        },
        "parameters": [
          {
            "name": "new_member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "voting_power",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABEcnAgMEAicCBAQAHwoAAwAEAEUcAEZGBi0IRQEtCEYCJQAAAEolAAAAdScCAQRHJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAMmJQAACw4eAgADAB4CAAQALQgBBQAAAQIBJwIGAAgtDgYFLQgBBwAAAQIBJwIIAAktDggHHgIACAAeAgAJADMqAAgACQAKJwIIAQEkAgAKAAAAzCUAAAs0HgIACQEKIglDChYKCgscCgsMAAQqDAkLJwIJAQAKKgoJDCQCAAwAAAD/JwINBAA8Bg0BJwIKAAMvCgAKAAwKKgsMCiQCAAoAAAEcJQAAC0YnAgoAAC0IAQsnAgwEBAAIAQwBJwMLBAEAIgsCDC0KDA0tDgoNACINAg0tDgoNACINAg0tDgoNKwIADAAAAAAAAAAAAgAAAAAAAAAALQgBDScCDgQFAAgBDgEnAw0EAQAiDQIOLQoODy0OCg8AIg8CDy0OCg8AIg8CDy0OCg8AIg8CDy0ODA8tCAEOAAABAgEtDgsOLQgBCwAAAQIBLQ4NCy0IAQ8AAAECAScCEAQALQ4QDy0IAREAAAECAS0OCREnAhIEASQCAAkAAAI1IwAAAe4tCAEDJwIEBAQACAEEAScDAwQBACIDAgQtCgQTLQ4GEwAiEwITLQ4KEwAiEwITLQ4KEy0OAw4tDg0LLQ4SDy0OCREjAAACwS0KEAMjAAACPgwiA0QEJAIABAAACogjAAACUC0LDgMtCwsELQsRDS0LBBMAIhMCEy0OEwQtCAETJwIUBAUACAEUAScDEwQBACIEAhQnAhUEBAAiEwIWPw8AFAAWLQIDAycABAQEJQAAC1gtCAUEACoEEhQtDgYULQ4EDi0OEwstDhIPLQ4NESMAAALBLQsOAy0LCwQtCxEGCioGCQ0kAgANAAAC4ycCEwQAPAYTAScCBgQCJAIACQAAAyUjAAAC9S0CAwMnAAQEBCUAAAtYLQgFDQAqDQYTLQ4BEy0ODQ4tDgQLLQ4GDy0OCREjAAADsS0KEAMjAAADLgwiA0QEJAIABAAACgIjAAADQC0LDgMtCwsELQsRDS0LBBMAIhMCEy0OEwQtCAETJwIUBAUACAEUAScDEwQBACIEAhQnAhUEBAAiEwIWPw8AFAAWLQIDAycABAQEJQAAC1gtCAUEACoEEhQtDgEULQ4EDi0OEwstDhIPLQ4NESMAAAOxLQsRBAoqBAkNJAIADQAAA8snAhMEADwGEwEtChADIwAAA9QMIgNEBCQCAAQAAAl8IwAAA+YtCw4DLQsLBC0LDw0tCwQTACITAhMtDhMELQgBEycCFAQFAAgBFAEnAxMEAQAiBAIUJwIVBAQAIhMCFj8PABQAFi0OAw4tDhMLLQ4NDy0OCBEAKhMSBC0LBAMKKgMKBAoqBAkLJAIACwAABFclAAALty8KAAMABBwKBAsGHAoLAwAcCgMEBicCAwYACioEAwskAgALAAAEgyMAAATILQsHAy8KAAMABBwKBAsFHAoLBwAcCgcEBScCBwUBACoEBwsOKgQLDSQCAA0AAAS4JQAAC8kcCgsEADAKAAQAAyMAAATILQsFAy0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQctDgoHACIHAgctDgoHACIHAgctDgoHLQgBBScCBwQFAAgBBwEnAwUEAQAiBQIHLQoHCy0OCgsAIgsCCy0OCgsAIgsCCy0OCgsAIgsCCy0ODAstCAEHAAABAgEtDgQHLQgBBAAAAQIBLQ4FBC0IAQsAAAECAS0OEAstCAEMAAABAgEtDgkMJAIACQAABcEjAAAFei0IAQ0nAg4EBAAIAQ4BJwMNBAEAIg0CDi0KDg8tDgMPACIPAg8tDgoPACIPAg8tDgoPLQ4NBy0OBQQtDhILLQ4JDCMAAAZNLQoQBSMAAAXKDCIFRA0kAgANAAAI9iMAAAXcLQsHBS0LBA0tCwwOLQsNDwAiDwIPLQ4PDS0IAQ8nAhEEBQAIAREBJwMPBAEAIg0CEScCEwQEACIPAhQ/DwARABQtAgUDJwAEBAQlAAALWC0IBQ0AKg0SES0OAxEtDg0HLQ4PBC0OEgstDg4MIwAABk0tCwcDLQsEBS0LDA0KKg0JDiQCAA4AAAZvJwIPBAA8Bg8BJAIACQAABqwjAAAGfC0CAwMnAAQEBCUAAAtYLQgFDQAqDQYOLQ4BDi0ODQctDgUELQ4GCy0OCQwjAAAHOC0KEAMjAAAGtQwiA0QFJAIABQAACHAjAAAGxy0LBwMtCwQFLQsMBi0LBQ0AIg0CDS0ODQUtCAENJwIOBAUACAEOAScDDQQBACIFAg4nAg8EBAAiDQIRPw8ADgARLQIDAycABAQEJQAAC1gtCAUFACoFEg4tDgEOLQ4FBy0ODQQtDhILLQ4GDCMAAAc4LQsMAwoqAwkFJAIABQAAB1InAgYEADwGBgEtChABIwAAB1sMIgFEAyQCAAMAAAfqIwAAB20tCwcBLQsEAy0LCwUtCwMGACIGAgYtDgYDLQgBBicCDQQFAAgBDQEnAwYEAQAiAwINJwIOBAQAIgYCDz8PAA0ADy0OAQctDgYELQ4FCy0OCAwAKgYSAy0LAwEKKgEKAwoqAwkEJAIABAAAB94lAAALtxwKAgMAMAoAAwABJi0LBwMtCwQFLQsLBi0LDA0MKgEGDiQCAA4AAAgMIwAACGIAIgUCDwAqDwEQLQsQDgAiAwIQACoQAREtCxEPACoODxAtAgUDJwAEBAUlAAALWC0IBQ4AIg4CDwAqDwERLQ4QES0OAwctDg4ELQ4GCy0ODQwjAAAIYgAqARIDLQoDASMAAAdbLQsHBS0LBAYtCwsNLQsMDgwqAw0PJAIADwAACJIjAAAI6AAiBgIRACoRAxMtCxMPACIFAhMAKhMDFC0LFBEAKg8REy0CBgMnAAQEBSUAAAtYLQgFDwAiDwIRACoRAxQtDhMULQ4FBy0ODwQtDg0LLQ4ODCMAAAjoACoDEgUtCgUDIwAABrUtCwcNLQsEDi0LCw8tCwwRDCoFDxMkAgATAAAJGCMAAAluACIOAhQAKhQFFS0LFRMAIg0CFQAqFQUWLQsWFAAqExQVLQIOAycABAQFJQAAC1gtCAUTACITAhQAKhQFFi0OFRYtDg0HLQ4TBC0ODwstDhEMIwAACW4AKgUSDS0KDQUjAAAFyi0LDgQtCwsNLQsPEy0LERQMKgMTFSQCABUAAAmeIwAACfQAIg0CFgAqFgMXLQsXFQAiBAIXACoXAxgtCxgWACoVFhctAg0DJwAEBAUlAAALWC0IBRUAIhUCFgAqFgMYLQ4XGC0OBA4tDhULLQ4TDy0OFBEjAAAJ9AAqAxIELQoEAyMAAAPULQsOBC0LCw0tCw8TLQsRFAwqAxMVJAIAFQAACiQjAAAKegAiDQIWACoWAxctCxcVACIEAhcAKhcDGC0LGBYAKhUWFy0CDQMnAAQEBSUAAAtYLQgFFQAiFQIWACoWAxgtDhcYLQ4EDi0OFQstDhMPLQ4UESMAAAp6ACoDEgQtCgQDIwAAAy4tCw4ELQsLDS0LDxMtCxEUDCoDExUkAgAVAAAKqiMAAAsAACINAhYAKhYDFy0LFxUAIgQCFwAqFwMYLQsYFgAqFRYXLQINAycABAQFJQAAC1gtCAUVACIVAhYAKhYDGC0OFxgtDgQOLQ4VCy0OEw8tDhQRIwAACwAAKgMSBC0KBAMjAAACPigAAAQEeEcMAAAEAyQAAAMAAAszKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVoJXTOJutIxjwEAgEmLQEDBgoABgIHJAAABwAAC24jAAALdy0AAwUjAAALti0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAuxLQEKCC0ECAsAAAoCCgAACwILIwAAC40nAQUEASYqAQABBbq7IdeCMxhkPAQCASYqAQABBdAH6/TLxmeQPAQCASY=",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_member"
    },
    {
      "abi": {
        "error_types": {
          "11649364024006299642": {
            "error_kind": "string",
            "string": "not a member"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5967729769606704330": {
            "error_kind": "string",
            "string": "Function add_to_tally_internal can only be called by the same contract"
          },
          "8927709774589806846": {
            "error_kind": "string",
            "string": "voting ended"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "vote_choice",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "voter",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_to_tally_internal"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13577528510695619250": {
            "error_kind": "string",
            "string": "Function add_token_member_internal can only be called by the same contract"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_token_member_internal"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "vote_choice",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "cast_vote",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "voting_duration",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "quorum_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "membership_mode",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "token_gate_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "erc20_token_address_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "erc20_min_balance",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBsJwAABGwnAgoEJycCCwQAHwoACgALAEUcAEVFAhwARkYCHABHRwIcAEhIAhwASUkCHABKSgIcAEtLAhwATEwCHABNTQIcAE5OAhwAT08CHABQUAIcAFFRAhwAUlICHABTUwIcAFRUAhwAVVUCHABWVgIcAFdXAhwAWFgCHABZWQIcAFpaAhwAW1sCHABcXAIcAF1dAhwAXl4CHABfXwIcAGBgAhwAYWECHABiYgIcAGNjAhwAZWUEHABmZgUcAGdnAhwAa2sGJwIBBEUnAgsEHy0IAQonAgwEIAAIAQwBJwMKBAEAIgoCDC0CAQMtAgwELQILBSUAAAFDLQoKAS0IZAItCGUDLQhmBC0IZwUtCGgGLQhpBy0IaggtCGsJJQAAAXUlAAABoCcCAQRsJwICBAA7DgACAAEAAAMFBy0AAwgtAAQJCgAIBwokAAAKAAABdC0BCAYtBAYJAAAIAggAAAkCCSMAAAFQJiwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAnAEQEAyYlAAAVfR4CAAsAHgIADAAtCAENAAABAgEnAg4AAS0ODg0tCAEPAAABAgEnAhAAAy0OEA8tCAERAAABAgEnAhIABC0OEhEtCAESAAABAgEnAhMABS0OExItCAETAAABAgEnAhQABi0OFBMtCAEVAAABAgEnAhYABy0OFhUtCAEWAAABAgEnAhcACS0OFxYtCAEXAAABAgEnAhgACy0OGBctCAEYAAABAgEnAhkADS0OGRgtCAEaAAABAgEnAhsADi0OGxotCAEbAAABAgEnAhwADy0OHBstCAEcAAABAgEnAh0AEC0OHRwtCAEdAAABAgEnAh4AES0OHh0eAgAeAC0IAR8nAiAEAwAIASABJwMfBAEAIh8CIDYOAB4AIAAnAiAEAQAqHyAiLQsiIScCIgQCACofIiQtCyQjHAohHwAEKh8jJCcCHwEBJAIAIQAAAvknAiMEADwGIwEtCAEhJwIjBAMACAEjAScDIQQBACIhAiM2DgAeACMCACohICMtCyMeACohIiUtCyUjHAoeIQAEKiEjJSQCAB4AAANFJwIhBAA8BiEBJwIeBAAtCAEhJwIjBAIACAEjAScDIQQBACIhAiMfOgAgAB4AIwAqISAmLQsmIxwKIyYEHAomIQAtCAEjAAABAgEnAiYAAi0OJiMtCAEmAAABAgEtDhAmJwIQBCctCAEnJwIoBCgACAEoAScDJwQBACInAigfOgAQACAAKC0IASgAAAECAScCKQAAJwIqACwtCAErJwIsBCkACAEsAScDKwQBACIrAiwtCiwtLQ4qLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLQAiLQItLQ4pLS0OKygnAioEKC0KHgojAAAFZQwqChALJAIACwAAFScjAAAFdy0LKAstCAEMJwIQBAQACAEQAScDDAQBACIMAhAtChAnLQ4pJwAiJwInLQ4pJwAiJwInLQ4pJysCABAAAAAAAAAAACgAAAAAAAAAAC0IAScnAigEBQAIASgBJwMnBAEAIicCKC0KKCstDikrACIrAistDikrACIrAistDikrACIrAistDhArLQgBEAAAAQIBLQ4MEC0IAQwAAAECAS0OJwwtCAEnAAABAgEtDh4nLQgBKAAAAQIBJwIrAQAtDisoLQoeCiMAAAY/DCoKKiwkAgAsAAATYyMAAAZRLQsoCwoqCysqJAIAKgAABmsnAiwEADwGLAEtCh4KIwAABnQMIgpECyQCAAsAABLdIwAABoYtCxALLQsMKi0LJywtCyotACItAi0tDi0qLQgBLScCLgQFAAgBLgEnAy0EAQAiKgIuJwIvBAQAIi0CMD8PAC4AMC0OCxAtDi0MLQ4sJy0OHygAKi0gDC0LDAstCyMMLQsmEC0ODCMtDhAmLQgBDCcCEAQEAAgBEAEnAwwEAQAiDAIQLQoQIy0OGSMAIiMCIy0OISMAIiMCIy0OCyMtCAELJwIQBAQACAEQAScDCwQBACILAhAtChAZLQ4pGQAiGQIZLQ4pGQAiGQIZLQ4pGSsCABAAAAAAAAAAAAMAAAAAAAAAAC0IARknAiEEBQAIASEBJwMZBAEAIhkCIS0KISMtDikjACIjAiMtDikjACIjAiMtDikjACIjAiMtDhAjLQgBEAAAAQIBLQ4LEC0IAQsAAAECAS0OGQstCAEZAAABAgEtDh4ZLQgBIQAAAQIBLQ4rIS0KHgojAAAH4QwiCkQjJAIAIwAAERkjAAAH8y0LIQwKKgwrIyQCACMAAAgNJwImBAA8BiYBLQoeCiMAAAgWDCIKRAwkAgAMAAAQkyMAAAgoLQsQDC0LCyMtCxkmLQsjJwAiJwInLQ4nIy0IAScnAigEBQAIASgBJwMnBAEAIiMCKCcCKgQEACInAiw/DwAoACwtDgwQLQ4nCy0OJhktDh8hAConIAwtCwwLCiolCwwkAgAMAAAIlCUAABWjCiokKQseAgAMAQoiDEMQFgoQGRwKGSEABCohDBkKKhArDCQCAAwAAAjHJwIhBAA8BiEBCiokGQwSKgsMECQCABAAAAjeJQAAFbUtCw0LLQgBDAAAAQIBLQ4pDC0IAQ0AAAECAS0ODg0nAhAEHygCABkAAQAtCh4KIwAACREMKgoQISQCACEAABAlIwAACSMtCwwBLQgBCicCDAQEAAgBDAEnAwoEAQAiCgIMLQoMDS0OKQ0AIg0CDS0OKQ0AIg0CDS0OKQ0rAgAMAAAAAAAAAAACAAAAAAAAAAAtCAENJwIQBAUACAEQAScDDQQBACINAhAtChAZLQ4pGQAiGQIZLQ4pGQAiGQIZLQ4pGQAiGQIZLQ4MGS0IAQwAAAECAS0OCgwtCAEKAAABAgEtDg0KLQgBEAAAAQIBLQ4eEC0IARkAAAECAS0OKxkkAgArAAAKMSMAAAnqLQgBIScCIwQEAAgBIwEnAyEEAQAiIQIjLQojJC0OFCQAIiQCJC0OKSQAIiQCJC0OKSQtDiEMLQ4NCi0OIBAtDisZIwAACr0tCh4NIwAACjoMIg1EISQCACEAAA+fIwAACkwtCwwNLQsKIS0LGSMtCyEkACIkAiQtDiQhLQgBJCcCJQQFAAgBJQEnAyQEAQAiIQIlJwImBAQAIiQCJz8PACUAJy0CDQMnAAQEBCUAABXHLQgFIQAqISAlLQ4UJS0OIQwtDiQKLQ4gEC0OIxkjAAAKvS0LDA0tCwoULQsZIQoqISsjJAIAIwAACt8nAiQEADwGJAEkAgArAAALHCMAAArsLQINAycABAQEJQAAFcctCAUhACohIiMtDgsjLQ4hDC0OFAotDiIQLQ4rGSMAAAuoLQoeDSMAAAslDCINRBQkAgAUAAAPGSMAAAs3LQsMDS0LChQtCxkhLQsUIgAiIgIiLQ4iFC0IASInAiMEBQAIASMBJwMiBAEAIhQCIycCJAQEACIiAiU/DwAjACUtAg0DJwAEBAQlAAAVxy0IBRQAKhQgIy0OCyMtDhQMLQ4iCi0OIBAtDiEZIwAAC6gtCxkUCioUKyEkAgAhAAALwicCIgQAPAYiAS0KHg0jAAALywwiDUQUJAIAFAAADpMjAAAL3S0LDBQtCwohLQsQIi0LISMAIiMCIy0OIyEtCAEjJwIkBAUACAEkAScDIwQBACIhAiQnAiUEBAAiIwImPw8AJAAmLQ4UDC0OIwotDiIQLQ4fGQAqIyAMLQsMCjQCAAorAgAKAAAAAAAAAAABAAAAAAAAAAAtCAEMJwIQBAUACAEQAScDDAQBACIMAhAtChAULQ4pFAAiFAIULQ4pFAAiFAIULQ4pFAAiFAIULQ4KFC0IAQoAAAECAS0IARAAAAECAS0IARQAAAECAS0IARkAAAECAS0IASEnAiIEBAAIASIBJwMhBAEAIiECIi0KIiMtDgEjACIjAiMtDikjACIjAiMtDikjLQ4hCi0ODBAtDiAULQ4rGS0KHg0jAAAM+gwiDUQMJAIADAAADg0jAAANDC0LCgwtCxANLQsUHi0LDSEAIiECIS0OIQ0tCAEhJwIiBAUACAEiAScDIQQBACINAiInAiMEBAAiIQIkPw8AIgAkLQ4MCi0OIRAtDh4ULQ4fGQAqISAMLQsMCjAKAAEACwAqCw4BMAoACgABLQsPATAKAAIAAS0LEQEcCgMCADAKAAIAAS0LEgEcCgQCADAKAAIAAS0LEwEwCgApAAEtCxUBMAoAKQABLQsWATAKACkAAS0LFwEwCgApAAEtCxgBHAoFAgAwCgACAAEtCxoBMAoABgABLQsbATAKAAcAAS0LHAEwCgAIAAEtCx0BHAoJAgAwCgACAAEeAgABADQCAAEmLQsKDC0LEB4tCxQhLQsZIgwqDSEjJAIAIwAADi8jAAAOhQAiHgIkACokDSUtCyUjACIMAiUAKiUNJi0LJiQAKiMkJS0CHgMnAAQEBSUAABXHLQgFIwAiIwIkACokDSYtDiUmLQ4MCi0OIxAtDiEULQ4iGSMAAA6FACoNIAwtCgwNIwAADPotCwwULQsKIS0LECItCxkjDCoNIiQkAgAkAAAOtSMAAA8LACIhAiUAKiUNJi0LJiQAIhQCJgAqJg0nLQsnJQAqJCUmLQIhAycABAQFJQAAFcctCAUkACIkAiUAKiUNJy0OJictDhQMLQ4kCi0OIhAtDiMZIwAADwsAKg0gFC0KFA0jAAALyy0LDBQtCwohLQsQIi0LGSMMKg0iJCQCACQAAA87IwAAD5EAIiECJQAqJQ0mLQsmJAAiFAImAComDSctCyclACokJSYtAiEDJwAEBAUlAAAVxy0IBSQAIiQCJQAqJQ0nLQ4mJy0OFAwtDiQKLQ4iEC0OIxkjAAAPkQAqDSAULQoUDSMAAAslLQsMIS0LCiMtCxAkLQsZJQwqDSQmJAIAJgAAD8EjAAAQFwAiIwInAConDSgtCygmACIhAigAKigNKi0LKicAKiYnKC0CIwMnAAQEBSUAABXHLQgFJgAiJgInAConDSotDigqLQ4hDC0OJgotDiQQLQ4lGSMAABAXACoNICEtCiENIwAACjoCKhAKIQIqISAjDiogISQkAgAkAAAQQSUAABYmLQsMIQwqIxAkJAIAJAAAEFclAAAWOAAiAQIlAColIyYtCyYkHAokIwAtCw0kBCojJCUAKiElIy0OIwwEKiQZIS0OIQ0AKgogIS0KIQojAAAJES0LEAwtCwsjLQsZJi0LIScMKgomKCQCACgAABC1IwAAEQsAIiMCKgAqKgosLQssKAAiDAIsACosCi0tCy0qACooKiwtAiMDJwAEBAUlAAAVxy0IBSgAIigCKgAqKgotLQ4sLS0ODBAtDigLLQ4mGS0OJyEjAAARCwAqCiAMLQoMCiMAAAgWACIMAiYAKiYKJy0LJyMtCxAmLQsLJy0LGSgtCyEqCioqKywkAgAsAAARTScCLQQAPAYtAQoiKEQqJAIAKgAAEb0jAAARXwwiKEQqJAIAKgAAEXElAAAWOC0CJgMnAAQEBCUAABXHLQgFKgAiKgIsACosKC0tDiMtACooICMOKigjJiQCACYAABGoJQAAFkotDioQLQ4nCy0OIxktDishIwAAEkktCh4mIwAAEcYMIiZEJyQCACcAABJXIwAAEdgtCxAmLQsLJy0LISgtCycqACIqAiotDionLQgBKicCLAQFAAgBLAEnAyoEAQAiJwIsJwItBAQAIioCLj8PACwALi0CJgMnAAQEBCUAABXHLQgFJwAqJyAsLQ4jLC0OJxAtDioLLQ4gGS0OKCEjAAASSQAqCiAjLQojCiMAAAfhLQsQJy0LCygtCxkqLQshLAwqJiotJAIALQAAEnkjAAASzwAiKAIuACouJi8tCy8tACInAi8AKi8mMC0LMC4AKi0uLy0CKAMnAAQEBSUAABXHLQgFLQAiLQIuACouJjAtDi8wLQ4nEC0OLQstDioZLQ4sISMAABLPAComICctCicmIwAAEcYtCxALLQsMKi0LJywtCygtDCoKLC4kAgAuAAAS/yMAABNVACIqAi8AKi8KMC0LMC4AIgsCMAAqMAoxLQsxLwAqLi8wLQIqAycABAQFJQAAFcctCAUuACIuAi8AKi8KMS0OMDEtDgsQLQ4uDC0OLCctDi0oIwAAE1UAKgogCy0KCwojAAAGdAAiCwItACotCi4tCy4sLQsQLS0LDC4tCycvLQsoMAoqMCsxJAIAMQAAE5cnAjIEADwGMgEKIi9EMCQCADAAABQHIwAAE6kMIi9EMCQCADAAABO7JQAAFjgtAi0DJwAEBAQlAAAVxy0IBTAAIjACMQAqMS8yLQ4sMgAqLyAsDiovLC0kAgAtAAAT8iUAABZKLQ4wEC0OLgwtDiwnLQ4rKCMAABSTLQoeLSMAABQQDCItRC4kAgAuAAAUoSMAABQiLQsQLS0LDC4tCygvLQsuMAAiMAIwLQ4wLi0IATAnAjEEBQAIATEBJwMwBAEAIi4CMScCMgQEACIwAjM/DwAxADMtAi0DJwAEBAQlAAAVxy0IBS4AKi4gMS0OLDEtDi4QLQ4wDC0OICctDi8oIwAAFJMAKgogLC0KLAojAAAGPy0LEC4tCwwvLQsnMC0LKDEMKi0wMiQCADIAABTDIwAAFRkAIi8CMwAqMy00LQs0MgAiLgI0ACo0LTUtCzUzACoyMzQtAi8DJwAEBAUlAAAVxy0IBTIAIjICMwAqMy01LQ40NS0OLhAtDjIMLQ4wJy0OMSgjAAAVGQAqLSAuLQouLSMAABQQACoKIAsAIicCKwAqKwosLQssDC0LKCsMKgsqLCQCACwAABVQJQAAFjgtAisDJwAEBCklAAAVxy0IBSwAIiwCLQAqLQsuLQ4MLi0OLCgtCgsKIwAABWUoAAAEBHhsDAAABAMkAAADAAAVoioBAAEF2sX11rRKMm08BAIBJioBAAEFilU6LCtnyO88BAIBJioBAAEFyA1zc27NtOE8BAIBJi0BAwYKAAYCByQAAAcAABXdIwAAFeYtAAMFIwAAFiUtAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAWIC0BCggtBAgLAAAKAgoAAAsCCyMAABX8JwEFBAEmKgEAAQUbvGXQP9zq3DwEAgEmKgEAAQXkCFBFArWMHzwEAgEmKgEAAQXQB+v0y8ZnkDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_initializer"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "title",
            "type": {
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "compressed_string::field_compressed_string::FieldCompressedString"
            },
            "visibility": "private"
          },
          {
            "name": "description",
            "type": {
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "compressed_string::field_compressed_string::FieldCompressedString"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "target_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "vZvbbl03Dobfxde5EHWgyLzKoCjS1C0MGE7gJgMMirz7iJRIbiez5NW9nbnp/kx3/Vs86EAt5++73+9/+/rnrw9Pf3z66+79v/6+++354fHx4c9fHz99/PDl4dPTsP59l+Q/UPjufXl3B7Xeve/yOX6u47OV9UnzE9fP2Odnh/WJ85PWz9Tu3gMM4KEPYmGxDOmchgSQAC0AXJDH0zkLDEseT+UCBm39qiYDseCAlgzMIqOcQAt6Hv6BwLCU4WmmYmAWFosMg2lCSSMaNQnwAjALiGU8VbJYUEAsw8FSqoFZal/QxjBaFegLEAxwQTdLNwuZRaI6gRdwNaAJVcI7Qb6iDci0oGQD+1U1SzVLM0vDBZgMmgEv6NXAvkKiOkEER3wqgwFOaCkZVANeAMVgPd5yNjBLAYO2oJqgVGUbcW4aQwVcQGYhs7BZpDIn8ATUgSnQAh2YgnzFqA2UWp3QDHiBBBNHkaBEDEGAF/Ri0BfIwCbgApkyWASqAU/oqRqYBcwCZslmKaJTBaoBL6hmqbRAJvoEGdjIYJfKnNAMeIGkG0fNd8oGuEAH3wXaBJKCnEALZGBNoRqsyFM1S12Rp1YMVuQJwaAZrMgTrchzWpHntCLPUAxW5DmDwYo8lxV5LtVgRZWrWapZmlmaWdAsfUWeezVYkWcyC63IMxeDFXlICZyaExuBPMlCMjl6UupGMismybSYJDHsWUgmRi9KzYmNZPYu6kacnUaYuowAZAYvakbgNnBbdlt2W3FbET3ZI0BHOqk6kZEsSR2VupHUQCclNOpuU4+UJNxUlIaNZCMCmVakI5B5pZRlYhEqkZFUzCK3Zbdlt8myugiNKjg1I9mnFvm3Se1MQldGV+6uLMvFJHJl8m9jV2b/Njbl4r4V9624b0WWU5JYFansLnVVpF5oEhmh29BtsrpOklFxURo2VmWpHE5KssEnPV9I6Rg2RwgrhDWHVRY1Q3IsJbA7yqZmqF8sWa8tBTZHDCuGtYe110BypBLYHTkH+hc3mcyG+hVZkR2hBpJjzoHdsUBgiNUUGGI1xFpxnL6hYg1kRworhZXDymSIKQd2R4BAdJzZ7Io1kBxLdpzJkspCqbaxuAjKdDBER0qBNZAdZYEdK5BiN+w69IVhhbBCWHNYc1i1+qAodketvoVhbRCIjlp9MM/PNZAcp8eKpApNsQWy43QTFcmQEjpqWiZmTyGVHOgppBrW6imkBoHNkkWNHbEEdkcdr2aT9fCvaeEZdcU5sokt0FPIuQaSJYBLDvS0cA1rDWsLawsrhnVGXdLCPQd6CpnCSp5CZghslixmXpjT9Hhid9R5MbsgnRfAis1xFtdEctQEZOljkpx5QBuhJIdKw+6oBbOwOWo/tlCCqs1V0oJRBB3vwrBCWCGsOaw5rEV1kyI5aloWoqNO9NwUW6D61rU1rIFhnW4qalq0tQNNy0RNy0K35gSBYdXNZ2ENZEd1cyE5lhzYHdULbSezLq+lKqqY+JZ1jSqoyI4cVs2F9qG6c49dVvtgsswXXY0WomNJgfoYa9ecLd3aci7EsMrxCaSjzdp4GoZVl9equlFG2oAunGU00a01lUByhLCCD6dmCGyBIVZCQR2StSRrh7oQU2ANlMeqPka2X+TKEOhWbUpBGvo8d+mJEFYtjVoV2R/LJZAcS1hLd6w5MKwNAltgfAWGWA8Fcucbp8AaSIZzl9Y4zE1YFTD7t2EJq9aOeozS+yysYdVThcYBm48MmzuEmAPD2iHQo44UVorh+N6d19490cV6coWuDtWmqHnT2x51SG5cBjbHGtbpkESn6xJUZb7pJix9UtY9eJLEfBEa6Zxo+v0S5q7XSKk4uU2PEw0Uu2MOq07gJqJUwJ4qzUgbo0lhYyNpIxa5DX0U2I26K3dXIX9WPJCeeXQR2QmNZAYskpC1eVGWZ8Ocdd+dVN2my7tcQY1uBALDqrNVbokGNnvKrkjybJonuY2KExmx23iNoszOeVJzYiMgo7JcHYRGNTlVJ1pOl4RoD3f/ku62WRJVsTlyWHVqitMDbUC62S6yoQG4zW4qCuTs5LYCTs3JlaurNH3227d3d3bv++uX5/t7ufa9uAge18OfPzzfP325e//09fHx3d2/Pzx+1f/pr88fnvTzy4fn8dsRlvun38fnEPzj4fFe6Nu7eDodPyrbxnp67ArsAmPYLyTgWEIOtLQ0BvfuIlxfaORjjSIr7dIY3OFIY+cKgQ0jj4ukQ1fqRqLqErLCMbqQGEZ/odHeIBz4c8NRs1zsqUQdB43DcNDGlSzHn+nJ2PQuJPILCX6DaEB6g3DsfCnSEcxxlFIOfYH8Fs6Un+xMlk1vJYaPEwObOh33w+ZLH83coSu7Mi1YTWMw3+rK0Dh0ZVMevTZLbR8HTJdoL+csbMp0HP/ASn1wxaOJnzfjGK1plMdoU/FwIYRdeWDOXh5Yjmts745sNMud8Qrn0J1doVYr0zouQCOqV6XlYq58l5a8q1F0hYto1vOV0ZKtgeNtCh8OoW9CmbNHMl/UxWgVX2psanwcL6TnnDlN3NphYfBOJMdkS+PceCRSdivpaF18JG00A4cj2buTL9y53CW/G8luLcViB49xtxgRkUPI6ex2Lw9MeJTdUm/PbmlvkN2Cb5Hd/gbZfcWdk9ndbfuFTEPeL1yVXSq+P40W6ii7FXbHOWqe3nHfcJiZuj2aEqEvyOOK9Iqz2LgTTr7XQjv0pb6FL+3/6Es59GWnwD4ISgCH0dgsQS2DBaNlDIlxI/lSY1ejzXf8lF2hMLw86e8cif1+vAuIUIwXcy81dvt9y77LXqw//WU+2qZA5WbV17CLFu4HjbKLpy3GraTrFNh2WryIxD/yI0crWi4y8oMG7nKarThHj9+v1EDfmcbrtus0SnKNMemONXh3fspxqr1Kgf0Ex+26McjfM5gfCY/zipu8VgI/SFKLvAL/g3BW304ue9l/lhKv0IF0lcZbuALFK3RccV43U3o0K30zX5F+rsZ4E+y+YKfrNLof4sZL0uNZ3+HWmbJTODdTdgpnZ0qvN5fXNpwcCw/n43BuN1fA5ptrz4eba+/b0vC0IqXDg/XZY8Jx89Z3fXBnG8W4HeTDUdD28qlgnJnKcVdPu+qo3Tc3+VOVEBHBFyp5d96oftzoh2fqncKYYi0usOg6jUzlf10+/aCxi8d4uecreksXhfpDPPap8XPL4HZ8/7RrmgDBL1wGlyvOxJS8zggSXXEmptTYi/1iGfxOgdPtxc7wBsXOuwJp3rmNtytwWCCvDORcarnuUtuTewO9HbY7vOuZWq/Fm+pO9Zr60L8VWfVRD6/CuN/e8TDd2vEw397xQEq3tjyQ4PaeR//A7ramZy9xquvZu3Ky7YHUbu97XhE51/jsRU52PmOZvPVAt5U4d6LbSpw90gHAzWe6V2J6rv15ReRc/7MVeRNvTnZA+1lzsn0B6D9Z5GwTtBc52QVBTjfPmp3EyVmzfQt2dtbs3j2drbNtTE+2Qttd92QrBBl/ai/04gDRDy9dIdPt50PYvoU6e0CE3Wuo88f/1wZz7pAIuzdRpxuAV1R6aXHWrO1aFd/Ib1Kp/eLci9eqnDs9w/6d1Mnj835d8ve4nK9d2tCSzL3dvDruJLbHknOObCXOOXLycLSR2HfNJ8v9FZFz1f6KyLlif0XkZK3vLs5O1/r2KvJUhWwVThXIyevQjcL21cMpL7YKp7w4+frje4Vfxo8fPj48v/h3999E6vnhw2+P9+vHP74+fbz47Zf/fLbf2L/b//z86eP971+f70Up/vH++M+/cBzpkPMv7+5Af0R4h4jyI+hv0zvs+ZdvMpj/Ag==",
      "is_unconstrained": true,
      "name": "create_proposal"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17072719129172364576": {
            "error_kind": "string",
            "string": "proposal did not pass"
          },
          "4253643505666188125": {
            "error_kind": "string",
            "string": "quorum not met"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "900405183110375111": {
            "error_kind": "string",
            "string": "already executed"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "execute_proposal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "9345055721478160917": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDAAMvCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWBsE6qnPACFTwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbNjqswDIXfJessYju/vMqoqmhLR0iIVgxc6ari3a8ZkQCLZHGnsyF2aD58DibNS9yay/R5bvv740tUHy9xGdquaz/P3eNaj+2j59mXUMvFgahICmdF5aTwnAHwyCloKcKS83wIPHopQOk1AIyBExXyEkCeQeSAVAwMB7wa9DLj5lmKWMB5HJpmef6uIq7zWQ9NP4qqn7pOij91N33/6OtZ99/jWA98V0nR9DceGXhvu2aJZrmtVvmlSD6sq1GrkABA4YCAPAK8sn5lcOxcggR9YGCeQWiMWRkcO8gxSlI8xDIwIGSl6AJCg1HJDnCbocEdGOYNdtjftUOjdStCk3FZO3xBCpKNStDYHQIPiPAGN0C9wY6SFgKKdRBRVgvgO8TQL4tBh+nFhPyLgUKfOp+0uIA6K6XUpmR1ZHAcfiqFGVkppfZgE2MVJvj8HlboUwxE6csPpG12EysVQoSpEiKt/+Oz3YuxSmXFqJKl1oTUHtZjgpjjLoaFNkVMUhB3diD6I6OwnZJiJ6MYFYzJmmpKENyaTKHP/72UOtXYrRJj7RFy4qy+tsPhODAvtKGtL12zpvepv+7ujn+f8U48TjyHx7W5TUOzkLYzBfD1A4MkfVoOCJyQkeRO8/Lofw==",
      "is_unconstrained": true,
      "name": "get_admin"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16651589314398098717": {
            "error_kind": "string",
            "string": "Function get_erc20_config can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "field"
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgEEACcCAgQAHwoAAQACAEQlAAAARSUAAABGLQIBRC0CAkUnAgMERCcCBAQCOw4ABAADJiUAAAC5HgIAAQAeAgACAB4CAAMAHgIABAAzKgADAAQABScCAwEBJAIABQAAAHklAAAA3x4CAAQJJAIABAAAAIslAAAA8ScCAwAQLwoAAwAEJwIDABEvCgADAAUcCgUGBhwKBgMAHAoDBQYtCgQBLQoFAiYoAAAEBHhGDAAABAMkAAADAAAA3ioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEF5xZUQe5jlR08BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVZbiuMwELyLvv2hfuiVqwwhOIkzGIwTPPHCEnz3bQU/F6SFWc+PVS1Z5a5SW9JLXatz/3mq29v9Sx0+Xurc1U1Tf56a+6V81vdWel9Kx4cz6kCF8hI4aSQCKFSQEFjaGEs/aBLgI/AjADsCBHVAiEB6EAUQTyAIiNOZR2CEmOKQMSOwMp04AjsC9+4ZhkJN6Z6eXVXFbFf5i6pH2VXtUx3avmkK9ats+vdLX4+yfbfPspNRXaiqvUorhLe6qSIaimW2Tk9F8mGcjazDTCDCNhSQpgCvrR85BDs3kwTecGCag9AYM3IIdpDiyEnxMKWBASEphTMULMs32wFuMTS4DYfZwQ77s3YwWjdSMBmXtMNnpCDZSQkau6LADUXYwQ3QO9iR00JAUx5ElNQCuIcY+mEx6HBemJBeGMjUqfOzFheQk1JyZUqWJw7B4X+lCEdSSq48xMQpCxN8eg/L1CkGovnPD8Q2uYnlEiHCORMi5m/8tmsxVuukGJ0rdbY8e2r0osVsdzHMlCniLAVxZQei33JktlPSgaZEBBuTNNXkSHApMo0+fbzkKtXYJRNjrfvGyoiVoBdb2SRt9TvYGnawlfQOthLsYOs/5OBKzvrQ/SsTym3NYT6qAizbe7zTDEcJy0vdbS6HQyTr6vLcVGN469vLavT5+zGNTJfLR3e/VNe+qyLTcsMEeX7IUclwjNdGCRgL5uMQP/0H",
      "is_unconstrained": true,
      "name": "get_erc20_config"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7840289186398101667": {
            "error_kind": "string",
            "string": "Function get_member_count can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAkvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVszk15s5hgozwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjuMgEEX/hTULqopnfqUVRU7itCxZTuS2RxpF/vcpIuPHSLDoTm9MAeGk7nUZeIprfR4/T013u3+Jw8dTnPumbZvPU3u/VENz73j0KVR8OBAHksJZcXBSeO4BcMtd0FKE2OfxELj1UoDScwCYAicOyEsAeQSRA1IpMBzwatAqBczFwIGBFLxGpkmKlNtp6Os6prZJliU8qr7uBnHoxraV4k/Vjq8ffT2q7tUOVc+zSoq6u3LLwFvT1jGa5Lpa5Zci+TCvRq3CAgAKOwTkEeCV9TODY+cWSNA7BuYZhMaYmcGxgxyjJMVDSgMDQlaKLiA0GLXYAW41NLgdw7zBDvu7dmi0bkZoMi5rhy9IQbJJCRq7QeAOEd7gBqg32FHSQkApDyLKagF8hxj6ZTHocHkxIf9ioFCnzi9aXECdlVIqU7I6MTgOP5XCjKyUUnmwiSkLE3x+DyvUKQai5csPpG12EyslQoRLJkRaf+Oz3YqxSmXFFBAAgZYyhWBXR8x+F8NCmSIuUhA3diD6PaOwnZJiJ5MYFYzJmmpKEFyLTKHPHy+lSjV2zcRYm4eU5eBGzvZ0+A9SqndL6cAFu3EkHr7TkbvVpel3V5YpwvqmOrf13L2N3WUzO/x9pJl05Xn090t9Hfs6ktZ7D/Dzg1CSO8ZLTOx4qdVxin/9Dw==",
      "is_unconstrained": true,
      "name": "get_member_count"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5227616292269356710": {
            "error_kind": "string",
            "string": "Function get_membership_mode can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAA0vCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVIjDlSGsJ2pjwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTWjSqWu9Frryq1ezH4Xw0KZIi5WEDfpQPR7RmE7JcWZTGZUMCabVFOC4FpkCn3+eClVqrFrJMbaPKRsBzd2tqfDf5BCvXuXFr8PKyAevdORu9Wl6XcXlimi+qY6t/XcvY3dZfN2+PtIb9KF59HfL/V17OtIWm89wM8PQknuGK8wseOlVscp/vU/",
      "is_unconstrained": true,
      "name": "get_membership_mode"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8418147970250171169": {
            "error_kind": "string",
            "string": "Function get_name can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndbts6DMffJde9ED8l9VUOhqHrsqFA0BZZe4CDoe9+SFmUkwIWujS7aX6m639IiqJp5/fu+/7b68+vD48/nn7tbv/5vft2fDgcHn5+PTzd3708PD2a9fcu+Z+su1u62RXY3Wb7sCOAm121Q2D79GOzQ2KD4lA7QO6AuLtFcDALogFJB7avID/FElA7CAeERcOiYckUkDsUDNAO7ukC/hX2pQjaAVNAnKKwUFg4LMwBpYNQQO6gGBBfkSHABZND7VA4oHSoGJAXoAQB/XKCFDAsXZCQArogUVjUr2IHDqgdclhyWEpYmmMOzbEGeQFujjXQDs0xceCA0sELoEFLplULi5+y2uCWsQbaIacADqgdioXDySF3cMcW6BZJGBAWCAuExRPF4JA7EAaEhSFAO4g5xujAAaWDR9HAl5vJQQJqh+Y8O5QOvncc1JPZoK1gg555JQzomVcOC/fMq0CALHnWtmUclAJyhyLLEuRES1azJ6oBQIAE9Mxn5ICy5DATBvSsZg4Lh0XCImHRsGhZspozBvTM5xKW0jOfKwTIkudc6wLFo1ggd/DdzWrgu5u9ZfnubuDbYYHSwVPH1duaCYo5VrylLJA7eOdbQDrUFGBpEf/SWhao7s8CYYGwQFgwLBgW8ooqDqVDS2YD7eDlJ+QgAe6zeg92NyyK6slUc6yWFGD/rLbute0U/59WddUbdUqDeJA5oOqEugQJiWDQsPlO1qXvS5AMm+8QbTcDqXGF0qASlIctsg3Jl7/TsNXhQZVBoQwpVADiWnDvvcwBKA3iQSXI86weOWjvO0YSlIfNm1Fuyr6hFyrD5ls6+z0GKsUVtW8rwISDhi32Gix3o+U2OWwog2oQ0aChwuNajShReVBEiV4XnbTHi5Xj2hrfQYkHlR4bef12GjZv6C1ewvCFCAaFV8TDxhERSRq02oYHSoOGch4qpV379naziznl68txv/cx5WRwsXHm+e64f3zZ3T6+Hg43u3/vDq/tn3493z22z5e7o521WPaP3+3TBH88HPZObzfr1Wn7UqRS+9U2ItQhAFTPJGBbAkryPdI0jHMeIpXPNHBbg1BEuoZxhi2NWSgFwg2bQGAzFJ5IMEga6bBts7qRzzTkCunQv5sORu9hTYJJ8mY6yiQUJI1IUPREAs8k6hWyAekK6ZjFYg0g/LB5cjMWwGsEQ385GOuEY2Hq9sLApE5tLIlYckXeDGVWpjaGh4Zx/WwoprEZyqw8xHv44oXUst3DJnWKlWjsfJtjdLOJzRwhwuEJEfMF2/Y0GE1pM5iJBFgTCw1jXItdzrsYTspUGGNphXmtdEQ915i0Uxv2owWpPU5ta0zK1O7lIx/2wLytMalTm65jbW0Hr7HYXfpcI0+2S163SwHZ1iiztY1SZ1gLDPO7CpuVqb0GiCrFk9v1ew2alIdg3PGF0mUKdSzrSSb+KA5cxw5KuO3FpEKtsmNV7SVLvlBD69Ao9TINSkPDXllsa0wqNHNURma9SKFy3FSqXOaDPSqNTpx0e11psq5cINzgIuu6Qv2DdPorhJ5OuXBZaVSoYblI4xqhwOg79oRWLtspGWIGwzzZryx/VwNURyyay2UaOY8ZzGaObY3y2Z0yU/jYTpkpfHSnCHy6vKbprGvjqbidzuktmnW9RZ8uybvbq/AVxmKRK4zF82hQRzQi29HkT8/FUq4wF398AJsMPjMNGQ89Yq9yNzV09ni/3qr9Trdq6PkwqbPH+1Qpmrrxycq8fyaePTglXLOasGw/WPNsBNPVE1HdFJl2kBR7puKFPUijgdQsn+1iE4XpxPChKKYKH4rig1PLe4Uvdnh3/3A8+ynvzaWOD3ffDvt++OP18f7k7Mt/z3Emfgp8Pj7d77+/HveutP4eaH/+oUQ39hLwi7+HtUO04doep/0Q/Cz6Wfny5s78Dw==",
      "is_unconstrained": true,
      "name": "get_name"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14397635560847713499": {
            "error_kind": "string",
            "string": "Function get_proposal can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "creator",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "title",
                "type": {
                  "fields": [
                    {
                      "name": "value",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "compressed_string::field_compressed_string::FieldCompressedString"
                }
              },
              {
                "name": "description",
                "type": {
                  "fields": [
                    {
                      "name": "value",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "compressed_string::field_compressed_string::FieldCompressedString"
                }
              },
              {
                "name": "proposal_type",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              },
              {
                "name": "target_address",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "start_block",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_block",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "executed",
                "type": {
                  "kind": "boolean"
                }
              }
            ],
            "kind": "struct",
            "path": "types::proposal::Proposal"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_proposal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3905717565539885644": {
            "error_kind": "string",
            "string": "Function get_proposal_count can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAsvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQU2M+VutwIiTDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjuMgEEX/hTULqopnfqUVRU7itCxZTuS2RxpF/vcpIuPHSLDoTm9MAeGk7nUZeIprfR4/T013u3+Jw8dTnPumbZvPU3u/VENz73j0KVR8OBAHksJZcXBSeO4BcMtd0FKE2OfxELj1UoDScwCYAicOyEsAeQSRA1IpMBzwatAqBczFwIGBFLxGpkmKlNtp6Os6prZJliU8qr7uBnHoxraV4k/Vjq8ffT2q7tUOVc+zSoq6u3LLwFvT1jGa5Lpa5Zci+TCvRq3CAgAKOwTkEeCV9TODY+cWSNA7BuYZhMaYmcGxgxyjJMVDSgMDQlaKLiA0GLXYAW41NLgdw7zBDvu7dmi0bkZoMi5rhy9IQbJJCRq7QeAOEd7gBqg32FHSQkApDyLKagF8hxj6ZTHocHkxIf9ioFCnzi9aXECdlVIqU7I6MTgOP5XCjKyUUnmwiSkLE3x+DyvUKQai5csPpG12EyslQoRLJkRaf+Oz3YqxSmXFqJKlypqlPFRYy9TsdzEslCniIgVxYwei3zMK2ykpdjKJUcGYrKmmBMG1yBT6/PFSqlRj10yMtXlIWQ5u5GxPh/8gpXq3lA5csBtH4uE7HblbXZp+d2WZIqxvqnNbz93b2F02s8PfR5pJV55Hf7/U17GvI2m99wA/PwgluWO8xMSOl1odp/jX/wA=",
      "is_unconstrained": true,
      "name": "get_proposal_count"
    },
    {
      "abi": {
        "error_types": {
          "13489005082718014639": {
            "error_kind": "string",
            "string": "Function get_quorum_threshold can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAUvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQW7MpKnqNiMrzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbfjqsgEMbfhWsvmBn+9lU2TWNbuzExtnH1JCeN736GRhRPAhe73RsZoPw63+cIPMW1OU+fp7a/3b/E4eMpzkPbde3nqbtf6rG99zz6FDI8LIgDVcIacbCVcNwD4Ja7oCrhQ5/HvefWVQKkWgLAGFhxQF4CyCOIHJCMgeaAV4OSMWAueg40xOA1Ms+ViLmdxqFpQmpJsizhUQ9NP4pDP3VdJf7U3fT60dej7l/tWA88KyvR9FduGXhruyZEc7WtlvmlSM4vq1FJvwKA/A4BeQQ4adzC4NjaFeLVjoF5BqHWemFwbCHHKElxENNAj5CVogoIBVqudoDdDPV2x9BvsMP8rh0KjV0QirTN2uEKUpBMVILaJAjcIfwb3AD5BjtKWggo5kFEWS2A7xBDvywGLa4vxudfDBTq1LpVi/WoslJKZUpGRQbH/qdSmJGVUioPNjFmob3L72GFOkVPtH75npTJbmKlRIhwzYRIqW98tqkYI2VWjCxZ6iEpj0SL3u9iWChTxFUKYoJAdHtGYTslyU5GMdJrnTVVlyC4FZlElz9eSpWqzZaJNiYPKcvBRE56OvwHKdW7oXjggkkcCYfvfORufWmH3ZVlDrChrc9ds3RvU39JZse/jzgTrzyP4X5prtPQBNJ27wF+fhBWZI/hEhM6rlLyOIe//gc=",
      "is_unconstrained": true,
      "name": "get_quorum_threshold"
    },
    {
      "abi": {
        "error_types": {
          "14800929215391895385": {
            "error_kind": "string",
            "string": "Function get_sponsored_fpc_address can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDAAYvCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQXNZ3az5SKPWTwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbNjqMwDMffJeccYjufvMqoqmhLR0iIVgystKp49zUjEuCQHHY6F2In9Q//jZPmJW7NZfo8t/398SWqj5e4DG3XtZ/n7nGtx/bR8+xLqOXhQFQkhbOiclJ49gB4ZBe0FGHxeT4EHr0UoPRqAEbDiQo5BJBnENkgFQ3DBkeDXmbcPEsREziPQ9Ms799lxHk+66HpR1H1U9dJ8afupu8ffT3r/nsc64FXlRRNf+ORgfe2axZrllu0yoci+bBGo1YhAYDCAQF5BHhl/cpg27kECfrAwDyD0BizMth2kGOUpHiIaWBAyErRBYQGo1I5wG0FDe7AMG8oh/3dcmi0bkVoMi5bDl+QgmSjEjR2h8ADIryhGqDeUI6SFgKKeRBRVgvgO8TQL4tBh+nDhPyHgUKfOp+0uIA6K6XUpmR1ZLAdfiqFGVkppfbgIsYsTPD5M6zQpxiI0s4PpG32ECslQoQpEyKt/2Pb7sVYpbJiVHHbOp3aQ8PW7OZ4imGhTRGTFMRdORD9kVE4TklxJaMYFYzJFtWUILg1mUKf/3spdaqxWybG2iPkxF59bYfDdWBeaENbX7pmde9Tf92tjn+fcSVeJ57D49rcpqFZSNudAvj5gUGSPi0XBHbISHKneXn1Pw==",
      "is_unconstrained": true,
      "name": "get_sponsored_fpc_address"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "yes_votes",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "no_votes",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "total_votes",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "voter_count",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              }
            ],
            "kind": "struct",
            "path": "types::proposal::VoteTally"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPrOreuc+s6t65z6zq3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86965z7zr3rnPvOveuc+86967z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d59mRtLNPOescNJr+PA46lFfTbjpN0XSLvjp/ZE3eNJra47THaY/THqc9TntEe0R7RHtEe0R7RHtEe0R7RHtEe9z2uO1x2+O2x22P2x63PW573Pa45ZGNS4+syZtG02xaTbvpNEVTe1h7WHtYe1h7WHtYe1h7WHtYe1h7eHt4e3h7eHt4e3h7eHt4e3h7eHuM9hjtMdpjtMdoj9Eeoz1Ge4z2GO0x22O2x2yP2R6zPWZ7zPaY7THbY7bHao/VHqs9Vnus9ljtsdpjtcdqj9Ueuz12e+z22O3RdT67zmfX+ew6n13n2f10xkdZ5yBr8qbRNJtW0246TdHUHtEe0R7RHtEe0R7RHtEe0R7RHtEetz1ue9z2uO1x2+O2x22P2x63PW55ZHPUI2vyptE0m1bTbjpN0dQe1h7WHtYe1h7WHtYe1h7WHtYe1h7eHt4e3h7eHt4e3h7eHt4e3h7eHqM9RnuM9hjtMdpjtMdoj9Eeoz1Ge8z2mO0x22O2x2yP2R6zPWZ7zPaY7bHaY7XHao/VHqs9Vnus9ljtsdpjtcduj90euz12e+z22O2x22O3x26PrvPVdb66zlfX+eo6X13nq+t8dZ2vrvPVdb66zlfX+eo6X13nq+t8dZ2vrvPVdb66zlfX+eo6X13nq+t8dZ2vrvPVdb66zlfXeXZfnUiKpvsoG7AeWZM3jabZtJp202mKpvaw9rD2sPaw9rD2sPaw9rD2sPaw9vD28Pb46jx+SaNpNq2m3XSaoukWfXX+yJraY7THaI+vzmMn7abTFE236KvzR9bkTaNpNrXHV+dxkk5TNN2ir84fWZM3jabZtJraY7XHao/VHl+dx02yJm8aTbNpNe2m0xRNt+i0x2mP0x6nPU57nPY47XHa47THaY9oj2iPaI9oj2iPaI9oj2iPaI9oj9setz1ue9z2uO2RX2fNMyy/0Qo6TX8e15Luo2zyevTncfHNRG8aTbNpNe2m0xRNtyi/8ApqD2sPaw9rD2sPaw9rD2sPaw9vD28Pbw9vD28Pbw9vD28Pbw9vj9Eeoz1Ge4z2GO0x2mO0x2iP0R6jPWZ7zPaY7THbY7bHbI/ZHrM9ZnvM9ljtsdpjtcdqj9Ueqz1We6z2WO2x2mO3x26P3R67PXZ77PbY7bHbY7fHbo/THqc9Tnuc9jjtcdrjtMdpj9Mepz2iPaI9oj2iPaI9oj2iPaI9oj2iPW573Pa47XHb47bHbY/bHrc9bnvc8shGskfW5E2jaTatpt10mqKpPbrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOo+s8us6j6zy6zqPrPLrOsx/tniRvGk2zaTXtptMUTbco6xzUHtEe0R5Z5560mnbTaYqmW5R1DrImbxpN7XHb47bHbY/bHrc8slntkTV502iaTatpN52maGoPaw9rD2sPaw9rD2sPaw9rD2sPaw9vD28Pbw9vD28Pbw9vD28Pbw9vj9Eeoz1Ge4z2GO0x2mO0x2iP0R6jPWZ7zPaY7THbY7bHbI/ZHrM9ZnvM9ljtsdpjtcdqj9Ueqz1We6z2WO2x2mO3x26P3R67PXZ77PbY7bHbY7fHbo/THqc9Tnuc9jjtcdrjtEfW+U2Kplv01bn9folGdOIgTuIibuIhBvE2Xrpdul26Xbpdul26Xbpdul263XLz7JErNKITB3ESF3ETDzGIdDO6Gd2MbkY3o5vRzehmdDO6Gd2cbk43p5vTzenmdHO6Od2cbk63QbdBt0G3QbdBt0G3QbdBt0G3QbeZbp5oRCem20qcxEXcxEMM4m1cP6IRnUi3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0O3S7dLt0u3S7dLt0u3S7dLt0u22m/1+RCM6cRAncRE38RCDSDejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3RjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWbJYJYMZslglgxmyWCWDGbJYJYMZslAlkTibUSWAI3oxEGcxEXcxEOkm9HN6eZ0c7o53ZxuTjenm9PN6eZ0G3QbdBt0w+M+LXESF/FzM088xCDexsySh0Z04iBO4iLSbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt0+3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLegWdAu6Bd2CbkG3oFvQLegWdLt0u3S7dLt0u3S7dLt0u3S7dLvtlj2LhUZ04iBO4iJu4iEGkW5Gt8yS7+G4nv2LhYOYbidxETfxEIN4GzNLHhrRiYNIN6eb083p5nRzug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26HboF3YJuQbegW9At6BZ0C7oF3YJul26Xbpdul26Xbpdul26Xbpdut93W70c0ohMHcRIXcRMPMYh0M7oZ3YxuRjdmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlmxmyWaWbGbJZpZsZslmlhxmyWGWHGbJYZYcZslhlhxmSbZ5/n16khjE25hZ8tCIThzESVzETaSb0c3o5nRzujndnG5ON6eb083p5nRzumWWfH9TxLP9s9CJ6ZYLlVnycBE/t2GJhxjE25hZ8tCIThzESVxEuk26TbpN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2PuWLYSFh0g31ryx5o01b6x5Y80ba95Y8zZ632xwJQdXcnAlJ1dy5kqORCfmSs7ESVzETcxjyznMIN7G9SMa0YmDOInplpNcm5g1nyu5f1WF+Zyw+O4V72xYLBzESeQObe7Q5g7tIPJcRxIAefYd7tDhDh3u0OEOHZ59TA07PB8Oz4fg+ZD58N3m3vlEsMJF/I7Cch2+fAjLmX35UHgbv3woNKITB3ESF7HuJm3D3YMPHXcPgEZ04iBO4iJu4iEGkW5GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptul26Hboduh26Hboduh26Hboduh26BZ0C7oF3YJuQbegW9At6BZ0C7pdul26Xbpdul26Xbpdul26MUucWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1mSvZbxPcNvZ69loRMHcRIXcRMPMYi30ehmdDO6Gd2MbkY3o5vRzehmdOtPPTd6LR86cRAncRHTbSUeYhDTLf/t+BGNmMd2EgdxEhdxEw8xiLdx/ohGpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui20q37y1M9lrG94iUnb2WhU4cxElcxE08xCDexkO3U91CG72WDwdxvrafjV7Lh5uY/Tt59mXf1cPbmH1XD43oxEGcxEXcRLoF3fJ9y9dasLN/Mhz/NVcnj+Ju4iFGYXZKxvd1vJ09kfF98W5nT2ThJh5iEG9j1vzXhrCzJ7LQiYM4iYu4iYeYbivxNuYT4B4a8XP7+gl29kQWZs1H4iJu4iEG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",
      "is_unconstrained": true,
      "name": "get_tally"
    },
    {
      "abi": {
        "error_types": {
          "13676344659716267636": {
            "error_kind": "string",
            "string": "Function get_token_address can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDAA8vCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQW9zCMB9DLedDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbNjqswDIXfJessYju/vMqoqmhLR0iIVgxc6ari3a8ZkQCLZHGnsyF2aD58DibNS9yay/R5bvv740tUHy9xGdquaz/P3eNaj+2j59mXUMvFgahICmdF5aTwnAHwyCloKcKS83wIPHopQOk1AIyBExXyEkCeQeSAVAwMB7wa9DLj5lmKWMB5HJpmef6uIq7zWQ9NP4qqn7pOij91N33/6OtZ99/jWA98V0nR9DceGXhvu2aJZrmtVvmlSD6sq1GrkABA4YCAPAK8sn5lcOxcggR9YGCeQWiMWRkcO8gxSlI8xDIwIGSl6AJCg1HJDnCbocEdGOYNdtjftUOjdStCk3FZO3xBCpKNStDYHQIPiPAGN0C9wY6SFgKKdRBRVgvgO8TQL4tBh+nFhPyLgUKfOp+0uIA6K6XUpmR1ZHAcfiqFGVkppfZgE2MVJvj8HlboUwxE6csPpG12EysVQoSpEiKt/+Oz3YuxSmXFqGKre0ieImCCmOMuhoU2RUxSEHd2IPojo7CdkmInoxgVjMmaakoQ3JpMoc//vZQ61ditEmPtEXLirL62w+E4MC+0oa0vXbOm96m/7u6Of5/xTjxOPIfHtblNQ7OQtjMF8PUDgyR9Wg4InJCR5E7z8uh/",
      "is_unconstrained": true,
      "name": "get_token_address"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5366287459706263972": {
            "error_kind": "string",
            "string": "Function get_token_gate_address can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDAA4vCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVKeOIDRmzZpDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjqswDIbfJessYjtXXmVUVbSlIyREKwaOdFTx7scZES6LZHGmsyF2aD78/5g0L3FrLtPnue3vjy9RfbzEZWi7rv08d49rPbaPnmdfQsWLA1GRFM6KyknhOQPgkVPQUoSY83wIPHopQOklAEyBExXyEkCeQeSAVAoMB7wadJxx8yxFKuA8Dk0Tn7+riOt81kPTj6Lqp66T4k/dTd8/+nrW/fc41gPfVVI0/Y1HBt7bronRLLfVKr8UyYdlNWoVVgBQOCAgjwCvrF8YHDu3QoI+MDDPIDTGLAyOHeQYJSkeUhkYELJSdAGhwajVDnCbocEdGOYNdtjftUOjdQtCk3FZO3xBCpJNStDYHQIPiPAGN0C9wY6SFgJKdRBRVgvgO8TQL4tBh+uLCfkXA4U+dX7V4gLqrJRSm5LVicFx+KkUZmSllNqDTUxVmODze1ihTzEQrV9+IG2zm1ipECJcKyHS+j8+270Yq1RWjCq1OuHOU7M5Yo67GBbaFHGVgrizA9EfGYXtlBQ7mcSoYEzWVFOC4NZkCn3+76XUqcZulRhrj5ATZ/W1HQ7HgTnShra+dM2S3qf+urs7/n2mO+k48Rwe1+Y2DU0kbWcK4OsHBkn6FA8InJCR5E5zfPQ/",
      "is_unconstrained": true,
      "name": "get_token_gate_address"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8972375130064208218": {
            "error_kind": "string",
            "string": "Function get_vote_tally can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "yes_votes",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "no_votes",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "total_votes",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "voter_count",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              }
            ],
            "kind": "struct",
            "path": "types::proposal::VoteTally"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABEknAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAFElAAAAVy0CAUUtAgJGLQIDRy0CBEgnAgUERScCBgQEOw4ABgAFJwBDBAMmJQAABpYeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAiiUAAAa8HgIABQkkAgAFAAAAnCUAAAbOJwIFAAAtCAEGJwIHBAQACAEHAScDBgQBACIGAgctCgcILQ4FCAAiCAIILQ4FCAAiCAIILQ4FCCsCAAcAAAAAAAAAAAIAAAAAAAAAAC0IAQgnAgkEBQAIAQkBJwMIBAEAIggCCS0KCQotDgUKACIKAgotDgUKACIKAgotDgUKACIKAgotDgcKLQgBBwAAAQIBLQ4GBy0IAQYAAAECAS0OCAYtCAEJAAABAgEnAgoEAC0OCgktCAELAAABAgEnAgwBAC0ODAsnAg0ADCcCDgQBJAIADAAAAb8jAAABeC0IAQInAgMEBAAIAQMBJwMCBAEAIgICAy0KAw8tDg0PACIPAg8tDgUPACIPAg8tDgUPLQ4CBy0OCAYtDg4JLQ4MCyMAAAJLLQoKAiMAAAHIDCICQwMkAgADAAAGECMAAAHaLQsHAi0LBgMtCwsILQsDDwAiDwIPLQ4PAy0IAQ8nAhAEBQAIARABJwMPBAEAIgMCECcCEQQEACIPAhI/DwAQABItAgIDJwAEBAQlAAAG4C0IBQMAKgMOEC0ODRAtDgMHLQ4PBi0ODgktDggLIwAAAkstCwcCLQsGAy0LCwgKKggMDSQCAA0AAAJtJwIPBAA8Bg8BJwIIBAIkAgAMAAACryMAAAJ/LQICAycABAQEJQAABuAtCAUNACoNCA8tDgEPLQ4NBy0OAwYtDggJLQ4MCyMAAAM7LQoKAiMAAAK4DCICQwMkAgADAAAFiiMAAALKLQsHAi0LBgMtCwsNLQsDDwAiDwIPLQ4PAy0IAQ8nAhAEBQAIARABJwMPBAEAIgMCECcCEQQEACIPAhI/DwAQABItAgIDJwAEBAQlAAAG4C0IBQMAKgMOEC0OARAtDgMHLQ4PBi0ODgktDg0LIwAAAzstCwsCCioCDAMkAgADAAADVScCDQQAPAYNAS0KCgEjAAADXgwiAUMCJAIAAgAABQQjAAADcC0LBwItCwYDLQsJDS0LAw8AIg8CDy0ODwMtCAEPJwIQBAUACAEQAScDDwQBACIDAhAnAhEEBAAiDwISPw8AEAASLQ4CBy0ODwYtDg0JLQ4ECwAqDw4DLQsDAgoqAgUDCioDDAQkAgAEAAAD4SUAAAc/LQgBAycCBAQFAAgBBAEnAwMEAQAiAwIELQoEBi0OBQYAIgYCBi0OBQYAIgYCBi0OBQYAIgYCBi0OBQYtCAEEAAABAgEtDgMEJwIDBAQtCgoBIwAABDcMKgEDBSQCAAUAAAS+IwAABEktCwQBACoBDgQtCwQCHAoCBQYcCgUEABwKBAIGACoBCAUtCwUEHAoEBgYcCgYFABwKBQQGACIBQwYtCwYFHAoFBwYcCgcGABwKBgUGACoBAwctCwcGHAoGAwUcCgMBABwKAQMFLQoCAS0KBAItCgMELQoFAyYcCgEFAAAqAgUGLwoABgAFLQsEBi0CBgMnAAQEBSUAAAbgLQgFBwAiBwIJACoJAQotDgUKLQ4HBAAqAQ4FLQoFASMAAAQ3LQsHAi0LBgMtCwkNLQsLDwwqAQ0QJAIAEAAABSYjAAAFfAAiAwIRACoRARItCxIQACICAhIAKhIBEy0LExEAKhAREi0CAwMnAAQEBSUAAAbgLQgFEAAiEAIRACoRARMtDhITLQ4CBy0OEAYtDg0JLQ4PCyMAAAV8ACoBDgItCgIBIwAAA14tCwcDLQsGDS0LCQ8tCwsQDCoCDxEkAgARAAAFrCMAAAYCACINAhIAKhICEy0LExEAIgMCEwAqEwIULQsUEgAqERITLQINAycABAQFJQAABuAtCAURACIRAhIAKhICFC0OExQtDgMHLQ4RBi0ODwktDhALIwAABgIAKgIOAy0KAwIjAAACuC0LBwMtCwYILQsJDy0LCxAMKgIPESQCABEAAAYyIwAABogAIggCEgAqEgITLQsTEQAiAwITACoTAhQtCxQSACoREhMtAggDJwAEBAUlAAAG4C0IBREAIhECEgAqEgIULQ4TFC0OAwctDhEGLQ4PCS0OEAsjAAAGiAAqAg4DLQoDAiMAAAHIKAAABAR4SQwAAAQDJAAAAwAABrsqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBXyER6SjBsFaPAQCASYtAQMGCgAGAgckAAAHAAAG9iMAAAb/LQADBSMAAAc+LQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAABzktAQoILQQICwAACgIKAAALAgsjAAAHFScBBQQBJioBAAEFursh14IzGGQ8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_vote_tally"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1895031872533078804": {
            "error_kind": "string",
            "string": "Function get_voting_duration can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAQvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQUaTIFyoGCjFDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjuMgEEX/hTULqopnfqUVRU7itCxZTuS2RxpF/vcpIuPHSLDoTm9MAeGk7nUZeIprfR4/T013u3+Jw8dTnPumbZvPU3u/VENz73j0KVR8OBAHksJZcXBSeO4BcMtd0FKE2OfxELj1UoDScwCYAicOyEsAeQSRA1IpMBzwatAqBczFwIGBFLxGpkmKlNtp6Os6prZJliU8qr7uBnHoxraV4k/Vjq8ffT2q7tUOVc+zSoq6u3LLwFvT1jGa5Lpa5Zci+TCvRq3CAgAKOwTkEeCV9TODY+cWSNA7BuYZhMaYmcGxgxyjJMVDSgMDQlaKLiA0GLXYAW41NLgdw7zBDvu7dmi0bkZoMi5rhy9IQbJJCRq7QeAOEd7gBqg32FHSQkApDyLKagF8hxj6ZTHocHkxIf9ioFCnzi9aXECdlVIqU7I6MTgOP5XCjKyUUnmwiSkLE3x+DyvUKQai5csPpG12EyslQoRLJkRaf+Oz3YqxSmXFqKKlXi3l4WEtdrPfxbBQpoiLFMSNHYh+zyhsp6TYySRGBWOyppoSBNciU+jzx0upUo1dMzHW5iFlObiRsz0d/oMU9yGfGHxDWBHx8J2O3K0uTb+7skwR1jfVua3n7m3sLpvZ4e8jzaQrz6O/X+rr2NeRtN57gJ8fhJLcMV5iYsdLrY5T/Ot/",
      "is_unconstrained": true,
      "name": "get_voting_duration"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13914258305110804072": {
            "error_kind": "string",
            "string": "Function get_voting_power can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTmM5DMffpde9iJ3YTniV1WjEMJ0RUgWoAyutRrz72jl2Tot0IqYwN/Cry/nXX3GS8nv3/fDt5efX+4cfj792N//83n073R+P9z+/Hh/vbp/vHx/U+nuX7EfVn3m/q7S7kf2u6SsA/a0voex3kMwgBlWhKkB2QAjg3Q3qQ5DVgmjQHEpRaAbNgXJAdeCwcFgkLCIOFQLYwTxdgAL0I3La7xBTQAmIt3JYclhKWEp1IAwQB4YAdpD4CKEAC1CzgTUHVIeGAbxAThBAAf54hhIQFswB4pAxICxsUaBBdbAcLhCWGpYaFnNsAV6gmGMLkAOkAPuIbFAdEAPYoSeTFNjeYgN26BnrUAKqQ3esgyVcwykNAngBShAQFggLhAXDYonK2hJkDbkAO5SwFHKgFKCOlWRQHSyKBdjByl3AoDmY8wvohxZNFFlWDdjWzgLkgJ5w7h4aZAjwEnAJS/ESMKUALwGTl4AZA7wEXL0EkrwEkrwEAimgBHgJBHOAl0AyBHh6pYSlhIXCQmHhsLCXQAQCvARSw1K9BNJSgJdAmpegJgzwElSwZBYDK4FGWm2Zd7B1sYA4WOqKjq9q66KoY1UwgB1sAi5QAppD07SQfWiTBZr5s0BYICwQFgwLhiVbk7CBOFgyF6AA/VDqo7cEqM+kNW02IRcIiznfwZJJ1UCV2T7L2m8Bt+gMlyULkGzRONGgFmRdwDbIU3evduIgGjbSZ9nGe+I0aLWpHmcjKfGE1KC+XhYatoaDxAkSDgoPANKgMihUAMezvVOpEw1qQbYDOVmGbJeDPsbZqKZBq80i6k9YgzqFDZNljTv5ctKtEQdJEA4bclBfZQsNW0mDyqChTEOFx7MSUfZdaKGaB0mQjdUeb99u+rM5ZgH0DWeh3gfUqQblYbMe7vHmEr7kEt5ngkHDxmlQ5DTLsMnwIHYEyHUo16HS+rOvr/tdnGK+Pp8OBzvEnB1r9LDzdHs6PDzvbh5ejsf97t/b40v/o19Ptw/99/PtSd/VlXF4+K6/VfDH/fFg9Lpfn07bj2KuzZ/WarUhoD5eSMC2hPYZV9dQFhkirVxo4LZGRiJyDWWBLY1ZKBXCDT2nwGYoZSJRgNJIB8ia0CYXGvQJ6eC/mw49yohLlEyymY46CQWtXZdIkPhMAi8k2idkA9InpGMWS4YcfugE2IwF8DOCyX85GBQchWnbhYFJn0odsUjDshnKrE31sB4ayu2joajGZiiz9tAkhhfU6vYMm/Qp6sFmrPymm8DmEJs5oteZ4UnOpVyxbM+D0WP3ZjBpllJce11vjmtG6HKK4aRN9QoSfpDuz0MCgS81JuMUKMYHJhwKWfvkQmHWpLI2qR6XVw3OlxqzLqVosAJrWVHe1FUmzQEtcqE38ratUWf5jH2WcrpOocU857NM/FEcuG72+awibzXybLcnjHUCVORKDW5Do7brNPTgN+YG1m2NSX9Kic6QwlcptBKjXK84Vyno7WDMP715bGtM6loqhBul0lpXaH+QTruIejrpyrLm0aGK9SqNzwgFxiTXu1K9bqUIjNElk/Va8t/VAOYRC0u9TkNk7Aa6029r8EdXykzhfStlpvDelVLah9trms62Dh79fmS7vWabKzCNzVVwc3MlnLbGKCvXs/bSYXjdQeFsl39zUKDZnQlx3RzPm+ONHzTZ5nWW5xg/ykRbByea7fMJ19No0u8KNkVkdljg1RP9snRbZB4OnoVzfo18IzK9ObVx+WqwXljslv7uRZdiIDe8ctlyrLkm9NGFP1GYbrLvimKq8K4o3rnRv1X4oi9v7+5PF/+RejWp0/3tt+PBX/54ebg7e/f5v6d4J/6j9XR6vDt8fzkdTGn9t5b++CdrCjLyF/tiUV9io31OyV6CvYv2bvvyas78Dw==",
      "is_unconstrained": true,
      "name": "get_voting_power"
    },
    {
      "abi": {
        "error_types": {
          "14281122302021304822": {
            "error_kind": "string",
            "string": "Function is_sponsored_voting_enabled can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAcvCgADAAQcCgQFARwKBQMAHAoDBAEtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQXGML0RreOB9jwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuswDIbfxWsvLMnXvspQStqmQyCkJZMcOJS8+5FLnMsBezHT2cSSXX/VL8uXp7jW5/Hz1HS3+5c4fDzFuW/atvk8tfdLNTT3jnufQsWPA3EgKZwVByeFZw+AW3ZBSxGiz/0hcOulAKVnAzAZThyQpwByDyIbpJJh2ODZoFUymIuBDQPJePVMkxQpttPQ13UMbRMsS3hUfd0N4tCNbSvFn6odXz/6elTdqx2qnkeVFHV35ZaBt6atozXJdbbKT0XyYZ6NWoUFABR2CMgjwCvrZwbbzi2QoHcMzDMIjTEzg20HOUZJiocUBgaErBRdQGgwakkHuDWhwe0Y5g3psL+bDo3WzQhNxmXT4QtSkGxSgsZuELhDhDdkA9Qb0lHSQkApDiLKagF8hxj6ZTHocFmYkF8YKNSp84sWF1BnpZTKlKxODLbDT6UwIyulVB6cxBSFCT5/hhXqFAPRsvMDaZs9xEqBEOESCZHW39i2WzFWqawYVUqpQbXZt7hAzP4Uw0KZIi5SEDfpQPR7RuE4JcWZTGJUMCabVFOC4FpkCn3+eilVqrFrJMbaPKQsBzdytrfDf5BCvVtIp7KldWHi1Tsd2a0uTb97sEwR1TfVua1n9zZ2l83o8PeRRtKD59HfL/V17OtIWl89wN8PQknuGJ8w0fFSq+MU//of",
      "is_unconstrained": true,
      "name": "is_sponsored_voting_enabled"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "10936026424632231026": {
            "error_kind": "string",
            "string": "not token-gated"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "membership_mode",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "token_addr",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "join_with_aztec_token",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10154189512851138137": {
            "error_kind": "string",
            "string": "not erc20-gated"
          },
          "10958896161817881596": {
            "error_kind": "string",
            "string": "insufficient balance"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7220720865510965904": {
            "error_kind": "string",
            "string": "nullifier already used"
          }
        },
        "parameters": [
          {
            "name": "verified_balance",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "proof_nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "tZ1bjlw3Dob30s9+0JUUs5UgCJzEGRgwnMCxBxgE3vuIFC/VDo6sdFW/pL7+7eIRJUoipdPx30+/vfvly39+fv/x9z/+evrhx7+ffvn0/sOH9//5+cMfv779/P6Pj1P9+ynxf3IpTz/UN/MTn37A+Vnnz40/YX22rJ/6c0/62fST1ifozzDWJ6odxPU59Ocx7eQ8gabhzAqxMh9d0jSRBwMpZFTgVpbKgAq1TugMQ6GZ0liBCb0amAKggPPpNTOAAjewsuWBCmQKsTKbWlMxMCWbUpJBn45Og7Umg2ZACs2UZko3hZsqAMUAFbjNC0Bh8CPKm6eWskFXyPZH2ZRiSnGFFLgzFwyFVgxQodsjOigAG0wMzYAUsBqggoy/ACiQfZ36gp6SQTMYClkN9sp/uTGQgnSmgCndlG4KVANUkPgUAIWRDfgRnYEUqBrgApBenUEL0nWDARVkxgh0A1KQhglMv/p0B3iUF6ACmoKmDFOGKWQKsZ0ZCciRuQAVsikZFEo2mA3rhYEU2IsFqMDzvc/gR57wC5oBP3R2FHKvCnBkLgAFbhh35kjFQHt+ZFOy9vwo2UB7fhTt+VGrgfb86NrzA7XnB2rPj5ENuoH2/KBmoD1PqRhor1I2JZtSTCmmVFOq9jy1YqA9T92Urj1PkA205wm05wmrgfY88QTpc40iniAdGfqCnFJ1GkYyrMTEUwISE6+FSmjEE1ipG/EUVpodBEVoGHHblFwbrg3XyDUyLfMU7kNoGEkHLwIjXpWgCnUn9qMz8dKp5Jp4JMQdjUloPgPluRyTSq6xHyiW2Y9F3MuLeCNSmi0YYo9ISTYlJdeya9m1Up3QiINFCYx4dVDip2UhMuI5puQauAausUdKaMTLhBIYsW9K9rTKq6zStIwkNIx4oVVCI44wJTDi3U3JrfAYLWpupbkVGS0h8YN7vIofi4bRcG24Rq7xCiwke54SGPGup9Sd+GmSwsgYLUKjmo1kFEBSHf5TnluNFzal7kRG0tJFw4iX5kFCoNSlpYtcy65l14prxTWOIUpCYMQxpOQaL9NK3Wm2lHikZf9TQiP2bRGnEVSEmtMwYo+oCqEScJqxiHt8UbGRgZqdbGRkV1SykYGenJqOguyMi3hrVAIjbp+MkWx40uMofSoko7+oOdnIYKlOqL2LNTtZj2NzrbnWXeuugWvSp9zjshEq2cjgcG3YyCAlp6ajIFumkOyZSmDE8UxdiEeV+2CUZiRRsgiNJCJ4jR28EhK3dHByoQRGMvqLmhMZ8czLSZrAw79QNk/DUHOoOdQSagmVN3ZCITSSuF7UnbgWSByIxEFiOBhX9VADQ2X3FLn/584kCI4c1XNXEeRWZa4ckvilCPoXSuK5aiiqVCslB5Ijr4aG3JwMUtmw3dIEwZGjyjBUCBVCxRTYAsmRFyPD4ShuSlWUpM4SzCkHhppDzaGWFNgCybHWwOHYSiA6Lo+rYHeEFNgChyPWQHQcYUwGdiGFMQpjRIZl+YZSVabA7lhDraG2UFsLHI69BqIjlEB5sJSzazQXtsDhKINVE9e3vJZlKVErL2aKMqsUwVGartgD2XmpZGVjNhyOPdQeKoQKoWKoEn1c9BbZtA2HI4Uqk0ywySRTlKZL0Z5TYAscjrJ4VJBKPwf2QGkOd3WTEVrYSyA6og9hQx/CNmpgqFQCfWD7mkNDsAeSY66Oq708mlKkrmHpq9cXoqNMf0Ufwo4psNkAdPRh6aMGhkqhkquQamCoq9eboA8hlBoYai2BPrCyx6/Bkk3ekByXx4IyLyoJchBwcV8AcyA58r6kKAPApw/zBIcf0aogOUp7FdFRBkARHGVKc1E5sQWSYw+1hwqhQqgY6hC7crq0mr5wOEpEKUpzOH6HRJSi+MaxM2ReKIa63FzIdrucXMnm07sgObZQxbcujxDfFnJWYMjNATkP43oig9jlgwdFClXGAnjkVz6gGGoOVVZaRfYCuOkkyxXy02Tvz1zWFdn8Z7IkSI7SXsVQIVQIVdYoRXQUhxTBUc4hFeXBJEiKs1xqgaHmUHOoMiyK6CizRREcxWPF7thToDwCBYejrMqK6CgTRxEcJRAVw9ggRwpj5MayjOZC8Y2rxXnSWQOHYw21htpCld1/oez+iuAou79iD5QHF0YZTUV0lN1/oQzWkMPXdWLcGSU/U+yB5LiavnA4SuLCdcJEcFxNXxgqhAqhYqgYqkTfGILgKNGn6KqU6IY9UJrOoSFVuiE6Lo8FZWZxhVGlPjccjuImreNpdJSkbKEMy0L0IawjB/oQVgqVfAhbSoHNBqvJjrNQ1gdFcJT2ymiuvVuGpa1eF1wBs7AF+hA2rIFoA9BGDvRhaRQqubo2d8VQc6ir13lYesmBPoRry1f0IewtBTYbrC6Z2MLl8UJwlHnBVfZEDgLi3lmJwEIJLkU0BBkALgbr2tG5opr3CiUQHFfALGyB5ChTmmvCiego7VUMFUKFUDFUDFUSF65sK6ymC8qwKPbA2ZxZmU1EjihDvt3hunDekNTAUNlNRR6WWVcJisptwOWbqMs3QZnzij2Q25DlwcsL7h0cJTBU9qJkubLh4Foo+7xhZ+SWrX1evjZyC/QBkGrf0EdTDsgNQ20l0MdYTgQMwxiEhTVbOHbGmi0Le6CvtHIwULgonrPfV1rKPk0p1l/Z8gtf9lXZ8g1vVOlU+bvNpzQ1n9LUa2CoUAJ94ScMFaM5IwXGI0YYI7PQVsHPbk7sgeS49sKFqP3Q1ja+LPQUeKOSetzkvN0wVKzaD02O3PVrowRGIylUMjfbKu0VQ80psAX6I+QaWLGGBXFo3SKurHhdKNZAdASJamBES8dn+dYCQ12xg4LDsKQaKJ06GGWTkK+tyn1hyYGhyiKm2B1bqK0FDscej+hhDMLCKnT5rrKsOmshOlIOlKgmvkzNVuC1qNxbLaFK7JQkN7AlMFTOEaevguBf6ymwO0Ko0ALJEUPFaM4ogfEICmPkFlp251t251vJgT2QrB/kDlkt9BIYqsSOeNzkhn4hhsqn76sf2vCWtdECo5EUKrmbPdXAUHMJdOd7SYFurNewwA7x0WrrvEcodScy4qV1Hi0xyikwCYERuSZBw8dTTTZtwxuVe5OP9JrU6fIt2dQXcUwpuVaLExo115q1Qk7hldxydyvg32UP+Ox9UnciI7mhWSThy+uHlOicLzUsySk08Ym/g5xyGIYqb3QU+btt2Ld6cUIjcA3AyK5umhzFLxreitGc3DKZFdmhF2VzVXbiRaU6oZHkFeK01Njry705ubZCQr7DGasihopoTksFvr41zIVB3jQyjVJyss6l7JrdhUwyV+VMXsmtVP8ue8A3yk22XSU0guwk8cmRTkMvnJvsqIvItRUSJK94lMBQecMtVd744HkIQiU5daPqmlwNLyKj5lobRhwvSm4Z3Ar4d9kDfq+gyx67iDtbqTtxfPIyMMsBffGgy/ap5JqERC2C4NhC5d218NlbX29VybfsFZG+3qwSAtfk7Sohe/uhy532ouGtkJdshMgt2ysQXTbaRdlclQ1VqTuRkbxtJU5LJby+3O0hUgcrdXNPzrgNb1Qyp8vwBg1zoZA3jUyTt66UrHPlvSsla4W8gqXUnNzKej/n69c3T/YW3M+fP717xy/B3bwW9+PfT3++/fTu4+enHz5++fDhzdN/3374In/prz/ffpTPz28/zT+dMfPu42/zcxr8/f2Hd0xf38S30/VX52kD6bdnbkJuYB6HPjORr03wzeBQG5MR3Qi1ZzbKtY15ksGHgmJjMuYrGztXRrZmzIO9fOlK25iYWWTy7pjXudEMfGajP6A74HW7YyaNqCZmaoaX3TE2rhS+zFiezBl2Y6I8M0EP6I2cHtAdO18q10WrHfPw6dKXXB7hTH1lZwq/TKQDQ9cDkzdxisN9mdlGu3RlF6YzuTcblc9J7nRl2rh0ZRMe867HTMBM5d1Efz5n8yZMiyT0a97Po1Y3MTOK50vYLkrnCXaz3pibdL9cB/POSIkuTbOsuzSyW01nsu8t6TNtvjSyd6fcuHO7Fn5jZLOgDrRQHxQGeKN5ydj2cjW2Ows92Q43i4p2ZYGz3LujYzwiOugB0VHTI6JjPCA66nY9Jd9fKNeXxce4GV14UXyEhXkIfWWhbpbSLieoYoLzz4iPDM9tbNZSufNcIZYizOch5nMLmyidtaUv6LNWDBtQn9vYDWu32TYP0cIP/GZMdyup3NPoXLlJKL+10dKuP21EZpr9MgtkuQ/c9MS/8qNEYlxvRuQfrai7MS2WTc5aCl9oA8htDHqZjepL4NxWx7WNTXxis8jABi+yQM32gnls/iIL8zLYc4UE1+PaNuPKxygW4uNmQ8n0L7qzNe/O/sJhrR6hE8eLbDzCFTkgXc3IbbxspmD2pQs387X317WRAdwXwPEyG4heJcys+NrGuHem7CyczZSdhdOZAvnu8Np2J8XCM8/5rsNrt7nKmzi6uWK53FyhbUPDhxVGukzgTtOEm5nyTZoAcH8aCfiANBLGA9JIoAekkd9x5yyNxE2gQvbNvpYXJZF9DB/bnl6SRMLwNmC5LDKw3Z9EYr83iUS4P4lEvDeJxHF/Eol0bxK5tXCURG79OEwiR7k/idzbOEsitzYOk8jR790adxbOtsadhdOtcYy7t8Z9d54lkXsbZ0nkzsYjXDlMIrcz5TABpPa6Nk6TyK2NwySS8N6ZsrNwNlN2Fk5nSk7p7vja9udhFrndXQ+zyJzq66aRt4nCzWr+7Vl12hZLZM2Yd1502YyctldM1TfIyT1fX8zstnr+lUezkrFvrne2p07YqqeSONoLrrsAMTqWLg+K8+6eqfQWK8g8K4ar67+cd/ehFDnUZITLPsnbG1Hw2Vf5N1uurew9As+ker85Y/2HR5vJU30pmafxNyekLxmbkfL12OwSU596tz3azi+JhlcrMICu2zDuT9Hz7qrpLEfPu6uZ0yQ9b2+ajrL0vLtnOk3T5Zcd78vT9yaOEvW9K4eZei5wf6r+HSNnufreyGGynne3TWc5yNbEWRKyNXGchdT7s9zv9OlZxv4dI2cp+9bIQ7w5TNr3s+Yw4851vLKR07x9b+QwcZdfl7xz1uxMHM6anYnjWdPa/XG27dPD5H2/8Z5m7w1fN3u/TSLGdZLZHvCqibyJdvcxcO6PeNkk90e8bfI9j85OgnNvr/tGwYhsgvKL3iggr2aAsF5GScdHRMl4SJQ84qWTDOkhUfKI104y7A6soPqaBDe98i+iBJOPD6b6oisD8oxzGru0ICvf3ScBsD8JAIiTgE29urvJyb160dtvThO+7dPvNeXwUGJ7M3V8KIHpdQ8lMPWIknG5lmQsDyg6sd5ddO5O0I6Lzt0F1WHRubuhOi46d1dUh0Xn1sRZ0bl15bToHOkBRefeyGHRuTVyWnSOenf6vDNxmD7vTBynz+MBZdq+Tw+Lzr2Rw6JzpFf25rTo3M6a03qRyisbOS46t0ZOi066+2J1a+Jw1tADrlYz3X+3uu/T06Jzu/EeFp0l5VctOm+TiHnVdpVElN3N1WmiWFJ7QKJY0vYVO7JunWvFuEwUv9eUs0SxPOT2qjzk9mo//ZIt0VReOoPBZh9hv3sR2JnY7r5njmxNnDlymAPsTGxP4c4c2Zo4c+TwLHBnYnsIf+bI1sSZI4dXARsT2zcajvzYWjhy4/Ctio2FcfdEH3fP83H3NN++onzkxdbCkReHr0lvLGx/JeHIi62FIy8Ofy3iWws/zR/f/vr+07N/K+Urm/r0/u0vH97pj79/+fjrzZ9+/t+f9if2b638+emPX9/99uXTO7YU/+DK/M+Pmf+XOfPmPf/05ikvoeAUamEhizDzoPkf/OkrN+n/",
      "is_unconstrained": true,
      "name": "join_with_erc20_proof"
    },
    {
      "abi": {
        "error_types": {
          "11649364024006299642": {
            "error_kind": "string",
            "string": "not a member"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7504532782847838406": {
            "error_kind": "string",
            "string": "caller is not admin"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEUtCEUBJQAAAEElAAAAbCcCAQRGJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAMmJQAACvseAgACAB4CAAMALQgBBAAAAQIBJwIFAAgtDgUELQgBBgAAAQIBJwIHAAktDgcGHgIABwAeAgAIADMqAAcACAAJJwIHAQEkAgAJAAAAwyUAAAshHgIACAEKIghDCRYKCQocCgoLAAQqCwgKJwIIAQAKKgkICyQCAAsAAAD2JwIMBAA8BgwBJwIJAAMvCgAJAAsKKgoLCSQCAAkAAAETJQAACzMnAgkAAC0IAQonAgsEBAAIAQsBJwMKBAEAIgoCCy0KCwwtDgkMACIMAgwtDgkMACIMAgwtDgkMKwIACwAAAAAAAAAAAgAAAAAAAAAALQgBDCcCDQQFAAgBDQEnAwwEAQAiDAINLQoNDi0OCQ4AIg4CDi0OCQ4AIg4CDi0OCQ4AIg4CDi0OCw4tCAENAAABAgEtDgoNLQgBCgAAAQIBLQ4MCi0IAQ4AAAECAScCDwQALQ4PDi0IARAAAAECAS0OCBAnAhEEASQCAAgAAAIsIwAAAeUtCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMSLQ4FEgAiEgISLQ4JEgAiEgISLQ4JEi0OAg0tDgwKLQ4RDi0OCBAjAAACuC0KDwIjAAACNQwiAkQDJAIAAwAACnUjAAACRy0LDQItCwoDLQsQDC0LAxIAIhICEi0OEgMtCAESJwITBAUACAETAScDEgQBACIDAhMnAhQEBAAiEgIVPw8AEwAVLQICAycABAQEJQAAC0UtCAUDACoDERMtDgUTLQ4DDS0OEgotDhEOLQ4MECMAAAK4LQsNAi0LCgMtCxAFCioFCAwkAgAMAAAC2icCEgQAPAYSAScCBQQCJAIACAAAAxwjAAAC7C0CAgMnAAQEBCUAAAtFLQgFDAAqDAUSLQ4BEi0ODA0tDgMKLQ4FDi0OCBAjAAADqC0KDwIjAAADJQwiAkQDJAIAAwAACe8jAAADNy0LDQItCwoDLQsQDC0LAxIAIhICEi0OEgMtCAESJwITBAUACAETAScDEgQBACIDAhMnAhQEBAAiEgIVPw8AEwAVLQICAycABAQEJQAAC0UtCAUDACoDERMtDgETLQ4DDS0OEgotDhEOLQ4MECMAAAOoLQsQAwoqAwgMJAIADAAAA8InAhIEADwGEgEtCg8CIwAAA8sMIgJEAyQCAAMAAAlpIwAAA90tCw0CLQsKAy0LDgwtCwMSACISAhItDhIDLQgBEicCEwQFAAgBEwEnAxIEAQAiAwITJwIUBAQAIhICFT8PABMAFS0OAg0tDhIKLQ4MDi0OBxAAKhIRAy0LAwIKKgIJAwoqAwgKJAIACgAABE4lAAALpC8KAAIAAxwKAwoGHAoKAgAcCgIDBicCAgYADCoCAwokAgAKAAAEeiUAAAu2LQsEAi0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBAotDgkKACIKAgotDgkKACIKAgotDgkKLQgBBCcCCgQFAAgBCgEnAwQEAQAiBAIKLQoKDC0OCQwAIgwCDC0OCQwAIgwCDC0OCQwAIgwCDC0OCwwtCAEKAAABAgEtDgMKLQgBAwAAAQIBLQ4EAy0IAQsAAAECAS0ODwstCAEMAAABAgEtDggMJAIACAAABXMjAAAFLC0IAQ0nAg4EBAAIAQ4BJwMNBAEAIg0CDi0KDhAtDgIQACIQAhAtDgkQACIQAhAtDgkQLQ4NCi0OBAMtDhELLQ4IDCMAAAX/LQoPBCMAAAV8DCIERA0kAgANAAAI4yMAAAWOLQsKBC0LAw0tCwwOLQsNEAAiEAIQLQ4QDS0IARAnAhIEBQAIARIBJwMQBAEAIg0CEicCEwQEACIQAhQ/DwASABQtAgQDJwAEBAQlAAALRS0IBQ0AKg0REi0OAhItDg0KLQ4QAy0OEQstDg4MIwAABf8tCwoCLQsDBC0LDA0KKg0IDiQCAA4AAAYhJwIQBAA8BhABJAIACAAABl4jAAAGLi0CAgMnAAQEBCUAAAtFLQgFDQAqDQUOLQ4BDi0ODQotDgQDLQ4FCy0OCAwjAAAG6i0KDwIjAAAGZwwiAkQEJAIABAAACF0jAAAGeS0LCgItCwMELQsMBS0LBA0AIg0CDS0ODQQtCAENJwIOBAUACAEOAScDDQQBACIEAg4nAhAEBAAiDQISPw8ADgASLQICAycABAQEJQAAC0UtCAUEACoEEQ4tDgEOLQ4ECi0ODQMtDhELLQ4FDCMAAAbqLQsMAgoqAggEJAIABAAABwQnAgUEADwGBQEtCg8BIwAABw0MIgFEAiQCAAIAAAfXIwAABx8tCwoBLQsDAi0LCwQtCwIFACIFAgUtDgUCLQgBBScCDQQFAAgBDQEnAwUEAQAiAgINJwIOBAQAIgUCDz8PAA0ADy0OAQotDgUDLQ4ECy0OBwwAKgURAi0LAgEKKgEJAgoqAggDJAIAAwAAB5AlAAALpDAKAAkAAS0LBgEvCgABAAIcCgIEBRwKBAMAHAoDAgUnAgMFAQIqAgMEDioDAgUkAgAFAAAHyyUAAAvIHAoEAgAwCgACAAEmLQsKAi0LAwQtCwsFLQsMDQwqAQUOJAIADgAAB/kjAAAITwAiBAIPACoPARAtCxAOACICAhAAKhABEi0LEg8AKg4PEC0CBAMnAAQEBSUAAAtFLQgFDgAiDgIPACoPARItDhASLQ4CCi0ODgMtDgULLQ4NDCMAAAhPACoBEQItCgIBIwAABw0tCwoELQsDBS0LCw0tCwwODCoCDRAkAgAQAAAIfyMAAAjVACIFAhIAKhICEy0LExAAIgQCEwAqEwIULQsUEgAqEBITLQIFAycABAQFJQAAC0UtCAUQACIQAhIAKhICFC0OExQtDgQKLQ4QAy0ODQstDg4MIwAACNUAKgIRBC0KBAIjAAAGZy0LCg0tCwMOLQsLEC0LDBIMKgQQEyQCABMAAAkFIwAACVsAIg4CFAAqFAQVLQsVEwAiDQIVACoVBBYtCxYUACoTFBUtAg4DJwAEBAUlAAALRS0IBRMAIhMCFAAqFAQWLQ4VFi0ODQotDhMDLQ4QCy0OEgwjAAAJWwAqBBENLQoNBCMAAAV8LQsNAy0LCgwtCw4SLQsQEwwqAhIUJAIAFAAACYsjAAAJ4QAiDAIVACoVAhYtCxYUACIDAhYAKhYCFy0LFxUAKhQVFi0CDAMnAAQEBSUAAAtFLQgFFAAiFAIVACoVAhctDhYXLQ4DDS0OFAotDhIOLQ4TECMAAAnhACoCEQMtCgMCIwAAA8stCw0DLQsKDC0LDhItCxATDCoCEhQkAgAUAAAKESMAAApnACIMAhUAKhUCFi0LFhQAIgMCFgAqFgIXLQsXFQAqFBUWLQIMAycABAQFJQAAC0UtCAUUACIUAhUAKhUCFy0OFhctDgMNLQ4UCi0OEg4tDhMQIwAACmcAKgIRAy0KAwIjAAADJS0LDQMtCwoMLQsOEi0LEBMMKgISFCQCABQAAAqXIwAACu0AIgwCFQAqFQIWLQsWFAAiAwIWACoWAhctCxcVACoUFRYtAgwDJwAEBAUlAAALRS0IBRQAIhQCFQAqFQIXLQ4WFy0OAw0tDhQKLQ4SDi0OExAjAAAK7QAqAhEDLQoDAiMAAAI1KAAABAR4RgwAAAQDJAAAAwAACyAqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBWgldM4m60jGPAQCASYtAQMGCgAGAgckAAAHAAALWyMAAAtkLQADBSMAAAujLQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAAC54tAQoILQQICwAACgIKAAALAgsjAAALeicBBQQBJioBAAEFursh14IzGGQ8BAIBJioBAAEFoara294cT/o8BAIBJioBAAEFG7xl0D/c6tw8BAIBJg==",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "remove_member"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7504532782847838406": {
            "error_kind": "string",
            "string": "caller is not admin"
          }
        },
        "parameters": [
          {
            "name": "new_fpc_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEElAAAAZycCAQRFJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJiUAAAD2HgIAAgAeAgADAB4CAAQAHgIABQAzKgAEAAUABicCBAEBJAIABgAAAJolAAABHB4CAAQBCiIEQwUWCgUGHAoGBwAEKgcEBicCBAEACioFBAckAgAHAAAAzScCCAQAPAYIAScCBAADLwoABAAFCioGBQQkAgAEAAAA6iUAAAEuJwIEAAYwCgABAAQmKAAABAR4RQwAAAQDJAAAAwAAARsqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBWgldM4m60jGPAQCASY=",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "tVbbitswEP0XP/tBc9Fl8itlCU7iLAbjBG9SKCH/3tHW8qUgQbfZl/hIio7nzBzJ86hO7eH+vu+G8+Wj2v14VIex6/vufd9fjs2tuww6+6hM/AETqh3VFQBVOx+fOgZQgDoBHEGciUvkFAQFDAnIBCxXO8QIdAbjLscJhGnJUwJxxikIlECaEfcHoIEErMan8SCYBPQ/pDyIkIBMgPSl5COIM/75rKskeX8b2zYqXuVAM3Ntxna4Vbvh3vd19bPp759/+rg2w+fz1oy6auqqHU76VMJz17cRPetlt8lvRQoy7UY2MhMAyYYC8hQQjAsTh2LvZxLhDQfmOQittROHYg85jpKUACkMFISsFC5QMFgzpwP8klDxGw77gnS4700Ho/MTBZP12XSEghQkl5SgdSsK3FDIC7IB5gXpKGkhoBQHEWW1AL5CDH2zGPQ4F0byhYGCT32YtXhBzkop2ZQcJw7F8r9SlCMrpWAPEUpRiNiltHZ7ZqFgU7QMyeqK2eUOPhbiAPGLPcR7l70IoWQPhzjbw1HeY2U5DmY5Figrp2RUTjZlwEWL/VJZHObKgiWPunRm19nkf3BGmC8wY1aft79j8IVcIs6pxJUxEMOWo2ByMkKcimrE2qwzpESCy2kzGLLOoNJVat0SiXXOf+HLoqnEsKSVOZfWModfOLSty3FQwaHoJflDP/6SLQ1x6bwRynzeyGbvMCr4lLRVSEZTbPOlKd2m1jPNpfFheyW/6ag5duOmSX5GtrFrDn07Dc/34bhavf26ppXUZF/Hy7E93cc2Mq07bW04GWp2b7HN1oF2QhbfnvHVvwE=",
      "is_unconstrained": true,
      "name": "set_sponsored_fpc"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7504532782847838406": {
            "error_kind": "string",
            "string": "caller is not admin"
          }
        },
        "parameters": [
          {
            "name": "enabled",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREAS0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAQAeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEmHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBJwIEAAMvCgAEAAUKKgYFBCQCAAQAAADvJQAAATgcCgEEACcCAQAHMAoABAABJigAAAQEeEUMAAAEAyQAAAMAAAElKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVoJXTOJutIxjwEAgEm",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "tVddj+ogEP0vffaBmWH48K9sNqZq3TRpqunqTW6M//0OXijtAyS7677IAcrpnOEMxXtz7Pa3j10/ns6fzfbt3uynfhj6j91wPrTX/jzK6L1R4QeAmi1tpHXN1kqL0gcIQAZAC6AwEqY0CHABmAhYJ+CbLaIAIyMYVhkfgaU4ZV0ELoyYAFwEPo6gggRMBCBhEgTAEaA8QxiAiYB0AvJSCqt0GPEBhBH/eGyapH13nbouSF8kQ1J0aaduvDbb8TYMm+ZPO9yeD31e2vHZXttJZtWm6cajtEJ46ocuoMcmr1blpUjOx9WolZ8J4BlepoAyBThlXOQQbO1M4vWKA8schMwcOQRbKHHUpDhIYaBHKErRFQoNrOZ0gM0J9XbFwS9Ih/nddGg0NlJoYltMh6tIwWDb/0qQzYICVxT+BdkA9YJ01LQQUIqDiIpaAF8hhn5ZDFqcN8aXNwYqPrVu1mI96qKUmk3J6MQh2P9UinAUpVTsAUpO1sShkPMpxuuqhYpRkTUkswvWplT6WIvE22wQb60pHoVQM4hBnA1iqOyyuhwDsxwGKsqpWVUno2rArIW/uTHGlTYGaz41qW6X+dRfcYefHaYIuBiEraQTcc4mLryB6NYcFaeT8pSyIZi5aA5fI8Fccgpd0RxUO0/Z5EjYGPuNz4ukkvLeEqtSWuscLnNotCUOqpgUrU8GkRuAL24N6VrJkTFzyVG5bqliVIZULYzZ6eFS9YUw0OcwuHieUsWqJNeWWQtYLjuk5lW2mmaHWLf+PLxLrz300+rm/ghsU9/uhy52T7fxsJi9/r2kmXTzv0znQ3e8TV1gWlz/5fdN3q/de/gPIB3GDev3R3j1Pw==",
      "is_unconstrained": true,
      "name": "set_sponsored_voting_enabled"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIIECfpVPHBYvigUoZAifBnp5b0KSSBz4vOltX8milXIrq5G9/qPf/yP//lP/++f/+u//Nv/+vf/84///F/+4x//9L//5V//9V/++b/+67//9//2f//l3//t7//3P/7x+/6f+Pt/53/6R4x//Gf/+x/D/0z8z8L/OP5n438O/ifwPzf/5/7wP1jlYpWLVS5WuVjlYpWLVS5WuVhl/H7vf8f7X3v/O9//rve//v53v/8973/j/e9bb7z1xltvvPXGW2+89cZbb7z1xltvvPXGW8/eevbWs7eevfXsrWdvPXvr2VvP3nr21ptvvfnWm2+9+dabb7351ptvvfnWm2+9+dZbb7311ltvvfXWW2+99dZbb7311ltvvfXW87eev/X8redvPX/r+VvP33r+1vO/9c73vxf/u3/vf8f737/1xu+DWbAK/pYc84O/NUf+x6cgCu6D8ysYBX8r2/hgFqwCL/hb2eyDUxAF38rfEXztARgF38rxwSxYBV6wC05BFNwHX8sARkGtfGvlWyt/zTO/bfnaB3AKouAC7OsiwCiwglmwCrxgF5yCKKiVR608auVRK49aedTKo1YetfKolUetPGplq5W/1pr2gRXMglXgBbvgFETBffD1GKBWnrXyrJVnrTxr5Vkrz1p51sqzVl618qqVV628auVVK69aedXKq1ZetfKqlb1W9lrZa2Wvlb1W9lrZa2Wvlb1W9lp518q7Vt618q6Vd628a+VdK+9aedfKu1Y+tfKplU+tfGrlUyufWvnUyqdWPrXyqZWjVo5aOWrlqJWjVo5aOWrlrwenfxAF98HXg4BRYAWzYBV4wS6olW+tfN/KM3swPhgFVvC38pofrAIv2AWnIArug68HAaPACmrlUSuPWnm8RJrjFETBS6Rpv4JRYAWzYBV4Qa1stbLVyl8Prv0HXw8CRoEVzIJV4AW74BREQa28auVVK69a+evBdT5YBV6wC05BFNwHXw8CRoEV1MpeK3utnK+A64NTEAX3wdeDgFFgBbNgFXhBrbxr5V0r71r51MqnVj618qmVT618auVTK59a+dTKp1aOWjlq5aiVo1aOWjlq5aiVo1aOWjlq5Vsr31r51sq3Vr618q2Vb618a+VbK9+38vr9CkaBFcyCVeAFu+AUREGtPGrlUSuPWnnUyqNWHrXyqJVHrTxq5VErW61stbLVylYrW61stbLVylYrW61stfKslWetPGvlWSvPWnnWyrNWnrXyrJVnrbxq5VUrr1p51cqrVl618qqVV628auVVK3ut7LWy18peK3ut7LVy9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t60KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgcje/B8YAWz4G/lPT7wgl1wCqLgPvh6EDAKrGAW1MpRK0etHLVy1MpRK99a+dbKt1a+tfKtlW+tfGvlWyvfWvm+le/vVzAKrGAWrAIv2AWnIApq5VErj1p51MqjVh618qiVR608auVRK49a2Wplq5WtVrZa2Wplq5WtVrZa2Wplq5VnrTxr5Vkrz1p51sqzVp618qyVZ608a+VVK69aedXKq1ZetfKqlVetvGrlVSuvWtlrZa+VvVb2WtlrZa+VvVb2WtlrZa+Vd628a+VdK+9aedfKu1betfKulXetvGvlUyufWvnUyqdWrh681YO3evBWD97qwVs9eKsHb/XgrR681YO3evBWD97qwVs9eKsHb/XgrR681YO3evBWD97qwVs9eKsHb/XgrR681YN/n7L/mkaTNc2m1eRNu+k0RVN7jPYY7THaY7THaI/RHqM9RnuM9hjtYe1h7WHtYe1h7WHtYe1h7WHtYe0x22O2x2yP2R6zPWZ7zPaY7THbY7bHao/VHqs9Vnus9ljtsdpjtcdqj9Ue3h7eHt4e3h7eHt4e3h7eHt4e3h67PXZ77PbY7bHbY7fHbo/dHrs9dnuc9jjtcdrjtMdpj9Mepz1Oe5z2OO0R7RHtEe0R7RHtEe0R7RHtEe0R7XHb47bHbY/bHrc9bnvc9rjtcduj+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfZ6zShvT1dF0i7LPT9JosqbZtJq8aTedpmi6j3Jw6dFosqbZtJq8aTedpmhqj9Eeoz1Ge4z2GO0x2mO0x2iP0R6jPaw9rD2sPaw9rD2sPaw9rD2sPaw9ZnvM9pjtMdtjtsdsj9kesz1me8z2WO2x2mO1x2qP1R6rPVZ7rPZY7bHaw9vD28Pbw9vD28Pbw9vD28Pbw9tjt8duj90euz12e+z22O2x22O3x26P0x6nPU57nPY47XHa47THaY/THqc9oj2iPaI9oj2iPaI9oj2iPaI9oj26z1f3+eo+X93nq/s856L2TdpNpyma7qMcjno0mqxpNq0mb9pNpyma2mO0x2iP0R6jPUZ7jPYY7THaY7THaA9rD2sPaw9rD2sPaw9rD2sPaw9rj9kesz1me8z2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TLdInMRFdOImHmIQbyOyBDiIdDt0O3Q7dDt0O3Q7dDt0C7oF3YJuQbegW9At6BZ0C7oF3S7dLt0u3S7dLt0u3S7dLt0u3W67rd+POIhGnMRFdOImHmIQ6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26ZZZ8v3trOYBYeBszS77fw7WcQSw04iQuohM38RCDeBudbk43p5vTzenmdHO6Od2cbk63TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0O3S7dLt0u3S7dLt0u3S7dLt0u22W44vFg6iESdxEZ24iYcYRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG6TbpNuk26TbpNuk26TbpNuk26TbswSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKQJTtxEZ24iYcYxNuILAEOohHptui26Lbotui26Lbo5nRzujndnG5ON6dbZonhzxkcYhA/N8uNyix5OIifm53ESVxEJ27iIQbxNmaWPBxEuh26Hboduh26Hboduh26Bd0ySyx3J7Pk4SQuohM38RCDeBszSx7S7dLt0u3S7dLt0u3S7dLttluOehYOohEncRGduImHGES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p9um26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26Fb0I1ZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJgllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxkSSQOohEncRGduImHGMTbeOh26Hboduh26Hboduh26HbodugWdAu6Bd2CbkG3oFvQLegWdAu6Xbpdul26Xbpdul26Xbpdul263XKbv9+POIhGnMRFdOImHmIQ6TboNug26DboNug26DboNug26DboZnTLLPn+LtzMQdbCSfzcvj/zNXOWtXATDzGItzGz5OEgGnES6TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26OZ0c7o53ZxuTjenm9PN6eZ0c7ptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbpdul26Xbpdul26Xbpdul26XbrfdMPf6cBCNOImL6MRNPMQg0m3QbdBt0G3QbdBt0G3QbdBt0G3QzehmdDO6Gd2YJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1lizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLMHca/4BXMy9PnRiup3EQwziLcTc68NBNOIkLqITN/EQ020k3kZkCXAQjTiJi+jETTxEug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui25ON6eb083p5nRzujndnG5ON6fbphuy5CYacRIX0YmbeIhBvI3IEiDdDt0O3TJLViQ6cRM/t4X/Noi3MbNk/RIH0YiTuIhO3MRDDOJtvHS7dLt0u3S7dLt0u3S7dLt0u+2GudeHg2jESVxEJ27iIQaRboNug26DboNug26DboNug26DboNuRjejm9HN6GZ0M7oZ3YxuRjej26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbopvTzenmdHO6Od2cbk43p5vTzem26bbptum26bbptum26bbptum26XbohmevnmjESVxEJ27iIQbxNuLZK5BuQbegW9At6BZ0C7oF3YJul26Xbpdul26Xbpdul26Xbpdut90w9/pwEI04iYvoxE08xCDSbdBt0G3QbdBt0G3QbdBt0G3QbdDN6GZ0M7oZ3YxuRjejm9HN6GZ0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdHO6Od2cbk43p5vTzenmdHO6Od023TbdMkv8lziJi/i5+UzcxEP83L4/Xzcx9wrMLHk4iEacxEV04iYeIt0O3YJuQbegW9At6BZ0C7oF3YJuQbdLt0u3S7dLt0u3S7dLt0u3S7fbbph7fTiIRpzERXTiJh5iEOk26DboNug26DboNug26DboNug26GZ0M7oZ3YxuRjejm9HN6GZ0M7pNuk26TbpNuk26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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "10154189512851138137": {
            "error_kind": "string",
            "string": "not erc20-gated"
          },
          "10958896161817881596": {
            "error_kind": "string",
            "string": "insufficient balance"
          },
          "11649364024006299642": {
            "error_kind": "string",
            "string": "not a member"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13489005082718014639": {
            "error_kind": "string",
            "string": "Function get_quorum_threshold can only be called statically"
          },
          "13577528510695619250": {
            "error_kind": "string",
            "string": "Function add_token_member_internal can only be called by the same contract"
          },
          "13676344659716267636": {
            "error_kind": "string",
            "string": "Function get_token_address can only be called statically"
          },
          "13914258305110804072": {
            "error_kind": "string",
            "string": "Function get_voting_power can only be called statically"
          },
          "14281122302021304822": {
            "error_kind": "string",
            "string": "Function is_sponsored_voting_enabled can only be called statically"
          },
          "14397635560847713499": {
            "error_kind": "string",
            "string": "Function get_proposal can only be called statically"
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14800929215391895385": {
            "error_kind": "string",
            "string": "Function get_sponsored_fpc_address can only be called statically"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16651589314398098717": {
            "error_kind": "string",
            "string": "Function get_erc20_config can only be called statically"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17072719129172364576": {
            "error_kind": "string",
            "string": "proposal did not pass"
          },
          "1895031872533078804": {
            "error_kind": "string",
            "string": "Function get_voting_duration can only be called statically"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3905717565539885644": {
            "error_kind": "string",
            "string": "Function get_proposal_count can only be called statically"
          },
          "4253643505666188125": {
            "error_kind": "string",
            "string": "quorum not met"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5227616292269356710": {
            "error_kind": "string",
            "string": "Function get_membership_mode can only be called statically"
          },
          "5366287459706263972": {
            "error_kind": "string",
            "string": "Function get_token_gate_address can only be called statically"
          },
          "5967729769606704330": {
            "error_kind": "string",
            "string": "Function add_to_tally_internal can only be called by the same contract"
          },
          "7220720865510965904": {
            "error_kind": "string",
            "string": "nullifier already used"
          },
          "7504532782847838406": {
            "error_kind": "string",
            "string": "caller is not admin"
          },
          "7840289186398101667": {
            "error_kind": "string",
            "string": "Function get_member_count can only be called statically"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8418147970250171169": {
            "error_kind": "string",
            "string": "Function get_name can only be called statically"
          },
          "8927709774589806846": {
            "error_kind": "string",
            "string": "voting ended"
          },
          "8972375130064208218": {
            "error_kind": "string",
            "string": "Function get_vote_tally can only be called statically"
          },
          "900405183110375111": {
            "error_kind": "string",
            "string": "already executed"
          },
          "9345055721478160917": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBTJwAABFMnAgIEAScCAwQAHwoAAgADAFItCFIBJQAAAEElAAAAvScCAQRTJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAYnAEUEAycARgEAJwBHBAAnAEgAACcASQEBJwBKBAEnAEsAAScATAQCJwBNBAQnAE4EBScATwQKJwBQBCcrAABRAAAAAAAAAAABAAAAAAAAAAAmJQAAOscpAgACABvWE/wKKgECAycCBAQAJwIGBAMAKgQGBS0IAQIACAEFAScDAgQBACICAgUtDgQFACIFAgUtDgQFJwIFBAMAKgIFBCcCBAADJwIFAAQnAgYABScCBwAGJwIIAAcnAgkACScCCgALJwILAA0nAgwADicCDQAPJwIOABAnAg8AESQCAAMAAAFSIwAADMYtCAEQJwIRBCgACAERAScDEAQBACIQAhEfMABQAEoAES0IAREAAAECAS0OEBEtCAEQAAABAgEtDEcQLQgBEicCEwQgAAgBEwEnAxIEAQAiEgITJwIUBB8AKhQTFC0KExUOKhQVFiQCABYAAAHNLQxIFQAiFQIVIwAAAbItCAETAAABAgEtDhITJwISBB8tCEcDIwAAAegMKgMSFCQCABQAADpSIwAAAfotCxEULQsQFQAqFRIWDioVFhckAgAXAAACGSUAADrtLQ4UES0OFhAtCxMUJwITAgAtCAEVJwIWBCAACAEWAScDFQQBACIVAhYnAhcEHwAqFxYXLQoWGA4qFxgZJAIAGQAAAmstDhMYACIYAhgjAAACUC0IARMAAAECAS0OFRMtCEcDIwAAAoEMKgMSFSQCABUAADn/IwAAApMtCxMUJwIVBBYtCAAWLQoRFy0KEBgACAAVACUAADr/LQIAAC0KFxMAIhNKFi0LFhUnAhYEFy0IABctChEYLQoQGQAIABYAJQAAOv8tAgAALQoYEwAiE0oXLQsXFhwKFhcEHAoXEwAnAhcEGC0IABgtChEZLQoQGgAIABcAJQAAOv8tAgAALQoZFgAiFkoYLQsYFxwKFxgFHAoYFgAnAhgEGS0IABktChEaLQoQGwAIABgAJQAAOv8tAgAALQoaFwAiF0oZLQsZGBwKGBkCHAoZFwAnAhkEGi0IABotChEbLQoQHAAIABkAJQAAOv8tAgAALQobGAAiGEoaLQsaGScCGgQbLQgAGy0KERwtChAdAAgAGgAlAAA6/y0CAAAtChwYACIYShstCxsaJwIbBBwtCAAcLQoRHS0KEB4ACAAbACUAADr/LQIAAC0KHRgAIhhKHC0LHBsnAhwEHS0IAB0tChEeLQoQHwAIABwAJQAAOv8tAgAALQoeGAAiGEoRLQsREBwKEBgGHAoYEQAeAgAQAB4CABgALQgBHAAAAQIBLQxLHC0IAR0AAAECAS0OBB0tCAEeAAABAgEtDgUeLQgBHwAAAQIBLQ4GHy0IASAAAAECAS0OByAtCAEhAAABAgEtDgghLQgBIgAAAQIBLQ4JIi0IASMAAAECAS0OCiMtCAEkAAABAgEtDgskLQgBJQAAAQIBLQ4MJS0IASYAAAECAS0ODSYtCAEnAAABAgEtDg4nLQgBKAAAAQIBLQ4PKB4CACkALQgBKicCKwQDAAgBKwEnAyoEAQAiKgIrNg4AKQArAAAiKkosLQssKwAiKkwtLQstLBwKKyoABCoqLC0kAgArAAAFIycCKgQAPAYqAS0IASonAisEAwAIASsBJwMqBAEAIioCKzYOACkAKwIAIipKKy0LKykAIipMLC0LLCscCikqAAQqKissJAIAKQAABW8nAioEADwGKgEtCAEpJwIqBAIACAEqAScDKQQBACIpAiofMABKAEcAKgAiKUorLQsrKhwKKisEHAorKQAtCAEqAAABAgEoAgArAAE4LQ4rKi0IASsAAAECASgCAC4AATktDi4rLQgBLicCLwQoAAgBLwEnAy4EAQAiLgIvHzAAUABKAC8tCAEvAAABAgEnAjAALC0IATEnAjIEKQAIATIBJwMxBAEAIjECMi0KMjMtDjAzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzACIzAjMtDEgzLQ4xLycCMAQoLQhHAyMAAAeJDCIDUBAkAgAQAAA5qSMAAAebLQsvEC0IARgnAi4EBAAIAS4BJwMYBAEAIhgCLi0KLi8tDEgvACIvAi8tDEgvACIvAi8tDEgvKwIALgAAAAAAAAAAKAAAAAAAAAAALQgBLycCMQQFAAgBMQEnAy8EAQAiLwIxLQoxMi0MSDIAIjICMi0MSDIAIjICMi0MSDIAIjICMi0OLjItCAEuAAABAgEtDhguLQgBGAAAAQIBLQ4vGC0IAS8AAAECAS0MRy8tCAExAAABAgEtDEYxLQhHAyMAAAheDCoDMDIkAgAyAAA5YiMAAAhwJwIwBDItCAAyLQouMy0KGDQtCi81LQoxNgAIADAAJQAAO3AtAgAALQozEC0LKhgtCysuLQ4YKi0OListCAEYJwIqBAQACAEqAScDGAQBACIYAiotCiorLQxIKwAiKwIrLQxIKwAiKwIrLQxIKy0LGCoAIioCKi0OKhgrAgAqAAAAAAAAAAADAAAAAAAAAAAtCAErJwIuBAUACAEuAScDKwQBACIrAi4tCi4vLQxILwAiLwIvLQxILwAiLwIvLQxILwAiLwIvLQ4qLy0IASoAAAECAS0OGCotCAEYAAABAgEtDisYLQgBKwAAAQIBLQxHKy0IAS4AAAECAS0MRi4nAi8EMC0IADAtCioxLQoYMi0KKzMtCi40LQoLNQAIAC8AJQAAO9wtAgAAJwIvBDAtCAAwLQoqMS0KGDItCiszLQouNC0KKTUACAAvACUAADvcLQIAACcCKQQvLQgALy0KKjAtChgxLQorMi0KLjMtChA0AAgAKQAlAAA73C0CAAAnAikELy0IAC8tCiowLQoYMS0KKzItCi4zAAgAKQAlAAA7cC0CAAAtCjAQCiosEBgkAgAYAAAKLCUAADzbCiItSBAeAgAYAQoiGEMpFgopKhwKKisABCorGCoKIilGGCQCABgAAApfJwIrBAA8BisBCiotKhgSKhAYKSQCACkAAAp2JQAAPO0tCxwQLQgBGAAAAQIBLQxIGC0IARwAAAECAS0MSxwoAgApAAEALQhHAyMAAAqkDCoDEiokAgAqAAA49CMAAAq2LQsYAy0IARInAhQEAwAIARQBJwMSBAEAIhICFC0KFBgtDgcYACIYAhgtDhAYJwIYBCktCAApLQoSKi0ITCstCEYsAAgAGAAlAAA8/y0CAAAtCioUNAIAFC0IARInAhQEBAAIARQBJwMSBAEAIhICFC0KFBgtDEgYACIYAhgtDEgYACIYAhgtDEgYLQgBFCcCGAQFAAgBGAEnAxQEAQAiFAIYLQoYHC0MSBwAIhwCHC0MSBwAIhwCHC0MSBwAIhwCHC0MURwtCAEYAAABAgEtDhIYLQgBEgAAAQIBLQ4UEi0IARQAAAECAS0MRxQtCAEcAAABAgEtDEYcJwIpBCotCAAqLQoYKy0KEiwtChQtLQocLi0KAy8ACAApACUAADvcLQIAACcCKgQrLQgAKy0KGCwtChItLQoULi0KHC8ACAAqACUAADtwLQIAAC0KLCkwCgADABAAIhBLAzAKACkAAy0LHQMtCx4QLQsfEi0LIBQtCyEYLQsiHC0LIx0tCyQeLQslHy0LJiAtCychLQsoIjAKABUAAzAKABMAEDAKABYAEjAIAEgAFDAIAEgAGDAIAEgAHDAIAEgAHTAKABcAHjAKABkAHzAKABoAIDAKABsAITAKABEAIh4CAAMANAIAAy0LAgMAIgMCAy0OAwIAIgICES0LEREtChEQJwISBAMAKgISAzsOABAAAyMAAAzGKQIAAwCAaLcdCioBAxAnAgMACCcCEQYAJwISBQEkAgAQAAAM8CMAAA9hLQgBECcCEwQDAAgBEwEnAxAEAQAiEAITHzAATABKABMtCAETAAABAgEtDhATLQgBEAAAAQIBLQxHECcCFQQWLQgAFi0KExctChAYAAgAFQAlAAA+kS0CAAAtChcUACIUShYtCxYVJwIWBBctCAAXLQoTGC0KEBkACAAWACUAAD6RLQIAAC0KGBQAIhRKEy0LExAcChAUBhwKFBMAHgIAEAAeAgAUAB4CABYAHgIAFwAzKgAWABcAGCQCABgAAA21JQAAPwIeAgAWAQoiFkMXFgoXGBwKGBkABCoZFhgKIhdGFiQCABYAAA3jJwIZBAA8BhkBLwoABAAWCioYFhckAgAXAAAN+yUAAD8ULQgBFicCFwQDAAgBFwEnAxYEAQAiFgIXLQoXGC0OAxgAIhgCGC0OFRgnAhgEGS0IABktChYaLQhMGy0IRhwACAAYACUAAD8mLQIAAC0KGhcKIhdIFgoiFkYYJAIAGAAADmIlAABAuC8KABcAFhwKFhgGHAoYFwAcChcWBgoqFhEXJAIAFwAADokjAAAOxS8KAAkAEBwKEBYFHAoWFAAcChQQBQAqEBIUDioQFBYkAgAWAAAOtSUAADrtHAoUEAAwCgAQAAkjAAAOxS0IARAnAhQEAwAIARQBJwMQBAEAIhACFC0KFBYtDgMWACIWAhYtDhUWJwIVBBYtCAAWLQoQFy0ITBgtCEYZAAgAFQAlAAA/Ji0CAAAtChcUCiIUSBAKIhBGFSQCABUAAA8sJQAAQLgwCgATABQtCwIQACIQAhAtDhACACICAhQtCxQULQoUEycCFQQDACoCFRA7DgATABAjAAAPYSkCABAA8eURawoqARATJAIAEwAAD3wjAAARsi0IARAnAhMEAgAIARMBJwMQBAEAIhACEx8wAEoASgATLQgBEwAAAQIBLQ4QEy0IARAAAAECAS0MRxAnAhUEFi0IABYtChMXLQoQGAAIABUAJQAAQMotAgAALQoXFAAiFEoTLQsTEB4CABMAHgIAFAAeAgAVAB4CABYAMyoAFQAWABckAgAXAAAQCyUAAD8CHgIAFQEKIhVDFhYKFhccChcYAAQqGBUXCiIWRhUkAgAVAAAQOScCGAQAPAYYAS8KAAQAFQoqFxUWJAIAFgAAEFElAAA/FC0IARUnAhYEAwAIARYBJwMVBAEAIhUCFi0KFhctDgMXACIXAhctDhAXJwIXBBgtCAAYLQoVGS0ITBotCEYbAAgAFwAlAAA/Ji0CAAAtChkWCiIWSBUKIhVGFyQCABcAABC4JQAAQLgvCgAWABUcChUXBhwKFxYAHAoWFQYMKhEVFiQCABYAABDfJQAAQR8tCAEVJwIWBAMACAEWAScDFQQBACIVAhYtChYXLQ4DFwAiFwIXLQ4QFycCFgQXLQgAFy0KFRgtCEwZLQhGGgAIABYAJQAAPyYtAgAALQoYEAoiEEgVCiIVRhYkAgAWAAARRiUAAEC4MAgASAAQLwoACQAQHAoQFgUcChYVABwKFRAFAioQEhUOKhIQFiQCABYAABF4JQAAQTEcChUQADAKABAACS0LAhAAIhACEC0OEAIAIgICFi0LFhYtChYVJwIXBAMAKgIXEDsOABUAECMAABGyKQIAEADAv84sCioBEBMkAgATAAARzSMAABQCLQgBECcCEwQCAAgBEwEnAxAEAQAiEAITHzAASgBKABMtCAETAAABAgEtDhATLQgBEAAAAQIBLQxHECcCFQQWLQgAFi0KExctChAYAAgAFQAlAABAyi0CAAAtChcUACIUShMtCxMQHgIAEwAeAgAUAB4CABUAHgIAFgAzKgAVABYAFyQCABcAABJcJQAAPwIeAgAVAQoiFUMWFgoWFxwKFxgABCoYFRcKIhZGFSQCABUAABKKJwIYBAA8BhgBCioXFBUkAgAVAAASnCUAAEFDLQgBFCcCFQQDAAgBFQEnAxQEAQAiFAIVLQoVFi0OAxYAIhYCFi0OEBYnAhYEFy0IABctChQYLQhMGS0IRhoACAAWACUAAD8mLQIAAC0KGBUKIhVIFAoiFEYWJAIAFgAAEwMlAABAuC8KABUAFBwKFBYGHAoWFQAcChUUBgoqFBEVJAIAFQAAEyojAAATZi8KAAkAExwKExUFHAoVFAAcChQTBQAqExIUDioTFBUkAgAVAAATViUAADrtHAoUEwAwCgATAAkjAAATZi0IARMnAhQEAwAIARQBJwMTBAEAIhMCFC0KFBUtDgMVACIVAhUtDhAVJwIUBBUtCAAVLQoTFi0ITBctCEYYAAgAFAAlAAA/Ji0CAAAtChYQCiIQSBMKIhNGFCQCABQAABPNJQAAQLgwCABLABAtCwIQACIQAhAtDhACACICAhQtCxQULQoUEycCFQQDACoCFRA7DgATABAjAAAUAikCABAAV+M9BAoqARATJAIAEwAAFB0jAAAX0y0IARAnAhMEAwAIARMBJwMQBAEAIhACEx8wAEwASgATLQgBEwAAAQIBLQ4QEy0IARAAAAECAS0MRxAnAhUEFi0IABYtChMXLQoQGAAIABUAJQAAPpEtAgAALQoXFAAiFEoWLQsWFRwKFRYGHAoWFAAcChQVBicCFwQYLQgAGC0KExktChAaAAgAFwAlAAA+kS0CAAAtChkWACIWShMtCxMQHgIAEwAeAgAWAB4CABcAHgIAGAAzKgAXABgAGSQCABkAABTnJQAAPwIvCgALABccChcZAhwKGRgAHAoYFwInAhgCAwoqFxgZJAIAGQAAFRMlAABBVS8KAA8AFxwKFxkGHAoZGAAcChgXBgwqFRcYCiIYRhUkAgAVAAAVPyUAAEFnJwIVABItCAEXJwIYBAMACAEYAScDFwQBACIXAhgtChgZLQ4VGQAiGQIZLQ4QGScCGQQaLQgAGi0KFxstCEwcLQhGHQAIABkAJQAAPyYtAgAALQobGAoiGEgXCiIXRhkkAgAZAAAVqyUAAEC4LwoAGAAXHAoXGQEcChkYABwKGBcBCiIXRhgkAgAYAAAV0iUAAEF5LQgBFycCGAQDAAgBGAEnAxcEAQAiFwIYLQoYGS0OFRkAIhkCGS0OEBknAhUEGC0IABgtChcZLQhMGi0IRhsACAAVACUAAD8mLQIAAC0KGRAKIhBIFQoiFUYXJAIAFwAAFjklAABAuDAIAEsAEB4CABABCiIQQxUWChUXHAoXGAAEKhgQFwoiFUYQJAIAEAAAFm0nAhgEADwGGAEtCAEQJwIVBAMACAEVAScDEAQBACIQAhUtChUYLQ4DGAAiGAIYLQ4XGCcCGAQZLQgAGS0KEBotCEwbLQhGHAAIABgAJQAAPyYtAgAALQoaFQoiFUgQCiIQRhgkAgAYAAAW1CUAAEC4LwoAFQAQHAoQGAYcChgVABwKFRAGCioQERUkAgAVAAAW+yMAABc3LwoACQAQHAoQFQUcChUTABwKExAFACoQEhMOKhATFSQCABUAABcnJQAAOu0cChMQADAKABAACSMAABc3LQgBECcCEwQDAAgBEwEnAxAEAQAiEAITLQoTFS0OAxUAIhUCFS0OFxUnAhUEFi0IABYtChAXLQhMGC0IRhkACAAVACUAAD8mLQIAAC0KFxMKIhNIEAoiEEYVJAIAFQAAF54lAABAuDAKABQAEy0LAhAAIhACEC0OEAIAIgICFC0LFBQtChQTJwIVBAMAKgIVEDsOABMAECMAABfTKQIAEAB0efZbCioBEBMnAhAACicCFAAMJAIAEwAAF/gjAAAb1y0IARMnAhUEBgAIARUBJwMTBAEAIhMCFR8wAE4ASgAVLQgBFQAAAQIBLQ4TFS0IARMAAAECAS0MRxMnAhcEGC0IABgtChUZLQoTGgAIABcAJQAAQYstAgAALQoZFgAiFkoYLQsYFycCGAQZLQgAGS0KFRotChMbAAgAGAAlAABBiy0CAAAtChoWACIWShktCxkYJwIZBBotCAAaLQoVGy0KExwACAAZACUAAEGLLQIAAC0KGxYAIhZKGi0LGhkcChkaAhwKGhYAJwIaBBstCAAbLQoVHC0KEx0ACAAaACUAAEGLLQIAAC0KHBkAIhlKGy0LGxonAhsEHC0IABwtChUdLQoTHgAIABsAJQAAQYstAgAALQodGQAiGUoVLQsVExwKExkGHAoZFQAeAgATAB4CABkAHgIAGwAeAgAcADMqABsAHAAdJAIAHQAAGUslAAA/Ah4CABsBCiIbQxwWChwdHAodHgAEKh4bHQoiHEYbJAIAGwAAGXknAh4EADwGHgEvCgAKABscChseBRwKHhwAHAocGwUvCgAFAB4cCh4gBBwKIB8AHAofHgQeAgAfBR4CACAFACogHiEOKiAhIiQCACIAABnEJQAAOu0tCAEeJwIgBAMACAEgAScDHgQBACIeAiAtCiAiLQ4QIgAiIgIiLQ4cIicCIgQjLQgAIy0KHiQtCEwlLQhGJgAIACIAJQAAPyYtAgAALQokIAoiIEgeCiIeRiIkAgAiAAAaKyUAAEC4HAofHgAcCiEfAC0IASEnAiIECwAIASIBJwMhBAEAIiECIi0KIiMtDhwjACIjAiMtDh0jACIjAiMtDhcjACIjAiMtDhgjACIjAiMtDhYjACIjAiMtDhojACIjAiMtDhUjACIjAiMtDh4jACIjAiMtDh8jACIjAiMtDEgjJwIVBCItCAAiLQogIy0KISQACAAVACUAAEH8LQIAAAAqGxIVDiobFRYkAgAWAAAa3CUAADrtHAoVEgAwCgASAAotCAESJwIVBAMACAEVAScDEgQBACISAhUtChUWLQ4UFgAiFgIWLQ4cFicCFgQaLQgAGi0KEhstCEwcLQhGHQAIABYAJQAAPyYtAgAALQobFQoiFUgSCiISRhYkAgAWAAAbTiUAAEC4LQgBEicCFgQFAAgBFgEnAxIEAQAiEgIWLQoWFy0MSBcAIhcCFy0MSBcAIhcCFy0MSBcAIhcCFy0MSBcnAhYEGi0IABotChUbLQoSHAAIABYAJQAAQkktAgAALQsCEgAiEgISLQ4SAgAiAgIWLQsWFi0KFhUnAhcEAwAqAhcSOw4AFQASIwAAG9cpAgASAHz5A0oKKgESEycCEgQHJwIVBAgnAhYECSQCABMAABwBIwAAH/UtCAETJwIXBAIACAEXAScDEwQBACITAhcfMABKAEoAFy0IARcAAAECAS0OExctCAETAAABAgEtDEcTJwIZBBotCAAaLQoXGy0KExwACAAZACUAAEDKLQIAAC0KGxgAIhhKFy0LFxMeAgAXAB4CABgAHgIAGQAeAgAaADMqABkAGgAbJAIAGwAAHJAlAAA/Ai0IARknAhoEAwAIARoBJwMZBAEAIhkCGi0KGhstDhAbACIbAhstDhMbJwIbBBwtCAAcLQoZHS0ITB4tCEYfAAgAGwAlAAA/Ji0CAAAtCh0aCiIaSBkKIhlGGyQCABsAABz3JQAAQLgnAhsEHC0IABwtChodAAgAGwAlAABCli0CAAAtCh0ZACIZShstCxsaHAoaHAUcChwbAAAiGUwcLQscGgAiGUUdLQsdHAAiGU0eLQseHQAiGU4fLQsfHhwKHiACHAogHwAAIhlEIC0LIB4AKhkSIS0LISAcCiAiBhwKIiEAACoZFSItCyIgHAogIwQcCiMiAAAqGRYjLQsjIBwKICQEHAokIwAAIhlPJC0LJCAcCiAkARwKJBkAHAoZIAEtCAEZJwIkBAMACAEkAScDGQQBACIZAiQtCiQlLQ4UJQAiJQIlLQ4TJScCJQQmLQgAJi0KGSctCEwoLQhGKQAIACUAJQAAPyYtAgAALQonJAoiJEgZCiIZRiUkAgAlAAAeGCUAAEC4JwIlBCYtCAAmLQokJwAIACUAJQAAQ38tAgAALQonGQAiGUolLQslJBwKJCYGHAomJQAcCiUkBgAiGUwmLQsmJRwKJScGHAonJgAcCiYlBgAiGUUnLQsnJhwKJicGHAonGQAcChkmBi8KAAYAGRwKGSgFHAooJwAKIiBGGSQCABkAAB6hJQAARDIcCicZBgwqJhkgCiIgRhkkAgAZAAAevSUAAEREDColJBkkAgAZAAAezyUAAERWLQgBGScCIAQDAAgBIAEnAxkEAQAiGQIgLQogJC0OECQAIiQCJC0OEyQnAiAEJC0IACQtChklLQhMJi0IRicACAAgACUAAD8mLQIAAC0KJRMKIhNIGQoiGUYgJAIAIAAAHzYlAABAuC0IARknAiAECwAIASABJwMZBAEAIhkCIC0KICQtDhskACIkAiQtDhokACIkAiQtDhwkACIkAiQtDh0kACIkAiQtDh8kACIkAiQtDh4kACIkAiQtDiEkACIkAiQtDiIkACIkAiQtDiMkACIkAiQtDEskJwIaBBstCAAbLQoTHC0KGR0ACAAaACUAAEH8LQIAAC0LAhMAIhMCEy0OEwIAIgICGi0LGhotChoZJwIbBAMAKgIbEzsOABkAEyMAAB/1KQIAEwCnD8A8CioBExckAgAXAAAgECMAACEaLQgBEycCFwQCAAgBFwEnAxMEAQAiEwIXHzAASgBKABctCAEXAAABAgEtDhMXLQgBEwAAAQIBLQxHEycCGQQaLQgAGi0KFxstChMcAAgAGQAlAABAyi0CAAAtChsYACIYShctCxcTHgIAFwAeAgAYAB4CABkAHgIAGgAzKgAZABoAGyQCABsAACCfJQAAPwIeAgAZAQoiGUMaFgoaGxwKGxwABCocGRsKIhpGGSQCABkAACDNJwIcBAA8BhwBLwoABAAZCiobGRokAgAaAAAg5SUAAD8UMAoAEwAHLQsCEwAiEwITLQ4TAgAiAgIaLQsaGi0KGhknAhsEAwAqAhsTOw4AGQATIwAAIRopAgATAA8DlC0KKgETFyQCABcAACE1IwAAIk0tCAETJwIXBAIACAEXAScDEwQBACITAhcfMABKAEoAFy0IARcAAAECAS0OExctCAETAAABAgEtDEcTJwIZBBotCAAaLQoXGy0KExwACAAZACUAAEDKLQIAAC0KGxgAIhhKFy0LFxMKIhNIFxYKFxMeAgAXAB4CABgAHgIAGQAeAgAaADMqABkAGgAbJAIAGwAAIc0lAAA/Ah4CABkBCiIZQxoWChobHAobHAAEKhwZGwoiGkYZJAIAGQAAIfsnAhwEADwGHAEvCgAEABkKKhsZGiQCABoAACITJQAAPxQcChMZADAKABkACC0LAhMAIhMCEy0OEwIAIgICGi0LGhotChoZJwIbBAMAKgIbEzsOABkAEyMAACJNKQIAEwDM2EqjCioBExckAgAXAAAiaCMAACdSLQgBEycCFwQEAAgBFwEnAxMEAQAiEwIXHzAARQBKABctCAEXAAABAgEtDhMXLQgBEwAAAQIBLQxHEycCGQQaLQgAGi0KFxstChMcAAgAGQAlAABEaC0CAAAtChsYACIYShotCxoZJwIaBBstCAAbLQoXHC0KEx0ACAAaACUAAERoLQIAAC0KHBgAIhhKGy0LGxoKIhpIGCcCGwQcLQgAHC0KFx0tChMeAAgAGwAlAABEaC0CAAAtCh0aACIaShctCxcTHgIAFwAeAgAaAB4CABsAHgIAHAAzKgAbABwAHSQCAB0AACNUJQAAPwIeAgAbAQoiG0McFgocHRwKHR4ABCoeGx0KIhxGGyQCABsAACOCJwIeBAA8Bh4BCiodGhskAgAbAAAjlCUAAETZLQgBGicCGwQDAAgBGwEnAxoEAQAiGgIbLQobHC0OEBwAIhwCHC0OGRwnAhwEHS0IAB0tChoeLQhMHy0IRiAACAAcACUAAD8mLQIAAC0KHhsKIhtIGgoiGkYcJAIAHAAAI/slAABAuCcCHAQdLQgAHS0KGx4ACAAcACUAAEKWLQIAAC0KHhoAKhoWHC0LHBscChscBBwKHBoAHAoaGwQeAgAaBQwqGxocCiIcRhokAgAaAAAkTiUAAETrLQgBGicCGwQDAAgBGwEnAxoEAQAiGgIbLQobHC0OAxwAIhwCHC0OExwnAhsEHC0IABwtChodLQhMHi0IRh8ACAAbACUAAD8mLQIAAC0KHRMKIhNIGgoiGkYbJAIAGwAAJLUlAABAuC8KABMAGhwKGhsGHAobEwAcChMaBgwqERoTJAIAEwAAJNwlAABBHy0IAREnAhMEAwAIARMBJwMRBAEAIhECEy0KExstDhQbACIbAhstDhkbJwIbBBwtCAAcLQoRHS0ITB4tCEYfAAgAGwAlAAA/Ji0CAAAtCh0TCiITSBEKIhFGGyQCABsAACVDJQAAQLgnAhsEHC0IABwtChMdAAgAGwAlAABDfy0CAAAtCh0RACIRShstCxsTHAoTHAYcChwbABwKGxMGACIRTBwtCxwbHAobHQYcCh0cABwKHBsGACIRRR0tCx0cHAocHgYcCh4dABwKHRwGACIRTR4tCx4dHAodHgUcCh4RAC0IAR0AAAECAS0OEx0tCAEeAAABAgEtDhseJAIAGAAAJggjAAAl5AAqExoXDioTFxgkAgAYAAAl+yUAADrtLQ4XHS0OGx4jAAAmLAAqGxoXDiobFxgkAgAYAAAmHyUAADrtLQ4THS0OFx4jAAAmLC0LHRMtCx4XACocGhgOKhwYGyQCABsAACZLJQAAOu0tDhMdLQ4XHi0IARonAhsEAwAIARsBJwMaBAEAIhoCGy0KGxwtDhQcACIcAhwtDhkcJwIbBBwtCAAcLQoaHS0ITB4tCEYfAAgAGwAlAAA/Ji0CAAAtCh0ZCiIZSBoKIhpGGyQCABsAACa6JQAAQLgcChMaABwKFxMAHAoYFwAtCAEYJwIbBAUACAEbAScDGAQBACIYAhstChscLQ4aHAAiHAIcLQ4THAAiHAIcLQ4XHAAiHAIcLQ4RHCcCEQQaLQgAGi0KGRstChgcAAgAEQAlAABCSS0CAAAtCwIRACIRAhEtDhECACICAhctCxcXLQoXEycCGAQDACoCGBE7DgATABEjAAAnUikCAAIAIqBdygoqAQIRJAIAEQAAJ20jAAAoex4CAAIAHgIAEQAeAgATAB4CABcAMyoAEwAXABgkAgAYAAAnliUAAD8CHgIAEwkkAgATAAAnqCUAAET9LQgBEycCFwQDAAgBFwEnAxMEAQAiEwIXLQoXGC0OBxgAIhgCGC0MSxgnAhgEGS0IABktChMaLQhMGy0IRhwACAAYACUAADz/LQIAAC0KGhceAgATADMqABcAEwAYJAIAGAAAKBIlAABFDy8IAEsAEycCGAQBJwIaBAMAKhgaGS0IARcACAEZAScDFwQBACIXAhktDhgZACIZAhktDhgZJwIZBAMAKhcZGC0KGBktDhMZACIXAhktCxkZLQoZGCcCGgQDACoXGhM7DgAYABMjAAAoeykCAAIAagH21QoqAQIRJAIAEQAAKJYjAAArBy0IAQInAhEEAgAIAREBJwMCBAEAIgICER8wAEoASgARLQgBEQAAAQIBLQ4CES0IAQIAAAECAS0MRwInAhcEGC0IABgtChEZLQoCGgAIABcAJQAAQMotAgAALQoZEwAiE0oRLQsRAh4CABEAHgIAEwAeAgAXAB4CABgAMyoAFwAYABkkAgAZAAApJSUAAD8CHgIAFwkkAgAXAAApNyUAAEUhLQgBFycCGAQDAAgBGAEnAxcEAQAiFwIYLQoYGS0OEBkAIhkCGS0OAhknAhAEGC0IABgtChcZLQhMGi0IRhsACAAQACUAAD8mLQIAAC0KGQIKIgJIEAoiEEYXJAIAFwAAKZ4lAABAuCcCFwQYLQgAGC0KAhkACAAXACUAAEKWLQIAAC0KGRAAIhBKFy0LFwIcCgIYBRwKGBcAACIQTBgtCxgCACIQRRktCxkYACIQTRotCxoZACIQThstCxsaHAoaHAIcChwbAAAiEEQcLQscGgAqEBIdLQsdHBwKHB0GHAodEgAAKhAVHS0LHRwcChwdBBwKHRUAACoQFh0tCx0cHAocHQQcCh0WAAAiEE8dLQsdHBwKHB0BHAodEAAnAh0ECicCHwQDACodHx4tCAEcAAgBHgEnAxwEAQAiHAIeLQ4dHgAiHgIeLQ4dHicCHgQDACocHh0tCh0eLQ4XHgAiHgIeLQ4CHgAiHgIeLQ4YHgAiHgIeLQ4ZHgAiHgIeLQ4bHgAiHgIeLQ4aHgAiHgIeLQ4SHgAiHgIeLQ4VHgAiHgIeLQ4WHgAiHgIeLQ4QHgAiHAISLQsSEi0KEhAnAhUEAwAqHBUCOw4AEAACIwAAKwcpAgACAGIRJPEKKgECECQCABAAACsiIwAALRMtCAECJwIQBAIACAEQAScDAgQBACICAhAfMABKAEoAEC0IARAAAAECAS0OAhAtCAECAAABAgEtDEcCJwISBBUtCAAVLQoQFi0KAhcACAASACUAAEDKLQIAAC0KFhEAIhFKEC0LEAIeAgAQAB4CABEAHgIAEgAeAgATADMqABIAEwAVJAIAFQAAK7ElAAA/Ah4CABIJJAIAEgAAK8MlAABFMy0IARInAhMEAwAIARMBJwMSBAEAIhICEy0KExUtDhQVACIVAhUtDgIVJwITBBQtCAAULQoSFS0ITBYtCEYXAAgAEwAlAAA/Ji0CAAAtChUCCiICSBIKIhJGEyQCABMAACwqJQAAQLgnAhMEFC0IABQtCgIVAAgAEwAlAABDfy0CAAAtChUSACISShMtCxMCHAoCFAYcChQTAAAiEkwULQsUAhwKAhUGHAoVFAAAIhJFFS0LFQIcCgIWBhwKFhUAACISTRYtCxYCHAoCFgUcChYSACcCFgQEJwIYBAMAKhYYFy0IAQIACAEXAScDAgQBACICAhctDhYXACIXAhctDhYXJwIXBAMAKgIXFi0KFhctDhMXACIXAhctDhQXACIXAhctDhUXACIXAhctDhIXACICAhQtCxQULQoUEycCFQQDACoCFRI7DgATABIjAAAtEykCAAIApmeECQoqAQIQJAIAEAAALS4jAAAt3B4CAAIAHgIAEAAeAgARAB4CABIAMyoAEQASABMkAgATAAAtVyUAAD8CHgIAEQkkAgARAAAtaSUAAEVFLwoACQARHAoREgUcChIJACcCEgQBJwIUBAMAKhIUEy0IAREACAETAScDEQQBACIRAhMtDhITACITAhMtDhITJwITBAMAKhETEi0KEhMtDgkTACIRAhMtCxMTLQoTEicCFAQDACoRFAk7DgASAAkjAAAt3CkCAAIAAwOKSgoqAQIJJAIACQAALfcjAAAupR4CAAIAHgIACQAeAgAQAB4CABEAMyoAEAARABIkAgASAAAuICUAAD8CHgIAEAkkAgAQAAAuMiUAAEVXLwoACgAQHAoQEQUcChEKACcCEQQBJwITBAMAKhETEi0IARAACAESAScDEAQBACIQAhItDhESACISAhItDhESJwISBAMAKhASES0KERItDgoSACIQAhItCxISLQoSEScCEwQDACoQEwo7DgARAAojAAAupSkCAAIAj6vJlAoqAQIJJAIACQAALsAjAAAwOy0IAQInAgkEAgAIAQkBJwMCBAEAIgICCR8wAEoASgAJLQgBCQAAAQIBLQ4CCS0IAQIAAAECAS0MRwInAhAEES0IABEtCgkSLQoCEwAIABAAJQAAQMotAgAALQoSCgAiCkoJLQsJAh4CAAkAHgIACgAeAgAQAB4CABEAMyoAEAARABIkAgASAAAvTyUAAD8CHgIAEAkkAgAQAAAvYSUAAEVpLQgBECcCEQQDAAgBEQEnAxAEAQAiEAIRLQoREi0OAxIAIhICEi0OAhInAgMEES0IABEtChASLQhMEy0IRhQACAADACUAAD8mLQIAAC0KEgIKIgJIAwoiA0YQJAIAEAAAL8glAABAuC8KAAIAAxwKAxAGHAoQAgAnAhAEAScCEgQDACoQEhEtCAEDAAgBEQEnAwMEAQAiAwIRLQ4QEQAiEQIRLQ4QEScCEQQDACoDERAtChARLQ4CEQAiAwIRLQsRES0KERAnAhIEAwAqAxICOw4AEAACIwAAMDspAgACAHbjJeUKKgECAyQCAAMAADBWIwAAMPoeAgACAB4CAAMAHgIACQAeAgAKADMqAAkACgAQJAIAEAAAMH8lAAA/Ah4CAAkJJAIACQAAMJElAABFey8KAAcACScCCgQBJwIRBAMAKgoREC0IAQcACAEQAScDBwQBACIHAhAtDgoQACIQAhAtDgoQJwIQBAMAKgcQCi0KChAtDgkQACIHAhAtCxAQLQoQCicCEQQDACoHEQk7DgAKAAkjAAAw+ikCAAIANsOR6goqAQIDJAIAAwAAMRUjAAAxwx4CAAIAHgIAAwAeAgAHAB4CAAkAMyoABwAJAAokAgAKAAAxPiUAAD8CHgIABwkkAgAHAAAxUCUAAEWNLwoACAAHHAoHCQEcCgkIACcCCQQBJwIQBAMAKgkQCi0IAQcACAEKAScDBwQBACIHAgotDgkKACIKAgotDgkKJwIKBAMAKgcKCS0KCQotDggKACIHAgotCwoKLQoKCScCEAQDACoHEAg7DgAJAAgjAAAxwykCAAIAKxGxmgoqAQIDJAIAAwAAMd4jAAAygh4CAAIAHgIAAwAeAgAHAB4CAAgAMyoABwAIAAkkAgAJAAAyByUAAD8CHgIABwkkAgAHAAAyGSUAAEWfLwoABAAHJwIIBAEnAgoEAwAqCAoJLQgBBAAIAQkBJwMEBAEAIgQCCS0OCAkAIgkCCS0OCAknAgkEAwAqBAkILQoICS0OBwkAIgQCCS0LCQktCgkIJwIKBAMAKgQKBzsOAAgAByMAADKCKQIAAgCezL7dCioBAgMkAgADAAAynSMAADNLHgIAAgAeAgADAB4CAAQAHgIABwAzKgAEAAcACCQCAAgAADLGJQAAPwIeAgAECSQCAAQAADLYJQAARbEvCgAFAAQcCgQHBBwKBwUAJwIHBAEnAgkEAwAqBwkILQgBBAAIAQgBJwMEBAEAIgQCCC0OBwgAIggCCC0OBwgnAggEAwAqBAgHLQoHCC0OBQgAIgQCCC0LCAgtCggHJwIJBAMAKgQJBTsOAAcABSMAADNLKQIAAgBVDdiGCioBAgMkAgADAAAzZiMAADQUHgIAAgAeAgADAB4CAAQAHgIABQAzKgAEAAUAByQCAAcAADOPJQAAPwIeAgAECSQCAAQAADOhJQAARcMvCgAGAAQcCgQGBRwKBgUAJwIGBAEnAggEAwAqBggHLQgBBAAIAQcBJwMEBAEAIgQCBy0OBgcAIgcCBy0OBgcnAgcEAwAqBAcGLQoGBy0OBQcAIgQCBy0LBwctCgcGJwIIBAMAKgQIBTsOAAYABSMAADQUKQIAAgDiUajzCioBAgMkAgADAAA0LyMAADTdHgIAAgAeAgADAB4CAAQAHgIABQAzKgAEAAUABiQCAAYAADRYJQAAPwIeAgAECSQCAAQAADRqJQAARdUvCgALAAQcCgQGAhwKBgUAJwIGBAEnAggEAwAqBggHLQgBBAAIAQcBJwMEBAEAIgQCBy0OBgcAIgcCBy0OBgcnAgcEAwAqBAcGLQoGBy0OBQcAIgQCBy0LBwctCgcGJwIIBAMAKgQIBTsOAAYABSMAADTdKQIAAgBONCwWCioBAgMkAgADAAA0+CMAADWcHgIAAgAeAgADAB4CAAQAHgIABQAzKgAEAAUABiQCAAYAADUhJQAAPwIeAgAECSQCAAQAADUzJQAARecvCgANAAQnAgYEAScCCAQDACoGCActCAEFAAgBBwEnAwUEAQAiBQIHLQ4GBwAiBwIHLQ4GBycCBwQDACoFBwYtCgYHLQ4EBwAiBQIHLQsHBy0KBwYnAggEAwAqBQgEOw4ABgAEIwAANZwpAgACACK0MAEKKgECAyQCAAMAADW3IwAANlseAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJAIABgAANeAlAAA/Ah4CAAQJJAIABAAANfIlAABF+S8KAAwABCcCBgQBJwIIBAMAKgYIBy0IAQUACAEHAScDBQQBACIFAgctDgYHACIHAgctDgYHJwIHBAMAKgUHBi0KBgctDgQHACIFAgctCwcHLQoHBicCCAQDACoFCAQ7DgAGAAQjAAA2WykCAAIAOUUtgAoqAQIDJAIAAwAANnYjAAA3Mx4CAAIAHgIAAwAeAgAEAB4CAAUAMyoABAAFAAYkAgAGAAA2nyUAAD8CHgIABAkkAgAEAAA2sSUAAEYLLwoADgAELwoADwAFHAoFBwYcCgcGACcCBwQCJwIJBAMAKgcJCC0IAQUACAEIAScDBQQBACIFAggtDgcIACIIAggtDgcIJwIIBAMAKgUIBy0KBwgtDgQIACIIAggtDgYIACIFAgctCwcHLQoHBicCCAQDACoFCAQ7DgAGAAQjAAA3MycCAgJVJwIDAm4nAgQCaycCBQJvJwIGAncnAgcCICcCCAJzJwIJAmUnAgoCbCcCCwJjJwIMAnQnAg0CcicCDgJ7JwIPAn0tCAEQJwIRBBwACAERAScDEAQBACIQAhEtChESLQ4CEgAiEgISLQ4DEgAiEgISLQ4EEgAiEgISLQ4DEgAiEgISLQ4FEgAiEgISLQ4GEgAiEgISLQ4DEgAiEgISLQ4HEgAiEgISLQ4IEgAiEgISLQ4JEgAiEgISLQ4KEgAiEgISLQ4JEgAiEgISLQ4LEgAiEgISLQ4MEgAiEgISLQ4FEgAiEgISLQ4NEgAiEgISLQ4HEgAiEgISLQ4OEgAiEgISLQ4IEgAiEgISLQ4JEgAiEgISLQ4KEgAiEgISLQ4JEgAiEgISLQ4LEgAiEgISLQ4MEgAiEgISLQ4FEgAiEgISLQ4NEgAiEgISLQ4PEgogRkkCJAIAAgAAOPQnAgMEHi0IAQQnAgUEHgAIAQUBLQoEBSoDAAUF6UlD6Js33SwAIgUCBQAiEAIGJwIHBBstAgYDLQIFBC0CBwUlAABGHScCBgQbACoFBgUtDEsFACIFAgUtDgEFACIFAgU8DgMEAioSAyoCIipKKw4oSiosJAIALAAAORAlAABBMS0LGCoMKisSLCQCACwAADkmJQAARk8AIhQCLQAqLSsuLQsuLBwKLCsALQscLAQqKywtACoqLSstDisYBCosKSotDiocACIDSiotCioDIwAACqQAIhACMwAqMwM0LQs0MicCMwQ0LQgANC0KLjUtChg2LQovNy0KMTgtCjI5AAgAMwAlAAA73C0CAAAAIgNKMi0KMgMjAAAIXgAiA0oQACIuAjEAKjEDMi0LMhgtCy8xDCoQMDIkAgAyAAA50iUAAEZPLQIxAycABAQpJQAARmEtCAUyACIyAjMAKjMQNC0OGDQtDjIvLQoQAyMAAAeJACIUAhYAKhYDFy0LFxUcChUXAhwKFxYAHAoWFQItCxMWLQIWAycABAQgJQAARmEtCAUXACIXAhgAKhgDGS0OFRktDhcTACIDShUtChUDIwAAAoEtCxEULQsQFQAqFQMWDioVFhckAgAXAAA6cSUAADrtDCIWUBUkAgAVAAA6gyUAAEZPACIUAhcAKhcWGC0LGBUtCxMULQIUAycABAQgJQAARmEtCAUWACIWAhcAKhcDGC0OFRgtDhYTACIDShQtChQDIwAAAegoAAAEBHhTDAAABAMkAAADAAA67CoBAAEF2sX11rRKMm08BAIBJioBAAEF0Afr9MvGZ5A8BAIBJiUAADrHLQsCAy0LAQQMIgNQBSQCAAUAADseJQAARk8AIgQCBgAqBgMHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIDSgUOKgMFByQCAAcAADtjJQAAOu0tDgQBLQ4FAi0KBgEmJQAAOsctCwQFCiIFRgYkAgAGAAA7jycCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAAEbALQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy0MSQQAIgZKAi0LAgEmJQAAOsctCwQGCiIGRgckAgAHAAA7+ycCCAQAPAYIAS0LAwYKIgZFByQCAAcAADx3IwAAPBEtCwEHLQsCCAwiBkUJJAIACQAAPCslAABGTy0CBwMnAAQEBCUAAEZhLQgFCQAiCQIKACoKBgstDgULACIGSgUOKgYFByQCAAcAADxiJQAAOu0tDgkBLQ4IAi0OBQMtDEYEIwAAPNonAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAABGwC0CAAAtCwEGLQsCBy0LBAgtAgYDJwAEBAQlAABGYS0IBQkAIglKCi0OBQotDgkBLQ4HAi0MSgMtDggEIwAAPNomKgEAAQWKVTosK2fI7zwEAgEmKgEAAQXIDXNzbs204TwEAgEmJQAAOsccCgIFAAQiBVEGLQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCC0MSAgAIggCCC0MSAgAIggCCC0MSAgtCAEHJwIIBAUACAEIAScDBwQBACIHAggtCggJLQxICQAiCQIJLQxICQAiCQIJLQxICQAiCQIJLQ4GCS0IAQYAAAECAS0OBQYtCAEFAAABAgEtDgcFLQgBBwAAAQIBLQxHBy0IAQgAAAECAS0MRggtCEcEIwAAPbgMIgRMCSQCAAkAAD4zIwAAPcokAgADAAA91yMAAD4HJwIBBAktCAAJLQoGCi0KBQstCgcMLQoIDS0ISw4ACAABACUAADvcLQIAACMAAD4HJwICBAktCAAJLQoGCi0KBQstCgcMLQoIDQAIAAIAJQAAO3AtAgAALQoKASYMKgQCCSQCAAkAAD5FIwAAPoMAIgECCgAqCgQLLQsLCScCCgQLLQgACy0KBgwtCgUNLQoHDi0KCA8tCgkQAAgACgAlAAA73C0CAAAjAAA+gwAiBEoJLQoJBCMAAD24JQAAOsctCwIDLQsBBAwiA0wFJAIABQAAPrAlAABGTwAiBAIGACoGAwctCwcFLQgBBicCBwQCAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIgNKBQ4qAwUHJAIABwAAPvUlAAA67S0OBAEtDgUCLQoGASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBWgldM4m60jGPAQCASYlAAA6xxwKAgUABCIFUQYtCAEFJwIHBAQACAEHAScDBQQBACIFAgctCgcILQxICAAiCAIILQxICAAiCAIILQxICC0IAQcnAggEBQAIAQgBJwMHBAEAIgcCCC0KCAktDEgJACIJAgktDEgJACIJAgktDEgJACIJAgktDgYJLQgBBgAAAQIBLQ4FBi0IAQUAAAECAS0OBwUtCAEHAAABAgEtDEcHLQgBCAAAAQIBLQxGCC0IRwQjAAA/3wwiBEwJJAIACQAAQFojAAA/8SQCAAMAAD/+IwAAQC4nAgEECS0IAAktCgYKLQoFCy0KBwwtCggNLQhLDgAIAAEAJQAAO9wtAgAAIwAAQC4nAgIECS0IAAktCgYKLQoFCy0KBwwtCggNAAgAAgAlAAA7cC0CAAAtCgoBJgwqBAIJJAIACQAAQGwjAABAqgAiAQIKACoKBAstCwsJJwIKBAstCAALLQoGDC0KBQ0tCgcOLQoIDy0KCRAACAAKACUAADvcLQIAACMAAECqACIESgktCgkEIwAAP98qAQABBbq7IdeCMxhkPAQCASYlAAA6xy0LAgMtCwEECiIDRwUkAgAFAABA6SUAAEZPACIESgUtCwUDLQgBBScCBgQCAAgBBgEnAwUEAQAiBQIGLQoGBy0OAwctDgQBLQxKAi0KBQEmKgEAAQWhqtrb3hxP+jwEAgEmKgEAAQUbvGXQP9zq3DwEAgEmKgEAAQW8bRI+X8A6sjwEAgEmKgEAAQWM6u2QD30mWTwEAgEmKgEAAQWYFdH/F4vr/DwEAgEmKgEAAQVkNSdewwhCkDwEAgEmJQAAOsctCwIDLQsBBAwiA04FJAIABQAAQaolAABGTwAiBAIGACoGAwctCwcFLQgBBicCBwQCAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIgNKBQ4qAwUHJAIABwAAQe8lAAA67S0OBAEtDgUCLQoGASYlAAA6xy0IRwMjAABCCgwiA08EJAIABAAAQh0jAABCHCYcCgMEAAAqAQQFACICAgYAKgYDBy0LBwQwCgAEAAUAIgNKBC0KBAMjAABCCiUAADrHLQhHAyMAAEJXDCIDTQQkAgAEAABCaiMAAEJpJhwKAwQAACoBBAUAIgICBgAqBgMHLQsHBDAKAAQABQAiA0oELQoEAyMAAEJXJQAAOsctCAEDJwIEBAsACAEEAScDAwQBACIDAgQtCgQFLQxIBQAiBQIFLQxIBQAiBQIFLQxIBQAiBQIFLQxIBQAiBQIFLQxIBQAiBQIFLQxIBQAiBQIFLQxIBQAiBQIFLQxIBQAiBQIFLQxIBQAiBQIFLQxIBS0IAQQAAAECAS0OAwQtCEcCIwAAQyIMIgJPAyQCAAMAAEM5IwAAQzQtCwQBJhwKAgMAACoBAwUvCgAFAAMtCwQFLQIFAycABAQLJQAARmEtCAUGACIGAgcAKgcCCC0OAwgtDgYEACICSgMtCgMCIwAAQyIlAAA6xy0IAQMnAgQEBQAIAQQBJwMDBAEAIgMCBC0KBAUtDEgFACIFAgUtDEgFACIFAgUtDEgFACIFAgUtDEgFLQgBBAAAAQIBLQ4DBC0IRwIjAABD1QwiAk0DJAIAAwAAQ+wjAABD5y0LBAEmHAoCAwAAKgEDBS8KAAUAAy0LBAUtAgUDJwAEBAUlAABGYS0IBQYAIgYCBwAqBwIILQ4DCC0OBgQAIgJKAy0KAwIjAABD1SoBAAEFDH7hvlU25sc8BAIBJioBAAEFOwf6O0xhY108BAIBJioBAAEF7O57l8RVzSA8BAIBJiUAADrHLQsCAy0LAQQMIgNFBSQCAAUAAESHJQAARk8AIgQCBgAqBgMHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIDSgUOKgMFByQCAAcAAETMJQAAOu0tDgQBLQ4FAi0KBgEmKgEAAQVS0aKbaO5syjwEAgEmKgEAAQV75Zi9LDVI/jwEAgEmKgEAAQV000T6SW/jITwEAgEmKgEAAQVyMQyWM6ynPzwEAgEmKgEAAQXHzq1Cudwk2zwEAgEmKgEAAQV8hEekowbBWjwEAgEmKgEAAQVszk15s5hgozwEAgEmKgEAAQU2M+VutwIiTDwEAgEmKgEAAQXBGWA1JSiGaDwEAgEmKgEAAQXNZ3az5SKPWTwEAgEmKgEAAQXGML0RreOB9jwEAgEmKgEAAQWBsE6qnPACFTwEAgEmKgEAAQUaTIFyoGCjFDwEAgEmKgEAAQW7MpKnqNiMrzwEAgEmKgEAAQVIjDlSGsJ2pjwEAgEmKgEAAQW9zCMB9DLedDwEAgEmKgEAAQVKeOIDRmzZpDwEAgEmKgEAAQXnFlRB7mOVHTwEAgEmAAADBQctAAMILQAECQoACAcKJAAACgAARk4tAQgGLQQGCQAACAIIAAAJAgkjAABGKiYqAQABBeQIUEUCtYwfPAQCASYtAQMGCgAGAgckAAAHAABGdyMAAEaALQADBSMAAEa/LQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAARrotAQoILQQICwAACgIKAAALAgsjAABGlicBBQQBJiUAADrHLQhHBSMAAEbODCIFRQYkAgAGAABHNiMAAEbgLQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAABHTCMAAEeuLQsCBwAiBwIJACoJBQotCwoILQsBCQAiCQILACoLBQwtCwwKACoICgstCwQILQIHAycABAQFJQAARmEtCAUKACIKAgwAKgwFDS0OCw0tDgkBLQ4KAi0OBgMtDggEIwAAR64AIgVKBi0KBgUjAABGzg==",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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i26LbpklM1cns+ThIE7iIm7iIRrRiUGk26Hboduh26Hboduh26Hboduh26Gb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm6Xbpdul26Xbpdul26Xbpdul2633bIptHAQJ3ERN/EQjejEINJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RjVkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJRdZEom3EVkCHMRJXMRNPEQjOpFuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb0y2z5PtrbzMbWQsH8XPLP96VvayFm3iIRnRiEG9jZsnDQaTbpdul26Xbpdul26XbLbeVza2FgziJi7iJh2hEJwaRboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLul26Xbpdul26Xbpdul26XbpdujFLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsG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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "PrivateCloak",
  "noir_version": "1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "PrivateCloak"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_duration",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "quorum_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sponsored_fpc_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sponsored_voting_enabled",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "member_voting_power",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "member_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "vote_tallies",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "membership_mode",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_gate_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "erc20_token_address_hash",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "erc20_min_balance",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "used_token_nullifiers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_voting_power",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::add_member_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::add_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_vote_choice",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "_voter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::add_to_tally_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::add_to_tally_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::add_token_member_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::add_token_member_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_vote_choice",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::cast_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::cast_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "_admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_voting_duration",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_quorum_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_membership_mode",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_token_gate_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_token_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_erc20_token_address_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_erc20_min_balance",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_title",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "compressed_string::field_compressed_string::FieldCompressedString"
                    }
                  },
                  {
                    "name": "_description",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "compressed_string::field_compressed_string::FieldCompressedString"
                    }
                  },
                  {
                    "name": "_proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_target_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::create_proposal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::create_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::execute_proposal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::execute_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_admin_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_erc20_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "field"
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_erc20_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_member_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_member_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_membership_mode_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_membership_mode_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::get_proposal_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "creator",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "title",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "compressed_string::field_compressed_string::FieldCompressedString"
                    }
                  },
                  {
                    "name": "description",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "compressed_string::field_compressed_string::FieldCompressedString"
                    }
                  },
                  {
                    "name": "proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "target_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "start_block",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_block",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "executed",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::proposal::Proposal"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_proposal_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_proposal_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_quorum_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_quorum_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_sponsored_fpc_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_sponsored_fpc_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::get_tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "yes_votes",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "no_votes",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "total_votes",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "voter_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::proposal::VoteTally"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_token_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_token_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_token_gate_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_token_gate_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::get_vote_tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "yes_votes",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "no_votes",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "total_votes",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "voter_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::proposal::VoteTally"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_vote_tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::get_voting_duration_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_voting_duration_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::get_voting_power_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::get_voting_power_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::is_sponsored_voting_enabled_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::is_sponsored_voting_enabled_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_membership_mode",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_token_addr",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::join_with_aztec_token_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::join_with_aztec_token_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_verified_balance",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_proof_nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::join_with_erc20_proof_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::join_with_erc20_proof_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::remove_member_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::remove_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_fpc_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::set_sponsored_fpc_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::set_sponsored_fpc_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_enabled",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "PrivateCloak::set_sponsored_voting_enabled_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::set_sponsored_voting_enabled_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "PrivateCloak::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "PrivateCloak::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
