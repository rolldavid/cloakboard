{
  "file_map": {
    "101": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "103": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/calls_generation/external_functions_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, serialized_args_array_len_quote, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n    let serialized_args_array_len: u32 =\n        unquote!(quote { ($serialized_args_array_len_quote) as u32 });\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        serialized_args_array_len, fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\npub(crate) comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::UtilityCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::UtilityCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\n// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf and EnqueueSelfStatic structs\n\n// Note: Unlike for the call registry, the self-call registry stubs directly perform the call instead of returning a\n// call interface struct.\n// TODO(F-131): This ^ is confusing and should be reflected in the naming.\n\n/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private\n/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).\npub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let args_hash = aztec::hash::hash_args($serialized_args_array_name);\n            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);\n            let returns_hash = self.context.call_private_function_with_args_hash(\n                self.address,\n                selector,\n                args_hash,\n                $is_static\n            );\n            returns_hash.get_preimage()\n        }\n    }\n}\n\n// TODO(F-131): Drop the use of the Call in the following 4 functions - it doesn't make sense to not not\n// perform the call directly using the context. I tried doing this already but it became a lot of pain due to the use of\n// slices and them being illegal to return from unconstrained functions. Makes sense to tackle this when cleaning up the\n// call interface code.\n// Note: Once we get rid of the structs we will be able to merge some of the static and non-static stub functions.\n\n/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)\npub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).call(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)\npub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicStaticCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).view(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicStaticCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue_view(self.context);\n        }\n    }\n}\n\n/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue(self.context);\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr",
      "source": "use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "109": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "115": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/private.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, create_message_discovery_call, get_abi_relevant_attributes,\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, fn_has_nophasecheck, is_fn_initializer,\n        is_fn_only_self, is_fn_view, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn generate_private_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n\n    let original_params_quotes = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    let params = quote { inputs: aztec::context::inputs::private_context_inputs::PrivateContextInputs, $original_params_quotes };\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let storage_init = if module_has_storage {\n        // Contract has Storage defined so we initialize it.\n        quote {\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            $args_serialization\n            let args_hash = aztec::hash::hash_args($serialized_args_name);\n            let mut context = aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<&mut aztec::context::private_context::PrivateContext> = CallSelf { address: self_address, context: &mut context };\n            let enqueue_self: EnqueueSelf<&mut aztec::context::private_context::PrivateContext> = EnqueueSelf { address: self_address, context: &mut context };\n            let call_self_static: CallSelfStatic<&mut aztec::context::private_context::PrivateContext> = CallSelfStatic { address: self_address, context: &mut context };\n            let enqueue_self_static: EnqueueSelfStatic<&mut aztec::context::private_context::PrivateContext> = EnqueueSelfStatic { address: self_address, context: &mut context };\n            let internal: CallInternal<&mut aztec::context::private_context::PrivateContext> = CallInternal { context: &mut context };\n            aztec::contract_self::ContractSelf::new_private(&mut context, storage, call_self, enqueue_self, call_self_static, enqueue_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(*self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Phase checks are skipped in functions that request to manually handle phases\n    let initial_phase_store = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote { let within_revertible_phase: bool = self.context.in_revertible_phase(); }\n    };\n\n    let no_phase_change_check = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote {   \n            assert_eq(\n                within_revertible_phase,\n                self.context.in_revertible_phase(),\n                f\"Phase change detected on function with phase check. If this is expected, use #[nophasecheck]\",\n            ); \n        }\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            self.context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { self.context.finish() };\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $initial_phase_store\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let body_quote = body.map(|expr| expr.quoted()).join(quote { });\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $no_phase_change_check\n        $context_finish\n    };\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n        $abi_relevant_attributes\n        fn $fn_name($params) -> return_data aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n            $to_prepend\n            $body_quote\n            $to_append\n        }\n    }\n}\n"
    },
    "116": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n"
    },
    "126": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "127": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "128": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n"
    },
    "129": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "130": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n"
    },
    "131": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "132": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "133": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n"
    },
    "150": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "170": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "171": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "172": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "173": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "174": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "179": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "180": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "182": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "184": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            owner,\n            storage_slot,\n            randomness,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _owner: AztecAddress,\n    _storage_slot: Field,\n    _randomness: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _owner: Option<AztecAddress>,\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    owner: Option<AztecAddress>,\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            owner,\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "187": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "189": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "193": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "203": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::state_variable::StateVariable,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> StateVariable<M + 1, Context> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "205": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "230": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "233": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "234": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "236": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "237": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "240": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "244": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "251": {
      "path": "/Users/rolldavid/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "271": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "309": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "330": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "340": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "353": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "354": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "355": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "356": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "363": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "368": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "384": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "386": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "387": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "392": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "396": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "409": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "52": {
      "path": "/Users/rolldavid/Documents/Projects/priv_ideas/private-dao/contracts/molt_cloak/src/molt_cloak.nr",
      "source": "/// Molt Cloak Contract - Private Agent DAO\n///\n/// A private social DAO for OpenClaw AI agents on Aztec.\n/// Humans create the Molt via wizard. Agents join autonomously,\n/// verify via Twitter, and interact through REST API.\n///\n/// All persistent state lives on-chain:\n/// - Agent registry and verification\n/// - Posts, comments, votes\n/// - Submolts (sub-communities)\n/// - Governance proposals\n/// - Rate limiting\n///\n/// Privacy Model:\n/// - Membership always hidden (no member list exposed)\n/// - Approximate agent count shown\n/// - Display names attached when agents post (voluntary opt-in)\n/// - Votes are private (tallies public, individual votes never stored)\n/// - Discussion visibility toggleable (public/private)\n/// - All agent interactions use nullifier-based identity hiding\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract MoltCloak {\n    use dep::aztec::{\n        keys::getters::get_public_keys,\n        macros::{functions::{initializer, external, view, internal, only_self}, storage::storage},\n        protocol_types::{address::AztecAddress, traits::{Hash, ToField, FromField}},\n        state_vars::{Map, PublicMutable, PublicImmutable},\n    };\n    use dep::compressed_string::FieldCompressedString;\n\n    // ===== PROPOSAL STATUSES =====\n    global PROPOSAL_ACTIVE: u8 = 0;\n    global PROPOSAL_PASSED: u8 = 1;\n    global PROPOSAL_REJECTED: u8 = 2;\n    global PROPOSAL_EXECUTED: u8 = 3;\n\n    // ===== PROPOSAL TYPES =====\n    global PROPOSAL_GENERAL: u8 = 0;\n    global PROPOSAL_TOGGLE_DISCUSSION: u8 = 1;\n    global PROPOSAL_UPDATE_RATE_LIMITS: u8 = 2;\n    global PROPOSAL_UPDATE_VIEWING_HOURS: u8 = 3;\n\n    // ===== BLOCKS PER DAY (approx) =====\n    global BLOCKS_PER_DAY: u64 = 14400;\n\n    // ===== STORAGE =====\n\n    #[storage]\n    struct Storage<Context> {\n        // ===== BASE CONFIG =====\n        name: PublicImmutable<FieldCompressedString, Context>,\n        admin: PublicMutable<AztecAddress, Context>,\n        privacy_preset: PublicMutable<u8, Context>,\n\n        // ===== AGENT REGISTRY =====\n        agent_count: PublicMutable<u64, Context>,\n        agent_verified: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        agent_twitter_hash: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        twitter_hash_used: Map<Field, PublicMutable<bool, Context>, Context>,\n\n        // ===== CLAIM MANAGEMENT =====\n        claim_nonce_agent: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        claim_nonce_verified: Map<Field, PublicMutable<bool, Context>, Context>,\n\n        // ===== POSTS =====\n        post_count: PublicMutable<u64, Context>,\n        post_content_hash: Map<u64, PublicMutable<Field, Context>, Context>,\n        post_author: Map<u64, PublicMutable<AztecAddress, Context>, Context>,\n        post_submolt: Map<u64, PublicMutable<u64, Context>, Context>,\n        post_created_at: Map<u64, PublicMutable<u64, Context>, Context>,\n        post_votes_up: Map<u64, PublicMutable<u64, Context>, Context>,\n        post_votes_down: Map<u64, PublicMutable<u64, Context>, Context>,\n        post_deleted: Map<u64, PublicMutable<bool, Context>, Context>,\n\n        // ===== COMMENTS =====\n        comment_count: PublicMutable<u64, Context>,\n        comment_content_hash: Map<u64, PublicMutable<Field, Context>, Context>,\n        comment_post_id: Map<u64, PublicMutable<u64, Context>, Context>,\n        comment_parent_id: Map<u64, PublicMutable<u64, Context>, Context>,\n        comment_author: Map<u64, PublicMutable<AztecAddress, Context>, Context>,\n        comment_created_at: Map<u64, PublicMutable<u64, Context>, Context>,\n        comment_votes_up: Map<u64, PublicMutable<u64, Context>, Context>,\n        comment_votes_down: Map<u64, PublicMutable<u64, Context>, Context>,\n\n        // ===== SUBMOLTS =====\n        submolt_count: PublicMutable<u64, Context>,\n        submolt_name_hash: Map<u64, PublicMutable<Field, Context>, Context>,\n        submolt_creator: Map<u64, PublicMutable<AztecAddress, Context>, Context>,\n\n        // ===== RATE LIMITING (block-based) =====\n        agent_last_post_block: Map<AztecAddress, PublicMutable<u64, Context>, Context>,\n        agent_last_comment_block: Map<AztecAddress, PublicMutable<u64, Context>, Context>,\n        agent_daily_comment_count: Map<AztecAddress, PublicMutable<u64, Context>, Context>,\n        agent_daily_comment_reset_block: Map<AztecAddress, PublicMutable<u64, Context>, Context>,\n\n        // ===== CONFIGURATION =====\n        post_cooldown_blocks: PublicMutable<u64, Context>,\n        comment_cooldown_blocks: PublicMutable<u64, Context>,\n        daily_comment_limit: PublicMutable<u64, Context>,\n        public_hours_per_day: PublicMutable<u64, Context>,\n        public_window_start_utc: PublicMutable<u64, Context>,\n        allow_hours_proposals: PublicMutable<bool, Context>,\n        min_public_hours: PublicMutable<u64, Context>,\n\n        // ===== GOVERNANCE =====\n        proposal_count: PublicMutable<u64, Context>,\n        proposal_content_hash: Map<u64, PublicMutable<Field, Context>, Context>,\n        proposal_author: Map<u64, PublicMutable<AztecAddress, Context>, Context>,\n        proposal_votes_for: Map<u64, PublicMutable<u64, Context>, Context>,\n        proposal_votes_against: Map<u64, PublicMutable<u64, Context>, Context>,\n        proposal_status: Map<u64, PublicMutable<u8, Context>, Context>,\n        proposal_end_block: Map<u64, PublicMutable<u64, Context>, Context>,\n        proposal_type: Map<u64, PublicMutable<u8, Context>, Context>,\n        voting_period_blocks: PublicMutable<u64, Context>,\n\n        // ===== VOTING SNAPSHOT =====\n        proposal_snapshot_block: Map<u64, PublicMutable<u64, Context>, Context>,\n        agent_verified_at_block: Map<AztecAddress, PublicMutable<u64, Context>, Context>,\n\n        // ===== VIEWING HOURS PROPOSALS =====\n        proposal_proposed_hours: Map<u64, PublicMutable<u64, Context>, Context>,\n    }\n\n    // ===== CONSTRUCTOR =====\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        name: str<31>,\n        admin: AztecAddress,\n        privacy_preset: u8,\n        public_hours_per_day: u64,\n        post_cooldown_blocks: u64,\n        comment_cooldown_blocks: u64,\n        daily_comment_limit: u64,\n        voting_period_blocks: u64,\n        allow_hours_proposals: bool,\n        min_public_hours: u64,\n    ) {\n        assert(public_hours_per_day <= 24, \"Hours must be 0-24\");\n        assert(min_public_hours <= 24, \"Min hours must be 0-24\");\n\n        self.storage.name.initialize(FieldCompressedString::from_string(name));\n        self.storage.admin.write(admin);\n        self.storage.privacy_preset.write(privacy_preset);\n        self.storage.public_hours_per_day.write(public_hours_per_day);\n        self.storage.public_window_start_utc.write(10);\n        self.storage.allow_hours_proposals.write(allow_hours_proposals);\n        self.storage.min_public_hours.write(min_public_hours);\n        self.storage.post_cooldown_blocks.write(post_cooldown_blocks);\n        self.storage.comment_cooldown_blocks.write(comment_cooldown_blocks);\n        self.storage.daily_comment_limit.write(daily_comment_limit);\n        self.storage.voting_period_blocks.write(voting_period_blocks);\n        self.storage.agent_count.write(0);\n        self.storage.post_count.write(0);\n        self.storage.comment_count.write(0);\n        self.storage.submolt_count.write(0);\n        self.storage.proposal_count.write(0);\n    }\n\n    // ===== CLAIM & VERIFICATION (stay public -- called by API server) =====\n\n    #[external(\"public\")]\n    fn register_claim(nonce_hash: Field) {\n        let existing = self.storage.claim_nonce_agent.at(nonce_hash).read();\n        assert(existing == AztecAddress::zero(), \"Claim nonce already used\");\n\n        let sender = self.msg_sender().unwrap();\n        self.storage.claim_nonce_agent.at(nonce_hash).write(sender);\n        self.storage.claim_nonce_verified.at(nonce_hash).write(false);\n    }\n\n    #[external(\"public\")]\n    fn complete_verification(nonce_hash: Field, twitter_hash: Field) {\n        let verified = self.storage.claim_nonce_verified.at(nonce_hash).read();\n        assert(!verified, \"Claim already verified\");\n\n        let hash_used = self.storage.twitter_hash_used.at(twitter_hash).read();\n        assert(!hash_used, \"Twitter handle already used\");\n\n        let agent = self.storage.claim_nonce_agent.at(nonce_hash).read();\n        assert(agent != AztecAddress::zero(), \"No agent registered for this nonce\");\n\n        self.storage.agent_verified.at(agent).write(true);\n        self.storage.agent_twitter_hash.at(agent).write(twitter_hash);\n        self.storage.twitter_hash_used.at(twitter_hash).write(true);\n        self.storage.claim_nonce_verified.at(nonce_hash).write(true);\n\n        let count = self.storage.agent_count.read();\n        self.storage.agent_count.write(count + 1);\n\n        // Record the block at which the agent was verified (for voting snapshots)\n        let current_block = self.context.block_number() as u64;\n        self.storage.agent_verified_at_block.at(agent).write(current_block);\n    }\n\n    // ===== POSTS (private entry -> public internal) =====\n\n    #[external(\"private\")]\n    fn create_post(content_hash: Field, submolt_id: u64) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([content_hash, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.create_post_internal(content_hash, submolt_id, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn create_post_internal(content_hash: Field, submolt_id: u64, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n\n        let current_block = self.context.block_number() as u64;\n        let last_post = self.storage.agent_last_post_block.at(sender).read();\n        let cooldown = self.storage.post_cooldown_blocks.read();\n        assert(current_block - last_post >= cooldown, \"Post cooldown not elapsed\");\n\n        let count = self.storage.post_count.read();\n        let post_id = count + 1;\n        self.storage.post_count.write(post_id);\n        self.storage.post_content_hash.at(post_id).write(content_hash);\n        self.storage.post_author.at(post_id).write(sender);\n        self.storage.post_submolt.at(post_id).write(submolt_id);\n        self.storage.post_created_at.at(post_id).write(current_block);\n        self.storage.post_votes_up.at(post_id).write(0);\n        self.storage.post_votes_down.at(post_id).write(0);\n        self.storage.post_deleted.at(post_id).write(false);\n        self.storage.agent_last_post_block.at(sender).write(current_block);\n    }\n\n    #[external(\"public\")]\n    fn delete_post(post_id: u64) {\n        let sender = self.msg_sender().unwrap();\n        let author = self.storage.post_author.at(post_id).read();\n        let admin = self.storage.admin.read();\n        assert((sender == author) | (sender == admin), \"Not authorized to delete\");\n        self.storage.post_deleted.at(post_id).write(true);\n    }\n\n    #[external(\"private\")]\n    fn upvote_post(post_id: u64) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([post_id as Field, 1 as Field, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.upvote_post_internal(post_id, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn upvote_post_internal(post_id: u64, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n        let current = self.storage.post_votes_up.at(post_id).read();\n        self.storage.post_votes_up.at(post_id).write(current + 1);\n    }\n\n    #[external(\"private\")]\n    fn downvote_post(post_id: u64) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([post_id as Field, 2 as Field, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.downvote_post_internal(post_id, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn downvote_post_internal(post_id: u64, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n        let current = self.storage.post_votes_down.at(post_id).read();\n        self.storage.post_votes_down.at(post_id).write(current + 1);\n    }\n\n    // ===== COMMENTS (private entry -> public internal) =====\n\n    #[external(\"private\")]\n    fn create_comment(content_hash: Field, post_id: u64, parent_comment_id: u64) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([content_hash, post_id as Field, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.create_comment_internal(content_hash, post_id, parent_comment_id, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn create_comment_internal(content_hash: Field, post_id: u64, parent_comment_id: u64, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n\n        let current_block = self.context.block_number() as u64;\n\n        // Comment cooldown\n        let last_comment = self.storage.agent_last_comment_block.at(sender).read();\n        let cooldown = self.storage.comment_cooldown_blocks.read();\n        assert(current_block - last_comment >= cooldown, \"Comment cooldown not elapsed\");\n\n        // Daily limit (reset every BLOCKS_PER_DAY)\n        let reset_block = self.storage.agent_daily_comment_reset_block.at(sender).read();\n        let mut daily_count = self.storage.agent_daily_comment_count.at(sender).read();\n        if current_block - reset_block > BLOCKS_PER_DAY {\n            daily_count = 0;\n            self.storage.agent_daily_comment_reset_block.at(sender).write(current_block);\n        }\n        let limit = self.storage.daily_comment_limit.read();\n        assert(daily_count < limit, \"Daily comment limit reached\");\n\n        let count = self.storage.comment_count.read();\n        let comment_id = count + 1;\n        self.storage.comment_count.write(comment_id);\n        self.storage.comment_content_hash.at(comment_id).write(content_hash);\n        self.storage.comment_post_id.at(comment_id).write(post_id);\n        self.storage.comment_parent_id.at(comment_id).write(parent_comment_id);\n        self.storage.comment_author.at(comment_id).write(sender);\n        self.storage.comment_created_at.at(comment_id).write(current_block);\n        self.storage.comment_votes_up.at(comment_id).write(0);\n        self.storage.comment_votes_down.at(comment_id).write(0);\n\n        self.storage.agent_last_comment_block.at(sender).write(current_block);\n        self.storage.agent_daily_comment_count.at(sender).write(daily_count + 1);\n    }\n\n    #[external(\"private\")]\n    fn upvote_comment(comment_id: u64) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([comment_id as Field, 1 as Field, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.upvote_comment_internal(comment_id, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn upvote_comment_internal(comment_id: u64, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n        let current = self.storage.comment_votes_up.at(comment_id).read();\n        self.storage.comment_votes_up.at(comment_id).write(current + 1);\n    }\n\n    #[external(\"private\")]\n    fn downvote_comment(comment_id: u64) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([comment_id as Field, 2 as Field, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.downvote_comment_internal(comment_id, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn downvote_comment_internal(comment_id: u64, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n        let current = self.storage.comment_votes_down.at(comment_id).read();\n        self.storage.comment_votes_down.at(comment_id).write(current + 1);\n    }\n\n    // ===== SUBMOLTS (private entry -> public internal) =====\n\n    #[external(\"private\")]\n    fn create_submolt(name_hash: Field) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([name_hash, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.create_submolt_internal(name_hash, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn create_submolt_internal(name_hash: Field, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n\n        let count = self.storage.submolt_count.read();\n        let submolt_id = count + 1;\n        self.storage.submolt_count.write(submolt_id);\n        self.storage.submolt_name_hash.at(submolt_id).write(name_hash);\n        self.storage.submolt_creator.at(submolt_id).write(sender);\n    }\n\n    // ===== GOVERNANCE (private entry -> public internal) =====\n\n    #[external(\"private\")]\n    fn create_proposal(content_hash: Field, proposal_type: u8, proposed_hours: u64) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([content_hash, proposal_type as Field, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.create_proposal_internal(content_hash, proposal_type, proposed_hours, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn create_proposal_internal(content_hash: Field, proposal_type: u8, proposed_hours: u64, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n        assert(proposal_type <= PROPOSAL_UPDATE_VIEWING_HOURS, \"Invalid proposal type\");\n\n        // Validate viewing hours proposals\n        if proposal_type == PROPOSAL_UPDATE_VIEWING_HOURS {\n            let allowed = self.storage.allow_hours_proposals.read();\n            assert(allowed, \"Viewing hours proposals not allowed\");\n            assert(proposed_hours <= 24, \"Proposed hours must be 0-24\");\n            let min_hours = self.storage.min_public_hours.read();\n            assert(proposed_hours >= min_hours, \"Proposed hours below minimum\");\n        }\n\n        let count = self.storage.proposal_count.read();\n        let proposal_id = count + 1;\n        self.storage.proposal_count.write(proposal_id);\n        self.storage.proposal_content_hash.at(proposal_id).write(content_hash);\n        self.storage.proposal_author.at(proposal_id).write(sender);\n        self.storage.proposal_votes_for.at(proposal_id).write(0);\n        self.storage.proposal_votes_against.at(proposal_id).write(0);\n        self.storage.proposal_status.at(proposal_id).write(PROPOSAL_ACTIVE);\n        self.storage.proposal_type.at(proposal_id).write(proposal_type);\n\n        // Store proposed hours for viewing hours proposals\n        if proposal_type == PROPOSAL_UPDATE_VIEWING_HOURS {\n            self.storage.proposal_proposed_hours.at(proposal_id).write(proposed_hours);\n        }\n\n        let voting_period = self.storage.voting_period_blocks.read();\n        let current_block = self.context.block_number() as u64;\n        self.storage.proposal_end_block.at(proposal_id).write(current_block + voting_period);\n\n        // Record snapshot block for voting eligibility\n        self.storage.proposal_snapshot_block.at(proposal_id).write(current_block);\n    }\n\n    #[external(\"private\")]\n    fn cast_vote(proposal_id: u64, support: bool) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([proposal_id as Field, secret]);\n        self.context.push_nullifier(nullifier);\n        self.enqueue_self.cast_vote_internal(proposal_id, support, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn cast_vote_internal(proposal_id: u64, support: bool, sender: AztecAddress) {\n        let is_verified = self.storage.agent_verified.at(sender).read();\n        assert(is_verified, \"Agent not verified\");\n\n        let status = self.storage.proposal_status.at(proposal_id).read();\n        assert(status == PROPOSAL_ACTIVE, \"Proposal not active\");\n\n        let current_block = self.context.block_number() as u64;\n        let end_block = self.storage.proposal_end_block.at(proposal_id).read();\n        assert(current_block <= end_block, \"Voting period ended\");\n\n        // Snapshot check: agent must have been verified before the proposal snapshot block\n        let snapshot_block = self.storage.proposal_snapshot_block.at(proposal_id).read();\n        let verified_at = self.storage.agent_verified_at_block.at(sender).read();\n        assert(verified_at > 0, \"Agent verification block not recorded\");\n        assert(verified_at <= snapshot_block, \"Agent verified after proposal snapshot\");\n\n        if support {\n            let current = self.storage.proposal_votes_for.at(proposal_id).read();\n            self.storage.proposal_votes_for.at(proposal_id).write(current + 1);\n        } else {\n            let current = self.storage.proposal_votes_against.at(proposal_id).read();\n            self.storage.proposal_votes_against.at(proposal_id).write(current + 1);\n        }\n    }\n\n    #[external(\"public\")]\n    fn execute_proposal(proposal_id: u64) {\n        let status = self.storage.proposal_status.at(proposal_id).read();\n        assert(status == PROPOSAL_ACTIVE, \"Proposal not active\");\n\n        let current_block = self.context.block_number() as u64;\n        let end_block = self.storage.proposal_end_block.at(proposal_id).read();\n        assert(current_block > end_block, \"Voting period not ended\");\n\n        let votes_for = self.storage.proposal_votes_for.at(proposal_id).read();\n        let votes_against = self.storage.proposal_votes_against.at(proposal_id).read();\n\n        if votes_for > votes_against {\n            let p_type = self.storage.proposal_type.at(proposal_id).read();\n\n            if p_type == PROPOSAL_TOGGLE_DISCUSSION {\n                // Backward compat: toggle between 0 and 24 hours\n                let current_hours = self.storage.public_hours_per_day.read();\n                if current_hours == 0 {\n                    self.storage.public_hours_per_day.write(24);\n                } else {\n                    self.storage.public_hours_per_day.write(0);\n                }\n                self.storage.proposal_status.at(proposal_id).write(PROPOSAL_EXECUTED);\n            } else if p_type == PROPOSAL_UPDATE_VIEWING_HOURS {\n                let proposed = self.storage.proposal_proposed_hours.at(proposal_id).read();\n                let min_hours = self.storage.min_public_hours.read();\n                assert(proposed >= min_hours, \"Proposed hours below minimum\");\n                self.storage.public_hours_per_day.write(proposed);\n                self.storage.proposal_status.at(proposal_id).write(PROPOSAL_EXECUTED);\n            } else if p_type == PROPOSAL_UPDATE_RATE_LIMITS {\n                self.storage.proposal_status.at(proposal_id).write(PROPOSAL_EXECUTED);\n            } else {\n                self.storage.proposal_status.at(proposal_id).write(PROPOSAL_PASSED);\n            }\n        } else {\n            self.storage.proposal_status.at(proposal_id).write(PROPOSAL_REJECTED);\n        }\n    }\n\n    // ===== VIEW FUNCTIONS =====\n\n    #[external(\"public\")]\n    #[view]\n    fn get_name() -> pub FieldCompressedString {\n        self.storage.name.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_admin() -> pub AztecAddress {\n        self.storage.admin.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_post_count() -> pub u64 {\n        self.storage.post_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_post_content_hash(id: u64) -> pub Field {\n        self.storage.post_content_hash.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_post_author(id: u64) -> pub AztecAddress {\n        self.storage.post_author.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_post_submolt(id: u64) -> pub u64 {\n        self.storage.post_submolt.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_post_created_at(id: u64) -> pub u64 {\n        self.storage.post_created_at.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_post_votes(id: u64) -> pub (u64, u64) {\n        (\n            self.storage.post_votes_up.at(id).read(),\n            self.storage.post_votes_down.at(id).read(),\n        )\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn is_post_deleted(id: u64) -> pub bool {\n        self.storage.post_deleted.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_comment_count() -> pub u64 {\n        self.storage.comment_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_comment_content_hash(id: u64) -> pub Field {\n        self.storage.comment_content_hash.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_comment_post_id(id: u64) -> pub u64 {\n        self.storage.comment_post_id.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_comment_parent_id(id: u64) -> pub u64 {\n        self.storage.comment_parent_id.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_comment_author(id: u64) -> pub AztecAddress {\n        self.storage.comment_author.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_comment_created_at(id: u64) -> pub u64 {\n        self.storage.comment_created_at.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_comment_votes(id: u64) -> pub (u64, u64) {\n        (\n            self.storage.comment_votes_up.at(id).read(),\n            self.storage.comment_votes_down.at(id).read(),\n        )\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_submolt_count() -> pub u64 {\n        self.storage.submolt_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_submolt(id: u64) -> pub (Field, AztecAddress) {\n        (\n            self.storage.submolt_name_hash.at(id).read(),\n            self.storage.submolt_creator.at(id).read(),\n        )\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_agent_count() -> pub u64 {\n        self.storage.agent_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn is_agent_verified(agent: AztecAddress) -> pub bool {\n        self.storage.agent_verified.at(agent).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_public_hours_per_day() -> pub u64 {\n        self.storage.public_hours_per_day.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_public_window_start_utc() -> pub u64 {\n        self.storage.public_window_start_utc.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_allow_hours_proposals() -> pub bool {\n        self.storage.allow_hours_proposals.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_min_public_hours() -> pub u64 {\n        self.storage.min_public_hours.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn is_currently_public(current_hour_utc: u64) -> pub bool {\n        let hours = self.storage.public_hours_per_day.read();\n        if hours == 0 {\n            false\n        } else if hours >= 24 {\n            true\n        } else {\n            let start = self.storage.public_window_start_utc.read();\n            let end = (start + hours) % 24;\n            if start < end {\n                (current_hour_utc >= start) & (current_hour_utc < end)\n            } else {\n                (current_hour_utc >= start) | (current_hour_utc < end)\n            }\n        }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_proposed_hours(id: u64) -> pub u64 {\n        self.storage.proposal_proposed_hours.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_rate_limits() -> pub (u64, u64, u64) {\n        (\n            self.storage.post_cooldown_blocks.read(),\n            self.storage.comment_cooldown_blocks.read(),\n            self.storage.daily_comment_limit.read(),\n        )\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_count() -> pub u64 {\n        self.storage.proposal_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_content_hash(id: u64) -> pub Field {\n        self.storage.proposal_content_hash.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_author(id: u64) -> pub AztecAddress {\n        self.storage.proposal_author.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_votes(id: u64) -> pub (u64, u64) {\n        (\n            self.storage.proposal_votes_for.at(id).read(),\n            self.storage.proposal_votes_against.at(id).read(),\n        )\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_status(id: u64) -> pub u8 {\n        self.storage.proposal_status.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_end_block(id: u64) -> pub u64 {\n        self.storage.proposal_end_block.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_type(id: u64) -> pub u8 {\n        self.storage.proposal_type.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_snapshot_block(id: u64) -> pub u64 {\n        self.storage.proposal_snapshot_block.at(id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_claim_agent(nonce_hash: Field) -> pub AztecAddress {\n        self.storage.claim_nonce_agent.at(nonce_hash).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn is_claim_verified(nonce_hash: Field) -> pub bool {\n        self.storage.claim_nonce_verified.at(nonce_hash).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_voting_period_blocks() -> pub u64 {\n        self.storage.voting_period_blocks.read()\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "62": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/calls.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata_array};\nuse crate::oracle::execution_cache;\n\n// PrivateCall\n\n#[must_use = \"Your private call needs to be passed into the `self.call(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_private_function(...args))`\"]\npub struct PrivateCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T>\nwhere\n    T: Deserialize,\n{\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_private_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\n// PrivateStaticCall\n\n#[must_use = \"Your private static call needs to be passed into the `self.view(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_private_static_function(...args))`\"]\npub struct PrivateStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_private_static_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\n// PublicCall\n\n#[must_use = \"Your public call needs to be passed into the `self.call(...)`, `self.enqueue(...)` or `self.enqueue_incognito(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_public_function(...args))`\"]\npub struct PublicCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    gas_opts: GasOpts,\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PublicCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub unconstrained fn call(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\n// PublicStaticCall\n\n#[must_use = \"Your public static call needs to be passed into the `self.view(...)`, `self.enqueue_view(...)` or `self.enqueue_view_incognito(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_public_static_function(...args))`\"]\npub struct PublicStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    return_type: T,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, let N: u32, T> PublicStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub unconstrained fn view(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view_incognito(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\n// UtilityCall\n\npub struct UtilityCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> UtilityCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n"
    },
    "70": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{\n        inputs::PrivateContextInputs, note_hash_read::NoteHashRead, returns_hash::ReturnsHash,\n    },\n    hash::{hash_args, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter, notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, find_first_index, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // Incrementing the side effect counter when ending setup ensures non\n        // ambiguity for the counter where we change phases.\n        self.side_effect_counter += 1;\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardize on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact approach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n        let side_effect = Scoped::new(\n            Counted::new(note_hash, self.next_counter()),\n            contract_address,\n        );\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Asserts that a NoteHashRead has been requested to the kernel by this context.\n    /// Asserts instead of returning a boolean to save on gates.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash read to assert that has been requested.\n    ///\n    pub fn assert_has_been_requested(self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n\n        // Safety: The index is constrained by the checks below.\n        let hinted_index = unsafe {\n            find_first_index(\n                self.note_hash_read_requests.storage(),\n                |r| (r.contract_address == contract_address) & (r.innermost() == note_hash),\n            )\n        };\n        // This assertion is not necessary, since the .get would fail. But it enables us to have a more explicit error message.\n        assert(\n            hinted_index != self.note_hash_read_requests.max_len(),\n            \"Note hash read has not been requested\",\n        );\n\n        let request = self.note_hash_read_requests.get(hinted_index);\n        assert_eq(request.contract_address, contract_address);\n        assert_eq(request.innermost(), note_hash);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    /// * `contract_address` - The contract address that emitted the nullifier\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the nullifier is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(\n        &mut self,\n        nullifier: Field,\n        contract_address: AztecAddress,\n    ) {\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incoming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes) or that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "74": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr",
      "source": "use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n"
    },
    "78": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "80": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "97": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "support",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "tVzdbhy3Dn4XX/tCpP7zKkVRuIlbGDCcwE0KHAR590NqJEreVLRWs7kxOeOdbySKpCRSw+93nx7//Pb3H08vf33+5+7Db9/v/nx9en5++vuP588fH74+fX6hu9/vDP8Bd/fBwo/7OyhXga4MXSFfYb77AHh/Z02lUClWait1lXqilmioNFaaiDqi+aDOVMp4nihWyniBqKuU8SLRUGmslPES0XxQbyplvEwUK7WVEh4aor5SwkMgGitNlRIeUj+CqRQqJTykfgRbqauU8agfIVTKeNSPkCrNB42MR/2JUClWynjUn+gq9ZUyHvUnxkoZj/oR80ET42UaJdvGjF4C8SD0W4IG+ikhIf0y0g9d+2E6/gU8xr7c5Cse/yDaQBeRL3j48Bg9pHtJfv6Drpom/fH19fGR/zOoFincl4fXx5evdx9evj0/39/9+/D8rfzony8PL4V+fXil/9JYPL58IkqAfz09PzL3474/beaPupjrw6Go7/E4RFgF8BEbAMQBwK4CYI62IlgDvkMktwqRWGsKQnJpaMOb5938+RBC60P0G89H03oQwWw932QYcfp+pf+Zrb48nxF2nvepPR/z7Pk8fx7AuNYD4sM4iKttsKH1weEow7ysyQ4aQMahAcum4EMbRdLpLYAYG0AKOwDBgNiSOQvgtwBEBmFPBkFkEPZkEKULcU8GI8CWDKLIIO7JIIoM4p4MknQh7clgBNiSQQoCEPdaEJs5p7TVgmzarJb3ZDAC7LUgNZ+W9xwK5jDMbLgzu4KBNhDkV0dlWvaLyUeZHYMdpmiSyghhUcHIIgrrdhqBCE0UiLFDWP92krdOw8hNp9CaPs/bFJcxAhpZ7tgpgtYRB22uRBfsXJpRwzAdY1hwXGiWTZqB29aRZEIfVOsuMLLmpkISPzWYyCWG02Zt3xTDQddO9G8VnGfm+aim3EcV5xiorT9CX34M7uaqdkRoi0CM1swxFO2CKEtZWrgoffGK13GylvNpCwEMYvcZijQUFXVJlpQu+cF15XVhZNMGFjLOhaEaW7d4P3q/C2Pzqgf1omAkjtxHNporQGI0AkIWNwPRVodWdineeqUzVjG3oR3kAq2fdkYFSTKzWZpgwhYIgAUBgRw3JOJykAWzGZT9J4koigrBNKlCsMPmxbzVVK84U0fG6sSNJYCpQLI2zQZsxk/8YDPrAkFW0KbwpGd9niS4ESOANjV431ePw7i8nWmD4k+t+CAH2NXDb/Yj22k/3NoyvLfB4XojwMqag1QqTBsRFPWy2GYFsMNKOMd1CAeioW5wx5cQSVtIin7SQrK3wl4oeVD0E22fZ50Z1j7hbaQm3mAVF0Ez2NznSK9gKPrpxG+MW33r/RXScKEvwXAuDXd+DRb9+TVYDGfXYDGeX4PFdH4NpmLYvmSwOF/9JHN2/ZTM+fVTwtPrp8WORL83rCE1BcUwOOGfOuJvMCTh9JCE07LQjCQnMZJNaS5uELI5v0HIcFaaKoKJEi4OWwirJpLdaRNRxbm4xdDmVmskbmxx8H2Xc2uO52eCnM7PBDmfnQnAmPNTARg4PxfoLVm0NzD2vMGBcWctToVYNRj652mL0QVyC5OhH4vJZD81GTCaroJ4IQtuCNCGtxig2r+X0c1xmnlTMbCPDBrn5xioJX7sf+ZtrmmFWD+aDPNWuF/aCujGj0OQ4yp5QrI3wDCnMaxEztF6RTe0vKaV+BPt4uwehrN9++dugRE3McRoaRsadjEkCkbO6HxfdjG85LfAgzmPYXcxXMcIboqB6bTVqq0Qi6No2HxkrTnZCn1OkGALzQlhPidoaSZvnKTgzRBfuJwTdAz0gjGmXy8xtKWp7/HA4G6BkWcYqzK1xigy1QKkTuZZMr0070vSkvooWf04+p9rMJLM1SFFu4eRk6yRDeYtjJgkLxyTgymGnm9yEmOlyKJJt0AB2OtPtiKTHMImhkQ5CWNvfFOWMGfKfj42WtbpCrnGG8hVD/zmuBC1XY8/D2K9iD+D16L5crCK8vjTMCV4zSPKZoxc0jRaClq2Z3VzShPi6d2p9zfYnfpwg92p2pLV3amWeFrenWqJp8XdqQaxvDvV8k6ru1NVIDfIGdNaSTZ0gMNZwkuz05JPzkYxPOLDNCUIQVESF40kTIi3cY4STttviDewX3U5sma/atoFQ9/YRcVqrpDqPNP6Dkr2WfTVmLiHQqE/21H89HQBRKutviUPPuz9fxphLRm1lhLTW7GmZ1qUfVnPtED7op5piaRl7xzzDbzz+XQU3CIfBTdISOkCWfTO11jMcITuOrsDEQrxcW53Wlop5NjUNeTB8sI1DbGhu5Hx6Po1xz5wOC5hh08ALqespPpW2RyhHfI6lyOsJVSwf0mBycMcQ1sHoHwN4dCFPQwrm3hnx1OWV2FAvgEGnMbouxHn0qY8vByacGHc+F5iaPnLJMEVGtvpZzKgJakwdIzg58HynM8H7TWMxaA9akmqtcCb3oqloD0a+0tbsRi0fwfD3gDDnMZYC9qjSaeD9jrGWtD+Coy4ibEUtH8PYyVov96XXYy1oP06ht3FWAraI8STVvtOK5aC9qgF/hd9h+rP5fNPWoLMxxXhtD9XMVb9OZ71pO+0Ys2fo/+lrVjz5+9h2BtgmNMYi/5cS02t+nMVY9Gfr2PETYw1f/4OxpI/X+7LLsaiP1/GsLsYa/7cnvWk77RizZ87+KX+PPoocY88l6ez5+1NxVi0t3WMuImxZm/vYCzZ23JfdjEW7W0Zw+5irNmbP3tg6p1WrNmbP31gSo2X9IgYZshbMRcLkpDmj6o2Mfoh1vFbrF0MHE4bwPpHvpTw9D2OFXAWxypZgDmKB1l4kLJNv3FDLRsFSb7TpRDgEO24qCryTlOCHHwg3rl5UxRVvc2XYbav6Gig8ly02mF+9Fk+ZyLxDcpm7AWMlpBy/UtGNxyhCJdNUXZQwcixlGCcmWNoR6eCbdb3Rqz2mmakXjED5s1Qv4oKPdkQUh+Zi8+5Maof7a2dIEfts6jV7AtqWaC17AtGdz5Lj9qXUatZeh1k8esV1PJRaykcFWI1hYNa+mUxhbPal+g3R3cxt4ZaOmo1t4bJnh6YRQhNHhrE8tim80f7dZkupud0hwi9QsZ4ZunSIWqZKNuTFWP+J17jl6HXEUJ002ZoSZNI84Mca6MJYpppxIw3mL3faUuUGluRkvwwR9E+RBlcoh2jZOvV2rwcevDjWYPLT+4xa9/SrVYheAclpV4eJ1vcROnhRy5msN+WpZII6kJvrZaeVs1g6Zt3vSc3qMvgvaydSUnmNW7UinxJToNacwHxO10+fHx6fVtGkwsv8skArrzoan1Fplx7sVCg5lDXECu1vPgl6ir1vBwlGirlQo4kKUyV5oNyFU5fq3CWa6zU8nLwqMJZqOdxPKpwhlqFM9QqnLzI5iqcTLkKJ7syrsJZKFZqK3WVepbFUYWz0FhpqjQflKtwFgqVYqW2UldpxfMVz1c8X/F8xeMqnBzR4SqchXJVT158cxnOg3E8MHAU4gQ+W8WVOIFnJC7FCawNXIuzTA0hVyaWaqb5KMd5MIzM2scFOQ+GkXlPGEtJ03zU5DyY2JjUmFLW1Bx1OQ8GGoONsSWYQoxrjC8xFWJCY2Jj0iH5lA+aGZenhAyNKRVTCTeXkqmkFdkViyXGNyY0ppRN5d+kxpTCqayzppRO5bqhphRPReZK+dRyrxRQ5XKixgnnheMypRwDoMEoqRDmUsmEMMfFSnmUaHtS8hLMgXBYAvXMWeFcidgz54Xjd/A6BdjMkPdvwIaGfPAboBRsZTw2NuSRAza3yvE7WPjAJlc5fgefkAT0wpXyrYzMple5UsKVJYS5cWyAyGcigE2wctikVorhFqlZkZUVWZWSuAcXm9RKYdUiNZub1JxpUnMiKzbMyoms2DgrJ7JyQbjYpOZSk5rLTWreNKl5kZVH4URWpWzuwYmsSuncgxNZlfK5ByeyKiV0D05kVcroHhy/g9cVUErpsv5CKabLR1uhlNM9uFIAl1tQSuoeXG5cKat7cPyOxFIrpXUPzgrH78jld/wOXuRBKbF7cPyOMm5Hmd3yRG7cUWqXW8o2XTkUzgpX3sEyTV64IFwULvGkzW1h47Zl9Nm8KwfCYWsfW7g1hXPCeeGCcFGeSMLlyqFp70BT3sEr038fXp8e/nx+5FmMJ7pvLx/bpEaXX//3pf2nVY/+8vr54+Onb6+PPAEOJaTp72+0t0LgCRL6rXyPjm+h3CILIEfD96zcI+3EzLdcvxXvLfIt32/5e2v4Vvj5lUe14gPKut/vj3+T5jrP/04dBO4x/P6DZ/L/Aw==",
      "is_unconstrained": false,
      "name": "cast_vote",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10330371483337376860": {
            "error_kind": "string",
            "string": "Voting period ended"
          },
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14446999286126106136": {
            "error_kind": "string",
            "string": "Agent verification block not recorded"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15468464099753430534": {
            "error_kind": "string",
            "string": "Function cast_vote_internal can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5200913191555279574": {
            "error_kind": "string",
            "string": "Proposal not active"
          },
          "9794026722560667155": {
            "error_kind": "string",
            "string": "Agent verified after proposal snapshot"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "support",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "cast_vote_internal"
    },
    {
      "abi": {
        "error_types": {
          "113085549400429254": {
            "error_kind": "string",
            "string": "Claim already verified"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17068651471790847605": {
            "error_kind": "string",
            "string": "Twitter handle already used"
          },
          "4048396286052499169": {
            "error_kind": "string",
            "string": "No agent registered for this nonce"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "nonce_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "twitter_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "complete_verification"
    },
    {
      "abi": {
        "error_types": {
          "10912982978800048688": {
            "error_kind": "string",
            "string": "Hours must be 0-24"
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "822412312360312459": {
            "error_kind": "string",
            "string": "Min hours must be 0-24"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "privacy_preset",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "public_hours_per_day",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "post_cooldown_blocks",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "comment_cooldown_blocks",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "daily_comment_limit",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "voting_period_blocks",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "allow_hours_proposals",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "min_public_hours",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_initializer"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "content_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "post_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "parent_comment_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "create_comment",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "11237875760331549985": {
            "error_kind": "string",
            "string": "Comment cooldown not elapsed"
          },
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15946742046864573155": {
            "error_kind": "string",
            "string": "Function create_comment_internal can only be called by the same contract"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7372167904069661094": {
            "error_kind": "string",
            "string": "Daily comment limit reached"
          }
        },
        "parameters": [
          {
            "name": "content_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "post_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "parent_comment_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "create_comment_internal"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "content_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "submolt_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "create_post",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "13082641925069760057": {
            "error_kind": "string",
            "string": "Post cooldown not elapsed"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8658656849933845587": {
            "error_kind": "string",
            "string": "Function create_post_internal can only be called by the same contract"
          }
        },
        "parameters": [
          {
            "name": "content_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "submolt_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "create_post_internal"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "content_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "proposed_hours",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "create_proposal",
      "verification_key": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPKAAAAAAAAAAAAAAAAAAAAa42vXOEFBKeWA9pvpznhejQAAAAAAAAAAAAAAAAAAAAAACO1XJCcmNZ699wfk5/8GQAAAAAAAAAAAAAAAAAAAFlhyOYMdiyKvYzflYDnn68KAAAAAAAAAAAAAAAAAAAAAAAGJQQsmSw22LrvTNYsrccAAAAAAAAAAAAAAAAAAABf92icMy35mWe1Nz1Tx1P9LgAAAAAAAAAAAAAAAAAAAAAAFpYXI87MMHO38gdCDFIHAAAAAAAAAAAAAAAAAAAAQM2RODwIb2kQYal5nHnBcHQAAAAAAAAAAAAAAAAAAAAAAANT9QxpqotYt0XcCPlYBQAAAAAAAAAAAAAAAAAAALGoDZXcei6r09fU3q3kv9mFAAAAAAAAAAAAAAAAAAAAAAAowqvRrJW2YKjiw+SxjH8AAAAAAAAAAAAAAAAAAADILO8IxZk5LxisNZU8arfI5AAAAAAAAAAAAAAAAAAAAAAAHmRBnVhhmaBLkytRRYC3AAAAAAAAAAAAAAAAAAAAxMumr9mAilK4VFOcjEheJ7UAAAAAAAAAAAAAAAAAAAAAABmULW7M2eg8yvABsrAfuAAAAAAAAAAAAAAAAAAAADM6+qNOVynurkQJ/fhzl3KcAAAAAAAAAAAAAAAAAAAAAAAXrzFKRDPXBPSsTvXeGVUAAAAAAAAAAAAAAAAAAADTNeQx3JxKMOA8gDqrNlAeKAAAAAAAAAAAAAAAAAAAAAAAGe3GLyEXfIVhZuZ6/NVAAAAAAAAAAAAAAAAAAAAAi7CXmqb14Aa3cOZ3wSzxg6gAAAAAAAAAAAAAAAAAAAAAAB2qWDx6gzNhwq4tEB6ELAAAAAAAAAAAAAAAAAAAANBcqRwLmKq35ePlaI6dP7GGAAAAAAAAAAAAAAAAAAAAAAALg5FDNul+wgGPid97SdsAAAAAAAAAAAAAAAAAAABNhlHZYWQzHDBu/Vy+WyxIowAAAAAAAAAAAAAAAAAAAAAACpI3Sbx3bDuxWmc0ud6bAAAAAAAAAAAAAAAAAAAAJzF9LwqADNbKcfUoT8KtTa8AAAAAAAAAAAAAAAAAAAAAAA518y3hD5iLVkztpJIXywAAAAAAAAAAAAAAAAAAAB5J8PjTkTM7ZuCKjl4o1N0dAAAAAAAAAAAAAAAAAAAAAAAGAYYZQRXqMgE23QeNvXEAAAAAAAAAAAAAAAAAAADZ096+UM1fAwCzY/8yELfi0QAAAAAAAAAAAAAAAAAAAAAAFfi1kajDOd0fc6qymKffAAAAAAAAAAAAAAAAAAAAvKoQ6J6fspLz33FdV2HzFegAAAAAAAAAAAAAAAAAAAAAACkeU8yDqdi7HqGV0DRoGAAAAAAAAAAAAAAAAAAAAITtKVDk4/26egYQcty1kXx0AAAAAAAAAAAAAAAAAAAAAAAqpIA1Yw6zwKNn+rtE8wIAAAAAAAAAAAAAAAAAAAAL4fDcglQlC3MJFmw3YnZJewAAAAAAAAAAAAAAAAAAAAAADJaGTzaYu1W2Cuv/wNQvAAAAAAAAAAAAAAAAAAAAyUIiRyvIkLXkXH60NqWON8wAAAAAAAAAAAAAAAAAAAAAABWUx5sd5Td0T2Z+ak7zrAAAAAAAAAAAAAAAAAAAAKuG4zZYaypoBTcwQ0oHtHCaAAAAAAAAAAAAAAAAAAAAAAAgVJc65m4Sosr1xyMM9RwAAAAAAAAAAAAAAAAAAAAXACh/XTk/o9IK/Aro8G+ByAAAAAAAAAAAAAAAAAAAAAAACZ5IbeDCeeCEh6nSGtoDAAAAAAAAAAAAAAAAAAAA+wYJeKPbJY+uu20vA+5RcIQAAAAAAAAAAAAAAAAAAAAAABTXr+VMekoT6B9Ag2aqygAAAAAAAAAAAAAAAAAAABuaUgB6RGrAgqm5JgTU8JyHAAAAAAAAAAAAAAAAAAAAAAAENgiQi4DQQ2OLDDQHaQAAAAAAAAAAAAAAAAAAAABdB3e+yEpRZ/o2bfWa25Yf9wAAAAAAAAAAAAAAAAAAAAAAAGp2vn+X1E4tKf5ANR+BAAAAAAAAAAAAAAAAAAAAnyapJY9ByjQKZTGq6XpkhWsAAAAAAAAAAAAAAAAAAAAAAA0/xvb5mP2Ya9Jx5b5V5wAAAAAAAAAAAAAAAAAAAFgyL2G5fMvNY7ejC5Qz7MV6AAAAAAAAAAAAAAAAAAAAAAAi8odrcksBBheV0RXn6/MAAAAAAAAAAAAAAAAAAABIc8rhQ/ks+8DzgnVI67+p3AAAAAAAAAAAAAAAAAAAAAAABYabvgWMPkOYmBPMohXXAAAAAAAAAAAAAAAAAAAAaEzzfsugneNT/CB9EcKLTAcAAAAAAAAAAAAAAAAAAAAAACRGPHEI2Mf4TTmubjwaSQAAAAAAAAAAAAAAAAAAABAtRnpAoTqsrijnvE22zyiYAAAAAAAAAAAAAAAAAAAAAAAfdUE7PJTyON/rNR6K9/EAAAAAAAAAAAAAAAAAAAC0o9SMsJ7XV2SspPkZOzQFkAAAAAAAAAAAAAAAAAAAAAAAID3C9KekSfAzeNcdJ3P9AAAAAAAAAAAAAAAAAAAAjgGCAgyg82C4EjkXxrXQ4WIAAAAAAAAAAAAAAAAAAAAAAARH1aEOBO7X7VHpRvOSmQAAAAAAAAAAAAAAAAAAAAyCB3Q+kPf0VLHrHRQ6AmBSAAAAAAAAAAAAAAAAAAAAAAAIvpNhE+/h9BpR2drBV9sAAAAAAAAAAAAAAAAAAAC1+96F+ya+iUkEKrmoHnNvDwAAAAAAAAAAAAAAAAAAAAAALUf4hPvWEwE9kBNldQAeAAAAAAAAAAAAAAAAAAAAjtOVH3m0GRFiKiwKwyuNwP8AAAAAAAAAAAAAAAAAAAAAAA7vzfMXUkmOwJfMgBgFpgAAAAAAAAAAAAAAAAAAAEJJ4QZZSzMPEhhbkk6OlOqiAAAAAAAAAAAAAAAAAAAAAAAa2+jfnrNGzjfadVPtdDIAAAAAAAAAAAAAAAAAAACJJx9BSihirbTJpwtMTsFWOAAAAAAAAAAAAAAAAAAAAAAALmo0X+8kEfsFdxU5nx/4AAAAAAAAAAAAAAAAAAAAaALLXDBPTuUIb1pXSaCYxO8AAAAAAAAAAAAAAAAAAAAAAChhM5QV85Y0+AZ7TnjecwAAAAAAAAAAAAAAAAAAABESlesLXjPolnTW7s+mYxdvAAAAAAAAAAAAAAAAAAAAAAAVIJMmag1KOAo++6+6CWIAAAAAAAAAAAAAAAAAAAC16Kbky8rGhufvbgcIkWb24QAAAAAAAAAAAAAAAAAAAAAAE2jj9Nx3Au9E8p8DaWyVAAAAAAAAAAAAAAAAAAAAt6Dm8xLmyt3txn7rWN2MscEAAAAAAAAAAAAAAAAAAAAAAAb7FVe21RjjvsboiaAlLgAAAAAAAAAAAAAAAAAAACBB/xkEwITsRyhyuswTEPYGAAAAAAAAAAAAAAAAAAAAAAAa/N7Q0/3RilwTyqpGFYEAAAAAAAAAAAAAAAAAAAAqNU3IcdvipDfTW6D1wSX1iAAAAAAAAAAAAAAAAAAAAAAAFIJ/cL1jIbn63RGYWyp3AAAAAAAAAAAAAAAAAAAAPrM+16ToZYHr1DdSVRIWZokAAAAAAAAAAAAAAAAAAAAAAAR48ax0KzQLhNKdv9dGmQAAAAAAAAAAAAAAAAAAAGlzkW8E549zr9OX2qEMHICcAAAAAAAAAAAAAAAAAAAAAAAL6Jam8hjbjW+g7KqIYsUAAAAAAAAAAAAAAAAAAAAt/yuJkcxM+XZMK3mMUVpgmgAAAAAAAAAAAAAAAAAAAAAAARU+mkyXgEq+EBniHPSYAAAAAAAAAAAAAAAAAAAAAXHXwTXBtsot/SzBAvBPIngAAAAAAAAAAAAAAAAAAAAAAAR20LY4eV0fHtGN/Df9rAAAAAAAAAAAAAAAAAAAAKb1fP0C9fk/zwU2Z4TZHMYNAAAAAAAAAAAAAAAAAAAAAAAS13BM/so7lydT7lD6u+cAAAAAAAAAAAAAAAAAAADVD/nNGCtPTtWp9Zvn/pqTRgAAAAAAAAAAAAAAAAAAAAAACk2G1fIkFlrqqB75Do+hAAAAAAAAAAAAAAAAAAAAg0pKKEJysWBd94GNje7vcNwAAAAAAAAAAAAAAAAAAAAAAAg0sb0/3vApkqM/a9dwfwAAAAAAAAAAAAAAAAAAAFH/mpMKykIRY40kqWUqLmwdAAAAAAAAAAAAAAAAAAAAAAAqJdcYWuCmIOS2n8p/J1sAAAAAAAAAAAAAAAAAAADLMwEbfsJSRXmYRKxYbpmB8wAAAAAAAAAAAAAAAAAAAAAADcYazy27mt12yDmCLI/yAAAAAAAAAAAAAAAAAAAA/k3DVYMJ3uEbB3NHeCyg4UsAAAAAAAAAAAAAAAAAAAAAABrgJOfQ7srEPA0w/FVtFQAAAAAAAAAAAAAAAAAAAGY3omzPJJAib1Zf0+zMJodYAAAAAAAAAAAAAAAAAAAAAAAsd7T6wbXPfZMQMuGgLicAAAAAAAAAAAAAAAAAAABgfwkBPvHmcPCElFoOhQtoLAAAAAAAAAAAAAAAAAAAAAAAK3Lx8QGso2ZpxnrPDIqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACyzPFaxVzRI/ucO9wVGoz3AwAAAAAAAAAAAAAAAAAAAAAAJe+oDBZnjVJvXwLTtngtAAAAAAAAAAAAAAAAAAAAhxG+BkIBXQmnMFCFTEPss50AAAAAAAAAAAAAAAAAAAAAABXyyPVfhs8cwX1tb1TlPgAAAAAAAAAAAAAAAAAAAGvMegX/lalrKJQkxfczZw2WAAAAAAAAAAAAAAAAAAAAAAAAxDcm91tv2g3iLODg36sAAAAAAAAAAAAAAAAAAAAdCgnXF47JO614WPluZPC0jQAAAAAAAAAAAAAAAAAAAAAAL5tuC04sAZaN5cMkgqp9AAAAAAAAAAAAAAAAAAAAFLmaKhz1vbFNGPy31tW7G0MAAAAAAAAAAAAAAAAAAAAAABibwBFKqYLGRXSxHbsAPgAAAAAAAAAAAAAAAAAAAIFYESpGMQpiuEn23VYsLIaUAAAAAAAAAAAAAAAAAAAAAAASkF6WwsjbCGXWk491oyQ="
    },
    {
      "abi": {
        "error_types": {
          "10581129473648605397": {
            "error_kind": "string",
            "string": "Function create_proposal_internal can only be called by the same contract"
          },
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1939303983761409499": {
            "error_kind": "string",
            "string": "Viewing hours proposals not allowed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4612943103503554032": {
            "error_kind": "string",
            "string": "Proposed hours below minimum"
          },
          "590589903550671092": {
            "error_kind": "string",
            "string": "Proposed hours must be 0-24"
          },
          "7830024613194784770": {
            "error_kind": "string",
            "string": "Invalid proposal type"
          }
        },
        "parameters": [
          {
            "name": "content_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "proposed_hours",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "create_proposal_internal"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "name_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "create_submolt",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "12306828111948424472": {
            "error_kind": "string",
            "string": "Function create_submolt_internal can only be called by the same contract"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "name_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "create_submolt_internal"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5425679372158780026": {
            "error_kind": "string",
            "string": "Not authorized to delete"
          }
        },
        "parameters": [
          {
            "name": "post_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "delete_post"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "comment_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "downvote_comment",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10556702571134275233": {
            "error_kind": "string",
            "string": "Function downvote_comment_internal can only be called by the same contract"
          },
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "comment_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "downvote_comment_internal"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "post_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "downvote_post",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13545014029643762475": {
            "error_kind": "string",
            "string": "Function downvote_post_internal can only be called by the same contract"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "post_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "downvote_post_internal"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4612943103503554032": {
            "error_kind": "string",
            "string": "Proposed hours below minimum"
          },
          "5200913191555279574": {
            "error_kind": "string",
            "string": "Proposal not active"
          },
          "9001026953704595809": {
            "error_kind": "string",
            "string": "Voting period not ended"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "execute_proposal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "9345055721478160917": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDAAMvCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWBsE6qnPACFTwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbNjqMwDMffJeccYjufvMqoqmhLR0iIVgystKp49zUjEuCQHHY6F2In+If/xoS8xK25TJ/ntr8/vkT18RKXoe269vPcPa712D56nn0JtVwciIqkcFZUTgrPHgCP7IKWIiw+z4fAo5cClF4NwGg4USGHAPIMIhukomHY4GjQy4ybZyliAudxaJrl+buMOM9nPTT9KKp+6jop/tTd9H3T17Puv8exHnhVSdH0Nx4ZeG+7ZrFmuUWrfCiSD2s0ahUSAMAeEJBHgFfWrwy2nUsQBwcG5hmExpiVwTYHZhglKR5iGhgQslJ0AaHBqFQOcFtBnT4wzBvKYX+3HBqtWxGajMuWwxekINmoBI3dENwoe0R4QzVAvaEcJS0EFPMgoqwWwHeIoV8Wgw7Tiwn5FwOFPnU+aXEBdVZKqU3J6shgO/xUCjOyUkrtwUWMWZjg83tYoU8xEKUvP5C22U2slAgRpkyItP6Pz3YvxiqVFVPaCA24tKkbVJggBo9aCm2KmKQg7sqByhwZhe2UFFcyilHBmGxRTQmCW5Mp9PnfS6lTjd0yMdYeISf26ms7HI4D80Ib2vrSNat7n/rrbnX8+4wr8TjxHB7X5jYNzULazhTA1w8MkvRpOSCwQ0aSO83Lo/8B",
      "is_unconstrained": true,
      "name": "get_admin"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18042930026913969259": {
            "error_kind": "string",
            "string": "Function get_agent_count can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAUvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQX6ZV1DkW+0azwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVbLboMwEPwXn33w7vrJr1RRRBJSISESUahURfx7lwjzqGQf2vSCZ012sjNebD/EpToN78e6vd4+RPH2EKeubpr6/djczmVf31qefQg1PRyIgqRwVhROCs8RAI8cgpYiTDHPh8CjlwKUngFgBE4UyCmAPIPIgFQEhgFng1YRMC8GBgYieM6MoxSxtmPfVdVU2qZYlnAvu6rtRdEOTSPFZ9kMzx993Mv2OfZlx2+VFFV74ZEJr3VTTWiUa7ZKpyL5MGejVmEhALA7CkhTgFfWzxyMnVtIHOw4MM1BaIyZORhzYoIjJ8VDLAMDQlKKzlBoMGqxA9xqqNM7DvMCO+z/2qHRuplCk3FJO3xGCpKNStDYlUKFHUV4gRugXmBHTgsBxTqIKKkF8BVi6J/FoMNlYUJ6YSDTp84vWlxAnZSSa1OyOnIwDn+VwhxJKbn2YBNjFSb49B6W6VMMRMuXH0jb5CaWK4QIl0qItP7FZ7sVY5VKislthM5rHbU479ZmN7jXkmlTxEUK4sYOVGbPkdlOSbGTUYwKxiRNNTkSXJtMoU8fL7lONXatxFibJsnLwY2c7enwgyTX75bigQt24wh5Xt8Dh+W57nZXlnEi6+ry1FRzeB3a8+Zt/3WPb+KV597dztVl6KqJab33AD/fCCW5w3SJmQIvtTqM019/Aw==",
      "is_unconstrained": true,
      "name": "get_agent_count"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7932861672720419212": {
            "error_kind": "string",
            "string": "Function get_allow_hours_proposals can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDACcvCgADAAQcCgQFARwKBQMAHAoDBAEtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVuFy+pRs/JjDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbbboMwDIbfJde5iO0ceZWpqmhLJyREKwaTpop3n6kIh0nJxdbdEDupv/p3TMhDXKrT8H6s2+vtQxRvD3Hq6qap34/N7Vz29a3l2YdQ08OBKEgKZ0XhpPDsAfDILmgpwuTzfAg8eilA6dkAjIYTBXIIIM8gskEqGoYNjgatosFcDGwYiMZzZhyliLkd+66qptQ2ybKEe9lVbS+KdmgaKT7LZnj+6ONets+xLzteVVJU7YVHBl7rppqsUa7RKh2K5MMcjVqFBQBgdwhII8Ar62cG284tEAc7BqYZhMaYmcE2ByYYOSkeYhoYEJJSdAahwailHODWgjq9Y5gXlMP+bzk0WjcjNBmXLIfPSEGyUQkauyJU2CHCC6oB6gXlyGkhoJgHESW1AL5CDP2zGHS4bExIbwxk+tT5RYsLqJNScm1KVkcG2+GvUpiRlJJrDy5izMIEnz7DMn2KgWh58wNpmzzEcokQ4ZIJkda/eG23YqxSSTHZg1Cjjlq8tmuzG9xrybQp4iIFcVMOVGbPyBynpLiSUYwKxiSLanIQXJtMoU9/XnKdauyaibE2DcnLwY2c7dfhByTT7xbiqWwJFwB53t0Du+W57nYXlnFCdXV5aqrZvQ7tebPaf93jSrzw3LvbuboMXTWR1lsP8PONUJI7TFeYyfFSq8M4/fU3",
      "is_unconstrained": true,
      "name": "get_allow_hours_proposals"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1855851805910989972": {
            "error_kind": "string",
            "string": "Function get_claim_agent can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "nonce_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnRbts6DIbfJde5kCiKkvoqwzBkXTYECNIiaw9wMPTdR9r85aSAhS5tb5ovdPWbFClKdv5sfuy/P//6djj9fPi9ufvyZ/P9fDgeD7++HR/ud0+Hh5Na/2yC/an6N203NW/uynbT9FuM+qlfI283MZihGFSFqhCTA0WAbO5IB8WkFiKD5sCs0AyaQ06A6iCwCCwFllIcagSIg3k6QwboLVLYbogCgAG4lGBJsDAsXB0yAYqDRIA4FNyiZIAFqLNBNQGqQyOAzJBCBGSAD0+RAbBQAhSHRABYxKIgg+pgczgDLBWWCos5NoPMwObYDNkhBoDdIhlUByKAOEyTmRXELomBOEwzNgEDqsPk2AQ24RoOtwiQGXKIAFgiLBEWgsUmKmlJZCvIGcSBYeHskANAHeNgUB0sihnEwdLN0aA5mPMz6E1ZJyrbrBqIrZ0ZsgP5hMvkoUGKAE+BMCzsKZAcAJ4CyZ4CEQJ4CqR6CkrwFJTgKSgxABjgKSiUAJ6CkiLAp7cwLAxLhiXDIrCIp6CUCPAUlApL9RSUFgCegtI8BTUQwFNQo00mG1gKNNJqy3wCWxczFAebOtb2VW1dsDpWCwHEwTrgDAxoDk2nJdtNW5mhmT8zwBJhibAQLARLsiIRg+JgkzlDBuhN89R6GaA+Z81psw45Ayzm/AQ2mVldbVPVWQe3JcNTxw6hE3cyBeuWgTz+GCzVTt3GOlbCRBmUu81clDhRwwhz0qmCSrdZJ5+pUqdua90D6+ZOUFa3QBFjpz3Hyly3o9CJO1UQ6wixnSiKV79SBpVus64kaaIGqt1mHVNsO4wtYYSVxESElabUbVN3mklA1G2UOzVQSp26CvexgihJuBOiJCtqJ/F4qTHGNtwjBe5UPbZk+7lTt1kFT/FOe848IsVO8CpxtzEiSjl0WmzdA0mdunLpKtNhRF5ethscVL49nfd7O6dcnFz0PPO4O+9PT5u70/PxuN38tzs+T//0+3F3mj6fdme9qrW6P/3QTxX8eTjujV62y+iwPpRSbT6aOLQuoNVzJRHXJaL2rOoayqV0kRKvNGhdI1HO2TWUdeCKxiiUGuGGHkXiaig8kOCYQ58OXTaLG3ylkT9gOuRzp0NPK8UlOOWyOh11EApZuc6RUJZFQgvlUqJ9wGzE8AHTMYpFGwD8SCmtxhLpI4JJnxyMdsKemLaemDio01J7LKURr4YyKlM9j0NDub03FNVYDWVUHjqJ8CK3ut7DBnVKenbpK78lltUmNnJEn1i6Jykx37BsL4PRk/VqMCMJPcwwNOJlmWa6jmVQpvqUAT+yPhgufrR0rTFopzGjfejZoSvos9u1wqhIy1KkeiJeNPh6h6NRlWYUGMclrZRf5bUMiiM2zIU+dLd1jTqaT+yzOYXbFBr6uVzMxD/FQctmny4y8lojjXb7TFgnMXO5UUNa16jtNg19ldD7BtV1jUF9FkZlFJabFBqjletTzE0K+oDS+1+Q9bymQV65RrjBNdPFWv2H6ewtI16eFv4tJb1CFetNGh8RSuydXJ+L6m0rpcTeuspgvXL6XI0o0mORUm/TKKWffHSnX9eQ966UkcLbVspI4a0rhdu7y2s4nW1pPPoKZL28RpurPpv3zbXQ6uaaaVgaPa1SL8or5BsPCo3XDgp59MxEtGyOl8Xxyo882Oa1l6fuiL4byWsHpzza5wMtp9FAdfV0nsvosCCLJ/o+dFVkWOsBfbDRjatFUOqt5Peut4HCcG97UxRDhTdF8cb99bXCV/26uz+cr37reTGp82H3/bj3rz+fT/cXV5/+f8QV/Fb0eH643/94Pu9NafnBSP980RdJW/1d4qu9p9Ov+lphS63Y12hXya7K1xdz5i8=",
      "is_unconstrained": true,
      "name": "get_claim_agent"
    },
    {
      "abi": {
        "error_types": {
          "10708939150157633029": {
            "error_kind": "string",
            "string": "Function get_comment_author can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnbbhs5DIbfxde5kCiRkvIqRVGkqVsYMJzATRZYFHn3JTX8ZTuLEVInuYk/c6J/eNJhxn82P7bfn3992x1+Pvze3H75s/l+3O33u1/f9g/3d0+7h4Na/2yC/am8uU03m6Zfin7otxhvNjHo95gNzKJXYkwK1aA6kDikuLklG5XUQqSQM6ApiAKrJdn/cHOQBKgOBZYCS4WlFocWAbIAmasLMMBuoXenFAAZgEsZlgwLw8LVQQhQHEoEiEPFLXoiO5hgUGgJUBdIgQDiECOAAT48UQbAkhKgOGQIZliKjcoG1aHnsAMsDZbmltwd6yAO3bEO7EABYLdgg+qQCCAOPZnaNrnYpWogDj1jHTKgOnTHOmg4WcPhEAHiEGGJsBAsBEuCxRKVtSU4R4A4MCzMDhIA6lgmg+pgUSwgDlbunAyagzm/gN1UEyWW1Q4xANghecKll9IgR4CXQBgW9hKIBICXQMRLIIUAXgJpXoISvQQlegkKBUAGeAlKSgAvQckR4OktDAvDIrAILAWW4iUoNQK8BKXB0rwENQSAl6AGL0GNBPASVLJRYmAl0EirTfMONi8WKA69uE3B5gWrY7USQBxsEVwgA9oCLWhamAyKg/mzACwEC8GSYEmwZGuSalAcejI7MMBuamuyVXkB81lr2myFXACW7ryBJVPMVZvUFqmu4TRIQDEMUnXpa33yTCgVUB42K7tQ3wrioGGzvErqxBghDVTyoGGz9cipgtqwNXgQbeo78SCo9F1ooT6Vlh1KQDkMyoN0hNiWFsXnQYx9PV9o2Gx9Eu7EoDZs1hoinZqPoJAGVVAcNuuPhYgGDVuKg3jQUM5DhcdYQZRUwqA8qIKsv3u8Kfh0V8I9Uhy23gfcqYFo2Gxh6PEmrAxx2X46ZRo0bBwHIadJhk2GB4IoUxnKZajUPvbl5WaDM8u3p+N2a0eWs0OMHm0e747bw9Pm9vC8399s/rnbP/d/+v14d+ifT3dHvaqdsj380E8V/Lnbb41ebk6jw/pQSrX5aMqhDQHtowuJuC6hPSXVNZRLGSIlXmjQukYitnneNZR14IrGLJQa4QY1iquh5ImEHgjCSEcsp4SWfKHBH5AO+dx0ZD3YuUROXFbTUSehUBJEQiwnCW2Uc4n2AdmI4QPSMYslxQQ/dLavxhLpI4JJnxwMFRqFaeuFiZM+1ZMKYimN8mooszZNkqGh3N4bimqshjJrD00ivOBW19ewSZ/q80waM7+lLKuL2MyRlGh4klLOV0zb82AkhNVgZguhNBmxSGsnEabLWCZtqg8e8EMfPc5W05YuNfJsvozl46wsSeqlwqRJc22QyO1se0o1v90LhgQFWveiTKZKOU2VGvmkkS/3WaqzuqLNczw1F/Gr7pq1qL4eQCB0lovXGinMqordnlO4TqFhV5GzTPxVHHQ6cqSzivzPizSrKaHD9eVLuVJD2tCo7TqNFIaGnibXNSaraMnojJLlKoWWsaE0vs6HGGiswvqss67RZnM1wo1cmc5WjL9Ip70/8HTylWVNo0MV61UaHxFKHPuJPZ1dN1NKHEtXmczXzJ+roc+UIxYp9TqNUsb5S88b6xr1vTNlpvC2mTJTeOtM4fju9pqms50WHn03s95esy0+Co8tvtDqFs952hqjrFLP2ivwtceVtnZcYZltKnTaHM+b45UfPNnmdS1PWH6UmdeObzzb5wOdzsSB6uozArfZYUFOnrDIqsi01wPWwUZXzhZBq7fC751vE4Xp3vamKKYKb4rijfvra4Wv+vXufne8+PHpxaSOu7vv+61//fl8uD+7+vTvI67gx6vH48P99sfzcWtKp1+w9M8XfbF1oy+tvtobRP2qjyc3+quLfY12lexq+fpizvwH",
      "is_unconstrained": true,
      "name": "get_comment_author"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6343299670262723826": {
            "error_kind": "string",
            "string": "Function get_comment_content_hash can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnbTis7DIbfpde9SOzYSXiVJYQKlKVKVUFdsKUtxLtvO2OnU7Ym6ipwQ796yD8+5TDT99Xj9v7t993u8PT8Z3Xz6311f9zt97vfd/vnh83r7vkg1vdV0D+FVje4XlX5kuVDvsW4XsUg32NSUItciREFikIxADbAuLoBHYViARBIyaEKsACJBfV/qBowOhSD7JbsluKWkg1qdOAJQF2dgBz0FnJ3wOCQHPxScktyC7mFigGDQzbI0YENit+iJbKBCgaBig5lAgzgwAYxOpCDDUdIDm5BdMgGyQWTW7KOSgrFoOWwgVuqW6pZUnOsARs0xxqQAQQHvQUpFAMEBzZoyZS2SVkvFQU2aBlrkByKQXOsgYSTJBwK0YENoluiW8At4BZ0iyYqSUtQig5sQG4hMuDgII4lUCgGGsUEbKDlTqhQDdT5CfSmkijWrDaIwYEM0BLOrZQKKTpYCZjcQlYC5uBgJWC2EnAGBysBVytBjlaCHK0EGYJDcrASZEQHK0FO0cHSm8kt5BZ2C7sluyVbCXKJDlaCXN1SrQQlBAcrQQlWghLBwUpQQEexgpZAIi06zRvovJggG7TiVgGdFySOlQIObKCL4ATJoU5Qg6SFQCEbqD8TuAXcAm5Bt6BbkjZJUcgGLZkNyEFvqmuyVnkC9VlqWnWFnMAtzXkFTSarqzqpNVJZw6ETO8XQSdS5rfVomRDKTqnbtOwMbSuInbpN88rYiHwEV6ecOnWbrkdGxal2W3UPok59I+rkKm0XmqhNpWmHYqcUOqVOMoJ1S4ts8yDGtp5P1G26PjE1IqfabdoazI2qjYCAnYpT7Dbtj4kAOnUbxk7UqSunrkJ9LHuUkEOn1Kk4aX+3eDHYdBfye2DsttYH1Kg6QbfpwtDiRV8Z4rT9NErQqdsodvKcIncbdw/Yo8TclXNXKW3sx8d65WeWu9fjdqtHltkhRo42L5vj9vC6ujm87ffr1T+b/Vv7pz8vm0P7fN0c5ap0yvbwKJ8i+LTbb5U+1qfRYXkoYKk2GlKoXUD66EwiLktIT3ExDeGcu0iOZxqwrIFAOs+bhrAMXNAYhVKiuwEV4mIoaSAhB4LQ0xHzKaE5nWnQN6SDfzYdSQ52JpGQ8mI6yiAUQPZIgPgkIY0yl6jfkI0YviEdo1gwovshs30xlgjfEQz+cDCQoRemLhcmDvpUTioeS66QFkMZtSlycg3h+tVQRGMxlFF7SBLdC6pleQ0b9Kk8z2Cf+RUTLy5iI0cQoXuCmNIV03YeDIewGMxoIWQKfSVkmrlBcB7LoE3lwcP9kEeP2Wpa8VwjjeZLXz5mZUEu5wqDJk2lukSqs+0JS7rcC3IJCLDsRR5MlXyaKiXSSSOd77NQRnX1Nk/x1FxAn7pr1KLyesADgVkuPmtgGFXVd3vCcJ1C9V2FZ5n4qzjgdOTAWUX+5wWOago+W+XlS75Sg2vXKPU6DQxdQ06TyxqDVTQn74yc+CqFmnxDqXSdDzFAX4XlWWdZo47manQ3UiGYrRh/kU59f2DppCvLir1DBctVGt8RSuz7iT6dXTdTcuxLVx7M10Q/qyHPlD0WzuU6jZz7+UvOG8sa5aszZaRw2UwZKVw6Uyh+ub2G6aynhUfezSy312iLj0x9i8+wuMVTGrZGLyuXWXsFuvK4Qrh0XCEebSpw2hznzfHJDxps87KWoy8/wkRLxzca7fMBTmfiAGXxGYHq6LDAJ0+IeVFk2OvB18EKV84W9lavmb463wYKw73toiiGChdFceH++lnhVr5uHnbHsx+fPlTquNvc77f29ent8DC7+vrvi1/xH69ejs8P28e341aVTr9gyZ9f8mJrLS+tbvUNonyVx5O1/OqiX6NeBb2abz/Umf8A",
      "is_unconstrained": true,
      "name": "get_comment_content_hash"
    },
    {
      "abi": {
        "error_types": {
          "15584638513261197059": {
            "error_kind": "string",
            "string": "Function get_comment_count can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDABMvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQXYR8IoJ843AzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVbLboMwEPwXn33w7vrJr1RRRBJSISESUahURfx7lwjzqGQf2vSCZ+3sZGe8GD/EpToN78e6vd4+RPH2EKeubpr6/djczmVf31qefQg1PRyIgqRwVhROCs8RAI8cgpYiTDHPh8CjlwKUngFgBE4UyCmAPIPIgFQEhgFng1YRMC8GBgYieM6MoxSxtmPfVdVU2qZYlnAvu6rtRdEOTSPFZ9kMzx993Mv2OfZlx6tKiqq98MiE17qpJjTKNVulU5F8mLNRq7AQANgdBaQpwCvrZw7Gzi0kDnYcmOYgNMbMHIw5McGRk+IhloEBISlFZyg0GLXYAW411Okdh3mBHfZ/7dBo3UyhybikHT4jBclGJWjsSqHCjiK8wA1QL7Ajp4WAYh1ElNQC+Aox9M9i0OGyMSG9MZDpU+cXLS6gTkrJtSlZHTkYh79KYY6klFx7sImxChN8+gzL9CkGouXND6Rt8hDLFUKESyVEWv/itd2KsUolxeQOQks2dhjjTX8Y3GvJtCniIgVxYwcqs+fIHKek2MkoRgVjkqaaHAmuTabQpz8vuU41dq3EWJsmycvBjZzt1+EHSa7feUNiv9uNI+R5fw8clue6211Zxomsq8tTU83hdWjPm9X+6x5X4pXn3t3O1WXoqolpvfcAP98IJbnDdImZAi+1OozTX38D",
      "is_unconstrained": true,
      "name": "get_comment_count"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1354009649190367750": {
            "error_kind": "string",
            "string": "Function get_comment_created_at can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTiM7DMffpde9SOzYSXiV1WrVZcuqUlVQF450hHj3Y2fszJSjiboFbuA3HuZffyXOlNfNr/3Pl98/DqeHxz+bu2+vm5/nw/F4+P3j+Hi/ez48nsT6ugn6o9DmDrebKhdZfslVjNtNDHIdk4Ja5E6MKFAUigGwAcbNHehTKBYAgZQcqgALkFhQ/4aqAaNDMchuyW4pbinZoEYHngDU1QnIQT9CPh0wOCQHv5XcktxCbqFiwOCQDXJ0YIPiH9ES2UAFg0BFhzIBBnBggxgdyMEeR0gObkF0yAbJBZNbsj6VFIpBy2EDt1S3VLOk5lgDNmiONSADCA76EaRQDBAc2KAlU9omZb1VFNigZaxBcigGzbEGEk6ScChEBzaIboluAbeAW9AtmqgkLUEpOrABuYXIgIODOJZAoRhoFBOwgZY7oUI1UOcn0A+VRLFmtUEMDmSAlnBupVRI0cFKwOQWshIwBwcrAbOVgDM4WAm4WglytBLkaCXIEBySg5UgIzpYCXKKDpbeTG4ht7Bb2C3ZLdlKkEt0sBLk6pZqJSghOFgJSrASlAgOVoIC+hQraAkk0qLLvIGuiwmyQStuFdB1QeJYKeDABroJTpAc6gQ1SFoIFLKB+jOBW8At4BZ0C7olaZMUhWzQktmAHPRDdU/WKk+gPktNq+6QE7ilOa+gyWR1VduPoe3h0KnbdBvXPAhlp7aAJqJO4gSjknqqOZBRAJ26TSvPbVBo6SfK3ZZFj0mpBH+ipE7VqXZbtfLE2FI+UbdF6MROEDq5SsT+bNsY2/xqy2ki6lSddBoxt/EWpxUgxE6127RVWZ9oc8dotmnW2myMtrKEihNgp25D6JSdUrcl9wAodOrK1FW4P1s8ymkgTeRRTiNpomzxTpOnjXHfFoRmW7XYUBeXUbdpO7d4MbkvSNDJvULuNvaIMMdO3Va6Bz4cIpauXF0lhfbs29t24yeaH8/n/V4PNIsjjhx8nnbn/el5c3d6OR63m392x5f2R3+edqf2+3l3lrvSKfvTL/ktgg+H417pbTs/HdYfBSzVnoYUaheQjrqQiOsSsQTNYdMQzrmL5HihAesaUjHdBZqGsDy4ojEKpUR3AyrE1VDSQEKOC6GnI+Y5oTldaNAnpIO/Nh0JtMebRJJWXk1HGYQCyB4JEM8S0ihLifoJ2YjhE9IxigUjuh9yEl2NJcJnBINfHAxk6IWp64WJgz6Vc4zHkiuk1VBGbYqcXEO4fjQU0VgNZdQekkT3gmpZ38MGfSqjBfvKr5h4dRMbOYII3RMZOOmGZbsMhkNYDWa0EWY5uXgsOaa5LASXsQzaVF5L3A95MVnsphUvNdJovfTtY1EW5HKpMGjSVKpLpLoYTzJfr/eCXAICrHuRB0slz0ulRJo10uWchTKqq7d5inNzAb3rrlGLyjHOA4FFLt5rYBhV1ac9YbhNoXpr8SITfxUHzEcOXFTkf17gqKbgq1W+msk3anDtGqXepoGhayCUdY3BLpqTd0ZOfJNCTT5QKt3mg7ww9V048HpdsY7WanQ3UiFY7Bh/kU79dsHSSTeWFXuHCpabND4jlNjnibzFldtWSo5968qD9ZroazUic4+Fc7lNI+d+/pLzxrpG+ehKGSlct1JGCteuFIofbq9hOuu88cg3N+vtNRrxkamP+AyrI57SsDV6Wbks2ivQjccVCmvHFeLRUIF5OC6b450fNBjzspejbz/CRGvHNxrN+QDzmThAWX1HoDo6LPDsCTGvi4zDgUU4y5fZdy+io5d7xt5nvMgIFr5+0fXyVrhx2bKvuZrpowt/oDAcsldFMVS4KoorB/17he9yubs/nC/+R/amUufD7udxb5cPL6f7xd3nf5/8jv+P7en8eL//9XLeq9L8jzb58Q1D2SLk7/pFp1zKm+cWQ9TLqHfl+CsvUd/f1Jn/AA==",
      "is_unconstrained": true,
      "name": "get_comment_created_at"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5374214884256418360": {
            "error_kind": "string",
            "string": "Function get_comment_parent_id can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndbts6DIDfJde5kEiRkvoqwzBkXToECNIiaw9wUPTdDymTstMDC1na3jSf6Yrmrygnr5tf+58vv38cTg+PfzZ33143P8+H4/Hw+8fx8X73fHg8ifR1E/RPoc0dbjdVLrJ8yFWM200Mch2TgkrkTowoUBSKAbABxs0d6CoUCYBASg5VgAVIJKj/Q9WA0aEYZJdklxSXlGxQowNPAGrqBOSgj5CnAwaH5OC3kkuSS8glVAwYHLJBjg5sUPwRLZANVGEQqOhQJsAADmwQowM52HKE5OASRIdskFxhcknWVUmhGLQYNnBJdUk1SWqGNWCDZlgDMoDgoI8ghWKA4MAGLZhSNinrraLABi1iDZJDMWiGNRB3krhDITqwQXRJdAm4BFyCLtFAJSkJStGBDcglRAYcHMSwBArFQL2YgA003QkVqoEaP4E+VALFGtUGMTiQAVrAuaVSIUUHSwGTS8hSwBwcLAXMlgLO4GAp4GopyNFSkKOlIENwSA6WgozoYCnIKTpYeDO5hFzCLmGXZJdkS0Eu0cFSkKtLqqWghOBgKSjBUlAiOFgKCugqVtAUiKdF27yB9sUE2aAltwpoX5AYVgo4sIFughMkhzpBDRIWAoVsoPZM4BJwCbgEXYIuSVokRSEbtGA2IAd9qO7JmuUJ1GbJadUdcgKXNOMVNJispmr5MbQ9HDp1mW7jGgeh7NQaaCLqJEYwKqmlGgMZBdCpyzTz3AaFpn6i3GVZ9DEpleArSupUnWqXVUtPjC3kE3VZhE7sBKGTa4nY17aNsc2v1k4TUafqpNOIuY23OHWAEDvVLtNSZV3R5o7RLNOotdkYrbOEihNgpy5D6JSdUpcltwAodOqaqWvhvra4l9NAmsi9nEbSRNn8nSZPG+O+LQjNsmq+oTaXUZdpOTd/MbktSNDJrULuMnaPMMdOXVa6BT4cIpauubqWFNrat7ftxk80P57P+70eaBZHHDn4PO3O+9Pz5u70cjxuN//sji/tn/487U7t83l3lrtSKfvTL/kUhQ+H417pbTuvDutLAUu11ZBC7Qqkoi5UxHUVsQSNYdMhnHNXkuOFDljXIRnTXaDpEJaFKzpGrpToZkCFuOpKGqiQ40Lo4Yh5DmhOFzroE8LBXxuOBFrjTUWSUl4NRxm4AsjuCRDPKqRQlirqJ0Qjhk8Ix8gXjOh2yEl01ZcIn+EMfrEzkKEnpq4nJg7qVM4x7kuukFZdGZUpcnIdwvWjroiOVVdG5SFBdCuolvU9bFCnMlqwd37FxKub2MgQROiWyMBJN7Tt0hkOYdWZ0UbIJXiFCeMcEYJLXwZlKq8lboe8mCx204qXOtKoX/r2sUgLcrnUMCjSVKqrSHUxnmS+Xm8FuQoIsG5FHrRKnlulRJp1pMs5C2WUVy/zFOfiAnpXXaMSlWOcOwKLWLzXgWGUVZ/2hOE2DdWnCi8i8Vd+wHzkwEVG/mcFjnIK3q3y1Uy+UQfXrqPU23Rg6DoQyrqOwS6ak1dGTnyThpq83SvdZoO8MPVdOPB6XrGOejW6GakQLHaMvwinfrtg4aQb04q9QgXLTTo+w5XY54m8xZXbOiXHvnXlQb8m+lodkbn7wrncpiPnfv6S88a6jvLRThlpuK5TRhqu7RSKHy6vYTjrvPHINzfr5TUa8ZGpj/gMqyOe0rA0elrl2DHbEejG48piN393XCEeDRWYh+OyON7ZQYMxL3s5+vYjTLR2fKPRnA8wn4kDlNV3BKqjwwLPlhDzupKxO7BwZ/ky++5FdPRyz9jrjBcRwcLXN13wDbnCjW3L3nM100cbf6BhOGSv8mKo4Sovrhz07zV8l8vd/eF88RvZm6o6H3Y/j3u7fHg53S/uPv/75Hf8N7an8+P9/tfLea+a5h/a5M83DGWLkL/rF51yKW+eWwxRL6PeleOvvER9f1Nj/gM=",
      "is_unconstrained": true,
      "name": "get_comment_parent_id"
    },
    {
      "abi": {
        "error_types": {
          "11187874927356395033": {
            "error_kind": "string",
            "string": "Function get_comment_post_id can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQcAEREBS0IRAElAAAASiUAAABQLQIBRScCAgRFJwIDBAE7DgADAAInAEMEAyYlAAAFhx4CAAIAHgIAAwAeAgAEAB4CAAUAMyoABAAFAAYnAgQBASQCAAYAAACDJQAABa0eAgAFCSQCAAUAAACVJQAABb8cCgEFACcCAQAALQgBBicCBwQEAAgBBwEnAwYEAQAiBgIHLQoHCC0OAQgAIggCCC0OAQgAIggCCC0OAQgrAgAHAAAAAAAAAAACAAAAAAAAAAAtCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkKLQ4BCgAiCgIKLQ4BCgAiCgIKLQ4BCgAiCgIKLQ4HCi0IAQcAAAECAS0OBgctCAEGAAABAgEtDggGLQgBCQAAAQIBJwIKBAAtDgoJLQgBCwAAAQIBJwIMAQAtDgwLJwINABUnAg4EASQCAAwAAAG9IwAAAXYtCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMPLQ4NDwAiDwIPLQ4BDwAiDwIPLQ4BDy0OAgctDggGLQ4OCS0ODAsjAAACSS0KCgIjAAABxgwiAkMDJAIAAwAABQEjAAAB2C0LBwItCwYDLQsLCC0LAw8AIg8CDy0ODwMtCAEPJwIQBAUACAEQAScDDwQBACIDAhAnAhEEBAAiDwISPw8AEAASLQICAycABAQEJQAABdEtCAUDACoDDhAtDg0QLQ4DBy0ODwYtDg4JLQ4ICyMAAAJJLQsHAi0LBgMtCwsICioIDA0kAgANAAACaycCDwQAPAYPASQCAAwAAAKtIwAAAngnAggEAi0CAgMnAAQEBCUAAAXRLQgFDQAqDQgPLQ4FDy0ODQctDgMGLQ4ICS0ODAsjAAADOS0KCgIjAAACtgwiAkMDJAIAAwAABHsjAAACyC0LBwItCwYDLQsLCC0LAw0AIg0CDS0ODQMtCAENJwIPBAUACAEPAScDDQQBACIDAg8nAhAEBAAiDQIRPw8ADwARLQICAycABAQEJQAABdEtCAUDACoDDg8tDgUPLQ4DBy0ODQYtDg4JLQ4ICyMAAAM5LQsLAwoqAwwFJAIABQAAA1MnAggEADwGCAEtCgoCIwAAA1wMIgJDAyQCAAMAAAP1IwAAA24tCwcCLQsGAy0LCQUtCwMIACIIAggtDggDLQgBCCcCCgQFAAgBCgEnAwgEAQAiAwIKJwINBAQAIggCDz8PAAoADy0OAgctDggGLQ4FCS0OBAsAKggOAy0LAwIKKgIBAwoqAwwBJAIAAQAAA98lAAAGMC8KAAIAARwKAQMFHAoDAgAcCgIBBSYtCwcDLQsGBS0LCQgtCwsKDCoCCA0kAgANAAAEFyMAAARtACIFAg8AKg8CEC0LEA0AIgMCEAAqEAIRLQsRDwAqDQ8QLQIFAycABAQFJQAABdEtCAUNACINAg8AKg8CES0OEBEtDgMHLQ4NBi0OCAktDgoLIwAABG0AKgIOAy0KAwIjAAADXC0LBwMtCwYILQsJDS0LCw8MKgINECQCABAAAASdIwAABPMAIggCEQAqEQISLQsSEAAiAwISACoSAhMtCxMRACoQERItAggDJwAEBAUlAAAF0S0IBRAAIhACEQAqEQITLQ4SEy0OAwctDhAGLQ4NCS0ODwsjAAAE8wAqAg4DLQoDAiMAAAK2LQsHAy0LBggtCwkPLQsLEAwqAg8RJAIAEQAABSMjAAAFeQAiCAISACoSAhMtCxMRACIDAhMAKhMCFC0LFBIAKhESEy0CCAMnAAQEBSUAAAXRLQgFEQAiEQISACoSAhQtDhMULQ4DBy0OEQYtDg8JLQ4QCyMAAAV5ACoCDgMtCgMCIwAAAcYoAAAEBHhGDAAABAMkAAADAAAFrCoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFm0NQ+HSTvhk8BAIBJi0BAwYKAAYCByQAAAcAAAXnIwAABfAtAAMFIwAABi8tAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAGKi0BCggtBAgLAAAKAgoAAAsCCyMAAAYGJwEFBAEmKgEAAQW6uyHXgjMYZDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndbts6DIDfJde5kEiRkvoqwzBkXToECNIiaw9wUPTdDymTstMDC1na3jSf6Yrmrygnr5tf+58vv38cTg+PfzZ33143P8+H4/Hw+8fx8X73fHg8ifR1E/RPoc0dbjdVLrJ8yFWM200Mch2TgkrkTowoUBSKAbABxs0d6CoUCYBASg5VgAVIJKj/Q9WA0aEYZJdklxSXlGxQowNPAGrqBOSgj5CnAwaH5OC3kkuSS8glVAwYHLJBjg5sUPwRLZANVGEQqOhQJsAADmwQowM52HKE5OASRIdskFxhcknWVUmhGLQYNnBJdUk1SWqGNWCDZlgDMoDgoI8ghWKA4MAGLZhSNinrraLABi1iDZJDMWiGNRB3krhDITqwQXRJdAm4BFyCLtFAJSkJStGBDcglRAYcHMSwBArFQL2YgA003QkVqoEaP4E+VALFGtUGMTiQAVrAuaVSIUUHSwGTS8hSwBwcLAXMlgLO4GAp4GopyNFSkKOlIENwSA6WgozoYCnIKTpYeDO5hFzCLmGXZJdkS0Eu0cFSkKtLqqWghOBgKSjBUlAiOFgKCugqVtAUiKdF27yB9sUE2aAltwpoX5AYVgo4sIFughMkhzpBDRIWAoVsoPZM4BJwCbgEXYIuSVokRSEbtGA2IAd9qO7JmuUJ1GbJadUdcgKXNOMVNJispmr5MbQ9HDp1mW7jGgeh7NQaaCLqJEYwKqmlGgMZBdCpyzTz3AaFpn6i3GVZ9DEpleArSupUnWqXVUtPjC3kE3VZhE7sBKGTa4nY17aNsc2v1k4TUafqpNOIuY23OHWAEDvVLtNSZV3R5o7RLNOotdkYrbOEihNgpy5D6JSdUpcltwAodOqaqWvhvra4l9NAmsi9nEbSRNn8nSZPG+O+LQjNsmq+oTaXUZdpOTd/MbktSNDJrULuMnaPMMdOXVa6BT4cIpauubqWFNrat7ftxk80P57P+70eaBZHHDn4PO3O+9Pz5u70cjxuN//sji/tn/487U7t83l3lrtSKfvTL/kUhQ+H417pbTuvDutLAUu11ZBC7Qqkoi5UxHUVsQSNYdMhnHNXkuOFDljXIRnTXaDpEJaFKzpGrpToZkCFuOpKGqiQ40Lo4Yh5DmhOFzroE8LBXxuOBFrjTUWSUl4NRxm4AsjuCRDPKqRQlirqJ0Qjhk8Ix8gXjOh2yEl01ZcIn+EMfrEzkKEnpq4nJg7qVM4x7kuukFZdGZUpcnIdwvWjroiOVVdG5SFBdCuolvU9bFCnMlqwd37FxKub2MgQROiWyMBJN7Tt0hkOYdWZ0UbITH0nlCP2vKsTXPoyKFN5LXE75MVksZtWvNSRRv3St49FWpDLpYZBkaZSXUWqi/Ek8/V6K8hVQIB1K/KgVfLcKiXSrCNdzlkoo7x6mac4FxfQu+oalagc49wRWMTivQ4Mo6z6tCcMt2moPlV4EYm/8gPmIwcuMvI/K3CUU/Bula9m8o06uHYdpd6mA0PXgVDWdQx20Zy8MnLimzTU5AOl0m02yAtT34UDr+cV66hXo5uRCsFix/iLcOq3CxZOujGt2CtUsNyk4zNciX2eyFtcua1TcuxbVx70a6Kv1RGZuy+cy206cu7nLzlvrOsoH+2UkYbrOmWk4dpOofjh8hqGs84bj3xzs15eoxEfmfqIz7A64ikNS6OnlcuivALdeFxZtOy74wrxaKjAPByXxfHODhqMednL0bcfYaK14xuN5nyA+UwcoKy+I1AdHRZ4toSY15WM3YGFO8uX2XcvoqOXe8ZeZ7yICBa+vumCb8gVbmxb9p6rmT7a+AMNwyF7lRdDDVd5ceWgf6/hu1zu7g/ni9/I3lTV+bD7edzb5cPL6X5x9/nfJ7/jv7E9nR/v979eznvVNP/QJn++YShbhPxdv+iUS3nz3GKIehn1rhx/5SXq+5sa8x8=",
      "is_unconstrained": true,
      "name": "get_comment_post_id"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4986039336305063277": {
            "error_kind": "string",
            "string": "Function get_comment_votes can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_comment_votes"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3498960012662131245": {
            "error_kind": "string",
            "string": "Function get_min_public_hours can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDACgvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQUwjs2X3gXKLTwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVbLboMwEPwXn33w7vrJr1RRRBJSISESUahURfx7lwjzqGQf2vSCZ012sjNebD/EpToN78e6vd4+RPH2EKeubpr6/djczmVf31qefQg1PRyIgqRwVhROCs8RAI8cgpYiTDHPh8CjlwKUngFgBE4UyCmAPIPIgFQEhgFng1YRMC8GBgYieM6MoxSxtmPfVdVU2qZYlnAvu6rtRdEOTSPFZ9kMzx993Mv2OfZlx2+VFFV74ZEJr3VTTWiUa7ZKpyL5MGejVmEhALA7CkhTgFfWzxyMnVtIHOw4MM1BaIyZORhzYoIjJ8VDLAMDQlKKzlBoMGqxA9xqqNM7DvMCO+z/2qHRuplCk3FJO3xGCpKNStDYlUKFHUV4gRugXmBHTgsBxTqIKKkF8BVi6J/FoMNlYUJ6YSDTp84vWlxAnZSSa1OyOnIwDn+VwhxJKbn2YBNjFSb49B6W6VMMRMuXH0jb5CaWK4QIl0qItP7FZ7sVY5VKisluhMZGTxlv+sPgXkumTREXKYgbO1CZPUdmOyXFTkYxKhiTNNXkSHBtMoU+fbzkOtXYtRJjbZokLwc3cranww+SXL9bigcu2I0j5Hl9DxyW57rbXVnGiayry1NTzeF1aM+bt/3XPb6JV557dztXl6GrJqb13gP8fCOU5A7TJWYKvNTqME5//Q0=",
      "is_unconstrained": true,
      "name": "get_min_public_hours"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8418147970250171169": {
            "error_kind": "string",
            "string": "Function get_name can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnbbhs5DIbfxde5EI+S8iqLokhTtwhgJIGbLLAo8u5LakSNHWCE1HFv4s+czG+SoiiO/Xv3ff/t9efXh8cfT792t//83n07PhwODz+/Hp7u714enh7N+nuX/E/W3S3d7ArsbrO92DuAm121t8D26u/NDokNikPtALkD4u4WwcEsiAYkHdg+gvwSS0DtIBwQFg2LhiVTQO5QMEA7uKcL+EfYhyJoB0wBcYnCQmHhsDAHlA5CAbmDYkB8RIYAF0wOtUPhgNKhYkBegBIE9NsJUsCwdEFCCuiCRGFRv4sdOKB2yGHJYSlhaY45NMca5AW4OdZAOzTHxIEDSgcvgAYtmVYtLH7JaoNbxhpoh5wCOKB2KBYOJ4fcwR1boFskYUBYICwQFk8Ug0PuQBgQFoYA7SDmGKMDB5QOHkUDX24mBwmoHZrz7FA6+N5xUE9mg7aCDXrmlTCgZ145LNwzrwIBsuRZ25ZxUArIHYosS5ATLVnNnqgGAAES0DOfkQPKksNMGNCzmjksHBYJi4RFw6JlyWrOGNAzn0tYSs98rhAgS55zrQsUj2KB3MF3N6uB7272luW7u4FvhwVKB08dV29rJijmWPGWskDu4J1vAelQU4ClRfxDa1mguj8LhAXCAmHBsGBYyCuqOJQOLZkNtIOXn5CDBLjP6j3Y3bAoqidTzbFaUoD9s9q617ZT/H9a1VVv1CkN4kHmgKoT6hIkJIJBw+Y7WZe+L0EybL5DtB0GUuMOpUElKA9bZBuSL3+nYavDgyqDQhlSqADEveDee5kDUBrEg0qQ51k9ctDed4wkKA+bN6PclH1DL1SGzbd09jMGKsUdtW8rwISDhi32Giyn0XJMDhvKoBpENGio8LhXI0pUHhRRotdFJ+3xYuW4t8ZnUOJBpcdGXr+dhs0beouXMHwhgkHhFfGwcUREkgattuGB0qChnIdKafe+vd3sYk75+nLc731MORlcbJx5vjvuH192t4+vh8PN7t+7w2v7p1/Pd4/t9eXuaFctlv3jd3s1wR8Ph73T2816d9q+FanUfreNCHUIWPWcScC2BJTke6RpGOc8RDKcaeC2BqGIdA1ju3FDYxZKgXDDJhDYDIUnEgySRjps26xu8JmGXCEd+nfTweg9rEkwSd5MR5mEgqQRCYquElYopxL1CtmAdIV0zGKxBhB+2Dy5GQvgNYKhvxyMdcKxMHV7YWBSpzaWRCy5Im+GMitTG8NDw7h+NhTT2AxlVh7iPXzxQmrZ7mGTOsVKNHa+zTG62cRmjhDh8ISI+YJtexqMprQZzKwRStIRi9ggMkQEz2OZlKkwxtIK81rpmOhcY9JObdiPFqT2OLWtMSlTO8tHPuyBeVtjUqc2XUc+bAevsRCfn5OYJ9slr9ulgGxrlNnaRqkzrAWG8q7CZmVqXwPEyuLJcf1egyblIRgnvlC6TKGOZT3JxB/FgevYQQm3vZhUKAjGqtqXLPlCDa1Do9TLNCgNDfvKYltjUqGZozIy60UKleNQqXKZD/aoNDpx0u11pcm6coFwg4us6wr1D9LpXyH0dMqFy0qjQg3LRRrXCAVG37EntHLZTskQMxjmyX5l+bsaoONMAc3lMo2cxwxmM8e2RvnsTpkpfGynzBQ+ulMEPl1e03TWtfFU3E7n9IhmXY/o0yV5d7wKX2EsFrnCWDyPBnVEI7IdTf70XCzlCnPxxwewyeAz05Dx0CP2Ve6mhs4e79ej2k+6VYPPH4l19nifKkVTNz5ZmffPxLMHp4RrVhOW7Qdrno1gunoiqpsi0w6SYs9UvLAHaTSQmuWzXWyiMJ0YPhTFVOFDUXxwanmv8MXe3t0/HM9+yntzqePD3bfDvr/98fp4f3L15b/nuBI/BT4fn+7331+Pe1dafw+0P/9Qohv7EvCLfw9rb9GGa3uc9rfgV9Gvypc3d+Z/",
      "is_unconstrained": true,
      "name": "get_name"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13917265889930826957": {
            "error_kind": "string",
            "string": "Function get_post_author can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnbbhs5DIbfxde5kHiSlFcpiiJN3cKA4QRussCiyLsvqSFlO4sRUie5ib/hRP/wpMPYfzY/tt+ff33bHX4+/N7cfvmz+X7c7fe7X9/2D/d3T7uHg1r/bJL9qby5xZtN04uiH3qV880mJ73OZGAWvZMzKlSD6gDigHlzCzYK1QKgQBTQFESB1YL2P9wcBAOqQwlLCUsNSy0OLQfIAmCuLsAB9gh9OmAKoIC4RWGhsHBYuDoIBBSHkgPEocYjeiI7mGBSaBhQF8AEAeKQcwAH+HAECggLYkBxoBCksBQbRQbVoeewQ1haWJpbqDvWQRy6Yx3YAVKAPYINqgNCgDj0ZGrbULFb1UAcesY6UEB16I510HBIw+GUA8QhhyWHBcICYcGwWKJIW4IpB4gDh4XZQVKAOkZgUB0sigXEwcpNaNAczPkF7KGaKLGsdsgpgB3QEy69lAaUA7wEwmFhL4FICvASiHgJpECAl0Cal6BkL0HJXoICKYACvAQFMcBLUCgHeHoLh4XDImGRsJSwFC9BqTnAS1BaWJqXoKYU4CWoyUtQMwR4CSrYKDGwEmik1aZ5B5sXCxSHXtymYPOC1bFaIUAcbBFcgALaAi1pWhgMioP5s0BYICwQFgwLhoWsSapBcejJ7MAB9lBbk63KC5jPWtNmK+QCYenOG1gyxVy1SW2R6hoOgyQop0GqLn2tR8+EUgmiYbOyC/StIA8aNsurYCeOEdKCCg0aNluPnGpQG7YWHmSb+k48KFT6LrRQn0rLDiVBlAbRIB0htqVl8XmQc1/PFxo2W5+EO3FQGzZrDZFOzUdAwkE1KA+b9cdCAIOGDfMgHjSUaajwGCsRJZQ0iAbVIOvvHi8mn+5K8QzMw9b7gDu1IBg2Wxh6vBgrQ162n04Eg4aN86DIKcqwyfBAIkosQ7kMldrHvrzcbOLM8u3puN3akeXsEKNHm8e74/bwtLk9PO/3N5t/7vbP/Z9+P94d+ufT3VHvaqdsDz/0UwV/7vZbo5eb0+i0PhSwNh8NlNoQ0D66kMjrEtpTUl1DuZQhUvKFBqxrILDN866hrANXNGah1BxuQIO8GgpNJPRAkEY6cjkltNCFBn9AOuRz00F6sHMJQi6r6aiTUAAlIgGWk4Q2yrlE+4Bs5PQB6ZjFghnDD53tq7Fk+Ihg8JODgQKjMG29MHnSp3pSiVhKA1oNZdamKBQayu29oajGaiiz9tAkhhfc6voaNulTfZ/BMfMbkqwuYjNHEGF4gkh0xbQ9D0ZSWg1mthAyV4pYWPKpLAyXsUzaVF88wg999ThbTRteatBsvozl46wsKPVSYdKkVFtIUDvbnrDS273gkIAE616UyVQpp6lSM5806HKfhTqra7Q55VNzAb/qrlmL6tcDEQic5eK1BqZZVWO3Z0zXKbTYVeQsE38VB5yOHHhWkf95gbOaQsxW/fKlXKkhbWjUdp0GpqGhp8l1jckqWig6o5BcpdAoNpTG1/mQE4xVWN911jXabK7mcIMqw9mK8RfpJBrp5CvLiqNDFetVGh8RSh77ib2dXTdTSh5LV5nMV+LP1dB3yhGLlHqdRinj/KXnjXWN+t6ZMlN420yZKbx1pnB+d3tN09lOC49+N7PeXrMtPguPLb7A6hbPNG2NUVapZ+2V+MrjCqS14wrLbFOB0+Z43hyv/ODJNq9rOYYjysxrxzee7fMJTmfiBHX1HYHb7LAgJ09YZFVk2usp1sEGV84WiVZvhd873yYK073tTVFMFd4UxRv319cKX/Xy7n53vPjx6cWkjru77/utX/58Ptyf3X369zHuxI9Xj8eH++2P5+PWlE6/YOmfL/rF1o1+afXVvkHUS309udFfXewy212wu+XriznzHw==",
      "is_unconstrained": true,
      "name": "get_post_author"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7039288653030155395": {
            "error_kind": "string",
            "string": "Function get_post_content_hash can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnbbhs5DIbfxde5kHiSlFcpiiJN3cKA4QRussCiyLsvqSFlO4sRUie5iT9zon940mHGfzY/tt+ff33bHX4+/N7cfvmz+X7c7fe7X9/2D/d3T7uHg1r/bJL9qby5xZtN0y9FP/RbzjebnPR7JgOz6JWcUaEaVAcQB8ybW7BRqBYABaKApiAKrBa0/+HmIBhQHUpYSlhqWGpxaDlAFgBzdQEOsFvo3QFTAAXEJQoLhYXDwtVBIKA4lBwgDjVu0RPZwQSTQsOAugAmCBCHnAM4wIcjUEBYEAOKA4UghaXYKDKoDj2HHcLSwtLcQt2xDuLQHevADpAC7BZsUB0QAsShJ1Pbhopdqgbi0DPWgQKqQ3esg4ZDGg6nHCAOOSw5LBAWCAuGxRJF2hJMOUAcOCzMDpIC1DECg+pgUSwgDlZuQoPmYM4vYDfVRIlltUNOAeyAnnDppTSgHOAlEA4LewlEUoCXQMRLIAUCvATSvAQlewlK9hIUSAEU4CUoiAFegkI5wNNbOCwcFgmLhKWEpXgJSs0BXoLSwtK8BDWlAC9BTV6CmiHAS1DBRomBlUAjrTbNO9i8WKA49OI2BZsXrI7VCgHiYIvgAhTQFmhJ08JgUBzMnwXCAmGBsGBYMCxkTVINikNPZgcOsJvammxVXsB81po2WyEXCEt33sCSKeaqTWqLVNdwGCRBOQ1SdelrPXomlEoQDZuVXaBvBXnQsFleBTtxjJAWVGjQsNl65FSD2rC18CDb1HfiQaHSd6GF+lRadigJojSIBukIsS0ti8+DnPt6vtCw2fok3ImD2rBZa4h0aj4CEg6qQXnYrD8WAhg0bJgH8aChTEOFx1iJKKGkQTSoBll/93gx+XRXintgHrbeB9ypBcGw2cLQ48VYGfKy/XQiGDRsnAdFTlGGTYYHElFiGcplqNQ+9uXlZhNnlm9Px+3Wjixnhxg92jzeHbeHp83t4Xm/v9n8c7d/7v/0+/Hu0D+f7o56VTtle/ihnyr4c7ffGr3cnEan9aGAtflooNSGgPbRhURel9CekuoayqUMkZIvNGBdA4FtnncNZR24ojELpeZwAxrk1VBoIqEHgjTSkcspoYUuNPgD0iGfmw7Sg51LEHJZTUedhAIoEQmwnCS0Uc4l2gdkI6cPSMcsFswYfuhsX40lw0cEg58cDBQYhWnrhcmTPtWTSsRSGtBqKLM2RaHQUG7vDUU1VkOZtYcmMbzgVtfXsEmf6vMMjpnfkGR1EZs5ggjDE0SiK6bteTCS0mows4WQCSOnysJDhOEylkmb6oNH+KGPHmeracNLDZrNl7F8nJUFpV4qTJqUagsJamfbE1Z6uxccEpBg3YsymSrlNFVqPqUT6XKfhTqra5SE8qm5gF9116xF9fVABAJnuXitgWlW1djtGdN1Ci12FTnLxF/FAacjB55V5H9e4KymELNVX76UKzWkDY3artPANDT0NLmuMVlFC0VnFJKrFBrFhtL4Oh9ygrEKJ1mvK7bZXM3hBlWGsxXjL9Jp7w88nXxlWXF0qGK9SuMjQsljP7Gns+tmSslj6SqT+Ur8uRr6TDlikVKv0yhlnL/0vLGuUd87U2YKb5spM4W3zhTO726vaTrbaeHRdzPr7TXb4rPw2OILrG7xTNPWGGWVetZeia88rhRaO66wzDYVOG2O583xyg+ebPO6lmMsP8rMa8c3nu3zCU5n4gR19RmB2+ywICdPWGRVZNrrKdbBBlfOFom6tMLvnW8Thene9qYopgpviuKN++trha/69e5+d7z48enFpI67u+/7rX/9+Xy4P7v69O9jXIkfrx6PD/fbH8/HrSmdfsHSP1/0xdaNvrT6am8Q9as+ntzory72NdtVsKvl64s58x8=",
      "is_unconstrained": true,
      "name": "get_post_content_hash"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5178739621314325697": {
            "error_kind": "string",
            "string": "Function get_post_count can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAsvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVH3pQ/WK5swTwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVbLboMwEPwXn33w7vrJr1RRRBJSISESUahURfx7lwjzqGQf2vSCZ012sjNebD/EpToN78e6vd4+RPH2EKeubpr6/djczmVf31qefQg1PRyIgqRwVhROCs8RAI8cgpYiTDHPh8CjlwKUngFgBE4UyCmAPIPIgFQEhgFng1YRMC8GBgYieM6MoxSxtmPfVdVU2qZYlnAvu6rtRdEOTSPFZ9kMzx993Mv2OfZlx2+VFFV74ZEJr3VTTWiUa7ZKpyL5MGejVmEhALA7CkhTgFfWzxyMnVtIHOw4MM1BaIyZORhzYoIjJ8VDLAMDQlKKzlBoMGqxA9xqqNM7DvMCO+z/2qHRuplCk3FJO3xGCpKNStDYlUKFHUV4gRugXmBHTgsBxTqIKKkF8BVi6J/FoMNlYUJ6YSDTp84vWlxAnZSSa1OyOnIwDn+VwhxJKbn2YBNjFSb49B6W6VMMRMuXH0jb5CaWK4QIl0qItP7FZ7sVY5VKislthAZD7DA0hGuzG9xrybQp4iIFcWMHKrPnyGynpNjJKEYFY5KmmhwJrk2m0KePl1ynGrtWYqxNk+Tl4EbO9nT4QZLrd0vxwAW7cYQ8r++Bw/Jcd7sryziRdXV5aqo5vA7tefO2/7rHN/HKc+9u5+oydNXEtN57gJ9vhJLcYbrETIGXWh3G6a+/AQ==",
      "is_unconstrained": true,
      "name": "get_post_count"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2608738334220796783": {
            "error_kind": "string",
            "string": "Function get_post_created_at can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQcAEREBS0IRAElAAAASiUAAABQLQIBRScCAgRFJwIDBAE7DgADAAInAEMEAyYlAAAFhx4CAAIAHgIAAwAeAgAEAB4CAAUAMyoABAAFAAYnAgQBASQCAAYAAACDJQAABa0eAgAFCSQCAAUAAACVJQAABb8cCgEFACcCAQAALQgBBicCBwQEAAgBBwEnAwYEAQAiBgIHLQoHCC0OAQgAIggCCC0OAQgAIggCCC0OAQgrAgAHAAAAAAAAAAACAAAAAAAAAAAtCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkKLQ4BCgAiCgIKLQ4BCgAiCgIKLQ4BCgAiCgIKLQ4HCi0IAQcAAAECAS0OBgctCAEGAAABAgEtDggGLQgBCQAAAQIBJwIKBAAtDgoJLQgBCwAAAQIBJwIMAQAtDgwLJwINAA8nAg4EASQCAAwAAAG9IwAAAXYtCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMPLQ4NDwAiDwIPLQ4BDwAiDwIPLQ4BDy0OAgctDggGLQ4OCS0ODAsjAAACSS0KCgIjAAABxgwiAkMDJAIAAwAABQEjAAAB2C0LBwItCwYDLQsLCC0LAw8AIg8CDy0ODwMtCAEPJwIQBAUACAEQAScDDwQBACIDAhAnAhEEBAAiDwISPw8AEAASLQICAycABAQEJQAABdEtCAUDACoDDhAtDg0QLQ4DBy0ODwYtDg4JLQ4ICyMAAAJJLQsHAi0LBgMtCwsICioIDA0kAgANAAACaycCDwQAPAYPASQCAAwAAAKtIwAAAngnAggEAi0CAgMnAAQEBCUAAAXRLQgFDQAqDQgPLQ4FDy0ODQctDgMGLQ4ICS0ODAsjAAADOS0KCgIjAAACtgwiAkMDJAIAAwAABHsjAAACyC0LBwItCwYDLQsLCC0LAw0AIg0CDS0ODQMtCAENJwIPBAUACAEPAScDDQQBACIDAg8nAhAEBAAiDQIRPw8ADwARLQICAycABAQEJQAABdEtCAUDACoDDg8tDgUPLQ4DBy0ODQYtDg4JLQ4ICyMAAAM5LQsLAwoqAwwFJAIABQAAA1MnAggEADwGCAEtCgoCIwAAA1wMIgJDAyQCAAMAAAP1IwAAA24tCwcCLQsGAy0LCQUtCwMIACIIAggtDggDLQgBCCcCCgQFAAgBCgEnAwgEAQAiAwIKJwINBAQAIggCDz8PAAoADy0OAgctDggGLQ4FCS0OBAsAKggOAy0LAwIKKgIBAwoqAwwBJAIAAQAAA98lAAAGMC8KAAIAARwKAQMFHAoDAgAcCgIBBSYtCwcDLQsGBS0LCQgtCwsKDCoCCA0kAgANAAAEFyMAAARtACIFAg8AKg8CEC0LEA0AIgMCEAAqEAIRLQsRDwAqDQ8QLQIFAycABAQFJQAABdEtCAUNACINAg8AKg8CES0OEBEtDgMHLQ4NBi0OCAktDgoLIwAABG0AKgIOAy0KAwIjAAADXC0LBwMtCwYILQsJDS0LCw8MKgINECQCABAAAASdIwAABPMAIggCEQAqEQISLQsSEAAiAwISACoSAhMtCxMRACoQERItAggDJwAEBAUlAAAF0S0IBRAAIhACEQAqEQITLQ4SEy0OAwctDhAGLQ4NCS0ODwsjAAAE8wAqAg4DLQoDAiMAAAK2LQsHAy0LBggtCwkPLQsLEAwqAg8RJAIAEQAABSMjAAAFeQAiCAISACoSAhMtCxMRACIDAhMAKhMCFC0LFBIAKhESEy0CCAMnAAQEBSUAAAXRLQgFEQAiEQISACoSAhQtDhMULQ4DBy0OEQYtDg8JLQ4QCyMAAAV5ACoCDgMtCgMCIwAAAcYoAAAEBHhGDAAABAMkAAADAAAFrCoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFJDQZsXssw288BAIBJi0BAwYKAAYCByQAAAcAAAXnIwAABfAtAAMFIwAABi8tAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAGKi0BCggtBAgLAAAKAgoAAAsCCyMAAAYGJwEFBAEmKgEAAQW6uyHXgjMYZDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTiM7DMffpde9SOzYSXiV1WrVZcuqUlVQF450hHj3Y2fszJSjiboFbuA3HuZffyXO0NfNr/3Pl98/DqeHxz+bu2+vm5/nw/F4+P3j+Hi/ez48nsT6ugn6o9DmDrebKhdZfslVjNtNDHIdk4Ja5E6MKFAUigGwAcbNHehTKBYAgZQcqgALkFhQ/4aqAaNDMchuyW4pbinZoEYHngDU1QnIQT9CPh0wOCQHv5XcktxCbqFiwOCQDXJ0YIPiH9ES2UAFg0BFhzIBBnBggxgdyMEeR0gObkF0yAbJBZNbsj6VFIpBy2EDt1S3VLOk5lgDNmiONSADCA76EaRQDBAc2KAlU9omZb1VFNigZaxBcigGzbEGEk6ScChEBzaIboluAbeAW9AtmqgkLUEpOrABuYXIgIODOJZAoRhoFBOwgZY7oUI1UOcn0A+VRLFmtUEMDmSAlnBupVRI0cFKwOQWshIwBwcrAbOVgDM4WAm4WglytBLkaCXIEBySg5UgIzpYCXKKDpbeTG4ht7Bb2C3ZLdlKkEt0sBLk6pZqJSghOFgJSrASlAgOVoIC+hQraAkk0qLLvIGuiwmyQStuFdB1QeJYKeDABroJTpAc6gQ1SFoIFLKB+jOBW8At4BZ0C7olaZMUhWzQktmAHPRDdU/WKk+gPktNq+6QE7ilOa+gyWR1VduPoe3h0KnbdBvXPAhlp7aAJqJO4gSjknqqOZBRAJ26TSvPbVBo6SfK3ZZFj0mpBH+ipE7VqXZbtfLE2FI+UbdF6MROEDq5SsT+bNsY2/xqy2ki6lSddBoxt/EWpxUgxE6127RVWZ9oc8dotmnW2myMtrKEihNgp25D6JSdUrcl9wAodOrK1FW4P1s8ymkgTeRRTiNpomzxTpOnjXHfFoRmW7XYUBeXUbdpO7d4MbkvSNDJvULuNvaIMMdO3Va6Bz4cIpauXF0lhfbs29t24yeaH8/n/V4PNIsjjhx8nnbn/el5c3d6OR63m392x5f2R3+edqf2+3l3lrvSKfvTL/ktgg+H417pbTs/HdYfBSzVnoYUaheQjrqQiOsSsQTNYdMQzrmL5HihAesaUjHdBZqGsDy4ojEKpUR3AyrE1VDSQEKOC6GnI+Y5oTldaNAnpIO/Nh0JtMebRJJWXk1HGYQCyB4JEM8S0ihLifoJ2YjhE9IxigUjuh9yEl2NJcJnBINfHAxk6IWp64WJgz6Vc4zHkiuk1VBGbYqcXEO4fjQU0VgNZdQekkT3gmpZ38MGfSqjBfvKr5h4dRMbOYII3RMZOOmGZbsMhkNYDWa0EVLR48sUixzwqYsQXMYyaFN5LXE/5MVksZtWvNRIo/XSt49FWZDLpcKgSVOpLpHqYjzJfL3eC3IJCLDuRR4slTwvlRLndGK6nLNQRnX1Nk9xbi6gd901alE5xnkgsMjFew0Mo6r6tCcMtylUnyq8yMRfxQHzkQMXFfmfFziqKfhqlX/N5Bs1uHaNUm/TwNA1EMq6xmAXzck7Iye+SaEmHyiVbvNBXpj6Lhx4va5YR2s1uhupECx2jL9IZ0o9nXRjWbF3qGC5SeMzQol9nshbXLltpeTYt648WK+JvlYjMvdYOJfbNHLu5y85b6xrlI+ulJHCdStlpHDtSqH44fYaprPOG4/852a9vUYjPjL1EZ9hdcRTGrZGLyuXRXsFuu24UkNaO64Qj4YKzMNx2Rzv/KDBmJe9HN0RYaK14xuN5nyA+UwcoKy+I1AdHRZ49oSY10XG4cAinOXL7LsX0dHLPWPvM15kBAtfv+iCb8gVbly27GuuZvrowh8oDIfsVVEMFa6K4spB/17hu1zu7g/ni+/I3lTqfNj9PO7t8uHldL+4+/zvk9/x79iezo/3+18v570qzV+0yY9vGMoWIX/Xf3TKpbx5bjFEvYx6V46/8hL1/U2d+Q8=",
      "is_unconstrained": true,
      "name": "get_post_created_at"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18233219403911674536": {
            "error_kind": "string",
            "string": "Function get_post_submolt can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTiM7DMffpde9SOzYSXiV1WrVZcuqUlVQF450hHj3Y2fszJSjiboFbuA3HuZffyXOlNfNr/3Pl98/DqeHxz+bu2+vm5/nw/F4+P3j+Hi/ez48nsT6ugn6o9DmDrebKhdZfslVjNtNDHIdk4Ja5E6MKFAUigGwAcbNHehTKBYAgZQcqgALkFhQ/4aqAaNDMchuyW4pbinZoEYHngDU1QnIQT9CPh0wOCQHv5XcktxCbqFiwOCQDXJ0YIPiH9ES2UAFg0BFhzIBBnBggxgdyMEeR0gObkF0yAbJBZNbsj6VFIpBy2EDt1S3VLOk5lgDNmiONSADCA76EaRQDBAc2KAlU9omZb1VFNigZaxBcigGzbEGEk6ScChEBzaIboluAbeAW9AtmqgkLUEpOrABuYXIgIODOJZAoRhoFBOwgZY7oUI1UOcn0A+VRLFmtUEMDmSAlnBupVRI0cFKwOQWshIwBwcrAbOVgDM4WAm4WglytBLkaCXIEBySg5UgIzpYCXKKDpbeTG4ht7Bb2C3ZLdlKkEt0sBLk6pZqJSghOFgJSrASlAgOVoIC+hQraAkk0qLLvIGuiwmyQStuFdB1QeJYKeDABroJTpAc6gQ1SFoIFLKB+jOBW8At4BZ0C7olaZMUhWzQktmAHPRDdU/WKk+gPktNq+6QE7ilOa+gyWR1VduPoe3h0KnbdBvXPAhlp7aAJqJO4gSjknqqOZBRAJ26TSvPbVBo6SfK3ZZFj0mpBH+ipE7VqXZbtfLE2FI+UbdF6MROEDq5SsT+bNsY2/xqy2ki6lSddBoxt/EWpxUgxE6127RVWZ9oc8dotmnW2myMtrKEihNgp25D6JSdUrcl9wAodOrK1FW4P1s8ymkgTeRRTiNpomzxTpOnjXHfFoRmW7XYUBeXUbdpO7d4MbkvSNDJvULuNvaIMMdO3Va6Bz4cIpauXF0lhfbs29t24yeaH8/n/V4PNIsjjhx8nnbn/el5c3d6OR63m392x5f2R3+edqf2+3l3lrvSKfvTL/ktgg+H417pbTs/HdYfBSzVnoYUaheQjrqQiOsSsQTNYdMQzrmL5HihAesaUjHdBZqGsDy4ojEKpUR3AyrE1VDSQEKOC6GnI+Y5oTldaNAnpIO/Nh0JtMebRJJWXk1HGYQCyB4JEM8S0ihLifoJ2YjhE9IxigUjuh9yEl2NJcJnBINfHAxk6IWp64WJgz6Vc4zHkiuk1VBGbYqcXEO4fjQU0VgNZdQekkT3gmpZ38MGfSqjBfvKr5h4dRMbOYII3RMZOOmGZbsMhkNYDWa0Ecp533MqTLMIwWUsgzaV1xL3Q15MFrtpxUuNNFovfftYlAW5XCoMmjSV6hKpLsaTzNfrvSCXgADrXuTBUsnzUimRZo10OWehjOrqJUlxbi6gd901alE5xnkgsMjFew0Mo6r6tCcMtylUnyq8yMRfxQHzkQMXFfmfFziqKfhqla9m8o0aXLtGqbdpYOgaCGVdY7CL5uSdkRPfpFCTD5RKt/kgL0x9Fw68Xleso7Ua3Y1UCBY7xl+kU79dsHTSjWXF3qGC5SaNzwgl9nkib3HltpWSY9+68mC9JvpajcjcY+FcbtPIuZ+/5LyxrlE+ulJGCtetlJHCtSuF4ofba5jOOm888s3NenuNRnxk6iM+w+qIpzRsjV5WLov2CnTrcaWuHVeIR0MF5uG4bI53ftBgzMtejr79CBOtHd9oNOcDzGfiAGX1HYHq6LDAsyfEvC4yDgcW4SxfZt+9iI5e7hl7n/EiI1j4+kUXfEOucOOyZW+QmumjC3+gMByyV0UxVLgqiisH/XuF73K5uz+cL/5H9qZS58Pu53Fvlw8vp/vF3ed/n/yO/4/t6fx4v//1ct6r0vyPNvnxDUPZIuTv+kWnXMqb5xZD1Muod+X4Ky9R39/Umf8A",
      "is_unconstrained": true,
      "name": "get_post_submolt"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3844188133549269817": {
            "error_kind": "string",
            "string": "Function get_post_votes can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_post_votes"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13624811166311613123": {
            "error_kind": "string",
            "string": "Function get_proposal_author can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQcAEREBS0IRAElAAAASiUAAABQLQIBRScCAgRFJwIDBAE7DgADAAInAEMEAyYlAAAFeB4CAAIAHgIAAwAeAgAEAB4CAAUAMyoABAAFAAYnAgQBASQCAAYAAACDJQAABZ4eAgAFCSQCAAUAAACVJQAABbAcCgEFACcCAQAALQgBBicCBwQEAAgBBwEnAwYEAQAiBgIHLQoHCC0OAQgAIggCCC0OAQgAIggCCC0OAQgrAgAHAAAAAAAAAAACAAAAAAAAAAAtCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkKLQ4BCgAiCgIKLQ4BCgAiCgIKLQ4BCgAiCgIKLQ4HCi0IAQcAAAECAS0OBgctCAEGAAABAgEtDggGLQgBCQAAAQIBJwIKBAAtDgoJLQgBCwAAAQIBJwIMAQAtDgwLJwINACsnAg4EASQCAAwAAAG9IwAAAXYtCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMPLQ4NDwAiDwIPLQ4BDwAiDwIPLQ4BDy0OAgctDggGLQ4OCS0ODAsjAAACSS0KCgIjAAABxgwiAkMDJAIAAwAABPIjAAAB2C0LBwItCwYDLQsLCC0LAw8AIg8CDy0ODwMtCAEPJwIQBAUACAEQAScDDwQBACIDAhAnAhEEBAAiDwISPw8AEAASLQICAycABAQEJQAABcItCAUDACoDDhAtDg0QLQ4DBy0ODwYtDg4JLQ4ICyMAAAJJLQsHAi0LBgMtCwsICioIDA0kAgANAAACaycCDwQAPAYPASQCAAwAAAKtIwAAAngnAggEAi0CAgMnAAQEBCUAAAXCLQgFDQAqDQgPLQ4FDy0ODQctDgMGLQ4ICS0ODAsjAAADOS0KCgIjAAACtgwiAkMDJAIAAwAABGwjAAACyC0LBwItCwYDLQsLCC0LAw0AIg0CDS0ODQMtCAENJwIPBAUACAEPAScDDQQBACIDAg8nAhAEBAAiDQIRPw8ADwARLQICAycABAQEJQAABcItCAUDACoDDg8tDgUPLQ4DBy0ODQYtDg4JLQ4ICyMAAAM5LQsLAwoqAwwFJAIABQAAA1MnAggEADwGCAEtCgoCIwAAA1wMIgJDAyQCAAMAAAPmIwAAA24tCwcCLQsGAy0LCQUtCwMIACIIAggtDggDLQgBCCcCCgQFAAgBCgEnAwgEAQAiAwIKJwINBAQAIggCDz8PAAoADy0OAgctDggGLQ4FCS0OBAsAKggOAy0LAwIKKgIBAwoqAwwBJAIAAQAAA98lAAAGIS8KAAIAASYtCwcDLQsGBS0LCQgtCwsKDCoCCA0kAgANAAAECCMAAAReACIFAg8AKg8CEC0LEA0AIgMCEAAqEAIRLQsRDwAqDQ8QLQIFAycABAQFJQAABcItCAUNACINAg8AKg8CES0OEBEtDgMHLQ4NBi0OCAktDgoLIwAABF4AKgIOAy0KAwIjAAADXC0LBwMtCwYILQsJDS0LCw8MKgINECQCABAAAASOIwAABOQAIggCEQAqEQISLQsSEAAiAwISACoSAhMtCxMRACoQERItAggDJwAEBAUlAAAFwi0IBRAAIhACEQAqEQITLQ4SEy0OAwctDhAGLQ4NCS0ODwsjAAAE5AAqAg4DLQoDAiMAAAK2LQsHAy0LBggtCwkPLQsLEAwqAg8RJAIAEQAABRQjAAAFagAiCAISACoSAhMtCxMRACIDAhMAKhMCFC0LFBIAKhESEy0CCAMnAAQEBSUAAAXCLQgFEQAiEQISACoSAhQtDhMULQ4DBy0OEQYtDg8JLQ4QCyMAAAVqACoCDgMtCgMCIwAAAcYoAAAEBHhGDAAABAMkAAADAAAFnSoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFvRUNkYPHgsM8BAIBJi0BAwYKAAYCByQAAAcAAAXYIwAABeEtAAMFIwAABiAtAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAGGy0BCggtBAgLAAAKAgoAAAsCCyMAAAX3JwEFBAEmKgEAAQW6uyHXgjMYZDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnbbhs5DIbfxde5kHiSlFcpiiJN3cKA4QRussCiyLsvqSFlO4sRUie5iT9zon940mHGfzY/tt+ff33bHX4+/N7cfvmz+X7c7fe7X9/2D/d3T7uHg1r/bJL9qby5xZtN0y9FP/RbzjebnPR7JgOz6JWcUaEaVAcQB8ybW7BRqBYABaKApiAKrBa0/+HmIBhQHUpYSlhqWGpxaDlAFgBzdQEOsFvo3QFTAAXEJQoLhYXDwtVBIKA4lBwgDjVu0RPZwQSTQsOAugAmCBCHnAM4wIcjUEBYEAOKA4UghaXYKDKoDj2HHcLSwtLcQt2xDuLQHevADpAC7BZsUB0QAsShJ1Pbhopdqgbi0DPWgQKqQ3esg4ZDGg6nHCAOOSw5LBAWCAuGxRJF2hJMOUAcOCzMDpIC1DECg+pgUSwgDlZuQoPmYM4vYDfVRIlltUNOAeyAnnDppTSgHOAlEA4LewlEUoCXQMRLIAUCvATSvAQlewlK9hIUSAEU4CUoiAFegkI5wNNbOCwcFgmLhKWEpXgJSs0BXoLSwtK8BDWlAC9BTV6CmiHAS1DBRomBlUAjrTbNO9i8WKA49OI2BZsXrI7VCgHiYIvgAhTQFmhJ08JgUBzMnwXCAmGBsGBYMCxkTVINikNPZgcOsJvammxVXsB81po2WyEXCEt33sCSKeaqTWqLVNdwGCRBOQ1SdelrPXomlEoQDZuVXaBvBXnQsFleBTtxjJAWVGjQsNl65FSD2rC18CDb1HfiQaHSd6GF+lRadigJojSIBukIsS0ti8+DnPt6vtCw2fok3ImD2rBZa4h0aj4CEg6qQXnYrD8WAhg0bJgH8aChTEOFx1iJKKGkQTSoBll/93gx+XRXintgHrbeB9ypBcGw2cLQ48VYGfKy/XQiGDRsnAdFTlGGTYYHElFiGcplqNQ+9uXlZhNnlm9Px+3Wjixnhxg92jzeHbeHp83t4Xm/v9n8c7d/7v/0+/Hu0D+f7o56VTtle/ihnyr4c7ffGr3cnEan9aGAtflooNSGgPbRhURel9CekuoayqUMkZIvNGBdA4FtnncNZR24ojELpeZwAxrk1VBoIqEHgjTSkcspoYUuNPgD0iGfmw7Sg51LEHJZTUedhAIoEQmwnCS0Uc4l2gdkI6cPSMcsFswYfuhsX40lw0cEg58cDBQYhWnrhcmTPtWTSsRSGtBqKLM2RaHQUG7vDUU1VkOZtYcmMbzgVtfXsEmf6vMMjpnfkGR1EZs5ggjDE0SiK6bteTCS0mowM4mUKOat8lmbMlzGMmlTffAIP/TR42w1bXipQbP5MpaPs7Kg1EuFSZNSbSFB7Wx7wkpv94JDAhKse1EmU6WcpkrNfNKgy30W6qyu0eaUT80F/Kq7Zi2qrwciEDjLxWsNTLOqxm7PmK5TaLGryFkm/ioOOB058Kwi//MCZzWFmK368qVcqSFtaNR2nQamoaGnyXWNySpaKDqjkFyl0Cg2lMbX+ZATjFVYn3XWNdpsruZwgyrD2YrxF+m09weeTr6yrDg6VLFepfERoeSxn9jT2XUzpeSxdJXJfCX+XA19phyxSKnXaZQyzl963ljXqO+dKTOFt82UmcJbZwrnd7fXNJ3ttPDou5n19ppt8Vl4bPEFVrd4pmlrjLJKPWuvxFceV6qsHVdYZpsKnDbH8+Z45QeXmSMNaTiir6zWjm882+cTnM7ECerqMwK32WFBTp6wyKrItNdTrIMNrpwtEq3eCr93vk0Upnvbm6KYKrwpijfur68VvurXu/vd8eLHpxeTOu7uvu+3/vXn8+H+7OrTv49xJX68ejw+3G9/PB+3pnT6BUv/fNEXWzf60uqrvUHUr/p4cqO/utjXbFfBrpavL+bMfw==",
      "is_unconstrained": true,
      "name": "get_proposal_author"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1361523054280208260": {
            "error_kind": "string",
            "string": "Function get_proposal_content_hash can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTiM7DMffpde9SOzYSXiV1WpVoKwqVQV14UhHiHc/dsbOTDmaiC1wA7/xkP/4Kx8zvG7u97cvv38dTg+PfzY3P143t+fD8Xj4/ev4eLd7PjyexPq6Cfqj0OYGt5sqF1l+yVWM200Mch2TglrkTowoUBSKAbABxs0N6CgUC4BASg5VgAVILKh/Q9WA0aEYZLdktxS3lGxQowNPAOrqBOSgj5CnAwaH5OC3kluSW8gtVAwYHLJBjg5sUPwRLZENVDAIVHQoE2AABzaI0YEcbDhCcnALokM2SC6Y3JJ1VFIoBi2HDdxS3VLNkppjDdigOdaADCA46CNIoRggOLBBS6a0Tcp6qyiwQctYg+RQDJpjDSScJOFQiA5sEN0S3QJuAbegWzRRSVqCUnRgA3ILkQEHB3EsgUIx0CgmYAMtd0KFaqDOT6APlUSxZrVBDA5kgJZwbqVUSNHBSsDkFrISMAcHKwGzlYAzOFgJuFoJcrQS5GglyBAckoOVICM6WAlyig6W3kxuIbewW9gt2S3ZSpBLdLAS5OqWaiUoIThYCUqwEpQIDlaCAjqKFbQEEmnRad5A58UE2aAVtwrovCBxrBRwYANdBCdIDnWCGiQtBArZQP2ZwC3gFnALugXdkrRJikI2aMlsQA76UF2TtcoTqM9S06or5ARuac4raDJZXdVJrZHKGg6d2CmGTqLOba1Hy4RQdkrdpmVnaFtB7NRtmlfGRuQjuDrl1KnbdD0yKk6126p7EHXqG1EnV2m70ERtKk07FDul0Cl1khGsW1pkmwcxtvV8om7T9YmpETnVbtPWYG5UbQQE7FScYrdpf0wE0KnbMHaiTl05dRXqY9mjhBw6pU7FSfu7xYvBpruQPwNjt7U+oEbVCbpNF4YWL/rKEKftp1GCTt1GsZPnFLnbuHvAHiXmrpy7Smlj3962Gz+z/Ho+7/d6ZFkcYuRo87Q770/Pm5vTy/G43fyzO760P/rztDu138+7s9yVTtmf7uW3CD4cjnult+08OqwPBSzVRkMKtQtIH11IxHUJ6SkupiGccxfJ8UID1jUQSOd50xCWgSsao1BKdDegQlwNJQ0k5EAQejpinhOa04UGfUE6+HvTkeRgZxIJKa+mowxCAWSPBIhnCWmUpUT9gmzE8AXpGMWCEd0Pme2rsUT4imDwm4OBDL0wdb0wcdCnclLxWHKFtBrKqE2Rk2sI18+GIhqroYzaQ5LoXlAt62vYoE/lfQb7zK+YeHURGzmCCN0TxJSumLbLYDiE1WBGC2GVU1+PpcLc7ASXsQzaVF483A959VisphUvNdJovvTlY1EW5HKpMGjSVKpLpLrYnrCkj3tBPRkB1r3Ig6mS56lSIs0a6XKfhTKqq7d5inNzAb3rrlGLyucBDwQWuXivgWFUVd/tCcN1CtV3FV5k4q/igPnIgYuK/M8LHNUUfLbKx5d8pQbXrlHqdRoYuoacJtc1BqtoTt4ZOfFVCjX5hlLpOh9igL4Ky7vOukYdzdXobqRCsFgx/iKd+v3A0klXlhV7hwqWqzS+IpTY9xN9O7tupuTYl648mK+JvldD3il7LJzLdRo59/OXnDfWNcpnZ8pI4WMzZaTw0ZlC8dPtNUxnnRce+Taz3l6jLT4y9S0+w+oWT2nYGr2sXBbtFejK4wrC2nGFeLSpwLw5LpvjnR802OZlLUdffoSJ1o5vNNrnA8xn4gBl9R2B6uiwwLMnxLwqMuz14OtghStnC3ur10yfnW8DheHe9qEohgofiuKD++t7hZ9yubs7nC/++fSmUufD7va4t8uHl9Pd4u7zv09+x/959XR+vNvfv5z3qjT/B0t+/JAPW1v5aPVTvyDKpbyebGXO6GXUu6B38883deY/",
      "is_unconstrained": true,
      "name": "get_proposal_content_hash"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3905717565539885644": {
            "error_kind": "string",
            "string": "Function get_proposal_count can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDACkvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQU2M+VutwIiTDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVbLboMwEPwXn33w7vrJr1RRRBJSISESUahURfx7lwjzqGQf2vSCZ012sjNebD/EpToN78e6vd4+RPH2EKeubpr6/djczmVf31qefQg1PRyIgqRwVhROCs8RAI8cgpYiTDHPh8CjlwKUngFgBE4UyCmAPIPIgFQEhgFng1YRMC8GBgYieM6MoxSxtmPfVdVU2qZYlnAvu6rtRdEOTSPFZ9kMzx993Mv2OfZlx2+VFFV74ZEJr3VTTWiUa7ZKpyL5MGejVmEhALA7CkhTgFfWzxyMnVtIHOw4MM1BaIyZORhzYoIjJ8VDLAMDQlKKzlBoMGqxA9xqqNM7DvMCO+z/2qHRuplCk3FJO3xGCpKNStDYlUKFHUV4gRugXmBHTgsBxTqIKKkF8BVi6J/FoMNlYUJ6YSDTp84vWlxAnZSSa1OyOnIwDn+VwhxJKbn2YBNjFSb49B6W6VMMRMuXH0jb5CaWK4QIl0qItP7FZ7sVY5VKislthMFpWLQ4tza7wb2WTJsiLlIQN3agMnuOzHZKip2MYlQwJmmqyZHg2mQKffp4yXWqsWslxto0SV4ObuRsT4cfJLl+txQPXLAbR8jz+h44LM91t7uyjBNZV5enpprD69CeN2/7r3t8E6889+52ri5DV01M670H+PlGKMkdpkvMFHip1WGc/vob",
      "is_unconstrained": true,
      "name": "get_proposal_count"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8557100619347471449": {
            "error_kind": "string",
            "string": "Function get_proposal_end_block can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTiM7DMffpde9SOzYSXiV1WrVZcuqUlVQF450hHj3Y2fszJSjiboFbuA3HuZffyXOlNfNr/3Pl98/DqeHxz+bu2+vm5/nw/F4+P3j+Hi/ez48nsT6ugn6o9DmDrebKhdZfslVjNtNDHIdk4Ja5E6MKFAUigGwAcbNHehTKBYAgZQcqgALkFhQ/4aqAaNDMchuyW4pbinZoEYHngDU1QnIQT9CPh0wOCQHv5XcktxCbqFiwOCQDXJ0YIPiH9ES2UAFg0BFhzIBBnBggxgdyMEeR0gObkF0yAbJBZNbsj6VFIpBy2EDt1S3VLOk5lgDNmiONSADCA76EaRQDBAc2KAlU9omZb1VFNigZaxBcigGzbEGEk6ScChEBzaIboluAbeAW9AtmqgkLUEpOrABuYXIgIODOJZAoRhoFBOwgZY7oUI1UOcn0A+VRLFmtUEMDmSAlnBupVRI0cFKwOQWshIwBwcrAbOVgDM4WAm4WglytBLkaCXIEBySg5UgIzpYCXKKDpbeTG4ht7Bb2C3ZLdlKkEt0sBLk6pZqJSghOFgJSrASlAgOVoIC+hQraAkk0qLLvIGuiwmyQStuFdB1QeJYKeDABroJTpAc6gQ1SFoIFLKB+jOBW8At4BZ0C7olaZMUhWzQktmAHPRDdU/WKk+gPktNq+6QE7ilOa+gyWR1VduPoe3h0KnbdBvXPAhlp7aAJqJO4gSjknqqOZBRAJ26TSvPbVBo6SfK3ZZFj0mpBH+ipE7VqXZbtfLE2FI+UbdF6MROEDq5SsT+bNsY2/xqy2ki6lSddBoxt/EWpxUgxE6127RVWZ9oc8dotmnW2myMtrKEihNgp25D6JSdUrcl9wAodOrK1FW4P1s8ymkgTeRRTiNpomzxTpOnjXHfFoRmW7XYUBeXUbdpO7d4MbkvSNDJvULuNvaIMMdO3Va6Bz4cIpauXF0lhfbs29t24yeaH8/n/V4PNIsjjhx8nnbn/el5c3d6OR63m392x5f2R3+edqf2+3l3lrvSKfvTL/ktgg+H417pbTs/HdYfBSzVnoYUaheQjrqQiOsSsQTNYdMQzrmL5HihAesaUjHdBZqGsDy4ojEKpUR3AyrE1VDSQEKOC6GnI+Y5oTldaNAnpIO/Nh0JtMebRJJWXk1HGYQCyB4JEM8S0ihLifoJ2YjhE9IxigUjuh9yEl2NJcJnBINfHAxk6IWp64WJgz6Vc4zHkiuk1VBGbYqcXEO4fjQU0VgNZdQekkT3gmpZ38MGfSqjBfvKr5h4dRMbOYII3RMZOOmGZbsMhkNYDWYkEah4LPKqFmc3CC5jGbSpvJa4H/JisthNK15qpNF66dvHoizI5VJh0KSpVJdIdTGeZL5e7wW5BARY9yIPlkqel0qJNGukyzkLZVRXb/MU5+YCetddoxaVY5wHAotcvNfAMKqqT3vCcJtC9anCi0z8VRwwHzlwUZH/eYGjmoJ3uHw1k2/U4No1Sr1NA0PXQCjrGoNdNCfvjJz4JoWafKBUus0HeWHqu3Dg9bpiHa3V6G6kQrDYMf4infrtgqWTbiwr9g4VLDdpfEYosc8TeYsrt62UHPvWlQfrNdHXakTmHgvncptGzv38JeeNdY3y0ZUyUrhupYwUrl0pFD/cXsN01nnjkW9u1ttrNOIjUx/xGVZHPKVha/Syclm0V6AbjyuAa8cV4tFQgXk4LpvjnR+UR45UTN0R+UJr7fhGozkfYD4TByir7whUR4cFnj0h5nWRcTiwCGf5MvvuRXT0cs/Y+4wXGcHC1y+64BtyhRuXLfuaq5k+uvAHCsMhe1UUQ4Wrorhy0L9X+C6Xu/vD+eJ/ZG8qdT7sfh73dvnwcrpf3H3+98nv+P/Yns6P9/tfL+e9Ks3/aJMf3zCULUL+rl90yqW8eW4xRL2MeleOv/IS9f1NnfkP",
      "is_unconstrained": true,
      "name": "get_proposal_end_block"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "9819042744607351994": {
            "error_kind": "string",
            "string": "Function get_proposal_proposed_hours can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndbts6DIDfJde5kEiRkvoqwzBkXToECNIiaw9wUPTdDymTstMDC1na3jSf6Yrmrygnr5tf+58vv38cTg+PfzZ33143P8+H4/Hw+8fx8X73fHg8ifR1E/RPoc0dbjdVLrJ8yFWM200Mch2TgkrkTowoUBSKAbABxs0d6CoUCYBASg5VgAVIJKj/Q9WA0aEYZJdklxSXlGxQowNPAGrqBOSgj5CnAwaH5OC3kkuSS8glVAwYHLJBjg5sUPwRLZANVGEQqOhQJsAADmwQowM52HKE5OASRIdskFxhcknWVUmhGLQYNnBJdUk1SWqGNWCDZlgDMoDgoI8ghWKA4MAGLZhSNinrraLABi1iDZJDMWiGNRB3krhDITqwQXRJdAm4BFyCLtFAJSkJStGBDcglRAYcHMSwBArFQL2YgA003QkVqoEaP4E+VALFGtUGMTiQAVrAuaVSIUUHSwGTS8hSwBwcLAXMlgLO4GAp4GopyNFSkKOlIENwSA6WgozoYCnIKTpYeDO5hFzCLmGXZJdkS0Eu0cFSkKtLqqWghOBgKSjBUlAiOFgKCugqVtAUiKdF27yB9sUE2aAltwpoX5AYVgo4sIFughMkhzpBDRIWAoVsoPZM4BJwCbgEXYIuSVokRSEbtGA2IAd9qO7JmuUJ1GbJadUdcgKXNOMVNJispmr5MbQ9HDp1mW7jGgeh7NQaaCLqJEYwKqmlGgMZBdCpyzTz3AaFpn6i3GVZ9DEpleArSupUnWqXVUtPjC3kE3VZhE7sBKGTa4nY17aNsc2v1k4TUafqpNOIuY23OHWAEDvVLtNSZV3R5o7RLNOotdkYrbOEihNgpy5D6JSdUpcltwAodOqaqWvhvra4l9NAmsi9nEbSRNn8nSZPG+O+LQjNsmq+oTaXUZdpOTd/MbktSNDJrULuMnaPMMdOXVa6BT4cIpauubqWFNrat7ftxk80P57P+70eaBZHHDn4PO3O+9Pz5u70cjxuN//sji/tn/487U7t83l3lrtSKfvTL/kUhQ+H417pbTuvDutLAUu11ZBC7Qqkoi5UxHUVsQSNYdMhnHNXkuOFDljXIRnTXaDpEJaFKzpGrpToZkCFuOpKGqiQ40Lo4Yh5DmhOFzroE8LBXxuOBFrjTUWSUl4NRxm4AsjuCRDPKqRQlirqJ0Qjhk8Ix8gXjOh2yEl01ZcIn+EMfrEzkKEnpq4nJg7qVM4x7kuukFZdGZUpcnIdwvWjroiOVVdG5SFBdCuolvU9bFCnMlqwd37FxKub2MgQROiWyMBJN7Tt0hkOYdWZMPQl5tmXReMSXPoyKFN5LXE75MVksZtWvNSRRv3St49FWpDLpYZBkaZSXUWqi/Ek8/V6K8hVQIB1K/KgVfLcKiXSrCNdzlkoo7x6mac4JwToXXWNSlSOce4ILGLxXgeGUVZ92hOG2zRULy1eROKv/ID5yIGLjPzPChzlFLxb5auZfKMOrl1HqbfpwNB1IJR1HYNdNCevjJz4Jg01+UCpdJsN8sLUd+HA63nFOurV6GakQrDYMf4inPrtgoWTbkwr9goVLDfp+AxXYp8n8hZXbuuUHPvWlQf9muhrdUTm7gvncpuOnPv5S84b6zrKRztlpOG6ThlpuLZTKH64vIbhrPPGI9/crJfXaMRHpj7iM6yOeErD0uhp5bIor0A3HlcWMX13XCEeDRWYh+OyON7ZQYMxL3s5+vYjTLR2fKPRnA8wn4kDlNV3BKqjwwLPlhDzupKxO7BwZ/ky++5FdPRyz9jrjBcRwcLXN13w9Fa4sW3Ze65m+mjjDzQMh+xVXgw1XOXFlYP+vYbvcrm7P5wvfiN7U1Xnw+7ncW+XDy+n+8Xd53+f/I7/xvZ0frzf/3o571XT/EOb/PmGoWwR8nf9olMu5c1ziyHqZdS7cvyVl6jvb2rMfw==",
      "is_unconstrained": true,
      "name": "get_proposal_proposed_hours"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5138799157270560027": {
            "error_kind": "string",
            "string": "Function get_proposal_snapshot_block can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndbts6DIDfJde5kEiRkvoqwzBkXToECNIiaw9wUPTdDymTstMDC1na3jSf6Yrmrygnr5tf+58vv38cTg+PfzZ33143P8+H4/Hw+8fx8X73fHg8ifR1E/RPoc0dbjdVLrJ8yFWM200Mch2TgkrkTowoUBSKAbABxs0d6CoUCYBASg5VgAVIJKj/Q9WA0aEYZJdklxSXlGxQowNPAGrqBOSgj5CnAwaH5OC3kkuSS8glVAwYHLJBjg5sUPwRLZANVGEQqOhQJsAADmwQowM52HKE5OASRIdskFxhcknWVUmhGLQYNnBJdUk1SWqGNWCDZlgDMoDgoI8ghWKA4MAGLZhSNinrraLABi1iDZJDMWiGNRB3krhDITqwQXRJdAm4BFyCLtFAJSkJStGBDcglRAYcHMSwBArFQL2YgA003QkVqoEaP4E+VALFGtUGMTiQAVrAuaVSIUUHSwGTS8hSwBwcLAXMlgLO4GAp4GopyNFSkKOlIENwSA6WgozoYCnIKTpYeDO5hFzCLmGXZJdkS0Eu0cFSkKtLqqWghOBgKSjBUlAiOFgKCugqVtAUiKdF27yB9sUE2aAltwpoX5AYVgo4sIFughMkhzpBDRIWAoVsoPZM4BJwCbgEXYIuSVokRSEbtGA2IAd9qO7JmuUJ1GbJadUdcgKXNOMVNJispmr5MbQ9HDp1mW7jGgeh7NQaaCLqJEYwKqmlGgMZBdCpyzTz3AaFpn6i3GVZ9DEpleArSupUnWqXVUtPjC3kE3VZhE7sBKGTa4nY17aNsc2v1k4TUafqpNOIuY23OHWAEDvVLtNSZV3R5o7RLNOotdkYrbOEihNgpy5D6JSdUpcltwAodOqaqWvhvra4l9NAmsi9nEbSRNn8nSZPG+O+LQjNsmq+oTaXUZdpOTd/MbktSNDJrULuMnaPMMdOXVa6BT4cIpauubqWFNrat7ftxk80P57P+70eaBZHHDn4PO3O+9Pz5u70cjxuN//sji/tn/487U7t83l3lrtSKfvTL/kUhQ+H417pbTuvDutLAUu11ZBC7Qqkoi5UxHUVsQSNYdMhnHNXkuOFDljXIRnTXaDpEJaFKzpGrpToZkCFuOpKGqiQ40Lo4Yh5DmhOFzroE8LBXxuOBFrjTUWSUl4NRxm4AsjuCRDPKqRQlirqJ0Qjhk8Ix8gXjOh2yEl01ZcIn+EMfrEzkKEnpq4nJg7qVM4x7kuukFZdGZUpcnIdwvWjroiOVVdG5SFBdCuolvU9bFCnMlqwd37FxKub2MgQROiWyMBJN7Tt0hkOYdWZkYpQsvcthhqpKyG49GVQpvJa4nbIi8liN614qSON+qVvH4u0IJdLDYMiTaW6ilQX40nm6/VWkKuAAOtW5EGr5LlVyiKcmC7nLJRRXr3MU5yLC+hddY1KVI5x7ggsYvFeB4ZRVn3aE4bbNFSfKryIxF/5AfORAxcZ+Z8VOMopeLfKVzP5Rh1cu45Sb9Mh/dV3LyjrOga7aE5eGTnxTRpq8oFS6TYb5IWp78KB1/OKddSr0c1IhWCxY/xFOPXbBQsn3ZhW7BUqWG7S8RmuxD5P5C2u3NYpOfatKw/6NdHX6ojM3RfO5TYdOffzl5w31nWUj3bKSMN1nTLScG2nUPxweQ3DWeeNR765WS+v0YiPTH3EZ1gd8ZSGpdHTymVRXoFuPK4sjqLvjivEo6EC83BcFsc7OyiPDKmYZkOI1o5vNJrzAeYzcYCy+o5AdXRY4NkSYl5XMnYHFu4sX2bfvYiOXu4Ze53xIiJY+PqmC74hV7ixbdl7rmb6aOMPNAyH7FVeDDVc5cWVg/69hu9yubs/nC9+I3tTVefD7udxb5cPL6f7xd3nf5/8jv/G9nR+vN//ejnvVdP8Q5v8+SadukXI3/WLTrmUN88thqiXUe/K8Vdeor6/qTH/AQ==",
      "is_unconstrained": true,
      "name": "get_proposal_snapshot_block"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15811002909701486780": {
            "error_kind": "string",
            "string": "Function get_proposal_status can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQcAEREBS0IRAElAAAASiUAAABQLQIBRScCAgRFJwIDBAE7DgADAAInAEMEAyYlAAAFhx4CAAIAHgIAAwAeAgAEAB4CAAUAMyoABAAFAAYnAgQBASQCAAYAAACDJQAABa0eAgAFCSQCAAUAAACVJQAABb8cCgEFACcCAQAALQgBBicCBwQEAAgBBwEnAwYEAQAiBgIHLQoHCC0OAQgAIggCCC0OAQgAIggCCC0OAQgrAgAHAAAAAAAAAAACAAAAAAAAAAAtCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkKLQ4BCgAiCgIKLQ4BCgAiCgIKLQ4BCgAiCgIKLQ4HCi0IAQcAAAECAS0OBgctCAEGAAABAgEtDggGLQgBCQAAAQIBJwIKBAAtDgoJLQgBCwAAAQIBJwIMAQAtDgwLJwINAC4nAg4EASQCAAwAAAG9IwAAAXYtCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMPLQ4NDwAiDwIPLQ4BDwAiDwIPLQ4BDy0OAgctDggGLQ4OCS0ODAsjAAACSS0KCgIjAAABxgwiAkMDJAIAAwAABQEjAAAB2C0LBwItCwYDLQsLCC0LAw8AIg8CDy0ODwMtCAEPJwIQBAUACAEQAScDDwQBACIDAhAnAhEEBAAiDwISPw8AEAASLQICAycABAQEJQAABdEtCAUDACoDDhAtDg0QLQ4DBy0ODwYtDg4JLQ4ICyMAAAJJLQsHAi0LBgMtCwsICioIDA0kAgANAAACaycCDwQAPAYPASQCAAwAAAKtIwAAAngnAggEAi0CAgMnAAQEBCUAAAXRLQgFDQAqDQgPLQ4FDy0ODQctDgMGLQ4ICS0ODAsjAAADOS0KCgIjAAACtgwiAkMDJAIAAwAABHsjAAACyC0LBwItCwYDLQsLCC0LAw0AIg0CDS0ODQMtCAENJwIPBAUACAEPAScDDQQBACIDAg8nAhAEBAAiDQIRPw8ADwARLQICAycABAQEJQAABdEtCAUDACoDDg8tDgUPLQ4DBy0ODQYtDg4JLQ4ICyMAAAM5LQsLAwoqAwwFJAIABQAAA1MnAggEADwGCAEtCgoCIwAAA1wMIgJDAyQCAAMAAAP1IwAAA24tCwcCLQsGAy0LCQUtCwMIACIIAggtDggDLQgBCCcCCgQFAAgBCgEnAwgEAQAiAwIKJwINBAQAIggCDz8PAAoADy0OAgctDggGLQ4FCS0OBAsAKggOAy0LAwIKKgIBAwoqAwwBJAIAAQAAA98lAAAGMC8KAAIAARwKAQMCHAoDAgAcCgIBAiYtCwcDLQsGBS0LCQgtCwsKDCoCCA0kAgANAAAEFyMAAARtACIFAg8AKg8CEC0LEA0AIgMCEAAqEAIRLQsRDwAqDQ8QLQIFAycABAQFJQAABdEtCAUNACINAg8AKg8CES0OEBEtDgMHLQ4NBi0OCAktDgoLIwAABG0AKgIOAy0KAwIjAAADXC0LBwMtCwYILQsJDS0LCw8MKgINECQCABAAAASdIwAABPMAIggCEQAqEQISLQsSEAAiAwISACoSAhMtCxMRACoQERItAggDJwAEBAUlAAAF0S0IBRAAIhACEQAqEQITLQ4SEy0OAwctDhAGLQ4NCS0ODwsjAAAE8wAqAg4DLQoDAiMAAAK2LQsHAy0LBggtCwkPLQsLEAwqAg8RJAIAEQAABSMjAAAFeQAiCAISACoSAhMtCxMRACIDAhMAKhMCFC0LFBIAKhESEy0CCAMnAAQEBSUAAAXRLQgFEQAiEQISACoSAhQtDhMULQ4DBy0OEQYtDg8JLQ4QCyMAAAV5ACoCDgMtCgMCIwAAAcYoAAAEBHhGDAAABAMkAAADAAAFrCoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEF22v3YEdsuLw8BAIBJi0BAwYKAAYCByQAAAcAAAXnIwAABfAtAAMFIwAABi8tAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAGKi0BCggtBAgLAAAKAgoAAAsCCyMAAAYGJwEFBAEmKgEAAQW6uyHXgjMYZDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTiM5EIXfJde5sMt22eZVRqNRhgmjSFFAGVhphXj3rXLXcXdYtZUJcANfV9Mn9WeXO7xufu1/vvz+cTg9PP7Z3H173fw8H47Hw+8fx8f73fPh8STW143THyVt7sJ2U+Uiyy+58n678U6ufVRQi9zxPggUhWJAbBD85o70qSAWIoEYAVWABZJYgv5NqgYcAMUgw5JhKbCUbFA9gCcgdXWCBNCPkE+n4AARgFsRlghLgiUVAyZANsgewAYFH9ES2UAFnUANgDJBcARgA+8BCWCPB4oAWEIAZIMIwQhL1qeiQjFoOWwAS4WlmiU2xxqwQXOsQTIgB9CPSArFIBCADVoypW1i1ltFgQ1axhpEQDFojjWQcKKEk5wHsIGHxcNCsBAsARZNVJSWSNED2CDBkpIBO4A4FkmhGGgUE7CBljsGhWqgzk+gHyqJYs1qA+8AySBYwrmVUiF6gJWAEyzJSsDsAFYCZisBZwJYCbhaCbK3EmRvJcjkABFgJcghAKwEOXqApTcnWBIsDAvDkmHJVoJcPMBKkCss1UpQnANYCYqzEhRPACtBIX2KFbQEEmnRZd5A18UE2aAVtwroukjiWCkEYAPdBCeIgDpBdZKWRArZQP2ZABaChWAJsARYojZJUcgGLZkNEkA/VPdkrfIE6rPUtOoOOQEszXkFTSarq9p+TG0Pp07dptu45kEog9oCmih1Eic4KKmnmgMZBdSp27Ty3AaFln6i3G1Z9DgpFYcnSuxUQbXbqpXH+5byibrNUycGkesEFR/6s21jbPOrLaeJUqcK0mnE3Mabn1aAEINqt2mrsj7R5o7RbNOstdnobWUJFRCFTt0WqFMGxW6L8ICS69SVU1fh/mxBlNNAmghRTiNpomzxTpOnjXFsC0KzrVpsQReXUbdpO7d4Q4QvIVEneBW42xgRhew7dVvpHmA4+FC6coVKdO3Zt7ftBieaH8/n/V4PNIsjjhx8nnbn/el5c3d6OR63m392x5f2R3+edqf2+3l3lrvSKfvTL/ktgg+H417pbTs/7dYfpVCqPU3R1S4gHXUh4dclfHGaw6YhnHMXyf5Cg9Y1pGK6CzQNYXlwRWMUSvFwgyr51VDiQEKOC66nw+c5oTleaKRPSAd/bToiaY83iSitvJqOMgiFAiMSSjxLSKMsJeonZMO7T0jHKJbgA/yQk+hqLJ4+I5jwxcFQpl6Yul4YP+hTOccgllwproYyatPAERrC9aOhiMZqKKP2kCTCi1TL+h426FMZLaGv/Boir25iI0dCoO6JDJx4w7JdBsPOrQYzknAxIKfCPDd7ostYBm0qryXwQ15MFrtpDZcacbRe+vaxKEvgcqkwaNJYKiRiXYwnma/Xe5EgQY7WvciDpZLnpVJ8mjXi5ZylMqorShL93FyU3nXXqEXlGIdAaJGL9xrBjaqKaZ+Cu02hYqrwIhN/FQfNR46wqMj/vAijmhJWq3w1k2/U4No1Sr1NI7iuEaisawx20RzRGTnyTQo1YqDUdJsP8sLUd2HH63UNdbRWPdyIJdFix/iLdOq3C5bOdGNZQ+9QwXKTxmeE4vs8kbe4cttKyb5vXXmwXmP6Wg3P3GPhXG7TyLmfv+S8sa5RPrpSRgrXrZSRwrUrJfkPt9cwnXXeeOSbm/X2Go14z6mP+EyrIz7FYWv0snJZtJdLNx5XFo68O64kHg0Vmofjsjne+ZHyyJEaYndEvtBaO76l0Zx3NJ+JHZXVd4RUR4cFnj1JzOsi43BoEc7yZfbdi+igVUtGi8jXi4vjF1+/5By240o3LlpGe9ScPrrsBwrDEXtVFEOFq6K4csy/V/gul7v7w/niP2RvKnU+7H4e93b58HK6X9x9/vcJd/Aftqfz4/3+18t5r0rzv9nkx7fgyjZQ/q5fc8qlvHdug/N66fWuHH7lFer7mzrzHw==",
      "is_unconstrained": true,
      "name": "get_proposal_status"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15828287718154638353": {
            "error_kind": "string",
            "string": "Function get_proposal_type can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTiM7DMffpde9SOzETniV1WrVZcuqUlVQF450hHj3Y2fszJSjiboFbuA3HuZffyXOlNfNr/3Pl98/DqeHxz+bu2+vm5/nw/F4+P3j+Hi/ez48nsT6ugn6o+TNHW43VS5YfslVjNtNDHIdk4Ja5E6MKFAUigGQAcbNHehTKBYAgZQcqgAJZLGg/k2uBoQOxYDdwm4pbilsUKMDTQDq6gTZQT9CPh0wOCQHv5XcktyS3ZKLAYEDG3B0IIPiH9ES2UAFg0BFhzIBBnAggxgdsoM9jpAc3ILowAbJBZNbWJ9KCsWg5bCBW6pbqllSc6wBGTTHGmQDCA76EVmhGCA4kEFLprRNYr1VFMigZaxBcigGzbEGEk6ScHKIDmQQ3RLdAm4Bt6BbNFFJWiKn6EAG2S05G1BwEMcSKBQDjWICMtByJ1SoBur8BPqhkijSrDaIwSEboCWcWikVUnSwElB2S7YSEAUHKwGRlYAYHKwEVK0EHK0EHK0EDMEhOVgJGNHBSsApOlh6Obslu4XcQm5ht7CVgEt0sBJwdUu1EpQQHKwEJVgJSgQHK0EBfYoUtAQSadFl3kDXxQRs0IpbBXRdZHGsFHAgA90EJ0gOdYIaJC0ZFNhA/ZnALeAWcAu6Bd2StEmKAhu0ZDbIDvqhuidrlSdQn6WmVXfICdzSnFfQZJK6qu1H0PZw6NRtuo1rHoTYqS2giXIncYJQST3VHMgogE7dppWnNii09BNxt7HoUVYqwZ8oqVN1qt1WrTwxtpRP1G0ROpEThE6uErE/2zbGNr/acpood6pOOo2I2niL0woQIqfabdqqpE+0uWM02zRrbTZGW1lCxQmwU7chdGKn1G3JPYAcOnXl3FWoP1s8ymkgTeRRTiNpIrZ4p8nTxrhvC0KzrVpsqIvLqNu0nVu8mNwXzNDJvULqNvKIkGOnbivdAx8OEUtXrq6SQnv27W278RPNj+fzfq8HmsURRw4+T7vz/vS8uTu9HI/bzT+740v7oz9Pu1P7/bw7y13plP3pl/wWwYfDca/0tp2fDuuPApZqT0MKtQtIR11IxHWJWILmsGkIM3cRjhcasK4hFdNdoGkIy4MrGqNQSnQ3oEJcDSUNJOS4EHo6Is8J5XShkT8hHfS16UigPd4kkrTyajrKIBRA8kgg0ywhjbKUqJ+QjRg+IR2jWDCi+yEn0dVYInxGMPjFwQBDL0xdL0wc9KmcYzwWrpBWQxm1KVJyDeH60VBEYzWUUXtIEt2LXMv6HjboUxkt2Fd+xUSrm9jIEUTonsjASTcs22UwFMJqMCOJwNA7TM4wsxsZLmMZtKm8lrgf8mKy2E0rXmqk0Xrp28eiLEjlUmHQpKlUl0h1MZ5kvl7vRXYJCLDuBQ+WCs9LpcQ8a6TLOQtlVFdv8xTn5oL8rrtGLSrHOA8EFrl4r4FhVFWf9hnDbQrVpwotMvFXccB85MBFRf7nBY5qCr5a5asZvlGDatco9TYNDF0DoaxrDHZRTt4ZnOgmhZp8udd8mw/ywtR34UDrdcU6WqvR3Uglw2LH+It06rcLls58Y1mxd6hguUnjM0KJfZ7IW1y5baVw7FsXD9Zryl+rEYl6LMTlNg3mfv6S88a6RvnoShkpXLdSRgrXrpQcP9xew3TWeeORb27W22s04iPlPuIZVkd8TsPW6GWlsmivkG88rhCuHVcyjYYKzMNx2Rzv/Mg8cqRi6o7IF1prx7c8mvMB5jNxgLL6jpDr6LBAsyeZaF1kHA4swlm+zL57ER20amEvjXy9uDh+0fVLLvh2XOHGRUu+4irnjy77gcJwxF4VxVDhqiiuHPPvFb7L5e7+cL74D9mbSp0Pu5/HvV0+vJzuF3ef/33yO/4ftqfz4/3+18t5r0rzv9nkxzcMZYvA3/VrTrmU984thqiXUe/K4Vdeob6/qTP/AQ==",
      "is_unconstrained": true,
      "name": "get_proposal_type"
    },
    {
      "abi": {
        "error_types": {
          "10673276905078149436": {
            "error_kind": "string",
            "string": "Function get_proposal_votes can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_proposal_votes"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7534754072765660860": {
            "error_kind": "string",
            "string": "Function get_public_hours_per_day can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDACUvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVokNLoiR/+vDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbfjqsgEMbfhWsumBn+9lU2TWNbuzExtnH1JCeN737GRlBPAhe73Rv5wPLrfMMIPMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FGp+OBAHksJZcXBSeO4BcMtd0FKEuc/jIXDrpQClFwEYhRMH5CmAPILIglQUhgXPBq2iYC4GFgaieI1MkxQxttPQ1/Uc2iZYtvCo+robxKEb21aKP1U7vn709ai6VztUPb9VUtTdlVsG3pq2ntUk19kqPxXJh2U2ahUSAMDuEJBHgFfWLwzWziWIgx0D8wxCY8zCYM0TM4ySFQ8xDAwIWSu6gNBgVEoHuDWhTu8Y5g3psL+bDo3WLQhNxmXT4QtWkGx0gsauCBV2iPCGbIB6QzpKXggoxkFEWS+A7zBDv2wGHaaFCfmFgUKdOp+8uIA6a6VUpmR1ZLAOP7XCjKyVUnlwEmMUJvj8HlaoUwxE6csPpG12EysFQoQpEiKtv/HZbs1YpbJmyhsh6ejFg8MEMbj3UihTxGQFcZMOVGbPKGynpEIKhLUx2aSaEgTXIlPo88dLqVKNXSMx1uYhZTu4sbM9Hf6DlOrdUjxwwW4yQp7X98jd6tL0uyvLNMP6pjq39dK9jd1l83b4+4hv4pXn0d8v9XXs65m03nuAnx+EktxxvsTMHS+1Ok7zX/8D",
      "is_unconstrained": true,
      "name": "get_public_hours_per_day"
    },
    {
      "abi": {
        "error_types": {
          "12509127383602948390": {
            "error_kind": "string",
            "string": "Function get_public_window_start_utc can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDACYvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWtmVkURcPpJjwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVbLboMwEPwXn33w7vrJr1RRRBJSISESUahURfx7lwjzqGQf2vSCxyY72Rkvaz/EpToN78e6vd4+RPH2EKeubpr6/djczmVf31pefQg1PRyIgqRwVhROCs8zAB55ClqKMM15PQQevRSg9AwAI3CiQA4B5BVEBqQiMAw4GrSKgHkxMDAQwXNlHKWIuR37rqqm1DbJsoR72VVtL4p2aBopPstmeP7o4162z7EvO36rpKjaC49MeK2bakKjXKNVOhTJhzkatQoLAYDdUUCaAryyfuZg7NxC4mDHgWkOQmPMzMGYAxMcOSkeYhoYEJJSdIZCg1GLHeBWQ53ecZgX2GH/1w6N1s0UmoxL2uEzUpBsVILGrhQq7CjCC9wA9QI7cloIKOZBREktgK8QQ/8sBh0uGxPSGwOZOnV+0eIC6qSUXJmS1ZGDcfirFOZISsmVB5sYszDBp3tYpk4xEC1ffiBtk00slwgRLpkQaf2Lz3YrxiqVFJNthOiWTugJ1q5ucK8lU6aIixTEjR2ozJ4j005JsZNRjArGJE01ORJci0yhTx8vuUo1ds3EWJsmycvBjZzt6fCDJFfvluKBC3bjCHne3wNPy3Pd7a4s40TW1eWpqebpdWjPm7f91z2+iVeee3c7V5ehqyam9d4D/HwjlOQO0yVmmnip1WGc/vob",
      "is_unconstrained": true,
      "name": "get_public_window_start_utc"
    },
    {
      "abi": {
        "error_types": {
          "12732956046506269183": {
            "error_kind": "string",
            "string": "Function get_rate_limits can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABEcnAgEEACcCAgQAHwoAAQACAEQlAAAASSUAAABKLQIBRC0CAkUtAgNGJwIEBEQnAgUEAzsOAAUABCYlAAAA6h4CAAEAHgIAAgAeAgADAB4CAAQAMyoAAwAEAAUnAgMBASQCAAUAAAB9JQAAARAeAgAECSQCAAQAAACPJQAAASInAgMAIi8KAAMABBwKBAUFHAoFAwAcCgMEBScCAwAjLwoAAwAFHAoFBgUcCgYDABwKAwUFJwIDACQvCgADAAYcCgYHBRwKBwMAHAoDBgUtCgQBLQoFAi0KBgMmKAAABAR4RwwAAAQDJAAAAwAAAQ8qAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBbC0jA/sqxn/PAQCASY=",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVdbbuMwDLyLvv0hkqIeuUpRFE7iFAYMJ3CTBRZB7r5UatnOAtJuW+cnGtHRmMOhJeiq9s328v7W9ofjh9q8XNV2aLuufX/rjrv63B57iV6Vjj8uqA1Vyhu1cTLIDKBSQaZgZIxziYN2ArwAwBGgToDVBmUNkEQQI/AjMCQgLjd+BCzEGCIII7ApYmMm8k5wZgReCMlGwCMIKRIkYuSlqHUCVoAoQYAE7pHbrVJJ9tt5aJqoelEHqc6pHpr+rDb9pesq9avuLvc/fZzq/j6e60Ge6ko1/V5GITy0XRPRrZpX6/xSJB/G1Wh0mAgA7AMF5CmkGNaPHIKdm0gcPHBgnoOQmUcOwbIww1GS4iGlgQEhK8UUKAywnsoBbi6oMw8cvEI57HPLYdC6kcIQu2w5fEEKxo7+VIJsZwpplCVFWKEaoFcoR0kLAaU8iCirBXANMfRkMehwMibkjYFCnzo/aXEBTVZKqU3JmsQhOPxUinBkpZTaQ4qYsuDg83tYoU8xEE1ffiBjs5tYKREinDIhMuYbn+1SjNU6K6a0EQbjedLCODc746OWQpsiTlIQF+VAzY8che2UdIin5acYHZizReUSCc5NptHnj5dSp7KdM2Fr8yRlObiQszwd/iIp9buldOCCXVSE/Bf85YlDsNc5f0n/3F+CFfwlXMFfohX8/Yec//OX+Nn+Bjv5ayn7/ZJbwV+/hr9hBX+NXsNfv4K/Br/p76tM6107PNxmbpFsaOtt14zTw6XfLZ6ef5/Sk3QbOg3HXbO/DE1kmq9EIL8vxlYMr/HCIxPGis3rLb76Dw==",
      "is_unconstrained": true,
      "name": "get_rate_limits"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "9390253212426668636": {
            "error_kind": "string",
            "string": "Function get_submolt can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "field"
              },
              {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_submolt"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4902814770287037108": {
            "error_kind": "string",
            "string": "Function get_submolt_count can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDABsvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVECkwOrn9KtDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbbboMwDIbfJde5iO0ceZWpqmhLJyREKwaTpop3n6kIh0nJxdbdEDvUX/07JslDXKrT8H6s2+vtQxRvD3Hq6qap34/N7Vz29a3l2YdQ08OBKEgKZ0XhpPDsAfDILmgpwuTzfAg8eilA6dkAjIYTBXIIIM8gskEqGoYNjgatosFcDGwYiMZzZhyliLkd+66qptQ2ybKEe9lVbS+KdmgaKT7LZnj+6ONets+xLzt+q6So2guPDLzWTTVZo1yjVToUyYc5GrUKCwDA7hCQRoBX1s8Mtp1bIA52DEwzCI0xM4NtDkwwclI8xDQwICSl6AxCg1FLOcCtBXV6xzAvKIf933JotG5GaDIuWQ6fkYJkoxI0dkWosEOEF1QD1AvKkdNCQDEPIkpqAXyFGPpnMehwWZiQXhjI9KnzixYXUCel5NqUrI4MtsNfpTAjKSXXHlzEmIUJPr2HZfoUA9Hy5QfSNrmJ5RIhwiUTIq1/8dluxVilkmJyG6HTPjLQGcAFYnCvJdOmiIsUxE05UJk9I7OdkuJKRjEqGJMsqslBcG0yhT59vOQ61dg1E2NtGpKXgxs529PhByTX75bigQt2UxHyvL4Hdstz3e2uLOME6+ry1FSzex3a8+Zt/3WPb+KV597dztVl6KqJtN57gJ9vhJLcYbrETI6XWh3G6a+/AQ==",
      "is_unconstrained": true,
      "name": "get_submolt_count"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "924033799687402672": {
            "error_kind": "string",
            "string": "Function get_voting_period_blocks can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDADEvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQUM0tPYVtJ0sDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbbboMwDIbfJde5iO0ceZWpqmhLJyREKwaTpop3n6kIh0nJxdbdEDvUX/07JslDXKrT8H6s2+vtQxRvD3Hq6qap34/N7Vz29a3l2YdQ08OBKEgKZ0XhpPDsAfDILmgpwuTzfAg8eilA6dkAjIYTBXIIIM8gskEqGoYNjgatosFcDGwYiMZzZhyliLkd+66qptQ2ybKEe9lVbS+KdmgaKT7LZnj+6ONets+xLzt+q6So2guPDLzWTTVZo1yjVToUyYc5GrUKCwDA7hCQRoBX1s8Mtp1bIA52DEwzCI0xM4NtDkwwclI8xDQwICSl6AxCg1FLOcCtBXV6xzAvKIf933JotG5GaDIuWQ6fkYJkoxI0dkWosEOEF1QD1AvKkdNCQDEPIkpqAXyFGPpnMehwWZiQXhjI9KnzixYXUCel5NqUrI4MtsNfpTAjKSXXHlzEmIUJPr2HZfoUA9Hy5QfSNrmJ5RIhwiUTIq1/8dluxVilkmJyCOB1iQw+hnCBGNxrybQp4iIFcVMOVGbPyGynpLiSMREVjEkW1eQguDaZQp8+XnKdauyaibE2DcnLwY2c7enwA5Lrd0vxwAW7qQh5Xt8Du+W57nZXlnGCdXV5aqrZvQ7tefO2/7rHN/HKc+9u5+oydNVEWu89wM83QknuMF1iJsdLrQ7j9Nff",
      "is_unconstrained": true,
      "name": "get_voting_period_blocks"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17912964520792168034": {
            "error_kind": "string",
            "string": "Function is_agent_verified can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "agent",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndThw7DMffZa/3InZiO+FVjqqK0m2FtAK0hSMdVbz7sTN2ZhdpIrrQG/ith/mPv+Jklt+774dvLz+/3j/8ePy1u/nn9+7b6f54vP/59fh4d/t8//ig1t+7ZD+q/sz7XaXdjex3TT8B6G/9CGW/g2QGMagKVQGyA0IA725Qb4KsFkSD5lCKQjNoDpQDqgOHhcMiYRFxqBDADubpAhSgj8hpv0NMASUgLuWw5LCUsJTqQBggDgwB7CDxCKEAC1CzgTUHVIeGAbxAThBAAX57hhIQFswB4pAxICxsUaBBdbAcLhCWGpYaFnNsAV6gmGMLkAOkAHtENqgOiAHs0JNJCmyX2IAdesY6lIDq0B3rYAnXcEqDAF6AEgSEBcICYcGwWKKytgRZQy7ADiUshRwoBahjJRlUB4tiAXawchcwaA7m/AL60KKJIsuqAdvaWYAc0BPO3UODDAFeAi5hKV4CphTgJWDyEjBjgJeAq5dAkpdAkpdAIAWUAC+BYA7wEkiGAE+vlLCUsFBYKCwcFvYSiECAl0BqWKqXQFoK8BJI8xLUhAFeggqWzGJgJdBIqy3zDrYuFhAHS13R8VVtXRR1rAoGsINNwAVKQHNomhayhzZZoJk/C4QFwgJhwbBgWLI1CRuIgyVzAQrQh1IfvSVAfSatabMJuUBYzPkOlkyqBqrM9ixrvwXcojNclixAskXjRINakHUB2yBP3b3aiYNo2EjvZRvvidOg1aZ6nI2kxB1Sg/p6WWjYGg4SJ0g4KDwASIPKoFABHPf2TqVONKgF2Q7kZBmyXQ76GGejmgatNouo32EN6hQ2TJY17uTLSbdGHCRBOGzIQX2VLTRsJQ0qg4YyDRUe90pE2XehhWoeJEE2Vnu8fbvp9+aYBdA3nIV6H1CnGpSHzXq4x5tL+JJLeJ8JBg0bp0GR0yzDJsOD2BEg16Fch0rr976+7ndxivn6fDoc7BBzdqzRw87T7enw8Ly7eXg5Hve7f2+PL/2Pfj3dPvTfz7cnvaor4/DwXX+r4I/748Hodb/enbZvxVyb363VakMAgC8kYFtC+4yrayiLDBGBCw3c1shIRK6hrDduaMxCqRBu6DkFNkMpE4kClEY6QNaESrnQoE9IB//ddOhRRlyiZJLNdNRJKGjtukSCxKuENsq5RPuEbED6hHTMYsmQww+dAJuxAH5GMPkvB4OCozBtuzAw6VOpIxZpWDZDmbWpHtZDQ7l9NBTV2Axl1h6axPCCWt2eYZM+RT3YjJXfdBPYHGIzR/R1ZniScylXLNvzYPTYvRnMbBDqmXMM9aqHoiFCeBnLpE31FST8IN2fVz9avtSYjFOgGB+YcCjoi92lwqxJZW1SPS6vGuVyh8NZl1I0WIG1rEhv6iqThEKLXOgbedvWqLN8Rkkop+sUWsxzPsvEH8WBa1/ks4q81ciz3Z4w1glQkSs1uA2N2q7T0IPfmBtYtzUm/SklOkMKX6XQSoxyfcW5SkHfDsb80zePbY1JXUuFcKNUwrO1+gfptBdRTyddWdY8OlSxXqXxGaHAmOT6rlSvWykCY3TJZL2W/Hc1gHnEwlKv0xAZJx/d6bc1+KMrZabwvpUyU3jvSintw+01TWdbB49+P7LdXrPNFZjG5iq4ubkSTltjlJXrWXsluvKgkGHroECzdybEdXM8b443ftBkm9dZnmP8KBNtHZxots8nXE+jSb8r2BSR2WGBV0/0y9JtkXk4eBbO+WvkG5FJqzKM7T6fHZ4qv3/JpVBoeOWi5VhxTeijy36iMN1i3xXFVOFdUbxzm3+r8EU/3t7dny7+H/VqUqf722/Hg3/88fJwd3b1+b+nuBL/z3o6Pd4dvr+cDqa0/lNLf/yTNQUZ+Yt9ragfsdE+p2Qfwa6iXW1fXs2Z/wE=",
      "is_unconstrained": true,
      "name": "is_agent_verified"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6014542429501588543": {
            "error_kind": "string",
            "string": "Function is_claim_verified can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "nonce_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndThw7DMffZa/3InZiO+FVjqqK0m2FtAK0hSMdVbz7sTN2ZhdpIrrQG/ith/mPvxJnlt+774dvLz+/3j/8ePy1u/nn9+7b6f54vP/59fh4d/t8//ig1t+7ZD+q/sz7XaXdjex3TT8B6G/9CGW/g2QGMagKVQGyA0IA725Qb4KsFkSD5lCKQjNoDpQDqgOHhcMiYRFxqBDADubpAhSgj8hpv0NMASUgLuWw5LCUsJTqQBggDgwB7CDxCKEAC1CzgTUHVIeGAbxAThBAAX57hhIQFswB4pAxICxsUaBBdbAcLhCWGpYaFnNsAV6gmGMLkAOkAHtENqgOiAHs0JNJCmyX2IAdesY6lIDq0B3rYAnXcEqDAF6AEgSEBcICYcGwWKKytgRZQy7ADiUshRwoBahjJRlUB4tiAXawchcwaA7m/AL60KKJIsuqAdvaWYAc0BPO3UODDAFeAi5hKV4CphTgJWDyEjBjgJeAq5dAkpdAkpdAIAWUAC+BYA7wEkiGAE+vlLCUsFBYKCwcFvYSiECAl0BqWKqXQFoK8BJI8xLUhAFeggqWzGJgJdBIqy3zDrYuFhAHS13R7avauijqWBUMYAfbARcoAc2haVrIHtpkgWb+LBAWCAuEBcOCYcnWJGwgDpbMBShAH0p96y0B6jNpTZvtkAuExZzvYMmkaqDKbM+y9lvALbqHy5IFSLZonGhQC7IuYNvIU3evduIgGjbSe9m298Rp0GpTPc5GUuIOqUF9vSw0bA0HiRMkHBQeAKRBZVCoAI57e6dSJxrUgmwCOVmGbMpB38bZqKZBq80i6ndYgzqFDZNljTv5ctLRiIMkCIcNOaivsoWGraRBZdBQpqHC416JKPsUWqjmQRJk22qPt4+bfm+OvQD6wFmo9wF1qkF52KyHe7y5hC+5hPeZYNCwcRoUOc0ybDI8iIkAuQ7lOlRav/f1db+LU8zX59PhYIeYs2ONHnaebk+Hh+fdzcPL8bjf/Xt7fOl/9Ovp9qH/fr496VVdGYeH7/pbBX/cHw9Gr/v17rR9K+ba/G6tVhsCAHwhAdsS2mdcXUNZZIgIXGjgtkZGInINZb1xQ2MWSoVwQ88psBlKmUgUoDTSAbImVMqFBn1COvjvpkOPMuISJZNspqNOQkFr1yUSJF4ltFHOJdonZAPSJ6RjFkuGHH7oDrAZC+BnBJP/cjAoOArTtgsDkz6VOmKRhmUzlFmb6mE9NJTbR0NRjc1QZu2hSQwvqNXtPWzSp6gHm7Hymw6BzU1s5oi+zgxPci7limV7HoweuzeDmUnY+A4NG71DhPAylkmb6itI+EE6n1c/Wr7UmGynQLF9YMKhoC92lwqzJpW1SfW4vGqUywmHsy6laLACa1mR3tRVJs0BLXKhb+RtW6PO8hlzlnK6TqHFfs5nmfijOHAd9vmsIm818mzaE8Y6ASpypQa3oVHbdRp68Bv7BtZtjUl/SonOkMJXKbQSW7m+4lyloG8HY//TN49tjUldS4Vwo1TCs7X6B+m0F1FPJ11Z1jw6VLFepfEZocDYyfVdqV63UgTG1iWT9Vry39UA5hELS71OQ2ScfHTSb2vwR1fKTOF9K2Wm8N6VUtqH22uazrZuPPr9yHZ7zYYrMI3hKrg5XAmnrTHKyvWsvRJdeVA4m/JvDgo0e2dCXIfjeXO88YMmY1738hzbjzLR1sGJZnM+4XoaTfpdwaaIzA4LvHqiX5Zui8zDwbNwzl8j34hMWpVhjPt8dniq/P4ll0Kh4ZWLlmPFNaGPLvuJwnTEviuKqcK7onjnmH+r8EU/3t7dny7+H/VqUqf722/Hg3/88fJwd3b1+b+nuBL/z3o6Pd4dvr+cDqa0/lNLf/yTNQUZ+Yt9ragfsdE+p2Qfwa6iXW1fXs2Z/wE=",
      "is_unconstrained": true,
      "name": "is_claim_verified"
    },
    {
      "abi": {
        "error_types": {
          "1155064566203370228": {
            "error_kind": "string",
            "string": "Function is_currently_public can only be called statically"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "current_hour_utc",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQcAEREBS0IRAElAAAASiUAAABLLQIBRScCAgRFJwIDBAE7DgADAAImJQAAAXYeAgADAB4CAAQAHgIABQAeAgAGADMqAAUABgAHJwIFAQEkAgAHAAAAfiUAAAGcHgIABgkkAgAGAAAAkCUAAAGuJwIGACUvCgAGAAccCgcIBRwKCAYAHAoGBwUnAgYFAAoqBwYIJAIACAAAAWMjAAAAwScCBAUYDCoHBAYkAgAGAAAA4SMAAADYLQoFAyMAAAFaJwIFACYvCgAFAAYcCgYIBRwKCAUAHAoFBgUAKgYHBQ4qBgUIJAIACAAAARIlAAABwAYqBQQIBCoIBAkCKgUJBwwqBgcEDCoBBgUMKgEHBhYKBQEEKgEGBRYKBAcSKgEGCAQqBAUBBCoHCAQAKgEEBS0KBQMjAAABWi0KAwIjAAABcScCAQEALQoBAiMAAAFxLQoCASYoAAAEBHhGDAAABAMkAAADAAABmyoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFEAedGmkxSvQ8BAIBJioBAAEF0Afr9MvGZ5A8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVdbbuMwDLyLv/0hkXoxVymKwk3dwoDhBG6ywKLI3ZdsJT8KSLvrOj/2mIpGHHIkxx/VS/t8fXvqhtfTe3V4+Kiex67vu7en/nRsLt1p4OhHpeQS+Ip1FWx18HVF/KQ13/lRm7rSSgJeQGAQGGiMAHQCrjoAT9LIEQABFIExDGS6oQgsMwMxcCqBFPGSihJgIyBeC4WZwhcAkCHHAFUCvDpyGmB0AiliJUICXAQuRRxF4DlDowRQBCFFgkRkUZIICJAIVwtVjKCUxXChUMoiP0btGVgGAHEIfAT4Gbnd6ir14ekytq20YdEYbte5GdvhUh2Ga9/X1a+mv37+6P3cDJ/3SzPyKOfYDi98Z8LXrm8F3ep5tspPBQwUZ4NRNBFo7VYUOk+hg3IhcjD2fiLxesUBeQ4Ea23kYMwTMxwlKUGnNIBAZ6WYAoXRVk3lYB/OaZgVh92hHO6+5TDgfKQwaH22HKEgBWRjfSnhrTNTsFGWFLRDNbTaoRwlLbwxUx6ImNWiYQ8xeGcx4GFqDOUbows+9WHS4glMVkrJpuhM4mBMP5XCHFkpJXtwEVMWlkL+DCv4FAhx2vmExmUPsVIifLBPmSAas2HbLsU4pbJiigehh+kkDN7NWiystRRsCjBJAViUA5RdcxSOU1RcySRGkbXZotoSCcwmU6wnS1JyqnVzJta5PElZDizkLN8O30hKfneYXrj8h2euCIb/6W/Qc38X2+5bf4scYfZ7CGYbBymYOMhgjgPh5z5D3MFnaHbwGdodfPYXOf/mM/R39hmvPfc34DaPOFpw0BYOUspNZ7PSfhsH+pnDwTYOt+DYqgUXWkht4tDz+U46rLU88lNz7MbVJ95N2Mauee7b+Ph6HY6L0cvvcxpJn4jn8XRsX65jK0zzd6Lm64PH2odH+Qjkh2Dr4B9vsvQf",
      "is_unconstrained": true,
      "name": "is_currently_public"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17478564478509971481": {
            "error_kind": "string",
            "string": "Function is_post_deleted can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndTiM7DMffpde9SOzYSXiV1WrVZcuqUlVQF450hHj3Y2fszJSjiboFbuA3HuZffyXOlNfNr/3Pl98/DqeHxz+bu2+vm5/nw/F4+P3j+Hi/ez48nsT6ugn6o9DmDrebKhdZfslVjNtNDHIdk4Ja5E6MKFAUigGwAcbNHehTKBYAgZQcqgALkFhQ/4aqAaNDMchuyW4pbinZoEYHngDU1QnIQT9CPh0wOCQHv5XcktxCbqFiwOCQDXJ0YIPiH9ES2UAFg0BFhzIBBnBggxgdyMEeR0gObkF0yAbJBZNbsj6VFIpBy2EDt1S3VLOk5lgDNmiONSADCA76EaRQDBAc2KAlU9omZb1VFNigZaxBcigGzbEGEk6ScChEBzaIboluAbeAW9AtmqgkLUEpOrABuYXIgIODOJZAoRhoFBOwgZY7oUI1UOcn0A+VRLFmtUEMDmSAlnBupVRI0cFKwOQWshIwBwcrAbOVgDM4WAm4WglytBLkaCXIEBySg5UgIzpYCXKKDpbeTG4ht7Bb2C3ZLdlKkEt0sBLk6pZqJSghOFgJSrASlAgOVoIC+hQraAkk0qLLvIGuiwmyQStuFdB1QeJYKeDABroJTpAc6gQ1SFoIFLKB+jOBW8At4BZ0C7olaZMUhWzQktmAHPRDdU/WKk+gPktNq+6QE7ilOa+gyWR1VduPoe3h0KnbdBvXPAhlp7aAJqJO4gSjknqqOZBRAJ26TSvPbVBo6SfK3ZZFj0mpBH+ipE7VqXZbtfLE2FI+UbdF6MROEDq5SsT+bNsY2/xqy2ki6lSddBoxt/EWpxUgxE6127RVWZ9oc8dotmnW2myMtrKEihNgp25D6JSdUrcl9wAodOrK1FW4P1s8ymkgTeRRTiNpomzxTpOnjXHfFoRmW7XYUBeXUbdpO7d4MbkvSNDJvULuNvaIMMdO3Va6Bz4cIpauXF0lhfbs29t24yeaH8/n/V4PNIsjjhx8nnbn/el5c3d6OR63m392x5f2R3+edqf2+3l3lrvSKfvTL/ktgg+H417pbTs/HdYfBSzVnoYUaheQjrqQiOsSsQTNYdMQzrmL5HihAesaUjHdBZqGsDy4ojEKpUR3AyrE1VDSQEKOC6GnI+Y5oTldaNAnpIO/Nh0JtMebRJJWXk1HGYQCyB4JEM8S0ihLifoJ2YjhE9IxigUjuh9yEl2NJcJnBINfHAxk6IWp64WJgz6Vc4zHkiuk1VBGbYqcXEO4fjQU0VgNZdQekkT3gmpZ38MGfSqjBfvKr5h4dRMbOYII3RMZOOmGZbsMhkNYDWa0ETKg51SYZxGCy1gGbSqvJe6HvJgsdtOKlxpptF769rEoC3K5VBg0aSrVJVJdjCeZr9d7QS4BAda9yIOlkuelUiLNGulyzkIZ1dVLkuLcXEDvumvUonKM80BgkYv3GhhGVfVpTxhuU6g+VXiRib+KA+YjBy4q8j8vcFRT8NUqX83kGzW4do1Sb9PA0DUQyrrGYBfNyTsjJ75JoSYfKJVu80FemPouHHi9rlhHazW6G6kQLHaMv0infrtg6aQby4q9QwXLTRqfEUrs80Te4sptKyXHvnXlwXpN9LUakbnHwrncppFzP3/JeWNdo3x0pYwUrlspI4VrVwrFD7fXMJ113njkm5v19hqN+MjUR3yG1RFPadgavaxcFu0V6NbjSl07rhCPhgrMw3HZHO/8oMGYl70cffsRJlo7vtFozgeYz8QByuo7AtXRYYFnT4h5XWQcDizCWb7MvnsRHbQqxz7ucXF4Knz9kguuUOHGRcveHjXTR5f9QGE4Yq+KYqhwVRRXjvn3Ct/lcnd/OF/8h+xNpc6H3c/j3i4fXk73i7vP/z75Hf8P29P58X7/6+W8V6X532zy4xuGskXI3/VrTrmU984thqiXUe/K4Vdeob6/qTP/AQ==",
      "is_unconstrained": true,
      "name": "is_post_deleted"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2924643983786989658": {
            "error_kind": "string",
            "string": "Claim nonce already used"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "nonce_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "register_claim"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "comment_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "upvote_comment",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17979170562840502974": {
            "error_kind": "string",
            "string": "Function upvote_comment_internal can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "comment_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "upvote_comment_internal"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "post_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "upvote_post",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13559665052381278423": {
            "error_kind": "string",
            "string": "Function upvote_post_internal can only be called by the same contract"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "post_id",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tZzbbly3Dobfxde50JlkXqUoCjd1CwOGE7jJBjaKvHtFiodxiqWszDg38effWRyRokRKy8k/d388/P7lr98en//8+Pfd+1/+ufv95fHp6fGv354+frj//Pjxear/3CX+I5dy976+m1/h7j3Mr3V+3/jrWF9b1q/6fZ+P5czQJ7AyWOFHB07ACVAVMBvMp0uZQFMp/BSNBSWl9aOSukJmZTB0hWJKQYVaDea4y/z00ooCj3DBfLzyR/AIFzQDUgBTwBQ0BVGBigEsqCkbDAUec+0TajboCs1+1EzppnRXSGFUA1SAYgAKaB/BURUgNlgZmgEtaKkagEIuBkOhJIOuUE2pzQAVmhkE/jvA0AxIAU1BU8gUwgU9FQNQyNlgKMjAkKEZoALnqQAHs6UJHLE2M7NzxBYMBUwGzYAUaLrTKgMsGDywBaZkU7IpxZRiCidkawygwAm5wJSeDYYCZ2brDM0AFcQLBp7uNhi6ASnI4IEBFwAnpAAHU4AHVgU0ztCKgSk9G2jkYWjkYTQDjTyARh5II49JI4+5GGjksSSDZqCRx6qRx6oxxFYMTOmmdFOGKcMU0MgjaJwRi4EplA008pQ08pSagUaeskaeCj9FDDPyfXpKvC4WoAIvBwEOXZ/bF/Fy6JUBFXg8C4YCh25BN5hh6fNDc+IVq4RG2bXsWnGtuFZdq2yP9+kkI1wERjzhSjyAwcRTrsQeoBAZgWvizaJpb3DxSJyIQz6XM1Eop+rEGlvOnBeLOLZKcwSQmDi6IE/wtqNERs215lp3raMRZ4gSGEF2Gka8KYCMgHcFJTIi18i0kpoTGnGyKIER+6Y0jGpy6k5smYth4TlSQiPOfaVhNLJTd3IrPEdKbgXdCs+WUBU/UAiNOMOUXCuuFdd431UaRtwjKHUj3paV+NNICI1kjhYNI54F5JxsvANjERpGXGCVmhMa8UiVppcoDQtXYqVh1FxrrnXXumvDNc4h5HxpnENKwwhd4815Ea9tJR7pEEIlKXtKw4j7HAQhMhKPFvEIOJJS8xZxT6HUjYbNTB82Mx2yk2uYnLoT6SxIPVQCpcHtziIZH8+RlDmJ+JCYLupOZNSrk83W4JFKdMewiA/ITq6ha+gauUamgcS0C9nMSP1Tcq0kp+5EOgtSKJXASHwT4nymJDRnlbIQGXGWLOLquIijS7w7Iu+E1ITAiMen1J3IiKul0owa8QiQZ18JjJprzbXuWndtuMZlnHgWUEa6aBhxbijxCECIjDg3iIRQiZJpJB4tmvZmtWHkRmmWEUFwrKFWUTmwxMGeG75gd1wHjoWhjlDHhUqOcgZRREfeDQ3BkeSDZbzUFee5JAWGmkPNFyo5lhqIjuKxIji2HDgcl8frSNQCyXHUQHCEEjgcMYxhDwxjFMYIDfPyTQ5hyzfB0gJDraHWUFsNBMdeAofjyIHywSBIjms2F4LjmizicyGXr1mWBcGRC7FhDyRHGboiOy/nTzlKGoJjD7WHOkIdoUKokn2lyuG1BIIjhcpb2kI5YhrK0JsgOS6PF4JjEQtdTsgpsAXKcOTkLDO0sOfA4Qg+hRV8CiuWwFApB/rEtrWG5HieWiA65uIo45XZbA1tWtqK+sLhKMtfsQX6xDYZukxAA5+WhiUwVAqVXJVCbRjqinoV9CnspQSGWnOgT6yU7jVZvbVAdFweC8q6KCgoScDR6ZAC0RGro0xAzXzPwc3SbN8E0VHGqzgcZQIUeyAHVW9PaiA69lB7qCPUESqECmKXJ2vI0BXBUTJKUYbD+QuSUYriGwiSYw51ublQ7HIkQbZixVBbqLL/KsolF8dBTsS5yQfLQpf4AuTAHkiO4hsf1gvKkpagYvKoSyNgKJ/G45Vzs+GFynYbjwyrTyxWn1hcM7Qw1F4CwXGEOmI4kALjIyCMoVsgcUhWLKUeSI6yWhT5sSZYfSumlgIvVLbQBaUAKoYqycXn14m+VRCUQK8Bq+Qr+gaySr6iqXWVfMUWiI65OHptqama8zVVcmw1EBxlp22Cvl1VOV0bhiq50xeiI4Uq2xXHYd4/+shycodyzoGhlhTYHWuoXhYnuvO5xUe0MNbDAjvEHW+Veq0ERtzNK/EjfFdSi7XGVY7Ui7JrkjR8PVKLrGXFUGWL7fJ3eYtdT3FSKXWj7lpvTmQ0XBs+CmmPF7lldCtoz1b2gI9Ek8BIDh+LupOkr9wM29lp1uXi5JpkCF/E1FWLF45QpRR0YIRkT0FzIiN0DdGIqpNpft6uft6uft6uft6ufsqenYO5uk7Ui7oTGUltEKfX8VkeBv8QdG2lBLsn52fDC5XM6Z5sQD2ZC1KXlVwrxcmCu47Qi2wU6zC9yC03t9L9WfagL+pOZMSLVUnyE/kSP+n13py+5BSa+MR7wZDOWjFUPpLO47cg2lOtOIFRd60PI84YJdfAR2G3lJPcMroVsmeBPeBL3io1dhEHWwmMZDscPOlQ9YZ35mRzck1SYhRBdByhSnUd8uF2kz9pGMl1+CLXKDl1JUzJqTmhkd1UV7+qrlJoF1VzVQqqkrmKco2/qJvT6xZ6kX8IuiYpIe6hdJuKrq5SKk5TsgFRTk42NCqu2Y36JAsuVdeqjYJacXLL3a10efbr13d39nLwt88vDw/8bvDibeF8h/jp/uXh+fPd++cvT0/v7v53//RF/tLfn+6f5evn+5f50xmWh+c/5tdp8M/Hpwemr+/i6XT86DxOkD49t3ByA7NyvTKRj03MC5aBaoMvW8CNQH5loxzbmHWBNyyxMXk+eGBj5wpmG8Y83uVDV9rGRJMar+GYN1sxjPbKRn+DcIyfG442u3010eaWeRgO3Lgy67t5Mg9DYWImyqUJeoNo5PQG4dj5UvnaaY1jNgOHvuTyFs7Un+zMbJR8Yuh4YvImT+dObr7A3NYOXdml6ayGZqNy/brRlWnj0JVtejTwgI5yvIdt8nR2qNlyne8IxtHKL5uBzFvPyI95HBqHO2HeeTNKCXfqcZLt3eEKqe7MRu3QnV2mNsvTeWMUvvSr5gWON+Syy9Jhq/YynK1cNQY8rm+7Wc1Avg3OdwMXkXg9jLJJ816yzUeft0IxDqqvbez20u4ZmiLLZwf5ykLduAKRn7Ol62GjvW4Y6i4/e/GsiFDMm7nXFjbb6LxD9twsFz3Hf2zUXTytbek1XWeBLDHGRSR+yI8SvVO9mJH/2Bi7OS3WcMwjNVxpY5DbQLrOxrzX8G244LGNTX5Cs8yANq6yQL7jUL9uDPNKxstJGsfz2jbzOk/IvvHNa7yLtfoD4eTfd9Fw9iuntXqGTsSrbLyFK3IdrLtfw+tWCkRxhc16bfhzbcx33+7LPIJfZwPAG8nZOB3a6PnWlbKzcG6l7CycXSm93Zxe23BSbDzzxfXhMLbFNY/uxRXKYXHlm6xNavi0DrxIr9SvbBQqHTUKfde5lRLF8TI5vhnH2DU987ratp/JvR8eQXd1PpVo7udb9eNz7O5c30eMpI9xbGTvTrlw5/JU/o2RTaqO7OW+XjRP+ANtIHaM2R2Hs7u1QTkyZK7hIxsDbm8lx27VoQ/jorJ820oO2i19z/V5eUwXEW3nR3GqoYV8e0ML5daGFurtDS20WxvarYVTDe3Wj5MNLcDtDe3exrmGdmvjZEOL6dYyvbNwrkzvLJwt01hvLtP7cJ5raPc2zjW0Oxtv4crJhna7Uk42o0g/18bZhnZr42RDS+XWlbKzcG6l7CycXSnUb06vbThPNrTbEn+yoSX8yQ3tq3alH7Y88rukt3a0OeU3aGlnFrxBT5tTfYOm9nsenetqc9q9bRrVs21cROWHGluC7G8TUkrHs/wGXWlONzeEOdHtHWHevnA61RLmnG/vCfPuhdO5pnBv4lRXuHflZFuYd6+bzvaF3zFyrjHcGznZGeaMtxa8rYlzFW9r4mzJy7sXTidr3ndieq49/I6Rc/3h1sibeHOyQ9yvmpPtXS7wk42cbRL3Rk52ibnefKDamji5auobHKlyvf1MtY/pyVZxX3hP9op5e8n/Bs1iSdEszvIN192PXbYi+fB+LNftwYrMmYKZjhvOtn1xXMfwN8f1+F1+brtL9l79znC+hj9sz743FO8DKv+zkeOh7LpW/od6ZiVDP+5aW9t1RtCq976Ax783sl3EyTZ6KtfuA8PWMEG/eSvZmdjW8HOObE2cc+RkJ7ExsT19n/Jja+GUGydvADYW8Oa0wpuzCm9Oqu2rvVNebC2c8uLk68WNhe2r/FNebC2c8uLkrxN8a+HX+e39h8eXV/87z1c29fJ4//vTg37755fnDxc//fz/T/YT+999Pr18/PDwx5eXB7YU/8XP/OMXbPAOx/j13V2Wb2t/hy3xt5m/nf0UQv/1Kw/mXw==",
      "is_unconstrained": true,
      "name": "upvote_post_internal"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6504742485148360234": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "10330371483337376860": {
            "error_kind": "string",
            "string": "Voting period ended"
          },
          "10556702571134275233": {
            "error_kind": "string",
            "string": "Function downvote_comment_internal can only be called by the same contract"
          },
          "10581129473648605397": {
            "error_kind": "string",
            "string": "Function create_proposal_internal can only be called by the same contract"
          },
          "10673276905078149436": {
            "error_kind": "string",
            "string": "Function get_proposal_votes can only be called statically"
          },
          "10708939150157633029": {
            "error_kind": "string",
            "string": "Function get_comment_author can only be called statically"
          },
          "10912982978800048688": {
            "error_kind": "string",
            "string": "Hours must be 0-24"
          },
          "11187874927356395033": {
            "error_kind": "string",
            "string": "Function get_comment_post_id can only be called statically"
          },
          "11237875760331549985": {
            "error_kind": "string",
            "string": "Comment cooldown not elapsed"
          },
          "113085549400429254": {
            "error_kind": "string",
            "string": "Claim already verified"
          },
          "1155064566203370228": {
            "error_kind": "string",
            "string": "Function is_currently_public can only be called statically"
          },
          "12060341850569840067": {
            "error_kind": "string",
            "string": "Agent not verified"
          },
          "12306828111948424472": {
            "error_kind": "string",
            "string": "Function create_submolt_internal can only be called by the same contract"
          },
          "12509127383602948390": {
            "error_kind": "string",
            "string": "Function get_public_window_start_utc can only be called statically"
          },
          "12732956046506269183": {
            "error_kind": "string",
            "string": "Function get_rate_limits can only be called statically"
          },
          "13082641925069760057": {
            "error_kind": "string",
            "string": "Post cooldown not elapsed"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1354009649190367750": {
            "error_kind": "string",
            "string": "Function get_comment_created_at can only be called statically"
          },
          "13545014029643762475": {
            "error_kind": "string",
            "string": "Function downvote_post_internal can only be called by the same contract"
          },
          "13559665052381278423": {
            "error_kind": "string",
            "string": "Function upvote_post_internal can only be called by the same contract"
          },
          "1361523054280208260": {
            "error_kind": "string",
            "string": "Function get_proposal_content_hash can only be called statically"
          },
          "13624811166311613123": {
            "error_kind": "string",
            "string": "Function get_proposal_author can only be called statically"
          },
          "13917265889930826957": {
            "error_kind": "string",
            "string": "Function get_post_author can only be called statically"
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14446999286126106136": {
            "error_kind": "string",
            "string": "Agent verification block not recorded"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15468464099753430534": {
            "error_kind": "string",
            "string": "Function cast_vote_internal can only be called by the same contract"
          },
          "15584638513261197059": {
            "error_kind": "string",
            "string": "Function get_comment_count can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15811002909701486780": {
            "error_kind": "string",
            "string": "Function get_proposal_status can only be called statically"
          },
          "15828287718154638353": {
            "error_kind": "string",
            "string": "Function get_proposal_type can only be called statically"
          },
          "15946742046864573155": {
            "error_kind": "string",
            "string": "Function create_comment_internal can only be called by the same contract"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17068651471790847605": {
            "error_kind": "string",
            "string": "Twitter handle already used"
          },
          "17478564478509971481": {
            "error_kind": "string",
            "string": "Function is_post_deleted can only be called statically"
          },
          "17912964520792168034": {
            "error_kind": "string",
            "string": "Function is_agent_verified can only be called statically"
          },
          "17979170562840502974": {
            "error_kind": "string",
            "string": "Function upvote_comment_internal can only be called by the same contract"
          },
          "18042930026913969259": {
            "error_kind": "string",
            "string": "Function get_agent_count can only be called statically"
          },
          "18233219403911674536": {
            "error_kind": "string",
            "string": "Function get_post_submolt can only be called statically"
          },
          "1855851805910989972": {
            "error_kind": "string",
            "string": "Function get_claim_agent can only be called statically"
          },
          "1939303983761409499": {
            "error_kind": "string",
            "string": "Viewing hours proposals not allowed"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2608738334220796783": {
            "error_kind": "string",
            "string": "Function get_post_created_at can only be called statically"
          },
          "2924643983786989658": {
            "error_kind": "string",
            "string": "Claim nonce already used"
          },
          "3498960012662131245": {
            "error_kind": "string",
            "string": "Function get_min_public_hours can only be called statically"
          },
          "3844188133549269817": {
            "error_kind": "string",
            "string": "Function get_post_votes can only be called statically"
          },
          "3905717565539885644": {
            "error_kind": "string",
            "string": "Function get_proposal_count can only be called statically"
          },
          "4048396286052499169": {
            "error_kind": "string",
            "string": "No agent registered for this nonce"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4612943103503554032": {
            "error_kind": "string",
            "string": "Proposed hours below minimum"
          },
          "4902814770287037108": {
            "error_kind": "string",
            "string": "Function get_submolt_count can only be called statically"
          },
          "4986039336305063277": {
            "error_kind": "string",
            "string": "Function get_comment_votes can only be called statically"
          },
          "5138799157270560027": {
            "error_kind": "string",
            "string": "Function get_proposal_snapshot_block can only be called statically"
          },
          "5178739621314325697": {
            "error_kind": "string",
            "string": "Function get_post_count can only be called statically"
          },
          "5200913191555279574": {
            "error_kind": "string",
            "string": "Proposal not active"
          },
          "5374214884256418360": {
            "error_kind": "string",
            "string": "Function get_comment_parent_id can only be called statically"
          },
          "5425679372158780026": {
            "error_kind": "string",
            "string": "Not authorized to delete"
          },
          "590589903550671092": {
            "error_kind": "string",
            "string": "Proposed hours must be 0-24"
          },
          "6014542429501588543": {
            "error_kind": "string",
            "string": "Function is_claim_verified can only be called statically"
          },
          "6343299670262723826": {
            "error_kind": "string",
            "string": "Function get_comment_content_hash can only be called statically"
          },
          "7039288653030155395": {
            "error_kind": "string",
            "string": "Function get_post_content_hash can only be called statically"
          },
          "7372167904069661094": {
            "error_kind": "string",
            "string": "Daily comment limit reached"
          },
          "7534754072765660860": {
            "error_kind": "string",
            "string": "Function get_public_hours_per_day can only be called statically"
          },
          "7830024613194784770": {
            "error_kind": "string",
            "string": "Invalid proposal type"
          },
          "7932861672720419212": {
            "error_kind": "string",
            "string": "Function get_allow_hours_proposals can only be called statically"
          },
          "822412312360312459": {
            "error_kind": "string",
            "string": "Min hours must be 0-24"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8418147970250171169": {
            "error_kind": "string",
            "string": "Function get_name can only be called statically"
          },
          "8557100619347471449": {
            "error_kind": "string",
            "string": "Function get_proposal_end_block can only be called statically"
          },
          "8658656849933845587": {
            "error_kind": "string",
            "string": "Function create_post_internal can only be called by the same contract"
          },
          "9001026953704595809": {
            "error_kind": "string",
            "string": "Voting period not ended"
          },
          "924033799687402672": {
            "error_kind": "string",
            "string": "Function get_voting_period_blocks can only be called statically"
          },
          "9345055721478160917": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "9390253212426668636": {
            "error_kind": "string",
            "string": "Function get_submolt can only be called statically"
          },
          "9794026722560667155": {
            "error_kind": "string",
            "string": "Agent verified after proposal snapshot"
          },
          "9819042744607351994": {
            "error_kind": "string",
            "string": "Function get_proposal_proposed_hours can only be called statically"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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ADAKABwAHS0LAhgAIhgCGC0OGAIAIgICHS0LHR0tCh0cJwIeBAMAKgIeGDsOABwAGCMAABVOKQIAGAAPv2DICioBGBonAhgADCcCGwAOJwIcAA8nAh0AECcCHgARJwIfABIkAgAaAAAVhyMAABviLQgBGicCIAQEAAgBIAEnAxoEAQAiGgIgHzAASQBOACAtCAEgAAABAgEtDhogLQgBGgAAAQIBLQxLGicCIgQjLQgAIy0KICQtCholAAgAIgAlAACJyi0CAAAtCiQhACIhTiMtCyMiJwIjBCQtCAAkLQogJS0KGiYACAAjACUAAInKLQIAAC0KJSEAIiFOJC0LJCMcCiMkBRwKJCEAJwIkBCUtCAAlLQogJi0KGicACAAkACUAAInKLQIAAC0KJiMAIiNOIC0LIBoeAgAgAB4CACMAHgIAJAAeAgAlADMqACQAJQAmJAIAJgAAFnglAACHWx4CACQBCiIkSCUWCiUmHAomJwAEKickJgoiJUokJAIAJAAAFqYnAicEADwGJwEKKiYjJCQCACQAABa4JQAAijstCAEjJwIkBAMACAEkAScDIwQBACIjAiQtCiQlLQ4FJQAiJQIlLQ4aJScCJQQmLQgAJi0KIyctCFAoLQhKKQAIACUAJQAAh20tAgAALQonJAoiJEwjCiIjSiUkAgAlAAAXHyUAAIj/LwoAJAAjHAojJQEcCiUkABwKJCMBJAIAIwAAF0ElAACKTR4CACMFHAojJAUnAiUAHi0IASYnAicEAwAIAScBJwMmBAEAIiYCJy0KJygtDiUoACIoAigtDhooJwIoBCktCAApLQomKi0IUCstCEosAAgAKAAlAACHbS0CAAAtCionCiInTCYKIiZKKCQCACgAABe3JQAAiP8vCgAnACYcCiYoBRwKKCcAHAonJgUvCgALACccCicpBRwKKSgAHAooJwUCKiQmKA4qJiQpJAIAKQAAF/glAACKXwwqKCckCiIkSiYkAgAmAAAYDyUAAIpxLwoACAAkHAokJwUcCicmABwKJiQFACokFyYOKiQmJyQCACcAABg7JQAAgz4cCiYkADAKACQACC0IASYnAicEAwAIAScBJwMmBAEAIiYCJy0KJygtDhgoACIoAigtDiQoJwIoBCktCAApLQomKi0IUCstCEosAAgAKAAlAACHbS0CAAAtCionCiInTCYKIiZKKCQCACgAABitJQAAiP8wCgAiACctCAEiJwImBAMACAEmAScDIgQBACIiAiYtCiYnLQ4UJwAiJwInLQ4kJycCJwQoLQgAKC0KIiktCFAqLQhKKwAIACcAJQAAh20tAgAALQopJgoiJkwiCiIiSickAgAnAAAZGiUAAIj/MAoAGgAmLQgBIicCJgQDAAgBJgEnAyIEAQAiIgImLQomJy0OGycAIicCJy0OJCcnAicEKC0IACgtCiIpLQhQKi0ISisACAAnACUAAIdtLQIAAC0KKSYKIiZMIgoiIkonJAIAJwAAGYclAACI/zAKACEAJi0IASEnAiIEAwAIASIBJwMhBAEAIiECIi0KIiYtDhwmACImAiYtDiQmJwImBCctCAAnLQohKC0IUCktCEoqAAgAJgAlAACHbS0CAAAtCigiCiIiTCEKIiFKJiQCACYAABn0JQAAiP8cCiMhADAKACEAIi0IASInAiMEAwAIASMBJwMiBAEAIiICIy0KIyYtDh0mACImAiYtDiQmJwImBCctCAAnLQoiKC0IUCktCEoqAAgAJgAlAACHbS0CAAAtCigjCiIjTCIKIiJKJiQCACYAABpmJQAAiP8wCABMACMtCAEiJwIjBAMACAEjAScDIgQBACIiAiMtCiMmLQ4eJgAiJgImLQ4kJicCJgQnLQgAJy0KIigtCFApLQhKKgAIACYAJQAAh20tAgAALQooIwoiI0wiCiIiSiYkAgAmAAAa0yUAAIj/MAgATAAjLQgBIicCIwQDAAgBIwEnAyIEAQAiIgIjLQojJi0OHyYAIiYCJi0OJCYnAiQEJi0IACYtCiInLQhQKC0ISikACAAkACUAAIdtLQIAAC0KJyMKIiNMIgoiIkokJAIAJAAAG0AlAACI/zAIAEwAIy0IASInAiMEAwAIASMBJwMiBAEAIiICIy0KIyQtDiUkACIkAiQtDhokJwIjBCQtCAAkLQoiJS0IUCYtCEonAAgAIwAlAACHbS0CAAAtCiUaCiIaTCIKIiJKIyQCACMAAButJQAAiP8wCgAhABotCwIaACIaAhotDhoCACICAiItCyIiLQoiIScCIwQDACoCIxo7DgAhABojAAAb4ikCABoALVsFewoqARogJAIAIAAAG/0jAAAd7y0IARonAiAEAgAIASABJwMaBAEAIhoCIB8wAE4ATgAgLQgB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AisEMi0IADItCikzLQhQNC0ISjUACAArACUAAIdtLQIAAC0KMyoKIipMKQoiKUorJAIAKwAAKm0lAACI/zAKACAAKi0IASknAioEAwAIASoBJwMpBAEAIikCKi0KKistDiUrACIrAistDigrJwIrBDItCAAyLQopMy0IUDQtCEo1AAgAKwAlAACHbS0CAAAtCjMqCiIqTCkKIilKKyQCACsAACraJQAAiP8wCgAwACotCAEpJwIqBAMACAEqAScDKQQBACIpAiotCiorLQ4mKwAiKwIrLQ4oKycCKwQyLQgAMi0KKTMtCFA0LQhKNQAIACsAJQAAh20tAgAALQozKgoiKkwpCiIpSiskAgArAAArRyUAAIj/MAgATAAqLQgBKScCKgQDAAgBKgEnAykEAQAiKQIqLQoqKy0OJysAIisCKy0OKCsnAioEMi0IADItCikzLQhQNC0ISjUACAAqACUAAIdtLQIAAC0KMygKIihMKQoiKUoqJAIAKgAAK7QlAACI/zAIAEwAKC0IASgnAikEAwAIASkBJwMoBAEAIigCKS0KKSotDi4qACIqAiotDiAqJwIqBDItCAAyLQooMy0IUDQtCEo1AAgAKgAlAACHbS0CAAAtCjMpCiIpTCgKIihKKiQCACoAACwhJQAAiP8wCgAwACktCAEoJwIpBAMACAEpAScDKAQBACIoAiktCikqLQ4xKgAiKgIqLQ4gKicCKQQtLQgALS0KKC4tCFAvLQhKMAAIACkAJQAAh20tAgAALQouIAoiIEwoCiIoSikkAgApAAAsjiUAAIj/ACosFygOKiwoKSQCACkAACylJQAAgz4cCigpADAKACkAIC0LAiAAIiACIC0OIAIAIgICKS0LKSktCikoJwIqBAMAKgIqIDsOACgAICMAACzfKQIAIACCi+L/CioBICgkAgAoAAAs+iMAAC+8LQgBICcCKAQDAAgBKAEnAyAEAQAiIAIoHzAAUABOACgtCAEoAAABAgEtDiAoLQgBIAAAAQIBLQxLICcCKgQrLQgAKy0KKCwtCiAtAAgAKgAlAACJIy0CAAAtCiwpACIpTistCysqHAoqKwUcCispACcCKwQsLQgALC0KKC0tCiAuAAgAKwAlAACJIy0CAAAtCi0qACIqTigtCyggHgIAKAAeAgAqAB4CACsAHgIALAAzKgArACwALSQCAC0AAC2/JQAAh1seAgArAQoiK0gsFgosLRwKLS4ABCouKy0KIixKKyQCACsAAC3tJwIuBAA8Bi4BCiotKiskAgArAAAt/yUAAItgLQgBKicCKwQDAAgBKwEnAyoEAQAiKgIrLQorLC0OBSwAIiwCLC0OICwnAisELC0IACwtCiotLQhQLi0ISi8ACAArACUAAIdtLQIAAC0KLSAKIiBMKgoiKkorJAIAKwAALmYlAACI/y8KACAAKhwKKisBHAorIAAcCiAqASQCACoAAC6IJQAAik0tCAEgJwIqBAMACAEqAScDIAQBACIgAiotCiorLQ4mKwAiKwIrLQ4pKycCKwQsLQgALC0KIC0tCFAuLQhKLwAIACsAJQAAh20tAgAALQotKgoiKkwgCiIgSiskAgArAAAu7yUAAIj/LwoAKgAgHAogKwUcCisqABwKKiAFLQgBKicCKwQDAAgBKwEnAyoEAQAiKgIrLQorLC0OJiwAIiwCLC0OKSwnAisELC0IACwtCiotLQhQLi0ISi8ACAArACUAAIdtLQIAAC0KLSkKIilMKgoiKkorJAIAKwAAL2slAACI/wAqIBcqDiogKiskAgArAAAvgiUAAIM+HAoqIAAwCgAgACktCwIgACIgAiAtDiACACICAiotCyoqLQoqKScCKwQDACoCKyA7DgApACAjAAAvvCkCACAAjCMERgoqASAoJAIAKAAAL9cjAAAymS0IASAnAigEAwAIASgBJwMgBAEAIiACKB8wAFAATgAoLQgBKAAAAQIBLQ4gKC0IASAAAAECAS0MSyAnAioEKy0IACstCigsLQogLQAIACoAJQAAiSMtAgAALQosKQAiKU4rLQsrKhwKKisFHAorKQAnAisELC0IACwtCigtLQogLgAIACsAJQAAiSMtAgAALQotKgAiKk4oLQsoIB4CACgAHgIAKgAeAgArAB4CACwAMyoAKwAsAC0kAgAtAAAwnCUAAIdbHgIAKwEKIitILBYKLC0cCi0uAAQqListCiIsSiskAgArAAAwyicCLgQAPAYuAQoqLSorJAIAKwAAMNwlAACLci0IASonAisEAwAIASsBJwMqBAEAIioCKy0KKywtDgUsACIsAiwtDiAsJwIrBCwtCAAsLQoqLS0IUC4tCEovAAgAKwAlAACHbS0CAAAtCi0gCiIgTCoKIipKKyQC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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6504742485148360234": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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1FqoUSABGdiAeR2S2MwuUYEGdOAojFxyIQEZGGfBgX5d6iQK32TW70hsUJdIQAY2YAcKMNqhT1S0r+KMFWesHSjAaF8JNKADR6GhNw1qht409KahNw29aehNszoGc+AodPSmUx2DM7ABoeZQc6g5xo5j7DjGzsC5DYydgZYcaMmBllyej2MYaMmBlhxQg+cJnid4nuB5gucJnqdH9Rstzy80oAOr32h5fiEBoQbPEzxP8DzB8wTPEzxP8Dxx9RsxARnYgB0YahqowFCzQAeOwuX5hVON4hjC8xc2YAcKUIEGdOBUozjI6fnEuH+Iluw9XRjby8l8y0Fie7lEAzoQPSToIUEPCQMbsAMFiB4S9JCghwQ9pBh9yBqkGA+K8aAYD5EfZs2eRNVf4iiM/EDRDpEfKI4s8sOFDdiBAlSgAR04CiMTUIySyAQXdqAAFWhAB47CyAQXEhBqA2oDagNqA2oDagNqo9Si6i+RgAxswA4UoAIN6ECoEdQIagQ1ghpBjaBGUCOoEdQIagw1hhpDjaHGUGOoMdQYagw1hlqDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qHWoeaQE2gJlATqAnUBGoCNYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqBnUDGoGNYOaQc2gZlAzqBnUDGoONYcacgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5c05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglbeUSCzSgA0fhyiULCcjABuxAAUJtQG1AbZRafzyABGRgA3agAGPtVgMN6MBRSA8gAUNtBDZgB061+a6GRIFlogEdOAojl1w4z22+4iFRYCnzQ2QSBZaJHShABRrQgaMwcsmFBIRay3VpiQLLRAHmurREgWWi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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "molt_cloak.MoltCloak",
  "noir_version": "1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "MoltCloak"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_preset",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "agent_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "agent_verified",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "agent_twitter_hash",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "twitter_hash_used",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claim_nonce_agent",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claim_nonce_verified",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_content_hash",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_author",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_submolt",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_created_at",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_votes_up",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_votes_down",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_deleted",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_content_hash",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_post_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_parent_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_author",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_created_at",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_votes_up",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_votes_down",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "submolt_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "submolt_name_hash",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "submolt_creator",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "agent_last_post_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "agent_last_comment_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "agent_daily_comment_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "agent_daily_comment_reset_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "post_cooldown_blocks",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "comment_cooldown_blocks",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "daily_comment_limit",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_hours_per_day",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000025"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_window_start_utc",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000026"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "allow_hours_proposals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000027"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "min_public_hours",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000028"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000029"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_content_hash",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_author",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_votes_for",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_votes_against",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_status",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_end_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_type",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000030"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_period_blocks",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000031"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_snapshot_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000032"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "agent_verified_at_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000033"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_proposed_hours",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000034"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_support",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::cast_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::cast_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_support",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::cast_vote_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::cast_vote_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_nonce_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_twitter_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::complete_verification_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::complete_verification_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "_admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_privacy_preset",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_public_hours_per_day",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_post_cooldown_blocks",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_comment_cooldown_blocks",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_daily_comment_limit",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_voting_period_blocks",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_allow_hours_proposals",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "_min_public_hours",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_content_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_post_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_parent_comment_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::create_comment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::create_comment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_content_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_post_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_parent_comment_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::create_comment_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::create_comment_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_content_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_submolt_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::create_post_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::create_post_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_content_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_submolt_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::create_post_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::create_post_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_content_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_proposed_hours",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::create_proposal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::create_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_content_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_proposed_hours",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::create_proposal_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::create_proposal_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_name_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::create_submolt_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::create_submolt_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_name_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::create_submolt_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::create_submolt_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_post_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::delete_post_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::delete_post_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_comment_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::downvote_comment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::downvote_comment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_comment_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::downvote_comment_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::downvote_comment_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_post_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::downvote_post_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::downvote_post_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_post_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::downvote_post_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::downvote_post_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::execute_proposal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::execute_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_admin_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_agent_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_agent_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_allow_hours_proposals_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_allow_hours_proposals_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_nonce_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_claim_agent_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_claim_agent_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_comment_author_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_comment_author_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_comment_content_hash_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_comment_content_hash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_comment_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_comment_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_comment_created_at_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_comment_created_at_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_comment_parent_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_comment_parent_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_comment_post_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_comment_post_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_comment_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_comment_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_min_public_hours_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_min_public_hours_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_post_author_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_post_author_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_post_content_hash_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_post_content_hash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_post_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_post_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_post_created_at_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_post_created_at_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_post_submolt_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_post_submolt_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_post_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_post_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_author_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_author_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_content_hash_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_content_hash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_end_block_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_end_block_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_proposed_hours_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_proposed_hours_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_snapshot_block_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_snapshot_block_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_status_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_status_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_type_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_type_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_proposal_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_proposal_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_public_hours_per_day_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_public_hours_per_day_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_public_window_start_utc_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_public_window_start_utc_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_rate_limits_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 64
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_rate_limits_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_submolt_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "field"
                  },
                  {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_submolt_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_submolt_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_submolt_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::get_voting_period_blocks_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::get_voting_period_blocks_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_agent",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::is_agent_verified_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::is_agent_verified_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_nonce_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::is_claim_verified_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::is_claim_verified_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_current_hour_utc",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::is_currently_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::is_currently_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::is_post_deleted_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::is_post_deleted_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_nonce_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::register_claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::register_claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_comment_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::upvote_comment_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::upvote_comment_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_comment_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::upvote_comment_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::upvote_comment_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_post_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::upvote_post_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::upvote_post_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_post_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "molt_cloak::MoltCloak::upvote_post_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "molt_cloak::MoltCloak::upvote_post_internal_abi"
        }
      ]
    }
  },
  "transpiled": true
}
