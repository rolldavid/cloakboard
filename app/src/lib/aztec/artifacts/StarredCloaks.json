{
  "file_map": {
    "101": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "103": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "124": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "126": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/calls_generation/external_functions_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, serialized_args_array_len_quote, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n    let serialized_args_array_len: u32 =\n        unquote!(quote { ($serialized_args_array_len_quote) as u32 });\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        serialized_args_array_len, fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\npub(crate) comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::UtilityCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::UtilityCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\n// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf and EnqueueSelfStatic structs\n\n// Note: Unlike for the call registry, the self-call registry stubs directly perform the call instead of returning a\n// call interface struct.\n// TODO(F-131): This ^ is confusing and should be reflected in the naming.\n\n/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private\n/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).\npub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let args_hash = aztec::hash::hash_args($serialized_args_array_name);\n            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);\n            let returns_hash = self.context.call_private_function_with_args_hash(\n                self.address,\n                selector,\n                args_hash,\n                $is_static\n            );\n            returns_hash.get_preimage()\n        }\n    }\n}\n\n// TODO(F-131): Drop the use of the Call in the following 4 functions - it doesn't make sense to not not\n// perform the call directly using the context. I tried doing this already but it became a lot of pain due to the use of\n// slices and them being illegal to return from unconstrained functions. Makes sense to tackle this when cleaning up the\n// call interface code.\n// Note: Once we get rid of the structs we will be able to merge some of the static and non-static stub functions.\n\n/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)\npub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).call(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)\npub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicStaticCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).view(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicStaticCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue_view(self.context);\n        }\n    }\n}\n\n/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue(self.context);\n        }\n    }\n}\n"
    },
    "129": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr",
      "source": "use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "132": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "136": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/helpers.nr",
      "source": "use crate::macros::{\n    functions::auth_registry::AUTHORIZE_ONCE_REGISTRY,\n    utils::{is_fn_initializer, is_fn_only_self, is_fn_view},\n};\nuse std::meta::ctstring::AsCtString;\n\n/// Gathers all attributes relevant to the function's ABI and returns a quote that can be applied to the newly generated\n/// function. We apply the abi marker attributes instead of the original ones (e.g. abi_view instead of view) to avoid\n/// the relevant attribute's functionality from getting triggered.\npub(crate) comptime fn get_abi_relevant_attributes(f: FunctionDefinition) -> Quoted {\n    let mut attributes = quote {};\n\n    if is_fn_view(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_view] };\n    }\n\n    if is_fn_only_self(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self] };\n    }\n\n    if is_fn_initializer(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_initializer] };\n    }\n\n    attributes\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                self.address,\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        let args_len = f.parameters().len();\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(self.msg_sender().unwrap())) {\n            $fn_call(self.context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n"
    },
    "138": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/private.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, create_message_discovery_call, get_abi_relevant_attributes,\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, fn_has_nophasecheck, is_fn_initializer,\n        is_fn_only_self, is_fn_view, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn generate_private_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n\n    let original_params_quotes = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    let params = quote { inputs: aztec::context::inputs::private_context_inputs::PrivateContextInputs, $original_params_quotes };\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let storage_init = if module_has_storage {\n        // Contract has Storage defined so we initialize it.\n        quote {\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            $args_serialization\n            let args_hash = aztec::hash::hash_args($serialized_args_name);\n            let mut context = aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<&mut aztec::context::private_context::PrivateContext> = CallSelf { address: self_address, context: &mut context };\n            let enqueue_self: EnqueueSelf<&mut aztec::context::private_context::PrivateContext> = EnqueueSelf { address: self_address, context: &mut context };\n            let call_self_static: CallSelfStatic<&mut aztec::context::private_context::PrivateContext> = CallSelfStatic { address: self_address, context: &mut context };\n            let enqueue_self_static: EnqueueSelfStatic<&mut aztec::context::private_context::PrivateContext> = EnqueueSelfStatic { address: self_address, context: &mut context };\n            let internal: CallInternal<&mut aztec::context::private_context::PrivateContext> = CallInternal { context: &mut context };\n            aztec::contract_self::ContractSelf::new_private(&mut context, storage, call_self, enqueue_self, call_self_static, enqueue_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(*self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Phase checks are skipped in functions that request to manually handle phases\n    let initial_phase_store = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote { let within_revertible_phase: bool = self.context.in_revertible_phase(); }\n    };\n\n    let no_phase_change_check = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote {   \n            assert_eq(\n                within_revertible_phase,\n                self.context.in_revertible_phase(),\n                f\"Phase change detected on function with phase check. If this is expected, use #[nophasecheck]\",\n            ); \n        }\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            self.context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { self.context.finish() };\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $initial_phase_store\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let body_quote = body.map(|expr| expr.quoted()).join(quote { });\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $no_phase_change_check\n        $context_finish\n    };\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n        $abi_relevant_attributes\n        fn $fn_name($params) -> return_data aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n            $to_prepend\n            $body_quote\n            $to_append\n        }\n    }\n}\n"
    },
    "139": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n"
    },
    "146": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, owner: AztecAddress, storage_slot: Field, randomness: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field, owner: AztecAddress) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field, owner: AztecAddress) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, owner: aztec::protocol_types::address::AztecAddress, storage_slot: Field, randomness: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [aztec::protocol_types::traits::ToField::to_field(owner), storage_slot, randomness]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                owner: aztec::protocol_types::address::AztecAddress,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                owner: aztec::protocol_types::address::AztecAddress,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        let i = i as u8;\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n"
    },
    "149": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "150": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "151": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n"
    },
    "152": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "153": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n"
    },
    "154": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "156": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "173": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "185": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "188": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::{note_hash_read::NoteHashRead, PrivateContext},\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_read<Note>(retrieved_note: RetrievedNote<Note>) -> NoteHashRead\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(\n        retrieved_note.owner,\n        retrieved_note.storage_slot,\n        retrieved_note.randomness,\n    );\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        NoteHashRead::new_settled(compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        ))\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        NoteHashRead::new_transient(note_hash, retrieved_note.contract_address)\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(retrieved_note: RetrievedNote<Note>) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_note_hash_read(\n        retrieved_note,\n        compute_note_hash_read(retrieved_note),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_read` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_note_hash_read<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_read: NoteHashRead,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash = compute_siloed_note_hash(\n            note_hash_read.contract_address().unwrap(), // Safe since contract address must be populated for pending note reads.\n            note_hash_read.note_hash(),\n        );\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_read.note_hash()\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification = compute_note_hash_for_nullification(retrieved_note);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(\n        context,\n        retrieved_note.owner,\n        note_hash_for_nullification,\n    );\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "193": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "194": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "195": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "196": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "197": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "202": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "203": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "205": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "207": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            owner,\n            storage_slot,\n            randomness,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _owner: AztecAddress,\n    _storage_slot: Field,\n    _randomness: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _owner: Option<AztecAddress>,\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    owner: Option<AztecAddress>,\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            owner,\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "210": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "212": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "216": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "228": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "253": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "256": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "257": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "259": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "260": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "263": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "274": {
      "path": "/Users/rolldavid/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "294": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "353": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "363": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "376": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "377": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "378": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "379": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "386": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "391": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "407": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "409": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "410": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "415": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "419": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "444": {
      "path": "/Users/rolldavid/Documents/Projects/priv_ideas/private-dao/contracts/starred_cloaks/src/main.nr",
      "source": "pub mod types;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract StarredCloaks {\n    use dep::aztec::{\n        keys::getters::get_public_keys,\n        macros::{functions::{initializer, external, internal, view, only_self}, storage::storage},\n        protocol_types::{\n            address::AztecAddress,\n            traits::{Hash, ToField},\n        },\n        state_vars::{Map, PublicMutable},\n    };\n\n    // ===== STORAGE =====\n    // Using a Map-based approach similar to MultiAuthAccount.\n    // Each star is stored as: hash(owner, cloak_address) -> bool\n    // This allows O(1) lookup for \"is starred\" checks.\n    // To enumerate, the client keeps track of starred addresses locally.\n    #[storage]\n    struct Storage<Context> {\n        /// Maps hash(owner, cloak_address) -> is_starred\n        stars: Map<Field, PublicMutable<bool, Context>, Context>,\n        /// Counter per user (for debugging/info only)\n        star_counts: Map<AztecAddress, PublicMutable<u32, Context>, Context>,\n    }\n\n    // ===== INITIALIZER =====\n    // Contract has no state to initialize - just needed for deployment\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor() {}\n\n    // ===== PRIVATE FUNCTIONS =====\n\n    /// Star a cloak - creates a record that only the sender can verify ownership of\n    /// Uses a nullifier to prevent double-starring the same cloak\n    #[external(\"private\")]\n    fn star(cloak_address: AztecAddress) {\n        let sender = self.msg_sender().unwrap();\n\n        // Compute nullifier to prevent double-starring\n        // Derived from (sender, cloak_address) so each user can only star a cloak once\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        let nullifier = std::hash::pedersen_hash([\n            cloak_address.to_field(),\n            secret\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        // Enqueue the public state update\n        self.enqueue_self.add_star_internal(sender, cloak_address);\n    }\n\n    /// Unstar a cloak - removes the star record\n    /// Uses a different nullifier domain to prevent replay\n    #[external(\"private\")]\n    fn unstar(cloak_address: AztecAddress) {\n        let sender = self.msg_sender().unwrap();\n\n        // Compute nullifier for unstar operation (different domain)\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n        // Add a domain separator (1) to differentiate from star nullifier\n        let nullifier = std::hash::pedersen_hash([\n            1 as Field,\n            cloak_address.to_field(),\n            secret\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        // Enqueue the public state update\n        self.enqueue_self.remove_star_internal(sender, cloak_address);\n    }\n\n    // ===== INTERNAL PUBLIC FUNCTIONS =====\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_star_internal(owner: AztecAddress, cloak_address: AztecAddress) {\n        let star_id = std::hash::pedersen_hash([owner.to_field(), cloak_address.to_field()]);\n\n        // Check not already starred\n        let already_starred = self.storage.stars.at(star_id).read();\n        assert(!already_starred, \"already starred\");\n\n        // Add the star\n        self.storage.stars.at(star_id).write(true);\n\n        // Increment count\n        let count = self.storage.star_counts.at(owner).read();\n        self.storage.star_counts.at(owner).write(count + 1);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn remove_star_internal(owner: AztecAddress, cloak_address: AztecAddress) {\n        let star_id = std::hash::pedersen_hash([owner.to_field(), cloak_address.to_field()]);\n\n        // Check is starred\n        let is_starred = self.storage.stars.at(star_id).read();\n        assert(is_starred, \"not starred\");\n\n        // Remove the star\n        self.storage.stars.at(star_id).write(false);\n\n        // Decrement count\n        let count = self.storage.star_counts.at(owner).read();\n        if count > 0 {\n            self.storage.star_counts.at(owner).write(count - 1);\n        }\n    }\n\n    // ===== VIEW FUNCTIONS =====\n\n    /// Check if a specific cloak is starred by a specific owner\n    #[external(\"public\")]\n    #[view]\n    fn is_starred(owner: AztecAddress, cloak_address: AztecAddress) -> pub bool {\n        let star_id = std::hash::pedersen_hash([owner.to_field(), cloak_address.to_field()]);\n        self.storage.stars.at(star_id).read()\n    }\n\n    /// Get the star count for an owner\n    #[external(\"public\")]\n    #[view]\n    fn get_star_count(owner: AztecAddress) -> pub u32 {\n        self.storage.star_counts.at(owner).read()\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "84": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "85": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/calls.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata_array};\nuse crate::oracle::execution_cache;\n\n// PrivateCall\n\n#[must_use = \"Your private call needs to be passed into the `self.call(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_private_function(...args))`\"]\npub struct PrivateCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T>\nwhere\n    T: Deserialize,\n{\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_private_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\n// PrivateStaticCall\n\n#[must_use = \"Your private static call needs to be passed into the `self.view(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_private_static_function(...args))`\"]\npub struct PrivateStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_private_static_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\n// PublicCall\n\n#[must_use = \"Your public call needs to be passed into the `self.call(...)`, `self.enqueue(...)` or `self.enqueue_incognito(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_public_function(...args))`\"]\npub struct PublicCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    gas_opts: GasOpts,\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PublicCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub unconstrained fn call(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\n// PublicStaticCall\n\n#[must_use = \"Your public static call needs to be passed into the `self.view(...)`, `self.enqueue_view(...)` or `self.enqueue_view_incognito(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_public_static_function(...args))`\"]\npub struct PublicStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    return_type: T,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, let N: u32, T> PublicStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub unconstrained fn view(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view_incognito(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\n// UtilityCall\n\npub struct UtilityCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> UtilityCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n"
    },
    "92": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/note_hash_read.nr",
      "source": "use protocol_types::address::aztec_address::AztecAddress;\n\npub struct NoteHashRead {\n    note_hash: Field,\n    contract_address: Option<AztecAddress>,\n}\n\nimpl NoteHashRead {\n    pub fn new_transient(note_hash: Field, contract_address: AztecAddress) -> Self {\n        assert(\n            !contract_address.is_zero(),\n            \"Can't read a transient note with a zero contract address\",\n        );\n        Self { note_hash, contract_address: Option::some(contract_address) }\n    }\n\n    pub fn new_settled(note_hash: Field) -> Self {\n        Self { note_hash, contract_address: Option::none() }\n    }\n\n    pub fn note_hash(self) -> Field {\n        self.note_hash\n    }\n\n    pub fn contract_address(self) -> Option<AztecAddress> {\n        self.contract_address\n    }\n}\n"
    },
    "93": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{\n        inputs::PrivateContextInputs, note_hash_read::NoteHashRead, returns_hash::ReturnsHash,\n    },\n    hash::{hash_args, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter, notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, find_first_index, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // Incrementing the side effect counter when ending setup ensures non\n        // ambiguity for the counter where we change phases.\n        self.side_effect_counter += 1;\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardize on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact approach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n        let side_effect = Scoped::new(\n            Counted::new(note_hash, self.next_counter()),\n            contract_address,\n        );\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Asserts that a NoteHashRead has been requested to the kernel by this context.\n    /// Asserts instead of returning a boolean to save on gates.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash read to assert that has been requested.\n    ///\n    pub fn assert_has_been_requested(self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n\n        // Safety: The index is constrained by the checks below.\n        let hinted_index = unsafe {\n            find_first_index(\n                self.note_hash_read_requests.storage(),\n                |r| (r.contract_address == contract_address) & (r.innermost() == note_hash),\n            )\n        };\n        // This assertion is not necessary, since the .get would fail. But it enables us to have a more explicit error message.\n        assert(\n            hinted_index != self.note_hash_read_requests.max_len(),\n            \"Note hash read has not been requested\",\n        );\n\n        let request = self.note_hash_read_requests.get(hinted_index);\n        assert_eq(request.contract_address, contract_address);\n        assert_eq(request.innermost(), note_hash);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    /// * `contract_address` - The contract address that emitted the nullifier\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the nullifier is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(\n        &mut self,\n        nullifier: Field,\n        contract_address: AztecAddress,\n    ) {\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incoming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes) or that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "94": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "96": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "97": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr",
      "source": "use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14038773263350813474": {
            "error_kind": "string",
            "string": "already starred"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8345164613724797859": {
            "error_kind": "string",
            "string": "Function add_star_internal can only be called by the same contract"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "cloak_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_star_internal"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_initializer"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "1328284639907573998": {
            "error_kind": "string",
            "string": "Function get_star_count can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndThw7DMffZa+5iJ3YTniVo6qidFshrRa0hSMdVbz7sTN2ZhdpIrrQG/ith/mPv+Jk2N+77/tvLz+/Phx/PP7a3f7ze/ft9HA4PPz8eni8v3t+eDyq9fcu2Y+qP/PNrtLuVm52TT8B6G/9COVmB8kMYlAVqgJkB4QA3t2i3gRZLYgGzaEUhWbQHCgHVAcOC4dFwiLiUCGAHczTBShAH5HTzQ4xBZSAuJTDksNSwlKqA2GAODAEsIPEI4QCLEDNBtYcUB0aBvACOUEABfjtGUpAWDAHiEPGgLCwRYEG1cFyuEBYalhqWMyxBXiBYo4tQA6QAuwR2aA6IAawQ08mKbBdYgN26BnrUAKqQ3esgyVcwykNAngBShAQFggLhAXDYonK2hJkDbkAO5SwFHKgFKCOlWRQHSyKBdjByl3AoDmY8wvoQ4smiiyrBmxrZwFyQE84dw8NMgR4CbiEpXgJmFKAl4DJS8CMAV4Crl4CSV4CSV4CgRRQArwEgjnASyAZAjy9UsJSwkJhobBwWNhLIAIBXgKpYaleAmkpwEsgzUtQEwZ4CSpYMouBlUAjrbbMO9i6WEAcLHVFx1e1dVHUsSoYwA42ARcoAc2haVrIHtpkgWb+LBAWCAuEBcOCYcnWJGwgDpbMBShAH0p99JYA9Zm0ps0m5AJhMec7WDKpGqgy27Os/RZwi85wWbIAyRaNEw1qQdYFbIM8dfdqJw6iYSO9l228J06DVpvqcTaSEndIDerrZaFhazhInCDhoPAAIA0qg0IFcNzbO5U60aAWZDuQk2XIdjnoY5yNahq02iyifoc1qFPYMFnWuJMvJ90acZAE4bAhB/VVttCwlTSoDBrKNFR43CsRZd+FFqp5kATZWO3x9u2m35tjFkDfcBbqfUCdalAeNuvhHm8u4Usu4X0mGDRsnAZFTrMMmwwPYkeAXIdyHSqt3/v6erOLU8zX59N+b4eYs2ONHnae7k774/Pu9vhyONzs/r07vPQ/+vV0d+y/n+9OelVXxv74XX+r4I+Hw97o9Wa9O23firk2v1ur1YaA+nghAdsS2mdcXUNZZIi0cqGB2xoZicg1lAW2NGahVAg39JwCm6GUiUQBSiMdIGtCm1xo0Cekg/9uOvQoIy5RMslmOuokFLR2XSJB4jMJvJBon5ANSJ+QjlksGXL4oRNgMxbAzwgm/+VgUHAUpm0XBiZ9KnXEIg3LZiizNtXDemgot4+GohqboczaQ5MYXlCr2zNs0qeoB5ux8ptuAptDbOaIvs4MT3Iu5Yplex6MHrs3g5mtfG7RYEUQh4S+01yGMulSfQMJN0i356GBwJcak2kKFNMD0+pF1ja5UJj1qKw9qqflVYPzpcasSSn6q8BaVZQ3uZBJb0CLXOgLedvWqLN8xjZLOV2n0GKc81km/igOXPf6fFaRtxp5ttkTxjIBKnKlBrehUdt1GnruG2MD67bGpD+lRGdI4asUWomFpm84Vynoy8EYf/risa0xqWupMNZ7pbWu0P4gnfYe6umkK8uaR4cq1qs0PiMUGINcX5XqdStFYIwumazXkv+uBjCPWFjqdRoi4+CjG/22Bn90pcwU3rdSZgrvXSmlfbi9puls6+BpuJ3O6eYKTGNzFdzcXAmnrTHKyvWsvXQYXnNOyGXznECzNybEdW887403btBkl9dRnmP6KBNtHZtots0nXM+iSf9TsCkis7MCr57ov0q3Rebh4Fk45y+Rb0Rm7025joFczo6B9o7+7jWXYh43vHLVciy5JvTRdT9RmO6x74piqvCuKN65z79V+KIf7+4fThffR72a1Onh7tth7x9/vBzvz64+//cUV+L7rKfT4/3++8tpb0rrl1r645+sKcjIX+zfivoRddnmlOwj2FW0q+3LqznzPw==",
      "is_unconstrained": true,
      "name": "get_star_count"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3472255854549728106": {
            "error_kind": "string",
            "string": "Function is_starred can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "cloak_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "is_starred"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13721464325525241687": {
            "error_kind": "string",
            "string": "Function remove_star_internal can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17546193885696951090": {
            "error_kind": "string",
            "string": "not starred"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "cloak_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "remove_star_internal"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "cloak_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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c5mcy+RcJucyOZfJuUzOZXIuk3OZnMvkXCbnMjmXyblMzmVyLpNzmZzL5Fwm5zI5l8m5TM5lci6Tc5mcy+RcJucyOZfJuUzOZXIuk3OZnMvkXCbna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+fZiGSStIfO0J+HVUOxDflQDN2mL+ePZGgN7aEzNB42HjYeNh42Hj4ePh4+Hj4ePh4+Hj4ePh4+Hj4eMR4xHjEeMR4xHjEeMR4xHjEeMR53PO543PG443HH447HHY87Hnc8bntk49IjGVpDe+gM6ZAN+VAMjYeMh4yHjIeMh4yHjIeMh4yHjIeMxxqPNR5rPNZ4rPFY47HGY43HGo81Hns89njs8djjscdjj8cejz0eezz2eJzxOONxxuOMxxmPMx5nPM54nPE446HjoeOh46HjoeMxOT+T8zM5P5PzMznPpifTJBlaQ3voDOmQDflQDN0mHw8fDx8PHw8fDx8PHw8fDx8PH48YjxiPGI8YjxiPGI8YjxiPGI8YjzsedzzueNzxuONxx+OOxx2POx63PbI56pEMraE9dIZ0yIZ8KIbGQ8ZDxkPGQ8ZDxkPGQ8ZDxkPGQ8ZjjccajzUeazzWeKzxWOOxxmONxxqPPR57PPZ47PHY47HHY4/HHo89Hns8znic8TjjccbjjMcZjzMeZzzOeJzx0PHQ8dDx0PHQ8dDx0PHQ8dDx0PGYnOvkXCfnOjnXyblO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",
      "is_unconstrained": false,
      "name": "star",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "cloak_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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c5mcy+RcJucyOZfJuUzOZXIuk3OZnMvkXCbnMjmXyblMzmVyLpNzmZzL5Fwm5zI5l8m5TM5lci6Tc5mcy+RcJucyOZfJuUzOZXIuk3OZnMvkXCbna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m52tyvibna3K+Judrcr4m53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+d7cr4n53tyvifne3K+J+fZiGSStIfO0J+HVUOxDflQDN2mL+ePZGgN7aEzNB42HjYeNh42Hj4ePh4+Hj4ePh4+Hj4ePh4+Hj4eMR4xHjEeMR4xHjEeMR4xHjEeMR53PO543PG443HH447HHY87Hnc8bntk49IjGVpDe+gM6ZAN+VAMjYeMh4yHjIeMh4yHjIeMh4yHjIeMxxqPNR5rPNZ4rPFY47HGY43HGo81Hns89njs8djjscdjj8cejz0eezz2eJzxOONxxuOMxxmPMx5nPM54nPE446HjoeOh46HjoeMxOT+T8zM5P5PzMznPpifTJBlaQ3voDOmQDflQDN0mHw8fDx8PHw8fDx8PHw8fDx8PH48YjxiPGI8YjxiPGI8YjxiPGI8YjzsedzzueNzxuONxx+OOxx2POx63PbI56pEMraE9dIZ0yIZ8KIbGQ8ZDxkPGQ8ZDxkPGQ8ZDxkPGQ8ZjjccajzUeazzWeKzxWOOxxmONxxqPPR57PPZ47PHY47HHY4/HHo89Hns8znic8TjjccbjjMcZjzMeZzzOeJzx0PHQ8dDx0PHQ8dDx0PHQ8dDx0PGYnOvkXCfnOjnXyblO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",
      "is_unconstrained": false,
      "name": "unstar",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "TJ3LsjS7bpzf5Yw9aIAECPpVPHBYvigUoZAifBnp5b0KIJA58f7SOj8TxSpkV1eje/3HP/7H//yn//fP//Vf/u1//fv/+cd//i//8Y9/+t//8q//+i///F//9d//+3/7v//y7//29//7H//4ff9P/P2/6z/9I+Qf/9n+/qP1n1X/2fUfq/94/efUf6L+c/M/91f/qVVurXJrlVur3Frl1iq3Vrm1yq1V5Pd7/5X3X33/Xe+/+/3X3n/9/fe8/8b771tP3nry1pO3nrz15K0nbz1568lbT9568tbTt56+9fStp289fevpW0/fevrW07eevvXWW2+99dZbb7311ltvvfXWW2+99dZbb7319ltvv/X2W2+/9fZbb7/19ltvv/X2W2+/9eytZ289e+vZW8/eevbWs7eevfXsb73z/ffWf/33/ivvv3/rye+D1bAb/paU9cHfmpL/49MQDffB+TVIw9/KKh+sht1gDX8rq35wGqLhW/k7gq89CqThWzk+WA27wRq84TREw33wtUyBNPTKt1e+vfLXPOvblq99Ck5DNNwC/bqoQBq0YTXsBmvwhtMQDb2y9MrSK0uvLL2y9MrSK0uvLL2y9MrSK2uv/LXW0g+0YTXsBmvwhtMQDffB12MFvfLqlVevvHrl1SuvXnn1yqtXXr3y7pV3r7x75d0r715598q7V9698u6Vd69svbL1ytYrW69svbL1ytYrW69svbL1yt4re6/svbL3yt4re6/svbL3yt4re698euXTK59e+fTKp1c+vfLplU+vfHrl0ytHrxy9cvTK0StHrxy9cvTKXw8u+yAa7oOvBwukQRtWw26wBm/olW+vfN/KK3swPpAGbfhbea8PdoM1eMNpiIb74OvBAmnQhl5ZemXpleUl0pLTEA0vkZb+GqRBG1bDbrCGXll7Ze2Vvx7c/gdfDxZIgzasht1gDd5wGqKhV9698u6Vd6/89eA+H+wGa/CG0xAN98HXgwXSoA29svXK1ivnK+D+4DREw33w9WCBNGjDatgN1tAre6/svbL3yqdXPr3y6ZVPr3x65dMrn1759MqnVz69cvTK0StHrxy9cvTK0StHrxy9cvTK0SvfXvn2yrdXvr3y7ZVvr3x75dsr3175vpX379cgDdqwGnaDNXjDaYiGXll6ZemVpVeWXll6ZemVpVeWXll6ZemVtVfWXll7Ze2V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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "1328284639907573998": {
            "error_kind": "string",
            "string": "Function get_star_count can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13721464325525241687": {
            "error_kind": "string",
            "string": "Function remove_star_internal can only be called by the same contract"
          },
          "14038773263350813474": {
            "error_kind": "string",
            "string": "already starred"
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17546193885696951090": {
            "error_kind": "string",
            "string": "not starred"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3472255854549728106": {
            "error_kind": "string",
            "string": "Function is_starred can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8345164613724797859": {
            "error_kind": "string",
            "string": "Function add_star_internal can only be called by the same contract"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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AgIEHzAATABMAAQAIgJMBS0LBQQeAgACAB4CAAUAHgIABgAeAgAHADMqAAYABwAIJAIACAAAEdElAAAcyB4CAAYJJAIABgAAEeMlAAAfcC0IAQYnAgcEAwAIAQcBJwMGBAEAIgYCBy0KBwgtDgMIACIIAggtDgQIJwIEBActCAAHLQoGCC0ITgktCEgKAAgABAAlAAAdSy0CAAAtCggDCiIDSgQKIgRIBiQCAAYAABJKJQAAHvIvCgADAAQcCgQGBBwKBgMAJwIGBAEnAggEAwAqBggHLQgBBAAIAQcBJwMEBAEAIgQCBy0OBgcAIgcCBy0OBgcnAgcEAwAqBAcGLQoGBy0OAwcAIgQCBy0LBwctCgcGJwIIBAMAKgQIAzsOAAYAAyMAABK9JwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDg8SCiBISwIkAgACAAAUficCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQXpSUPomzfdLAAiBQIFACIQAgYnAgcEGy0CBgMtAgUELQIHBSUAAB+CJwIGBBsAKgUGBS0MTQUAIgUCBS0OAQUAIgUCBTwOAwQAIhECDgAqDgIPLQsPBBwKBA8GHAoPDgACKgQODwQqDwUTBChEEw8AKg4PFAoqBBQPJAIADwAAFMAnAhUEADwGFQEKIhNFBBYKBA8cCgQUABwKDwQABCoUDg8EKgQTFQAqDxUWBCIURg8EIgRFFAAqDxQEDCoWBA8kAgAPAAAVBycCBAQAPAYEAS0LEAQEIgJODy0CBAMnAAQE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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10522114655416116165": {
            "error_kind": "string",
            "string": "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8556029555939094797": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "StarredCloaks",
  "noir_version": "1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "StarredCloaks"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "stars",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "star_counts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_cloak_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "StarredCloaks::add_star_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::add_star_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "StarredCloaks::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "StarredCloaks::get_star_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::get_star_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_cloak_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "StarredCloaks::is_starred_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::is_starred_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "StarredCloaks::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_cloak_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "StarredCloaks::remove_star_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::remove_star_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_cloak_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "StarredCloaks::star_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::star_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "StarredCloaks::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_cloak_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "StarredCloaks::unstar_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "StarredCloaks::unstar_abi"
        }
      ]
    }
  },
  "transpiled": true
}
