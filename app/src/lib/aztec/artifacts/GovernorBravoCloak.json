{
  "file_map": {
    "103": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/calls_generation/external_functions_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, serialized_args_array_len_quote, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n    let serialized_args_array_len: u32 =\n        unquote!(quote { ($serialized_args_array_len_quote) as u32 });\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        serialized_args_array_len, fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\npub(crate) comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::UtilityCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::UtilityCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\n// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf and EnqueueSelfStatic structs\n\n// Note: Unlike for the call registry, the self-call registry stubs directly perform the call instead of returning a\n// call interface struct.\n// TODO(F-131): This ^ is confusing and should be reflected in the naming.\n\n/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private\n/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).\npub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let args_hash = aztec::hash::hash_args($serialized_args_array_name);\n            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);\n            let returns_hash = self.context.call_private_function_with_args_hash(\n                self.address,\n                selector,\n                args_hash,\n                $is_static\n            );\n            returns_hash.get_preimage()\n        }\n    }\n}\n\n// TODO(F-131): Drop the use of the Call in the following 4 functions - it doesn't make sense to not not\n// perform the call directly using the context. I tried doing this already but it became a lot of pain due to the use of\n// slices and them being illegal to return from unconstrained functions. Makes sense to tackle this when cleaning up the\n// call interface code.\n// Note: Once we get rid of the structs we will be able to merge some of the static and non-static stub functions.\n\n/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)\npub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).call(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)\npub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicStaticCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).view(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicStaticCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue_view(self.context);\n        }\n    }\n}\n\n/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue(self.context);\n        }\n    }\n}\n"
    },
    "108": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr",
      "source": "use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "111": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "117": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/private.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, create_message_discovery_call, get_abi_relevant_attributes,\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, fn_has_nophasecheck, is_fn_initializer,\n        is_fn_only_self, is_fn_view, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn generate_private_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n\n    let original_params_quotes = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    let params = quote { inputs: aztec::context::inputs::private_context_inputs::PrivateContextInputs, $original_params_quotes };\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let storage_init = if module_has_storage {\n        // Contract has Storage defined so we initialize it.\n        quote {\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            $args_serialization\n            let args_hash = aztec::hash::hash_args($serialized_args_name);\n            let mut context = aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<&mut aztec::context::private_context::PrivateContext> = CallSelf { address: self_address, context: &mut context };\n            let enqueue_self: EnqueueSelf<&mut aztec::context::private_context::PrivateContext> = EnqueueSelf { address: self_address, context: &mut context };\n            let call_self_static: CallSelfStatic<&mut aztec::context::private_context::PrivateContext> = CallSelfStatic { address: self_address, context: &mut context };\n            let enqueue_self_static: EnqueueSelfStatic<&mut aztec::context::private_context::PrivateContext> = EnqueueSelfStatic { address: self_address, context: &mut context };\n            let internal: CallInternal<&mut aztec::context::private_context::PrivateContext> = CallInternal { context: &mut context };\n            aztec::contract_self::ContractSelf::new_private(&mut context, storage, call_self, enqueue_self, call_self_static, enqueue_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(*self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Phase checks are skipped in functions that request to manually handle phases\n    let initial_phase_store = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote { let within_revertible_phase: bool = self.context.in_revertible_phase(); }\n    };\n\n    let no_phase_change_check = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote {   \n            assert_eq(\n                within_revertible_phase,\n                self.context.in_revertible_phase(),\n                f\"Phase change detected on function with phase check. If this is expected, use #[nophasecheck]\",\n            ); \n        }\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            self.context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { self.context.finish() };\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $initial_phase_store\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let body_quote = body.map(|expr| expr.quoted()).join(quote { });\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $no_phase_change_check\n        $context_finish\n    };\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n        $abi_relevant_attributes\n        fn $fn_name($params) -> return_data aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n            $to_prepend\n            $body_quote\n            $to_append\n        }\n    }\n}\n"
    },
    "118": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n"
    },
    "128": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "129": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "130": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n"
    },
    "131": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "132": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n"
    },
    "133": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "134": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "135": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n"
    },
    "152": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "172": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "173": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "174": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "175": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "176": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "181": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "182": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "184": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "186": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            owner,\n            storage_slot,\n            randomness,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _owner: AztecAddress,\n    _storage_slot: Field,\n    _randomness: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _owner: Option<AztecAddress>,\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    owner: Option<AztecAddress>,\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            owner,\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "189": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "191": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "195": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "205": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::state_variable::StateVariable,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> StateVariable<M + 1, Context> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "207": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "232": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "235": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "236": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "238": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "239": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "242": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "246": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "253": {
      "path": "/Users/rolldavid/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "273": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "311": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "332": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "342": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "355": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "356": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "357": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "358": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "365": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "370": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "386": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "388": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "389": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "394": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "398": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "411": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/Users/rolldavid/Documents/Projects/priv_ideas/private-dao/contracts/governor_bravo/src/governor_bravo_cloak.nr",
      "source": "/// Governor Bravo Cloak Contract -- Full Privacy Implementation\n///\n/// Implements all OpenZeppelin Governor features with full privacy on Aztec:\n/// - GovernorCore: propose, execute, cancel, castVote, state machine\n/// - GovernorSettings: governance-updatable votingDelay, votingPeriod, proposalThreshold\n/// - GovernorVotes + GovernorVotesQuorumFraction: dynamic quorum as fraction of total supply\n/// - GovernorCountingSimple: For/Against/Abstain with private voting\n/// - GovernorCountingFractional: split voting power across choices\n/// - GovernorTimelockControl: timelock queue/execute\n/// - GovernorStorage: on-chain proposal detail storage\n/// - GovernorPreventLateQuorum: extend deadline if quorum reached late\n/// - GovernorProposalGuardian: designated guardian can cancel proposals\n/// - Multi-target proposals: batched protocol upgrades\n/// - Private delegation: delegate voting power without revealing relationships\n///\n/// Privacy Architecture:\n/// - Private token gating (token-only, no admin invite)\n/// - Private proposal threshold proof (ZK range proof)\n/// - Fully private voting (nullifier-based, voter identity never stored)\n///\n/// NOTE: All helper function logic has been inlined at call sites because\n/// Aztec Noir v3 contract functions annotated with #[external(\"public\")] or\n/// #[internal(\"public\")] return PublicCall<...> objects that cannot be used\n/// synchronously from other contract functions.\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract GovernorBravoCloak {\n    use dep::aztec::{\n        keys::getters::get_public_keys,\n        macros::{functions::{initializer, external, view, only_self, internal}, storage::storage},\n        protocol_types::{address::AztecAddress, traits::{Hash, ToField, FromField}},\n        state_vars::{Map, PublicMutable, PublicImmutable},\n    };\n    use dep::compressed_string::FieldCompressedString;\n    use crate::types::proposal::GovernorProposal;\n\n    // ===== PROPOSAL STATES (Governor Bravo / OZ compatible) =====\n    global STATE_PENDING: u8 = 0;\n    global STATE_ACTIVE: u8 = 1;\n    global STATE_CANCELED: u8 = 2;\n    global STATE_DEFEATED: u8 = 3;\n    global STATE_SUCCEEDED: u8 = 4;\n    global STATE_QUEUED: u8 = 5;\n    global STATE_EXPIRED: u8 = 6;\n    global STATE_EXECUTED: u8 = 7;\n\n    // ===== VOTE SUPPORT =====\n    global VOTE_AGAINST: u8 = 0;\n    global VOTE_FOR: u8 = 1;\n    global VOTE_ABSTAIN: u8 = 2;\n\n    // ===== STORAGE =====\n\n    #[storage]\n    struct Storage<Context> {\n        // ===== CONFIGURATION (immutable after init or governance-updatable) =====\n        name: PublicImmutable<FieldCompressedString, Context>,\n\n        // GovernorSettings (updatable via governance only)\n        voting_delay: PublicMutable<u32, Context>,\n        voting_period: PublicMutable<u32, Context>,\n        proposal_threshold: PublicMutable<u128, Context>,\n\n        // GovernorVotesQuorumFraction\n        quorum_numerator: PublicMutable<u128, Context>,\n        quorum_denominator: PublicMutable<u128, Context>,\n\n        // GovernorPreventLateQuorum\n        late_quorum_extension: PublicMutable<u32, Context>,\n\n        // GovernorTimelockControl\n        timelock_delay: PublicMutable<u32, Context>,\n\n        // GovernorProposalGuardian\n        proposal_guardian: PublicMutable<AztecAddress, Context>,\n\n        // ===== PROPOSALS (GovernorStorage) =====\n        proposals: Map<Field, PublicMutable<GovernorProposal, Context>, Context>,\n        proposal_count: PublicMutable<u64, Context>,\n\n        // Vote tallies (public aggregates only -- voter identity never stored)\n        proposal_for_votes: Map<Field, PublicMutable<u128, Context>, Context>,\n        proposal_against_votes: Map<Field, PublicMutable<u128, Context>, Context>,\n        proposal_abstain_votes: Map<Field, PublicMutable<u128, Context>, Context>,\n\n        // ===== TOKEN / VOTING POWER =====\n        governance_token: PublicImmutable<AztecAddress, Context>,\n        token_address: PublicImmutable<AztecAddress, Context>,\n        total_supply_snapshot: Map<Field, PublicMutable<u128, Context>, Context>,\n\n        // Voting power (private state managed via token proofs)\n        voting_power: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        delegated_power: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        delegates: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        total_voting_power: PublicMutable<u128, Context>,\n\n        // Checkpoint: account -> block -> voting power at that block\n        voting_power_checkpoints: Map<AztecAddress, Map<Field, PublicMutable<u128, Context>, Context>, Context>,\n        // Track latest checkpoint block per account (for writes)\n        latest_checkpoint_block: Map<AztecAddress, PublicMutable<u32, Context>, Context>,\n\n        // ===== TOKEN GATING (token-only, no admin invite) =====\n        // mode: 0 = aztec-token, 1 = erc20-token\n        membership_mode: PublicMutable<u8, Context>,\n        token_gate_address: PublicMutable<AztecAddress, Context>,\n        erc20_token_address_hash: PublicMutable<Field, Context>,\n        erc20_min_balance: PublicMutable<u128, Context>,\n        used_nullifiers: Map<Field, PublicMutable<bool, Context>, Context>,\n\n        // ===== PRIVACY CONFIG =====\n        privacy_membership: PublicMutable<u8, Context>,\n        privacy_proposals: PublicMutable<u8, Context>,\n        privacy_voting: PublicMutable<u8, Context>,\n        privacy_treasury: PublicMutable<u8, Context>,\n        privacy_identity: PublicMutable<u8, Context>,\n        privacy_delegation: PublicMutable<u8, Context>,\n        privacy_execution: PublicMutable<u8, Context>,\n        privacy_quorum: PublicMutable<u8, Context>,\n        privacy_threshold: PublicMutable<u8, Context>,\n        privacy_guardian: PublicMutable<u8, Context>,\n        privacy_timelock: PublicMutable<u8, Context>,\n        privacy_fractional: PublicMutable<u8, Context>,\n        privacy_late_quorum: PublicMutable<u8, Context>,\n        privacy_storage: PublicMutable<u8, Context>,\n\n        // ===== TIMELOCK ROLES =====\n        timelock_proposer: PublicMutable<AztecAddress, Context>,\n        timelock_executor: PublicMutable<AztecAddress, Context>,\n        timelock_canceller: PublicMutable<AztecAddress, Context>,\n\n        // ===== CLOAK MODE =====\n        // 0 = token-holder, 1 = multisig, 2 = hybrid\n        cloak_mode: PublicImmutable<u8, Context>,\n\n        // ===== COUNCIL (mode 1 = multisig signers, mode 2 = security council) =====\n        council_member_0: PublicMutable<AztecAddress, Context>,\n        council_member_1: PublicMutable<AztecAddress, Context>,\n        council_member_2: PublicMutable<AztecAddress, Context>,\n        council_member_3: PublicMutable<AztecAddress, Context>,\n        council_member_4: PublicMutable<AztecAddress, Context>,\n        council_member_5: PublicMutable<AztecAddress, Context>,\n        council_member_6: PublicMutable<AztecAddress, Context>,\n        council_member_7: PublicMutable<AztecAddress, Context>,\n        council_member_8: PublicMutable<AztecAddress, Context>,\n        council_member_9: PublicMutable<AztecAddress, Context>,\n        council_member_10: PublicMutable<AztecAddress, Context>,\n        council_member_11: PublicMutable<AztecAddress, Context>,\n        council_count: PublicMutable<u8, Context>,\n        council_threshold: PublicMutable<u8, Context>,       // M-of-N for normal ops\n        emergency_threshold: PublicMutable<u8, Context>,     // higher threshold, mode 2 only\n\n        // Per-proposal council approval tracking\n        council_approvals: Map<Field, Map<AztecAddress, PublicMutable<bool, Context>, Context>, Context>,\n        council_approval_counts: Map<Field, PublicMutable<u8, Context>, Context>,\n\n        // ===== VISIBILITY =====\n        // true = open (anyone can view), false = closed (token holders only)\n        // Can be changed via governance proposal\n        is_publicly_viewable: PublicMutable<bool, Context>,\n    }\n\n    // ===== INITIALIZER =====\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        name: str<31>,\n        governance_token: AztecAddress,\n        voting_delay: u32,\n        voting_period: u32,\n        proposal_threshold: u128,\n        quorum_numerator: u128,\n        quorum_denominator: u128,\n        late_quorum_extension: u32,\n        timelock_delay: u32,\n        proposal_guardian: AztecAddress,\n        membership_mode: u8,\n        token_gate_address: AztecAddress,\n        erc20_token_address_hash: Field,\n        erc20_min_balance: u128,\n        cloak_mode: u8,\n        council_members: [AztecAddress; 12],\n        council_count: u8,\n        council_threshold: u8,\n        emergency_threshold: u8,\n        is_publicly_viewable: bool,\n    ) {\n        self.storage.name.initialize(FieldCompressedString::from_string(name));\n        self.storage.cloak_mode.initialize(cloak_mode);\n        self.storage.is_publicly_viewable.write(is_publicly_viewable);\n\n        // Token fields (mode 0 and 2)\n        self.storage.governance_token.initialize(governance_token);\n        self.storage.token_address.initialize(governance_token);\n\n        // GovernorSettings\n        self.storage.voting_delay.write(voting_delay);\n        self.storage.voting_period.write(voting_period);\n        self.storage.proposal_threshold.write(proposal_threshold);\n\n        // GovernorVotesQuorumFraction\n        self.storage.quorum_numerator.write(quorum_numerator);\n        self.storage.quorum_denominator.write(if quorum_denominator == 0 { 100 } else { quorum_denominator });\n\n        // GovernorPreventLateQuorum\n        self.storage.late_quorum_extension.write(late_quorum_extension);\n\n        // GovernorTimelockControl\n        self.storage.timelock_delay.write(timelock_delay);\n\n        // GovernorProposalGuardian\n        self.storage.proposal_guardian.write(proposal_guardian);\n\n        // Token gating\n        self.storage.membership_mode.write(membership_mode);\n        self.storage.token_gate_address.write(token_gate_address);\n        self.storage.erc20_token_address_hash.write(erc20_token_address_hash);\n        self.storage.erc20_min_balance.write(erc20_min_balance);\n\n        // Initialize counters\n        self.storage.proposal_count.write(0);\n        self.storage.total_voting_power.write(0);\n\n        // Council storage\n        self.storage.council_count.write(council_count);\n        self.storage.council_threshold.write(council_threshold);\n        self.storage.emergency_threshold.write(emergency_threshold);\n\n        // Store council members\n        self.storage.council_member_0.write(council_members[0]);\n        self.storage.council_member_1.write(council_members[1]);\n        self.storage.council_member_2.write(council_members[2]);\n        self.storage.council_member_3.write(council_members[3]);\n        self.storage.council_member_4.write(council_members[4]);\n        self.storage.council_member_5.write(council_members[5]);\n        self.storage.council_member_6.write(council_members[6]);\n        self.storage.council_member_7.write(council_members[7]);\n        self.storage.council_member_8.write(council_members[8]);\n        self.storage.council_member_9.write(council_members[9]);\n        self.storage.council_member_10.write(council_members[10]);\n        self.storage.council_member_11.write(council_members[11]);\n\n        // Mode 1: give each council member voting_power = 1\n        if cloak_mode == 1 {\n            let mut total: u128 = 0;\n            for idx in 0..12 {\n                if idx < council_count as u32 {\n                    let member = council_members[idx];\n                    if !member.is_zero() {\n                        self.storage.voting_power.at(member).write(1);\n                        total += 1;\n                    }\n                }\n            }\n            self.storage.total_voting_power.write(total);\n        }\n\n        // Default privacy config (all private)\n        self.storage.privacy_membership.write(2);\n        self.storage.privacy_proposals.write(2);\n        self.storage.privacy_voting.write(2);\n        self.storage.privacy_treasury.write(1);\n        self.storage.privacy_identity.write(2);\n        self.storage.privacy_delegation.write(2);\n        self.storage.privacy_execution.write(1);\n        self.storage.privacy_quorum.write(1);\n        self.storage.privacy_threshold.write(2);\n        self.storage.privacy_guardian.write(1);\n        self.storage.privacy_timelock.write(1);\n        self.storage.privacy_fractional.write(2);\n        self.storage.privacy_late_quorum.write(1);\n        self.storage.privacy_storage.write(1);\n\n        // Timelock roles default to deployer (msg_sender)\n        let deployer = self.msg_sender().unwrap();\n        self.storage.timelock_proposer.write(deployer);\n        self.storage.timelock_executor.write(deployer);\n        self.storage.timelock_canceller.write(deployer);\n    }\n\n    // =========================================================================\n    // PRIVATE TOKEN GATING (Membership -- Token-Only, No Admin Invite)\n    // =========================================================================\n\n    /// Join with Aztec token proof (mode 0).\n    #[external(\"private\")]\n    fn join_with_token_proof(balance_commitment: Field) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([\n            balance_commitment,\n            secret\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.add_member_internal(sender, balance_commitment);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_member_internal(member: AztecAddress, balance_commitment: Field) {\n        let mode = self.storage.membership_mode.read();\n        assert(mode == 0, \"not aztec-token mode\");\n\n        let current = self.storage.voting_power.at(member).read();\n        if current == 0 {\n            self.storage.voting_power.at(member).write(1);\n            let total = self.storage.total_voting_power.read();\n            self.storage.total_voting_power.write(total + 1);\n\n            // Checkpoint: write effective votes at current block\n            let effective = 1 + self.storage.delegated_power.at(member).read();\n            let current_block = self.context.block_number();\n            self.storage.voting_power_checkpoints.at(member).at(current_block as Field).write(effective);\n            self.storage.latest_checkpoint_block.at(member).write(current_block);\n        }\n    }\n\n    /// Join with ERC20 proof (mode 1).\n    #[external(\"private\")]\n    fn join_with_erc20_proof(verified_balance: u128, proof_nullifier: Field) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([proof_nullifier, secret]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.add_erc20_member_internal(sender, verified_balance, proof_nullifier);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_erc20_member_internal(member: AztecAddress, verified_balance: u128, proof_nullifier: Field) {\n        let mode = self.storage.membership_mode.read();\n        assert(mode == 1, \"not erc20-token mode\");\n        assert(verified_balance >= self.storage.erc20_min_balance.read(), \"insufficient balance\");\n        assert(!self.storage.used_nullifiers.at(proof_nullifier).read(), \"nullifier already used\");\n\n        self.storage.used_nullifiers.at(proof_nullifier).write(true);\n\n        let current = self.storage.voting_power.at(member).read();\n        if current == 0 {\n            self.storage.voting_power.at(member).write(verified_balance);\n            let total = self.storage.total_voting_power.read();\n            self.storage.total_voting_power.write(total + verified_balance);\n\n            // Checkpoint: write effective votes at current block\n            let effective = verified_balance + self.storage.delegated_power.at(member).read();\n            let current_block = self.context.block_number();\n            self.storage.voting_power_checkpoints.at(member).at(current_block as Field).write(effective);\n            self.storage.latest_checkpoint_block.at(member).write(current_block);\n        }\n    }\n\n    // =========================================================================\n    // PRIVATE DELEGATION\n    // =========================================================================\n\n    /// Delegate voting power privately.\n    #[external(\"private\")]\n    fn delegate(delegatee: AztecAddress) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([\n            delegatee.to_field(),\n            secret,\n            0xDE1E6A7E\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.delegate_internal(sender, delegatee);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn delegate_internal(delegator: AztecAddress, delegatee: AztecAddress) {\n        let power = self.storage.voting_power.at(delegator).read();\n\n        let old_delegate = self.storage.delegates.at(delegator).read();\n        if !old_delegate.is_zero() {\n            let old_power = self.storage.delegated_power.at(old_delegate).read();\n            self.storage.delegated_power.at(old_delegate).write(old_power - power);\n        }\n\n        self.storage.delegates.at(delegator).write(delegatee);\n        if !delegatee.is_zero() {\n            let new_power = self.storage.delegated_power.at(delegatee).read();\n            self.storage.delegated_power.at(delegatee).write(new_power + power);\n        }\n\n        // Checkpoint all affected accounts\n        let current_block = self.context.block_number();\n\n        // Checkpoint delegator\n        let delegator_effective = self.storage.voting_power.at(delegator).read()\n            + self.storage.delegated_power.at(delegator).read();\n        self.storage.voting_power_checkpoints.at(delegator).at(current_block as Field).write(delegator_effective);\n        self.storage.latest_checkpoint_block.at(delegator).write(current_block);\n\n        // Checkpoint old delegatee\n        if !old_delegate.is_zero() {\n            let old_effective = self.storage.voting_power.at(old_delegate).read()\n                + self.storage.delegated_power.at(old_delegate).read();\n            self.storage.voting_power_checkpoints.at(old_delegate).at(current_block as Field).write(old_effective);\n            self.storage.latest_checkpoint_block.at(old_delegate).write(current_block);\n        }\n\n        // Checkpoint new delegatee\n        if !delegatee.is_zero() {\n            let new_effective = self.storage.voting_power.at(delegatee).read()\n                + self.storage.delegated_power.at(delegatee).read();\n            self.storage.voting_power_checkpoints.at(delegatee).at(current_block as Field).write(new_effective);\n            self.storage.latest_checkpoint_block.at(delegatee).write(current_block);\n        }\n    }\n\n    /// Get effective voting power (own + delegated)\n    #[external(\"public\")]\n    fn get_effective_votes(account: AztecAddress) -> u128 {\n        let own = self.storage.voting_power.at(account).read();\n        let delegated = self.storage.delegated_power.at(account).read();\n        own + delegated\n    }\n\n    // =========================================================================\n    // PRIVATE PROPOSING (with ZK threshold proof)\n    // =========================================================================\n\n    /// Create a new proposal with private threshold proof.\n    #[external(\"private\")]\n    fn propose(\n        actions_hash: Field,\n        description_hash: Field,\n        target_count: u8,\n        proposal_type: u8,\n    ) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([\n            actions_hash,\n            description_hash,\n            secret\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.create_proposal_internal(\n            sender, actions_hash, description_hash, target_count, proposal_type\n        );\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn create_proposal_internal(\n        proposer: AztecAddress,\n        actions_hash: Field,\n        description_hash: Field,\n        target_count: u8,\n        proposal_type: u8,\n    ) {\n        let mode = self.storage.cloak_mode.read();\n\n        // Mode 1 (multisig): require caller is council member, no token threshold\n        if mode == 1 {\n            // Inline _is_council_member_check\n            let council_count = self.storage.council_count.read();\n            let council_members = [\n                self.storage.council_member_0.read(),\n                self.storage.council_member_1.read(),\n                self.storage.council_member_2.read(),\n                self.storage.council_member_3.read(),\n                self.storage.council_member_4.read(),\n                self.storage.council_member_5.read(),\n                self.storage.council_member_6.read(),\n                self.storage.council_member_7.read(),\n                self.storage.council_member_8.read(),\n                self.storage.council_member_9.read(),\n                self.storage.council_member_10.read(),\n                self.storage.council_member_11.read(),\n            ];\n            let mut is_member = false;\n            for i in 0..12 {\n                if (i as u8) < council_count {\n                    if council_members[i].eq(proposer) {\n                        is_member = true;\n                    }\n                }\n            }\n            assert(is_member, \"not a council member\");\n        } else {\n            // Mode 0 and 2: verify proposer has sufficient voting power\n            // Inline _get_effective_votes_internal\n            let voting_power = self.storage.voting_power.at(proposer).read()\n                + self.storage.delegated_power.at(proposer).read();\n            let threshold = self.storage.proposal_threshold.read();\n            assert(voting_power >= threshold, \"below proposal threshold\");\n        }\n\n        let proposal_id = self.storage.proposal_count.read();\n        let voting_delay = self.storage.voting_delay.read();\n        let voting_period = self.storage.voting_period.read();\n        let current_block = self.context.block_number();\n\n        let proposal = GovernorProposal {\n            id: proposal_id,\n            proposer,\n            eta: 0,\n            start_block: current_block + voting_delay,\n            end_block: current_block + voting_delay + voting_period,\n            canceled: false,\n            executed: false,\n            actions_hash,\n            description_hash,\n            target_count,\n            proposal_type,\n        };\n\n        self.storage.proposals.at(proposal_id as Field).write(proposal);\n        self.storage.proposal_for_votes.at(proposal_id as Field).write(0);\n        self.storage.proposal_against_votes.at(proposal_id as Field).write(0);\n        self.storage.proposal_abstain_votes.at(proposal_id as Field).write(0);\n        self.storage.proposal_count.write(proposal_id + 1);\n\n        // Snapshot total supply at proposal creation for quorum calculation\n        self.storage.total_supply_snapshot.at(current_block as Field).write(\n            self.storage.total_voting_power.read()\n        );\n    }\n\n    /// Cancel a proposal. Guardian or proposer (if below threshold) can cancel.\n    #[external(\"public\")]\n    fn cancel(proposal_id: Field) {\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        let caller = self.msg_sender().unwrap();\n\n        let guardian = self.storage.proposal_guardian.read();\n        // Inline _get_effective_votes_internal\n        let proposer_votes = self.storage.voting_power.at(proposal.proposer).read()\n            + self.storage.delegated_power.at(proposal.proposer).read();\n        let threshold = self.storage.proposal_threshold.read();\n\n        assert(\n            caller.eq(guardian) | (caller.eq(proposal.proposer) & (proposer_votes < threshold)),\n            \"cannot cancel\"\n        );\n\n        proposal.canceled = true;\n        self.storage.proposals.at(proposal_id).write(proposal);\n    }\n\n    // =========================================================================\n    // FULLY PRIVATE VOTING (GovernorCountingSimple)\n    // =========================================================================\n\n    /// Cast a private vote.\n    #[external(\"private\")]\n    fn cast_vote(proposal_id: Field, support: u8) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([proposal_id, secret]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.tally_vote_internal(proposal_id, support, sender);\n    }\n\n    /// Cast vote with reason (reason is off-chain only for privacy)\n    #[external(\"private\")]\n    fn cast_vote_with_reason(proposal_id: Field, support: u8, _reason_hash: Field) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([proposal_id, secret]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.tally_vote_internal(proposal_id, support, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn tally_vote_internal(proposal_id: Field, support: u8, voter: AztecAddress) {\n        let proposal = self.storage.proposals.at(proposal_id).read();\n\n        assert(!proposal.canceled, \"proposal canceled\");\n        assert(self.context.block_number() >= proposal.start_block, \"voting not started\");\n        assert(self.context.block_number() <= proposal.end_block, \"voting ended\");\n\n        // Use snapshot voting power from proposal start block\n        let votes = self.storage.voting_power_checkpoints\n            .at(voter).at(proposal.start_block as Field).read();\n        // Fallback to current power if no checkpoint exists at snapshot block\n        let effective_votes = if votes > 0 {\n            votes\n        } else {\n            self.storage.voting_power.at(voter).read()\n                + self.storage.delegated_power.at(voter).read()\n        };\n        assert(effective_votes > 0, \"no voting power\");\n\n        // Tally votes -- only aggregates updated, no per-voter record\n        if support == VOTE_AGAINST {\n            let current = self.storage.proposal_against_votes.at(proposal_id).read();\n            self.storage.proposal_against_votes.at(proposal_id).write(current + effective_votes);\n        } else if support == VOTE_FOR {\n            let current = self.storage.proposal_for_votes.at(proposal_id).read();\n            self.storage.proposal_for_votes.at(proposal_id).write(current + effective_votes);\n        } else if support == VOTE_ABSTAIN {\n            let current = self.storage.proposal_abstain_votes.at(proposal_id).read();\n            self.storage.proposal_abstain_votes.at(proposal_id).write(current + effective_votes);\n        } else {\n            assert(false, \"invalid vote support\");\n        }\n\n        // Inline _check_late_quorum_internal\n        let mut lq_proposal = self.storage.proposals.at(proposal_id).read();\n        let extension = self.storage.late_quorum_extension.read();\n\n        if extension != 0 {\n            let current_block = self.context.block_number();\n            let extension_threshold = lq_proposal.end_block - extension;\n\n            if current_block >= extension_threshold {\n                let lq_for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n                let lq_abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n                // Inline _quorum_at_block_internal\n                let lq_total = self.storage.total_supply_snapshot.at(lq_proposal.start_block as Field).read();\n                let lq_numerator = self.storage.quorum_numerator.read();\n                let lq_denominator = self.storage.quorum_denominator.read();\n                let lq_quorum = if (lq_total == 0) | (lq_denominator == 0) {\n                    0\n                } else {\n                    (lq_total * lq_numerator) / lq_denominator\n                };\n\n                if lq_for_votes + lq_abstain_votes >= lq_quorum {\n                    let new_end = current_block + extension;\n                    if new_end > lq_proposal.end_block {\n                        lq_proposal.end_block = new_end;\n                        self.storage.proposals.at(proposal_id).write(lq_proposal);\n                    }\n                }\n            }\n        }\n    }\n\n    // =========================================================================\n    // FRACTIONAL VOTING (GovernorCountingFractional)\n    // =========================================================================\n\n    /// Cast a fractional vote: split voting power across For/Against/Abstain.\n    #[external(\"private\")]\n    fn cast_fractional_vote(\n        proposal_id: Field,\n        for_weight: u128,\n        against_weight: u128,\n        abstain_weight: u128,\n    ) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([proposal_id, secret]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.tally_fractional_internal(\n            proposal_id, for_weight, against_weight, abstain_weight, sender\n        );\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn tally_fractional_internal(\n        proposal_id: Field,\n        for_weight: u128,\n        against_weight: u128,\n        abstain_weight: u128,\n        voter: AztecAddress,\n    ) {\n        let proposal = self.storage.proposals.at(proposal_id).read();\n\n        assert(!proposal.canceled, \"proposal canceled\");\n        assert(self.context.block_number() >= proposal.start_block, \"voting not started\");\n        assert(self.context.block_number() <= proposal.end_block, \"voting ended\");\n\n        // Use snapshot voting power from proposal start block\n        let snapshot_power = self.storage.voting_power_checkpoints\n            .at(voter).at(proposal.start_block as Field).read();\n        let total_power = if snapshot_power > 0 {\n            snapshot_power\n        } else {\n            self.storage.voting_power.at(voter).read()\n                + self.storage.delegated_power.at(voter).read()\n        };\n        assert(total_power > 0, \"no voting power\");\n        assert(for_weight + against_weight + abstain_weight == total_power, \"weights must equal total power\");\n\n        if for_weight > 0 {\n            let current = self.storage.proposal_for_votes.at(proposal_id).read();\n            self.storage.proposal_for_votes.at(proposal_id).write(current + for_weight);\n        }\n        if against_weight > 0 {\n            let current = self.storage.proposal_against_votes.at(proposal_id).read();\n            self.storage.proposal_against_votes.at(proposal_id).write(current + against_weight);\n        }\n        if abstain_weight > 0 {\n            let current = self.storage.proposal_abstain_votes.at(proposal_id).read();\n            self.storage.proposal_abstain_votes.at(proposal_id).write(current + abstain_weight);\n        }\n\n        // Inline _check_late_quorum_internal\n        let mut lq_proposal = self.storage.proposals.at(proposal_id).read();\n        let extension = self.storage.late_quorum_extension.read();\n\n        if extension != 0 {\n            let current_block = self.context.block_number();\n            let extension_threshold = lq_proposal.end_block - extension;\n\n            if current_block >= extension_threshold {\n                let lq_for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n                let lq_abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n                // Inline _quorum_at_block_internal\n                let lq_total = self.storage.total_supply_snapshot.at(lq_proposal.start_block as Field).read();\n                let lq_numerator = self.storage.quorum_numerator.read();\n                let lq_denominator = self.storage.quorum_denominator.read();\n                let lq_quorum = if (lq_total == 0) | (lq_denominator == 0) {\n                    0\n                } else {\n                    (lq_total * lq_numerator) / lq_denominator\n                };\n\n                if lq_for_votes + lq_abstain_votes >= lq_quorum {\n                    let new_end = current_block + extension;\n                    if new_end > lq_proposal.end_block {\n                        lq_proposal.end_block = new_end;\n                        self.storage.proposals.at(proposal_id).write(lq_proposal);\n                    }\n                }\n            }\n        }\n    }\n\n    // =========================================================================\n    // TIMELOCK (GovernorTimelockControl)\n    // =========================================================================\n\n    /// Queue a succeeded proposal for execution after timelock delay.\n    #[external(\"public\")]\n    fn queue(proposal_id: Field) {\n        // Inline _get_state_internal\n        let st_proposal = self.storage.proposals.at(proposal_id).read();\n        let st_for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n        let st_against_votes = self.storage.proposal_against_votes.at(proposal_id).read();\n        let st_abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n        // Inline _quorum_at_block_internal\n        let st_total = self.storage.total_supply_snapshot.at(st_proposal.start_block as Field).read();\n        let st_numerator = self.storage.quorum_numerator.read();\n        let st_denominator = self.storage.quorum_denominator.read();\n        let st_quorum = if (st_total == 0) | (st_denominator == 0) {\n            0\n        } else {\n            (st_total * st_numerator) / st_denominator\n        };\n\n        let state = if st_proposal.canceled {\n            STATE_CANCELED\n        } else if self.context.block_number() < st_proposal.start_block {\n            STATE_PENDING\n        } else if self.context.block_number() <= st_proposal.end_block {\n            STATE_ACTIVE\n        } else if (st_for_votes <= st_against_votes) | ((st_for_votes + st_abstain_votes) < st_quorum) {\n            STATE_DEFEATED\n        } else if st_proposal.eta == 0 {\n            STATE_SUCCEEDED\n        } else if st_proposal.executed {\n            STATE_EXECUTED\n        } else if self.context.block_number() > st_proposal.eta + 14400 {\n            STATE_EXPIRED\n        } else {\n            STATE_QUEUED\n        };\n\n        assert(state == STATE_SUCCEEDED, \"not succeeded\");\n\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        let timelock_delay = self.storage.timelock_delay.read();\n        proposal.eta = self.context.block_number() + timelock_delay;\n        self.storage.proposals.at(proposal_id).write(proposal);\n    }\n\n    /// Execute a queued proposal after timelock has elapsed.\n    #[external(\"public\")]\n    fn execute(proposal_id: Field) {\n        // Inline _get_state_internal\n        let st_proposal = self.storage.proposals.at(proposal_id).read();\n        let st_for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n        let st_against_votes = self.storage.proposal_against_votes.at(proposal_id).read();\n        let st_abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n        // Inline _quorum_at_block_internal\n        let st_total = self.storage.total_supply_snapshot.at(st_proposal.start_block as Field).read();\n        let st_numerator = self.storage.quorum_numerator.read();\n        let st_denominator = self.storage.quorum_denominator.read();\n        let st_quorum = if (st_total == 0) | (st_denominator == 0) {\n            0\n        } else {\n            (st_total * st_numerator) / st_denominator\n        };\n\n        let state = if st_proposal.canceled {\n            STATE_CANCELED\n        } else if self.context.block_number() < st_proposal.start_block {\n            STATE_PENDING\n        } else if self.context.block_number() <= st_proposal.end_block {\n            STATE_ACTIVE\n        } else if (st_for_votes <= st_against_votes) | ((st_for_votes + st_abstain_votes) < st_quorum) {\n            STATE_DEFEATED\n        } else if st_proposal.eta == 0 {\n            STATE_SUCCEEDED\n        } else if st_proposal.executed {\n            STATE_EXECUTED\n        } else if self.context.block_number() > st_proposal.eta + 14400 {\n            STATE_EXPIRED\n        } else {\n            STATE_QUEUED\n        };\n\n        assert(state == STATE_QUEUED, \"not queued\");\n\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        assert(self.context.block_number() >= proposal.eta, \"timelock not elapsed\");\n\n        proposal.executed = true;\n        self.storage.proposals.at(proposal_id).write(proposal);\n\n        // In production: iterate targets[], call each with value and calldata\n    }\n\n    // =========================================================================\n    // GOVERNANCE PARAMETER UPDATES (self-governing -- via proposals only)\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_voting_delay(new_delay: u32) {\n        self.storage.voting_delay.write(new_delay);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_voting_period(new_period: u32) {\n        self.storage.voting_period.write(new_period);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_proposal_threshold(new_threshold: u128) {\n        self.storage.proposal_threshold.write(new_threshold);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_quorum_numerator(new_numerator: u128) {\n        let denominator = self.storage.quorum_denominator.read();\n        assert(new_numerator <= denominator, \"numerator exceeds denominator\");\n        self.storage.quorum_numerator.write(new_numerator);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_late_quorum_extension(new_extension: u32) {\n        self.storage.late_quorum_extension.write(new_extension);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_proposal_guardian(new_guardian: AztecAddress) {\n        self.storage.proposal_guardian.write(new_guardian);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_timelock_delay(new_delay: u32) {\n        self.storage.timelock_delay.write(new_delay);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_visibility(is_publicly_viewable: bool) {\n        self.storage.is_publicly_viewable.write(is_publicly_viewable);\n    }\n\n    // =========================================================================\n    // VIEW FUNCTIONS\n    // =========================================================================\n\n    // --- Always public (basic cloak info) ---\n\n    #[external(\"public\")]\n    #[view]\n    fn get_name() -> pub FieldCompressedString {\n        self.storage.name.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_count() -> pub u64 {\n        self.storage.proposal_count.read()\n    }\n\n    // --- Visibility-gated functions (require membership for closed cloaks) ---\n    // For closed cloaks, caller must have voting power to view sensitive data.\n    // Caller passes their address; we verify they are a member.\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal(proposal_id: Field, caller: AztecAddress) -> pub GovernorProposal {\n        // Check visibility: if closed, require caller to be a member\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n        self.storage.proposals.at(proposal_id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_state(proposal_id: Field, caller: AztecAddress) -> pub u8 {\n        // Check visibility\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n\n        // Inline _get_state_internal\n        let proposal = self.storage.proposals.at(proposal_id).read();\n        let for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n        let against_votes = self.storage.proposal_against_votes.at(proposal_id).read();\n        let abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n        // Inline _quorum_at_block_internal\n        let total = self.storage.total_supply_snapshot.at(proposal.start_block as Field).read();\n        let numerator = self.storage.quorum_numerator.read();\n        let denominator = self.storage.quorum_denominator.read();\n        let quorum = if (total == 0) | (denominator == 0) {\n            0\n        } else {\n            (total * numerator) / denominator\n        };\n\n        if proposal.canceled {\n            STATE_CANCELED\n        } else if self.context.block_number() < proposal.start_block {\n            STATE_PENDING\n        } else if self.context.block_number() <= proposal.end_block {\n            STATE_ACTIVE\n        } else if (for_votes <= against_votes) | ((for_votes + abstain_votes) < quorum) {\n            STATE_DEFEATED\n        } else if proposal.eta == 0 {\n            STATE_SUCCEEDED\n        } else if proposal.executed {\n            STATE_EXECUTED\n        } else if self.context.block_number() > proposal.eta + 14400 {\n            STATE_EXPIRED\n        } else {\n            STATE_QUEUED\n        }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_votes(proposal_id: Field, caller: AztecAddress) -> pub (u128, u128, u128) {\n        // Check visibility\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n\n        (\n            self.storage.proposal_for_votes.at(proposal_id).read(),\n            self.storage.proposal_against_votes.at(proposal_id).read(),\n            self.storage.proposal_abstain_votes.at(proposal_id).read(),\n        )\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_snapshot(proposal_id: Field, caller: AztecAddress) -> pub u32 {\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n        self.storage.proposals.at(proposal_id).read().start_block\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_deadline(proposal_id: Field, caller: AztecAddress) -> pub u32 {\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n        self.storage.proposals.at(proposal_id).read().end_block\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_eta(proposal_id: Field, caller: AztecAddress) -> pub u32 {\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n        self.storage.proposals.at(proposal_id).read().eta\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_proposer(proposal_id: Field, caller: AztecAddress) -> pub AztecAddress {\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n        self.storage.proposals.at(proposal_id).read().proposer\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_votes(account: AztecAddress, caller: AztecAddress) -> pub u128 {\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n        // Inline _get_effective_votes_internal\n        self.storage.voting_power.at(account).read()\n            + self.storage.delegated_power.at(account).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_past_votes(account: AztecAddress, block_number: u32, caller: AztecAddress) -> pub u128 {\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n\n        let checkpoint = self.storage.voting_power_checkpoints\n            .at(account).at(block_number as Field).read();\n        if checkpoint > 0 {\n            checkpoint\n        } else {\n            // Fallback to current effective votes if no checkpoint at that block\n            self.storage.voting_power.at(account).read()\n                + self.storage.delegated_power.at(account).read()\n        }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_delegate(account: AztecAddress, caller: AztecAddress) -> pub AztecAddress {\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n        self.storage.delegates.at(account).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_total_voting_power(caller: AztecAddress) -> pub u128 {\n        let is_public = self.storage.is_publicly_viewable.read();\n        if !is_public {\n            let caller_power = self.storage.voting_power.at(caller).read()\n                + self.storage.delegated_power.at(caller).read();\n            assert(caller_power > 0, \"closed cloak: caller must be a member\");\n        }\n        self.storage.total_voting_power.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_voting_delay() -> pub u32 {\n        self.storage.voting_delay.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_voting_period() -> pub u32 {\n        self.storage.voting_period.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_threshold() -> pub u128 {\n        self.storage.proposal_threshold.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_quorum_numerator() -> pub u128 {\n        self.storage.quorum_numerator.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_quorum_denominator() -> pub u128 {\n        self.storage.quorum_denominator.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn quorum(block_number: u32) -> pub u128 {\n        // Inline _quorum_at_block_internal\n        let total = self.storage.total_supply_snapshot.at(block_number as Field).read();\n        let numerator = self.storage.quorum_numerator.read();\n        let denominator = self.storage.quorum_denominator.read();\n\n        if (total == 0) | (denominator == 0) {\n            0\n        } else {\n            (total * numerator) / denominator\n        }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_late_quorum_extension() -> pub u32 {\n        self.storage.late_quorum_extension.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_timelock_delay() -> pub u32 {\n        self.storage.timelock_delay.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_guardian() -> pub AztecAddress {\n        self.storage.proposal_guardian.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_governance_token() -> pub AztecAddress {\n        self.storage.governance_token.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_membership_mode() -> pub u8 {\n        self.storage.membership_mode.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_token_gate_address() -> pub AztecAddress {\n        self.storage.token_gate_address.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_erc20_config() -> pub (Field, u128) {\n        (self.storage.erc20_token_address_hash.read(), self.storage.erc20_min_balance.read())\n    }\n\n    // =========================================================================\n    // HASH PROPOSAL (deterministic proposal ID from targets/values/calldatas)\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[view]\n    fn hash_proposal(actions_hash: Field, description_hash: Field) -> pub Field {\n        std::hash::pedersen_hash([actions_hash, description_hash])\n    }\n\n    // =========================================================================\n    // MULTISIG VOTING (mode 1)\n    // =========================================================================\n\n    /// Council member approves a proposal (1-person-1-vote).\n    #[external(\"public\")]\n    fn council_approve(proposal_id: Field) {\n        let mode = self.storage.cloak_mode.read();\n        assert((mode == 1) | (mode == 2), \"council approval not available in this mode\");\n\n        let caller = self.msg_sender().unwrap();\n\n        // Inline _is_council_member_check\n        let council_count = self.storage.council_count.read();\n        let council_members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n        let mut is_member = false;\n        for i in 0..12 {\n            if (i as u8) < council_count {\n                if council_members[i].eq(caller) {\n                    is_member = true;\n                }\n            }\n        }\n        assert(is_member, \"not a council member\");\n\n        // Prevent double approval\n        let already_approved = self.storage.council_approvals.at(proposal_id).at(caller).read();\n        assert(!already_approved, \"already approved\");\n\n        self.storage.council_approvals.at(proposal_id).at(caller).write(true);\n\n        let current_count = self.storage.council_approval_counts.at(proposal_id).read();\n        self.storage.council_approval_counts.at(proposal_id).write(current_count + 1);\n    }\n\n    // =========================================================================\n    // EMERGENCY FUNCTIONS (mode 2)\n    // =========================================================================\n\n    /// Emergency execute: bypasses timelock, requires emergency_threshold council approvals.\n    #[external(\"public\")]\n    fn emergency_execute(proposal_id: Field) {\n        let mode = self.storage.cloak_mode.read();\n        assert(mode == 2, \"emergency execute only in hybrid mode\");\n\n        let approval_count = self.storage.council_approval_counts.at(proposal_id).read();\n        let threshold = self.storage.emergency_threshold.read();\n        assert(approval_count >= threshold, \"insufficient emergency approvals\");\n\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        assert(!proposal.canceled, \"proposal canceled\");\n        assert(!proposal.executed, \"already executed\");\n\n        proposal.executed = true;\n        self.storage.proposals.at(proposal_id).write(proposal);\n    }\n\n    /// Emergency cancel: council cancels malicious proposals, requires council_threshold.\n    #[external(\"public\")]\n    fn emergency_cancel(proposal_id: Field) {\n        let mode = self.storage.cloak_mode.read();\n        assert(mode == 2, \"emergency cancel only in hybrid mode\");\n\n        let approval_count = self.storage.council_approval_counts.at(proposal_id).read();\n        let threshold = self.storage.council_threshold.read();\n        assert(approval_count >= threshold, \"insufficient council approvals to cancel\");\n\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        assert(!proposal.executed, \"already executed\");\n\n        proposal.canceled = true;\n        self.storage.proposals.at(proposal_id).write(proposal);\n    }\n\n    // =========================================================================\n    // COUNCIL MANAGEMENT (governance proposals only -- #[only_self])\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[only_self]\n    fn replace_council_member(old_member: AztecAddress, new_member: AztecAddress) {\n        let count = self.storage.council_count.read();\n\n        // Read all 12 members into array\n        let mut members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n\n        let mut replaced = false;\n        for i in 0..12 {\n            if (i as u8) < count {\n                if members[i].eq(old_member) {\n                    members[i] = new_member;\n                    replaced = true;\n                }\n            }\n        }\n        assert(replaced, \"old member not found\");\n\n        // Write all 12 back\n        self.storage.council_member_0.write(members[0]);\n        self.storage.council_member_1.write(members[1]);\n        self.storage.council_member_2.write(members[2]);\n        self.storage.council_member_3.write(members[3]);\n        self.storage.council_member_4.write(members[4]);\n        self.storage.council_member_5.write(members[5]);\n        self.storage.council_member_6.write(members[6]);\n        self.storage.council_member_7.write(members[7]);\n        self.storage.council_member_8.write(members[8]);\n        self.storage.council_member_9.write(members[9]);\n        self.storage.council_member_10.write(members[10]);\n        self.storage.council_member_11.write(members[11]);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_council_member(new_member: AztecAddress) {\n        let count = self.storage.council_count.read();\n        assert(count < 12, \"council full\");\n\n        // Read all 12 members into array\n        let mut members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n\n        members[count as u32] = new_member;\n\n        // Write all 12 back\n        self.storage.council_member_0.write(members[0]);\n        self.storage.council_member_1.write(members[1]);\n        self.storage.council_member_2.write(members[2]);\n        self.storage.council_member_3.write(members[3]);\n        self.storage.council_member_4.write(members[4]);\n        self.storage.council_member_5.write(members[5]);\n        self.storage.council_member_6.write(members[6]);\n        self.storage.council_member_7.write(members[7]);\n        self.storage.council_member_8.write(members[8]);\n        self.storage.council_member_9.write(members[9]);\n        self.storage.council_member_10.write(members[10]);\n        self.storage.council_member_11.write(members[11]);\n\n        self.storage.council_count.write(count + 1);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn remove_council_member(member: AztecAddress) {\n        let count = self.storage.council_count.read();\n\n        // Read all 12 members into array\n        let mut members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n\n        let mut found_index: u8 = 255;\n        for i in 0..12 {\n            if (i as u8) < count {\n                if members[i].eq(member) {\n                    found_index = i as u8;\n                }\n            }\n        }\n        assert(found_index != 255, \"member not found\");\n\n        // Shift remaining members down\n        let mut i = found_index;\n        for _ in 0..11 {\n            if i + 1 < count {\n                members[i as u32] = members[(i + 1) as u32];\n                i += 1;\n            }\n        }\n        // Zero out last slot\n        members[(count - 1) as u32] = AztecAddress::from_field(0);\n\n        // Write all 12 back\n        self.storage.council_member_0.write(members[0]);\n        self.storage.council_member_1.write(members[1]);\n        self.storage.council_member_2.write(members[2]);\n        self.storage.council_member_3.write(members[3]);\n        self.storage.council_member_4.write(members[4]);\n        self.storage.council_member_5.write(members[5]);\n        self.storage.council_member_6.write(members[6]);\n        self.storage.council_member_7.write(members[7]);\n        self.storage.council_member_8.write(members[8]);\n        self.storage.council_member_9.write(members[9]);\n        self.storage.council_member_10.write(members[10]);\n        self.storage.council_member_11.write(members[11]);\n\n        self.storage.council_count.write(count - 1);\n\n        // Ensure threshold does not exceed new count\n        let threshold = self.storage.council_threshold.read();\n        if threshold > count - 1 {\n            self.storage.council_threshold.write(count - 1);\n        }\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_council_threshold(new_threshold: u8) {\n        let count = self.storage.council_count.read();\n        assert(new_threshold <= count, \"threshold exceeds council size\");\n        assert(new_threshold > 0, \"threshold must be positive\");\n        self.storage.council_threshold.write(new_threshold);\n    }\n\n    // =========================================================================\n    // COUNCIL VIEW FUNCTIONS\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[view]\n    fn get_cloak_mode() -> pub u8 {\n        self.storage.cloak_mode.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_council_member(index: u8) -> pub AztecAddress {\n        // Inline _get_council_member_by_index\n        if index == 0 { self.storage.council_member_0.read() }\n        else if index == 1 { self.storage.council_member_1.read() }\n        else if index == 2 { self.storage.council_member_2.read() }\n        else if index == 3 { self.storage.council_member_3.read() }\n        else if index == 4 { self.storage.council_member_4.read() }\n        else if index == 5 { self.storage.council_member_5.read() }\n        else if index == 6 { self.storage.council_member_6.read() }\n        else if index == 7 { self.storage.council_member_7.read() }\n        else if index == 8 { self.storage.council_member_8.read() }\n        else if index == 9 { self.storage.council_member_9.read() }\n        else if index == 10 { self.storage.council_member_10.read() }\n        else if index == 11 { self.storage.council_member_11.read() }\n        else { AztecAddress::from_field(0) }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_council_count() -> pub u8 {\n        self.storage.council_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_council_threshold() -> pub u8 {\n        self.storage.council_threshold.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_emergency_threshold() -> pub u8 {\n        self.storage.emergency_threshold.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn is_council_member(addr: AztecAddress) -> pub bool {\n        // Inline _is_council_member_check\n        let count = self.storage.council_count.read();\n        let members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n        let mut found = false;\n        for i in 0..12 {\n            if (i as u8) < count {\n                if members[i].eq(addr) {\n                    found = true;\n                }\n            }\n        }\n        found\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_council_approval_count(proposal_id: Field) -> pub u8 {\n        self.storage.council_approval_counts.at(proposal_id).read()\n    }\n\n    // =========================================================================\n    // VISIBILITY\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[view]\n    fn get_is_publicly_viewable() -> pub bool {\n        self.storage.is_publicly_viewable.read()\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "64": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/calls.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata_array};\nuse crate::oracle::execution_cache;\n\n// PrivateCall\n\n#[must_use = \"Your private call needs to be passed into the `self.call(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_private_function(...args))`\"]\npub struct PrivateCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T>\nwhere\n    T: Deserialize,\n{\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_private_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\n// PrivateStaticCall\n\n#[must_use = \"Your private static call needs to be passed into the `self.view(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_private_static_function(...args))`\"]\npub struct PrivateStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_private_static_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\n// PublicCall\n\n#[must_use = \"Your public call needs to be passed into the `self.call(...)`, `self.enqueue(...)` or `self.enqueue_incognito(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_public_function(...args))`\"]\npub struct PublicCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    gas_opts: GasOpts,\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PublicCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub unconstrained fn call(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\n// PublicStaticCall\n\n#[must_use = \"Your public static call needs to be passed into the `self.view(...)`, `self.enqueue_view(...)` or `self.enqueue_view_incognito(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_public_static_function(...args))`\"]\npub struct PublicStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    return_type: T,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, let N: u32, T> PublicStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub unconstrained fn view(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view_incognito(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\n// UtilityCall\n\npub struct UtilityCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> UtilityCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n"
    },
    "72": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{\n        inputs::PrivateContextInputs, note_hash_read::NoteHashRead, returns_hash::ReturnsHash,\n    },\n    hash::{hash_args, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter, notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, find_first_index, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // Incrementing the side effect counter when ending setup ensures non\n        // ambiguity for the counter where we change phases.\n        self.side_effect_counter += 1;\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardize on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact approach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n        let side_effect = Scoped::new(\n            Counted::new(note_hash, self.next_counter()),\n            contract_address,\n        );\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Asserts that a NoteHashRead has been requested to the kernel by this context.\n    /// Asserts instead of returning a boolean to save on gates.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash read to assert that has been requested.\n    ///\n    pub fn assert_has_been_requested(self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n\n        // Safety: The index is constrained by the checks below.\n        let hinted_index = unsafe {\n            find_first_index(\n                self.note_hash_read_requests.storage(),\n                |r| (r.contract_address == contract_address) & (r.innermost() == note_hash),\n            )\n        };\n        // This assertion is not necessary, since the .get would fail. But it enables us to have a more explicit error message.\n        assert(\n            hinted_index != self.note_hash_read_requests.max_len(),\n            \"Note hash read has not been requested\",\n        );\n\n        let request = self.note_hash_read_requests.get(hinted_index);\n        assert_eq(request.contract_address, contract_address);\n        assert_eq(request.innermost(), note_hash);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    /// * `contract_address` - The contract address that emitted the nullifier\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the nullifier is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(\n        &mut self,\n        nullifier: Field,\n        contract_address: AztecAddress,\n    ) {\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incoming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes) or that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "73": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "75": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "76": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr",
      "source": "use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n"
    },
    "80": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "82": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "99": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17278438487631839627": {
            "error_kind": "string",
            "string": "Function add_council_member can only be called by the same contract"
          },
          "17625130927896797776": {
            "error_kind": "string",
            "string": "council full"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEUtCEUBJQAAAEElAAAAbCcCAQRGJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAMmJQAAA2YeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAOMHgIABQEKIgVDBhYKBgccCgcIAAQqCAUHJwIFAQAKKgYFCCQCAAgAAADSJwIJBAA8BgkBCioHAwUkAgAFAAAA5CUAAAOeJwIDAD8vCgADAAUcCgUHAhwKBwYAHAoGBQInAgcCDAwqBQcIJAIACAAAARUlAAADsCcCBwAzLwoABwAIJwIJADQvCgAJAAonAgsANS8KAAsADCcCDQA2LwoADQAOJwIPADcvCgAPABAnAhEAOC8KABEAEicCEwA5LwoAEwAUJwIVADovCgAVABYnAhcAOy8KABcAGCcCGQA8LwoAGQAaJwIbAD0vCgAbABwnAh0APi8KAB0AHi0IAR8nAiAEDQAIASABJwMfBAEAIh8CIC0KICEtDgghACIhAiEtDgohACIhAiEtDgwhACIhAiEtDg4hACIhAiEtDhAhACIhAiEtDhIhACIhAiEtDhQhACIhAiEtDhYhACIhAiEtDhghACIhAiEtDhohACIhAiEtDhwhACIhAiEtDh4hHAoGCAQnAgYEDAwqCAYKJAIACgAAAjglAAADwi0CHwMnAAQEDSUAAAPULQgFBAAiBAIKACoKCAwtDgEMJwIBBAEAKgQBCi0LCggwCgAIAAcnAgEEAgAqBAEILQsIBzAKAAcACQAiBEQHLQsHATAKAAEACycCAQQEACoEAQgtCwgHMAoABwANJwIBBAUAKgQBCC0LCAcwCgAHAA8nAgEEBgAqBAEILQsIBzAKAAcAEScCAQQHACoEAQgtCwgHMAoABwATJwIBBAgAKgQBCC0LCAcwCgAHABUnAgEECQAqBAEILQsIBzAKAAcAFycCAQQKACoEAQgtCwgHMAoABwAZJwIBBAsAKgQBCC0LCAcwCgAHABsAKgQGBy0LBwEwCgABAB0nAgECAQAqBQEEDioFBAYkAgAGAAADWiUAAAQzHAoEAQAwCgABAAMmKAAABAR4RgwAAAQDJAAAAwAAA4sqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBe/JWEJou8GLPAQCASYqAQABBfSZCzJtCiJQPAQCASYqAQABBeQIUEUCtYwfPAQCASYtAQMGCgAGAgckAAAHAAAD6iMAAAPzLQADBSMAAAQyLQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAABC0tAQoILQQICwAACgIKAAALAgsjAAAECScBBQQBJioBAAEF0Afr9MvGZ5A8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_council_member"
    },
    {
      "abi": {
        "error_types": {
          "10958896161817881596": {
            "error_kind": "string",
            "string": "insufficient balance"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5836097838366868111": {
            "error_kind": "string",
            "string": "not erc20-token mode"
          },
          "7220720865510965904": {
            "error_kind": "string",
            "string": "nullifier already used"
          },
          "8288633154968149222": {
            "error_kind": "string",
            "string": "Function add_erc20_member_internal can only be called by the same contract"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "verified_balance",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "proof_nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_erc20_member_internal"
    },
    {
      "abi": {
        "error_types": {
          "10807032649822229906": {
            "error_kind": "string",
            "string": "not aztec-token mode"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3975253606477278659": {
            "error_kind": "string",
            "string": "Function add_member_internal can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "balance_commitment",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABEcnAgMEAicCBAQAHwoAAwAEAEUtCEUBLQhGAiUAAABFJQAAAHAnAgEERycCAgQAOw4AAgABLAAAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACcARAQDJiUAAB5IHgIAAwAeAgAEAC0IAQUAAAECAScCBgAVLQ4GBS0IAQcAAAECAScCCAAWLQ4IBy0IAQgAAAECAScCCQAYLQ4JCC0IAQkAAAECAScCCgAZLQ4KCS0IAQoAAAECAScCCwAaLQ4LCh4CAAsAHgIADAAzKgALAAwADScCCwEBJAIADQAAAP0lAAAebh4CAAwBCiIMQw0WCg0OHAoODwAEKg8MDicCDAEACioNDA8kAgAPAAABMCcCEAQAPAYQAQoqDgQNJAIADQAAAUIlAAAegCcCBAAbLwoABAANHAoNDgIcCg4EABwKBA0CJwIEAgAKKg0EDiQCAA4AAAFzJQAAHpInAgQAAC0IAQ0nAg4EBAAIAQ4BJwMNBAEAIg0CDi0KDg8tDgQPACIPAg8tDgQPACIPAg8tDgQPKwIADgAAAAAAAAAAAgAAAAAAAAAALQgBDycCEAQFAAgBEAEnAw8EAQAiDwIQLQoQES0OBBEAIhECES0OBBEAIhECES0OBBEAIhECES0ODhEtCAEQAAABAgEtDg0QLQgBDQAAAQIBLQ4PDS0IAREAAAECAScCEgQALQ4SES0IARMAAAECAS0ODBMnAhQEASQCAAwAAAKMIwAAAkUtCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMVLQ4GFQAiFQIVLQ4EFQAiFQIVLQ4EFS0OAhAtDg8NLQ4UES0ODBMjAAADGC0KEgIjAAAClQwiAkQDJAIAAwAAHcIjAAACpy0LEAItCw0DLQsTDy0LAxUAIhUCFS0OFQMtCAEVJwIWBAUACAEWAScDFQQBACIDAhYnAhcEBAAiFQIYPw8AFgAYLQICAycABAQEJQAAHqQtCAUDACoDFBYtDgYWLQ4DEC0OFQ0tDhQRLQ4PEyMAAAMYLQsQAi0LDQMtCxMGCioGDA8kAgAPAAADOicCFQQAPAYVAScCBgQCJAIADAAAA3wjAAADTC0CAgMnAAQEBCUAAB6kLQgFDwAqDwYVLQ4BFS0ODxAtDgMNLQ4GES0ODBMjAAAECC0KEgIjAAADhQwiAkQDJAIAAwAAHTwjAAADly0LEAItCw0DLQsTDy0LAxUAIhUCFS0OFQMtCAEVJwIWBAUACAEWAScDFQQBACIDAhYnAhcEBAAiFQIYPw8AFgAYLQICAycABAQEJQAAHqQtCAUDACoDFBYtDgEWLQ4DEC0OFQ0tDhQRLQ4PEyMAAAQILQsTAwoqAwwPJAIADwAABCInAhUEADwGFQEtChICIwAABCsMIgJEAyQCAAMAABy2IwAABD0tCxACLQsNAy0LEQ8tCwMVACIVAhUtDhUDLQgBFScCFgQFAAgBFgEnAxUEAQAiAwIWJwIXBAQAIhUCGD8PABYAGC0OAhAtDhUNLQ4PES0OCxMAKhUUAy0LAwIKKgIEAwoqAwwNJAIADQAABK4lAAAfAy8KAAIAAxwKAw0GHAoNAgAcCgIDBicCAgYACioDAg0kAgANAAAE2iMAABTbLQsFAi0IAQMnAgUEBAAIAQUBJwMDBAEAIgMCBS0KBQ0tDgQNACINAg0tDgQNACINAg0tDgQNLQgBBScCDQQFAAgBDQEnAwUEAQAiBQINLQoNDy0OBA8AIg8CDy0OBA8AIg8CDy0OBA8AIg8CDy0ODg8tCAENAAABAgEtDgMNLQgBAwAAAQIBLQ4FAy0IAQ8AAAECAS0OEg8tCAEQAAABAgEtDgwQJAIADAAABdMjAAAFjC0IAREnAhMEBAAIARMBJwMRBAEAIhECEy0KExUtDgIVACIVAhUtDgQVACIVAhUtDgQVLQ4RDS0OBQMtDhQPLQ4MECMAAAZfLQoSBSMAAAXcDCIFRBEkAgARAAAcMCMAAAXuLQsNBS0LAxEtCxATLQsRFQAiFQIVLQ4VES0IARUnAhYEBQAIARYBJwMVBAEAIhECFicCFwQEACIVAhg/DwAWABgtAgUDJwAEBAQlAAAepC0IBREAKhEUFi0OAhYtDhENLQ4VAy0OFA8tDhMQIwAABl8tCw0CLQsDBS0LEBEKKhEMEyQCABMAAAaBJwIVBAA8BhUBJAIADAAABr4jAAAGji0CAgMnAAQEBCUAAB6kLQgFEQAqEQYTLQ4BEy0OEQ0tDgUDLQ4GDy0ODBAjAAAHSi0KEgIjAAAGxwwiAkQFJAIABQAAG6ojAAAG2S0LDQItCwMFLQsQES0LBRMAIhMCEy0OEwUtCAETJwIVBAUACAEVAScDEwQBACIFAhUnAhYEBAAiEwIXPw8AFQAXLQICAycABAQEJQAAHqQtCAUFACoFFBUtDgEVLQ4FDS0OEwMtDhQPLQ4RECMAAAdKLQsQBQoqBQwRJAIAEQAAB2QnAhMEADwGEwEtChICIwAAB20MIgJEBSQCAAUAABskIwAAB38tCw0CLQsDBS0LDxEtCwUTACITAhMtDhMFLQgBEycCFQQFAAgBFQEnAxMEAQAiBQIVJwIWBAQAIhMCFz8PABUAFy0OAg0tDhMDLQ4RDy0OCxAAKhMUAy0LAwIKKgIEAwoqAwwFJAIABQAAB/AlAAAfAycCAwABMAoAAwACLQsIAi8KAAIAAxwKAwgGHAoIBQAcCgUDBicCBQYBACoDBQgOKgMIDSQCAA0AAAgwJQAAHxUcCggDADAKAAMAAi0LBwItCAEDJwIHBAQACAEHAScDAwQBACIDAgctCgcILQ4ECAAiCAIILQ4ECAAiCAIILQ4ECC0IAQcnAggEBQAIAQgBJwMHBAEAIgcCCC0KCA0tDgQNACINAg0tDgQNACINAg0tDgQNACINAg0tDg4NLQgBCAAAAQIBLQ4DCC0IAQMAAAECAS0OBwMtCAENAAABAgEtDhINLQgBDwAAAQIBLQ4MDyQCAAwAAAk0IwAACO0tCAEQJwIRBAQACAERAScDEAQBACIQAhEtChETLQ4CEwAiEwITLQ4EEwAiEwITLQ4EEy0OEAgtDgcDLQ4UDS0ODA8jAAAJwC0KEgcjAAAJPQwiB0QQJAIAEAAAGp4jAAAJTy0LCActCwMQLQsPES0LEBMAIhMCEy0OExAtCAETJwIVBAUACAEVAScDEwQBACIQAhUnAhYEBAAiEwIXPw8AFQAXLQIHAycABAQEJQAAHqQtCAUQACoQFBUtDgIVLQ4QCC0OEwMtDhQNLQ4RDyMAAAnALQsIAi0LAwctCw8QCioQDBEkAgARAAAJ4icCEwQAPAYTASQCAAwAAAofIwAACe8tAgIDJwAEBAQlAAAepC0IBRAAKhAGES0OAREtDhAILQ4HAy0OBg0tDgwPIwAACqstChICIwAACigMIgJEByQCAAcAABoYIwAACjotCwgCLQsDBy0LDxAtCwcRACIRAhEtDhEHLQgBEScCEwQFAAgBEwEnAxEEAQAiBwITJwIVBAQAIhECFj8PABMAFi0CAgMnAAQEBCUAAB6kLQgFBwAqBxQTLQ4BEy0OBwgtDhEDLQ4UDS0OEA8jAAAKqy0LDwcKKgcMECQCABAAAArFJwIRBAA8BhEBLQoSAiMAAArODCICRAckAgAHAAAZkiMAAArgLQsIAi0LAwctCw0QLQsHEQAiEQIRLQ4RBy0IAREnAhMEBQAIARMBJwMRBAEAIgcCEycCFQQEACIRAhY/DwATABYtDgIILQ4RAy0OEA0tDgsPACoRFAMtCwMCCioCBAMKKgMMByQCAAcAAAtRJQAAHwMvCgACAAMcCgMHBhwKBwIAHAoCAwYAKgUDAg4qBQIHJAIABwAAC30lAAAfFR4CAAMFLQsJBS0IAQcnAggEBAAIAQgBJwMHBAEAIgcCCC0KCAktDgQJACIJAgktDgQJACIJAgktDgQJLQgBCCcCCQQFAAgBCQEnAwgEAQAiCAIJLQoJDS0OBA0AIg0CDS0OBA0AIg0CDS0OBA0AIg0CDS0ODg0tCAEJAAABAgEtDgcJLQgBBwAAAQIBLQ4IBy0IAQ0AAAECAS0OEg0tCAEPAAABAgEtDgwPJAIADAAADHsjAAAMNC0IARAnAhEEBAAIAREBJwMQBAEAIhACES0KERMtDgUTACITAhMtDgQTACITAhMtDgQTLQ4QCS0OCActDhQNLQ4MDyMAAA0HLQoSCCMAAAyEDCIIRBAkAgAQAAAZDCMAAAyWLQsJCC0LBxAtCw8RLQsQEwAiEwITLQ4TEC0IARMnAhUEBQAIARUBJwMTBAEAIhACFScCFgQEACITAhc/DwAVABctAggDJwAEBAQlAAAepC0IBRAAKhAUFS0OBRUtDhAJLQ4TBy0OFA0tDhEPIwAADQctCwkFLQsHCC0LDxAKKhAMESQCABEAAA0pJwITBAA8BhMBJAIADAAADWYjAAANNi0CBQMnAAQEBCUAAB6kLQgFEAAqEAYRLQ4BES0OEAktDggHLQ4GDS0ODA8jAAAN8i0KEgUjAAANbwwiBUQIJAIACAAAGIYjAAANgS0LCQUtCwcILQsPEC0LCBEAIhECES0OEQgtCAERJwITBAUACAETAScDEQQBACIIAhMnAhUEBAAiEQIWPw8AEwAWLQIFAycABAQEJQAAHqQtCAUIACoIFBMtDgETLQ4ICS0OEQctDhQNLQ4QDyMAAA3yLQsPCAoqCAwQJAIAEAAADgwnAhEEADwGEQEtChIFIwAADhUMIgVECCQCAAgAABgAIwAADictCwkFLQsHCC0LDRAtCwgRACIRAhEtDhEILQgBEScCEwQFAAgBEwEnAxEEAQAiCAITJwIVBAQAIhECFj8PABMAFi0OBQktDhEHLQ4QDS0OCw8AKhEUBy0LBwUKKgUEBwoqBwwIJAIACAAADpglAAAfAxwKAwcALQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OBAkAIgkCCS0OBAkAIgkCCS0OBAktCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkNLQ4EDQAiDQINLQ4EDQAiDQINLQ4EDQAiDQINLQ4ODS0IAQkAAAECAS0OAwktCAEDAAABAgEtDggDLQgBDQAAAQIBLQ4SDS0IAQ8AAAECAS0ODA8kAgAMAAAPkiMAAA9LLQgBECcCEQQEAAgBEQEnAxAEAQAiEAIRLQoREy0OBRMAIhMCEy0OBBMAIhMCEy0OBBMtDhAJLQ4IAy0OFA0tDgwPIwAAEB4tChIIIwAAD5sMIghEECQCABAAABd6IwAAD60tCwkILQsDEC0LDxEtCxATACITAhMtDhMQLQgBEycCFQQFAAgBFQEnAxMEAQAiEAIVJwIWBAQAIhMCFz8PABUAFy0CCAMnAAQEBCUAAB6kLQgFEAAqEBQVLQ4FFS0OEAktDhMDLQ4UDS0OEQ8jAAAQHi0LCQUtCwMILQsPEAoqEAwRJAIAEQAAEEAnAhMEADwGEwEkAgAMAAAQfSMAABBNLQIFAycABAQEJQAAHqQtCAUQACoQBhEtDgcRLQ4QCS0OCAMtDgYNLQ4MDyMAABEJLQoSBSMAABCGDCIFRAgkAgAIAAAW9CMAABCYLQsJBS0LAwgtCw8QLQsIEQAiEQIRLQ4RCC0IAREnAhMEBQAIARMBJwMRBAEAIggCEycCFQQEACIRAhY/DwATABYtAgUDJwAEBAQlAAAepC0IBQgAKggUEy0OBxMtDggJLQ4RAy0OFA0tDhAPIwAAEQktCw8ICioIDBAkAgAQAAARIycCEQQAPAYRAS0KEgUjAAARLAwiBUQIJAIACAAAFm4jAAARPi0LCQUtCwMILQsNEC0LCBEAIhECES0OEQgtCAERJwITBAUACAETAScDEQQBACIIAhMnAhUEBAAiEQIWPw8AEwAWLQ4FCS0OEQMtDhANLQ4LDwAqERQFLQsFAwoqAwQFCioFDAgkAgAIAAARryUAAB8DHAoCBQAwCgAFAAMtCwoCLQgBAycCBQQEAAgBBQEnAwMEAQAiAwIFLQoFCC0OBAgAIggCCC0OBAgAIggCCC0OBAgtCAEFJwIIBAUACAEIAScDBQQBACIFAggtCggJLQ4ECQAiCQIJLQ4ECQAiCQIJLQ4ECQAiCQIJLQ4OCS0IAQgAAAECAS0OAwgtCAEDAAABAgEtDgUDLQgBCQAAAQIBLQ4SCS0IAQoAAAECAS0ODAokAgAMAAASsyMAABJsLQgBDScCDgQEAAgBDgEnAw0EAQAiDQIOLQoODy0OAg8AIg8CDy0OBA8AIg8CDy0OBA8tDg0ILQ4FAy0OFAktDgwKIwAAEz8tChIFIwAAErwMIgVEDSQCAA0AABXoIwAAEs4tCwgFLQsDDS0LCg4tCw0PACIPAg8tDg8NLQgBDycCEAQFAAgBEAEnAw8EAQAiDQIQJwIRBAQAIg8CEz8PABAAEy0CBQMnAAQEBCUAAB6kLQgFDQAqDRQQLQ4CEC0ODQgtDg8DLQ4UCS0ODgojAAATPy0LCAItCwMFLQsKDQoqDQwOJAIADgAAE2EnAg8EADwGDwEkAgAMAAATniMAABNuLQICAycABAQEJQAAHqQtCAUNACoNBg4tDgEOLQ4NCC0OBQMtDgYJLQ4MCiMAABQqLQoSAiMAABOnDCICRAUkAgAFAAAVYiMAABO5LQsIAi0LAwUtCwoGLQsFDQAiDQINLQ4NBS0IAQ0nAg4EBQAIAQ4BJwMNBAEAIgUCDicCDwQEACINAhA/DwAOABAtAgIDJwAEBAQlAAAepC0IBQUAKgUUDi0OAQ4tDgUILQ4NAy0OFAktDgYKIwAAFCotCwoCCioCDAUkAgAFAAAURCcCBgQAPAYGAS0KEgEjAAAUTQwiAUQCJAIAAgAAFNwjAAAUXy0LCAEtCwMCLQsJBS0LAgYAIgYCBi0OBgItCAEGJwINBAUACAENAScDBgQBACICAg0nAg4EBAAiBgIPPw8ADQAPLQ4BCC0OBgMtDgUJLQ4LCgAqBhQCLQsCAQoqAQQCCioCDAMkAgADAAAU0CUAAB8DMAoABwABIwAAFNsmLQsIAi0LAwUtCwkGLQsKDQwqAQYOJAIADgAAFP4jAAAVVAAiBQIPACoPARAtCxAOACICAhAAKhABES0LEQ8AKg4PEC0CBQMnAAQEBSUAAB6kLQgFDgAiDgIPACoPAREtDhARLQ4CCC0ODgMtDgYJLQ4NCiMAABVUACoBFAItCgIBIwAAFE0tCwgFLQsDBi0LCQ0tCwoODCoCDQ8kAgAPAAAVhCMAABXaACIGAhAAKhACES0LEQ8AIgUCEQAqEQITLQsTEAAqDxARLQIGAycABAQFJQAAHqQtCAUPACIPAhAAKhACEy0OERMtDgUILQ4PAy0ODQktDg4KIwAAFdoAKgIUBS0KBQIjAAATpy0LCA0tCwMOLQsJDy0LChAMKgUPESQCABEAABYKIwAAFmAAIg4CEwAqEwUVLQsVEQAiDQIVACoVBRYtCxYTACoRExUtAg4DJwAEBAUlAAAepC0IBREAIhECEwAqEwUWLQ4VFi0ODQgtDhEDLQ4PCS0OEAojAAAWYAAqBRQNLQoNBSMAABK8LQsJCC0LAxAtCw0RLQsPEwwqBREVJAIAFQAAFpAjAAAW5gAiEAIWACoWBRctCxcVACIIAhcAKhcFGC0LGBYAKhUWFy0CEAMnAAQEBSUAAB6kLQgFFQAiFQIWACoWBRgtDhcYLQ4ICS0OFQMtDhENLQ4TDyMAABbmACoFFAgtCggFIwAAESwtCwkILQsDEC0LDREtCw8TDCoFERUkAgAVAAAXFiMAABdsACIQAhYAKhYFFy0LFxUAIggCFwAqFwUYLQsYFgAqFRYXLQIQAycABAQFJQAAHqQtCAUVACIVAhYAKhYFGC0OFxgtDggJLQ4VAy0OEQ0tDhMPIwAAF2wAKgUUCC0KCAUjAAAQhi0LCRAtCwMRLQsNEy0LDxUMKggTFiQCABYAABecIwAAF/IAIhECFwAqFwgYLQsYFgAiEAIYACoYCBktCxkXACoWFxgtAhEDJwAEBAUlAAAepC0IBRYAIhYCFwAqFwgZLQ4YGS0OEAktDhYDLQ4TDS0OFQ8jAAAX8gAqCBQQLQoQCCMAAA+bLQsJCC0LBxAtCw0RLQsPEwwqBREVJAIAFQAAGCIjAAAYeAAiEAIWACoWBRctCxcVACIIAhcAKhcFGC0LGBYAKhUWFy0CEAMnAAQEBSUAAB6kLQgFFQAiFQIWACoWBRgtDhcYLQ4ICS0OFQctDhENLQ4TDyMAABh4ACoFFAgtCggFIwAADhUtCwkILQsHEC0LDREtCw8TDCoFERUkAgAVAAAYqCMAABj+ACIQAhYAKhYFFy0LFxUAIggCFwAqFwUYLQsYFgAqFRYXLQIQAycABAQFJQAAHqQtCAUVACIVAhYAKhYFGC0OFxgtDggJLQ4VBy0OEQ0tDhMPIwAAGP4AKgUUCC0KCAUjAAANby0LCRAtCwcRLQsNEy0LDxUMKggTFiQCABYAABkuIwAAGYQAIhECFwAqFwgYLQsYFgAiEAIYACoYCBktCxkXACoWFxgtAhEDJwAEBAUlAAAepC0IBRYAIhYCFwAqFwgZLQ4YGS0OEAktDhYHLQ4TDS0OFQ8jAAAZhAAqCBQQLQoQCCMAAAyELQsIBy0LAxAtCw0RLQsPEwwqAhEVJAIAFQAAGbQjAAAaCgAiEAIWACoWAhctCxcVACIHAhcAKhcCGC0LGBYAKhUWFy0CEAMnAAQEBSUAAB6kLQgFFQAiFQIWACoWAhgtDhcYLQ4HCC0OFQMtDhENLQ4TDyMAABoKACoCFActCgcCIwAACs4tCwgHLQsDEC0LDREtCw8TDCoCERUkAgAVAAAaOiMAABqQACIQAhYAKhYCFy0LFxUAIgcCFwAqFwIYLQsYFgAqFRYXLQIQAycABAQFJQAAHqQtCAUVACIVAhYAKhYCGC0OFxgtDgcILQ4VAy0OEQ0tDhMPIwAAGpAAKgIUBy0KBwIjAAAKKC0LCBAtCwMRLQsNEy0LDxUMKgcTFiQCABYAABrAIwAAGxYAIhECFwAqFwcYLQsYFgAiEAIYACoYBxktCxkXACoWFxgtAhEDJwAEBAUlAAAepC0IBRYAIhYCFwAqFwcZLQ4YGS0OEAgtDhYDLQ4TDS0OFQ8jAAAbFgAqBxQQLQoQByMAAAk9LQsNBS0LAxEtCw8TLQsQFQwqAhMWJAIAFgAAG0YjAAAbnAAiEQIXACoXAhgtCxgWACIFAhgAKhgCGS0LGRcAKhYXGC0CEQMnAAQEBSUAAB6kLQgFFgAiFgIXACoXAhktDhgZLQ4FDS0OFgMtDhMPLQ4VECMAABucACoCFAUtCgUCIwAAB20tCw0FLQsDES0LDxMtCxAVDCoCExYkAgAWAAAbzCMAABwiACIRAhcAKhcCGC0LGBYAIgUCGAAqGAIZLQsZFwAqFhcYLQIRAycABAQFJQAAHqQtCAUWACIWAhcAKhcCGS0OGBktDgUNLQ4WAy0OEw8tDhUQIwAAHCIAKgIUBS0KBQIjAAAGxy0LDREtCwMTLQsPFS0LEBYMKgUVFyQCABcAABxSIwAAHKgAIhMCGAAqGAUZLQsZFwAiEQIZACoZBRotCxoYACoXGBktAhMDJwAEBAUlAAAepC0IBRcAIhcCGAAqGAUaLQ4ZGi0OEQ0tDhcDLQ4VDy0OFhAjAAAcqAAqBRQRLQoRBSMAAAXcLQsQAy0LDQ8tCxEVLQsTFgwqAhUXJAIAFwAAHNgjAAAdLgAiDwIYACoYAhktCxkXACIDAhkAKhkCGi0LGhgAKhcYGS0CDwMnAAQEBSUAAB6kLQgFFwAiFwIYACoYAhotDhkaLQ4DEC0OFw0tDhURLQ4WEyMAAB0uACoCFAMtCgMCIwAABCstCxADLQsNDy0LERUtCxMWDCoCFRckAgAXAAAdXiMAAB20ACIPAhgAKhgCGS0LGRcAIgMCGQAqGQIaLQsaGAAqFxgZLQIPAycABAQFJQAAHqQtCAUXACIXAhgAKhgCGi0OGRotDgMQLQ4XDS0OFREtDhYTIwAAHbQAKgIUAy0KAwIjAAADhS0LEAMtCw0PLQsRFS0LExYMKgIVFyQCABcAAB3kIwAAHjoAIg8CGAAqGAIZLQsZFwAiAwIZACoZAhotCxoYACoXGBktAg8DJwAEBAUlAAAepC0IBRcAIhcCGAAqGAIaLQ4ZGi0OAxAtDhcNLQ4VES0OFhMjAAAeOgAqAhQDLQoDAiMAAAKVKAAABAR4RwwAAAQDJAAAAwAAHm0qAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBTcq8BfiKy3DPAQCASYqAQABBZX6Su/Ys9WSPAQCASYtAQMGCgAGAgckAAAHAAAeuiMAAB7DLQADBSMAAB8CLQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAAHv0tAQoILQQICwAACgIKAAALAgsjAAAe2ScBBQQBJioBAAEFursh14IzGGQ8BAIBJioBAAEF0Afr9MvGZ5A8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tZzbjhw3skX/pZ/9wHuQ/pXBwJA9GkOAIBsa+wAHhv99GJtxqfag2HRn6kW1eqsrkkEGyeAl+4+Xf3388feff/j05d+//Ofl+3/88fLj10+fP3/6+YfPv/z04bdPv3yZ6h8vgf+JkV6+z9+9xJRevif+nD+X+ZmjfLb1WeTnUuVzrM9a5FN+blk+xQ4l+ZSfu9jpYmcE+dSfl50Usnz29RnlZy5vjBO4wJEVLnGcRU95moh9QgkKXaDOb6fEMJXE3+JyLiD5Ly7pAlbahJ4UVOFSMuQQFKb/iRiGAJcQwCXMiYEE8nxoLgxdoKjCRc11Ahd1gSqtCRDXHduhJtCDQhUYqgxRSggKRaELoFIBJMBlXsCPmIFRCgnUqKD/1VRpqpAqVBWGQC8KXWBkBXlEDUmBDc5WrjEoVIUhkLJCF8hJQb+OqAWoUtUgAhegBhGalaEKoDIBorQQFEwZAqhMQBdAZQJIAL2qMVSFIcCRAECtzqBtqLoxoWcFEhhRoS4gFAww/aqRoQtwwRaoklRJqmRVsiqF7SSGLsCRuUCVlhRIgAOgZoaqMATYC8DgbxWGtqBz4RfwQyvDEODIBHBlArhgBSD13GtWUKUlBan5TlLznaqC1HzvUvMjSM2PKDU/UlaQmh85KkjNjxIUpOZHkTocNSuo0lRpqpAqpEqXmh9d6nmMrCBKDCEZkVKUyp9UjYZSykrcTyqBuAU6E/cUoaHEXWQRV2MLTNw3WgQNJS6eEAlFrkuhpsSduWVQMRpKybRkWjYtm1ZM475cB6gYdSUE5yIuAU8ukaNAiP1oTDyGCpkGjxZNe8SlTxybhKmSg3NRNI39oIKJtCiVZDRL0GGFyyxUlZppzTQyjYpRV+KQFSIl7lZC/DSOCExTQlUpmhZNS6Zx6YW6Eg8OQqTEvgnZ03iGEGLLATSUWjHqSjznCpESD8NCZoUHYiGzMtRK4VxhEfxAegI/Fg2lbFo2rZjGvXZRTUakxKOyUFNCG1VQMepKnD2AKlqB+1vlEbhzj6o8nAk1pRyMitFQ4gliBBApcUmFTGumNdPINDKNY2hEEClxDAmp1rgnCzUljqGRQMWoK7Fvi3i0HBlUjYYSPEKyyHW/iJOLRVzji0hbpvVkpC3ThmlDW4ZCNKrSCsS9dhFPiEKkxOVDG2GaQ40TWh+E1l9UjbRliIpRl9qlnoy0xjHxCanWQzIyLZqGOuUax/QnpC3Ts2lZW6aXaFSlFTqP6IvYNyFS4ngePNZ1judBoKqEKFnUhTBPDh5ZMVHOGYiRpxdFMuQAUKyGSNAFC2MCdsOaHV1trjZXyVVylSfR0UFdCfW/qC1KIaAoGVgd4VdljMXR1eUikFthTm1AMiwoVQNCxe/CLyxWAvxa2FyFX1iyBPgl6Gp3lZNAxelPxOIFE++cXID8YKxbIqcGc/gGVkMeLhVdza7mB3UYwjfBbshjkSIZNjwYK7dWDSk4utpd7Q/qMBzZsSumkBzJMEbHZrg8TsDiOAxzdiTDkhybYXVjtTq6sebG0LALl28NOAxHcTQVy0tFV2N2JEOsiAWbIXqgIB6MpfJqTeBqzYVkuBprMCLkSgCSIaJPsDoORSw3Fdl5XlamEpMjGSZXk6vZ1exqcRXRxwvGhDlbkQybqzzMCVJ0RNELcBgujxeSIToZLyYSZnTF4ojicFVXtNDCFB2bYbEmrMWasNbk6GqLjtawdfUhAhbHbtiTIpatqzUxTa9maavWFzZDdH/B4mgNi2l7NUAr1iytJkdXm6vNVXKVXF21noHWhJjeFU3FBK9oDUsxaGMRhm3Bbrg8BqJf8GovYe6PvISbuXZw7IYYtheiAXiZNrNxfkTFjhHPMYIor2BTxApXsTpypfLCN3UEjGA3TK4mV7Or2dXiaoFdbizM+IpkiIgSRHE4fjH/K8I3Ag7D7upycyHbbezQ4Ew88gJrYjeMrsK3xo9YCYOgq5zJCHIqMxM9INS1A8eFJPwCr/oUh2FztblKrqKLLEQXESRDDG2CTTCvTIHW5l9xHIbR1ehqchVuLsTQJkiG8FiwGVZ/MKYZQTyCtw5X/iDYDdHJBJthj47V0Y1hHhI0YzEkRzJcvnVgN0R4CrpaXC2uYtQQbIYIT8FqiPAUxIMHsBuu1lzYFLFuj7wwzmvPuGNLFgPeQgx4gsWxG6Loguw8ryxy4tWuYjNsrjZXyVVytbuK6OOVSE6IPsGmmEN0rIYY8ARR9Abshsvjhc1w7ZQTcBguNxeiOFzVGS20sAXHatitCXO3JlzpgaCpJQTH6ji0sbAjrUiGmEIXrvJya655Hs1SVq0vrI7DkLKjNSyW6KsBSrdmKSM6mlpDdHQ1uhpdXbWOTfxkTVhzdHS1BMfqOLSxKkZwQTJcHgPRL3i9mFciwMu/icMQwbUQwzYQO9iRF+K5YSjmtXbGVrUgyitYHYch1m6CXKm8iswrERAkw+Zqc5VcJVe7q5hYeZ2aVyIg2BSx762I4hBwGCKieLWaVyKwMLm63Fw47SZel2bioXguJ4DVkIdiRVebq+1BHYYcfYrdEMdLgmQ48OAOrIrIHxRdja7GB3UYpuzYDXNyJMMSHZvh8rgBi+MwxEGaIBniME2wGXY31qujGxtubHTFAd94WZ2x4SDIk4+iq9nV7CoPbYpkyJGq2Ay5ZyniwRE4DNGagmSIxop8nBUifqEAyTBFx+o4DFfRF7LzseHQLjmSYXW1utpcba6Sq4g+3mmYS7LkSIbD1dEUsaegiKJ34DBcHi8kwwQLAweNwbE4cnFSYEQLLeSJVbEZkjZhiUSGPTm6OqKjNuzcGw7SWAU5gWI3jMlwlZdbE4fIq1nSqvWFzRDdX7A4WsOmVfQGtGZZp8uCrg5Xh6k5JEdXV60T0JoQU76iqzk6WsPmErSxcimO3XB5DES/4D2mgtl/7o8w8uSj2A17NkQD8H5UKZyiJN6PmtgNUV7BZogGEKyOXKmJi1NWwCzshtXV6mpztblKrhLscmOVVfSFZIiIEkRxOH6xDaDIvuUIHIbRVbgpyHb5RL/gyHqmmkAuGe8QlYo+X/ALGIoXol8Iutpcba6iWQSL4zCEm4LdENHHGxQTmyJOABRdja5GV1NwLI7DMGfHbliSIxkujwuwGqK/CRbHboiGFSTD7sZ6MxxubLixMRRp+cYtRMu3hdUwu5pdLa6iZwl2Q0SqIBliBBfEgzm4aLXmwuLYDdFYvCtROkKOtxcKNhIEEX2CzRBFF6yO7DxvJBTsKSh2w+pqdbW52lwlVxF9vL1QcKqg2A2Hqxj7gANjnyCKzqExkPoIFsduiE7GGxQFhxCK1RHF4arGIYQgBjxBMiRrwkHWhKNnR1dHctSGnSNFlMaqOGdQHIYYzBeu8vKVFBzGo1lqWLW+kAzR/QWrIQXHIg1Q1+y/sGdHV4erw9QYsqOrq9YrsBum7OhqTo5kiISTG6viVpniMFweA9Ev+AZCxWl+argKxMtqxWHIu1SCaAC+LDB3YXF1qwCHIcorSIZoAMFmiC7Nm1ATi+MwrK5WV5urzVVyFVkx759NLI7dEBEliOIQ33FCRAnCN44d7AgourrcXMh2efumrtkftbNmf8FuiM4gyA/mjbCaV9Fhgawmc3cVReddqnl6nR1NLejSRECr9RKjo9U61v6K1oQrPRB8UK04Kz0Q9EdUN9bcwuoiuCa2uggQ+ZlgM8R8wdsWtQYdXiu2+xVdxaDL2xZ1TfkLs6sILr65UGuxflyL9WPcVlN8UG1QqK04ukpeHLKhAvfbFN3YMAstmPMtJkdzfk3ugkXrYc3dy0Kxp7Xq6ood9hiH+oquYrhCPTSykjUyh1r3QnZXR3a0WqeQHa04FKNjdTRjlNwCHOKUdWIzRFsIFkf+Gu9HzZrW7HUewkRHVxE7HY9AEglcS3tBttszcOjXcDSg2A2TqwiuhTk5ulqiY3X0R1Q31twCHIooTg+OxbEbYozi3a+6pua4sBomVxE7HfcqkRguzK4iMeTNrSord3ytkKEtxOqapRe26NgMyVXy4tAw7P6I7saGWpjprzrfsMev2A3Xkmthk3pooRSzUIZhdXXFDi6RInkSdBUrd66HiWRf69HRCzlcHepmiyE4PqhWnGh7FS3aXsXs/WZMVu7Atd+Xgd1w7fctbIYYXnkzua0d+gELPTu6umKnA0kRx/qKqFS+77qO9fE1zOiCONYXfFCHYS6OrpbsSIbVH1HdWHMLawc5Mq4d5IXNcARHbm7enJ3bqXr60Nap/cLkKmKHN2fbWq4LuooJe+B3S7WvlWFYi6OrLTt2Q3KVvDg9OvojuhsbZmGd5cPNEs153MFTLI5d66GUZhZqdHQVsQOPsZsvSK5iwkY9rFP79bWeHb2Qw9VhbuKmuaKrMTpWR3sE7pwLZrdQ9Ey4YcJWLI7dEMMrukjteibcMB8LDldX7BTgUGyhOKJSKy6NZ/1aQ3AtTMnRVex4CzbD4mqpjsOw+iOqG2tuoestg4YJW7EbYgtfEFHNQ5sc1QfgMEyurtjhsQT31BVdxYQ9cGe+kH2tRsdm2Fxt1ZCC44PqxbFLMI26P8IuwbR1wr8wmvPrLH9hSo7NEMMr6qGXbhZqdnR1xQ4ByZBcxYSNeujdS9bNoT68kONBNTeHXdqZ6GrMjub8SNHRjI3sFnCrc72lkIyaEvdyIUQ0EONpwLc7GQ5XOW4yI2FJregqT9ZzbQTUG4cU7KIirQN5QVdzduyGxdVChjU6+iOqG2tuATdWCdSURjAqRp2LnfgtjSgXggnTsJBpGf5lYDUsrvIsnUMBDv2WXmolXJBf1ExrpETJyLRupejVyCwPtYIJe1FUVzExCxWjrsRj6HJ63YvHl6s+ZN2LX1TUPayhBclV6ur0uhuPb3V1Yd2NX6Qa1s9CWrk5mharkbqKVbSQWcn2XfaAdygIs7BQV+K+K4RYrXjXpqxXIyjryxSEC+5C8KnxKzi8plF0NaL6CCgvXhDWy0JNKZuWqxJHjJBrWgrsowuZ5WZWyL6Lt7o6qCtxZQs1IeyU5wDE61H8plLVt2tovcIFWiGxkAyLqzzZZj7QIWyIr29VfQ2qtmDk2lDiiBEyrVsp9PUqqsMs2wtWmHcXRXV1veG1SF3F/Tmhok5jNby+XPUhOBIXaupeo+joKs+sy+nWrUBdXcDOtZBqWAYLaeXiLFxIS0EpGlUjs5Lx3T///O5F3x394bevHz/yq6MPL5P+44+XXz98/fjlt5fvv/z++fN3L//34fPv+KX//PrhCz5/+/B1/u/04OOXf83PafDfnz5/ZPrzO/92eP7VeUoy5NtzJ26Ygbn7+MpEfG4i9sDXyWCD79uTGaH8ykZ6biPP8amKjckUn9nYudKjFmOOTPGpK2VjouD6nlRHJK9Qaq9s1Buqo33b6ijYxYSJOT7R0+roG1cS34ldnswd4wcT8ZWJcUNtxHBDdex8ybyTsMqRc37qS0x3OJO/sTOJkjXMeN4wcROncwtNfaG5d/TUlV2Y8g0ldSXPLPaiK9PGU1e24VHIKrSl52PYJk4T745rz5+b2+1Zz0+bgsx9Fo+PMXcun46EcedNS8ndyc+DbO8OZxLiztxIf+rOLlKLxilfOjEL9V3tQs8H5LSL0qa99rE6S3pXGfrz+W3XqvmhVXMP7kh9HaJpE+YpJWuP9BBdKdBrG5tGnVkLv26znJnbkfVZZORdhYTkfTbMZP6pkV2M1uYlmWcOz6f8vTvpwZ3HyfYvJdnEaCeN0bkKNwPzrOy8dXsK3rppPGvdvQ0aZmMEemYjbwbTijtSsDGPNB96y3jd4fjVk6cFqTaGBR8HM71OB/MmTsljfR63eITlv3S5vGvYmmzceIj0+rpVyy6Vw2Va6S0PWen/2Ii7+tQmmSe577MwdOhoDzXxt/xInl3nhxb5Hxtl16Yen/Mk9Z02msVn7eN9NrBokhhP/bmNTXxS0cig0t5lYdicNOr7yhCDTa8xtOftWne5dY82Nfb6kHGMv1GdpVh11nc2a7YI5Rf332XjDlditgidR1jv6ynk6Rdt+mtt39ZGbM18mXvS77NBZEuNmVo/tzGu9pSdhbOesrNw2lNauhxe2+ocPvCM9Lw6t5MrXn6TyZXS08m11W1oWLPOraOnKdx5opDCs0Sh0fVUsvUbUsk2bkglKdyQSr7hzlkqSdvV/bDdjvGwYvpbyeTI1du30LuSydF8RTzG0xihej2ZpHY1mSS6nkxSv5pM0rieTPZwNZncWjhKJrd+HCaTPV9PJvc2zpLJrY3DZLK3q1PkzsLZFLmzcDpF9nF5itxX51kyubdxlkzubNzhymEyue0ph4ngqN/WxmkyubVxmEyOfrWn7Cyc9ZSdhdOeEkO8HF/b+jzMJrez62E2GUP5xunkQ6pQQijPUgX8yaTnkT60IPMIbTwtSAy022fNNkVOrvH5Oc9usp9HbtrrMv+lsOdWtvtPVLKllNTLO07P+M/fZa/a9nRbMMZ4PVWPu1On41w9bo+dTpP1GMsN2fpbHp2l63F3+nRHvj4PNryVZybynny9hF7dRkrPI2Xc0AnT9rAjt+ad8Pn5U9wdQM1ppvohZ39ar28V5XA82J5AHY8HqXzr8SB5XjI5vitSknWeyQ+T4F8jJdH1pV3cHUedre3i7vjmdHEXt6dRR6u7uDuLOl3e4c/EXVvf7U0cLfD2rhyu8GKu15d4bxg5W+PtjRwu8mK+nLtuTZwlr1sTx9lruZ69vlGnZyu9N4ycLfW2Rm7x5nCxt+81hyu1uDsVusXI6Xpvb+RwwRd3B1SHvWZn4rDX7Ewc95p6fU9hX6eHi779xHu66nvjfOnyqu91GvEQZ39NI+oNF1JiveNGSmx3XEmJ7Y47KW95dLg0afkbL01eJZw9vCvhzNEjJefni9i22x+Y3c5CpfS2aeTtBkHvvjZ5vCPzd5LwXH2plcfzBHp3bHWcQO+OrQ4TaIo3JNC7Q6vDBJryDQk0lcsJ9NbEWQK9deU0gSa6IYHeGzlMoLdGThPofj0V6NdTgX5HKnDD8cIbdXqYQO+NHCbQOyO3eHOaQG97zWnu28c3NnKcQG+NnCbQI13uNTsTh71mZ+K414wbFmrbOj1NoLcT72kCPbb3Aawk/GdgnxrZphElWPct5X1Xfl+lIvOA4JmNFOL1VCSFdDUVSSFfT0VSKFdTkRTq9VQkhXY1FdmbOEpF9q4cpiJpd5J1moq8YeQsFdkbOUxFUrw8qG5NnA2qWxOng2qK1wfVN+r0LBV5w8hZKrI1cos3h6nIvtccZhEpxW9s5DQV2Rs5TEXS7vjqsNfsTBz2mp2J416Trqe8+zo9TEX2E+9hKpJ2h1e37OW9SiPy8zRid/R0eniccr7h8Bi7j1cPj98qytnhcdrd+T4+PE67V6ruOTz2tzEj/33j5618w75VKpf3rVK5Yd8qlcv7VqncsG+VyuV9q72Js2Sx3LBvlcoN+1ZvGDlMFssN+1bp+hFWun6Ele44wko3HGG9UaeHyWK5Yd9qa+QWb06TxXLDvlWq4xsbOU4W6w37VqldX2K160usdscSq92wxKo37FvtJ97TZHH3itItyeKrNCI+ve6bKNyQLFK8I0PbHl4dZ2i77evjDG0f9bYlONJ7O45dxh5UL/e9nYntpHfmyNbEmSOHU+/OxHbReubI1sSZI4dL552JeD204vXQipdDa3+iceTI3sSRI6fnKjsT/XIf2Zs4c6Rf7iPxemeP1zt7vN7Z93c0zxzZmjhz5PCm6MbEuOzHuOzGuOzF9sXIIy+2Fo68OHw5c2Nh+xcQjrzYWjjy4vCvMGwsbP/iyZEXWwtHXhz+1ZW/Wvjn/PHDT5++/vDwhyv/+JNNff304cfPH+XHf//+5aeH//3t/3/V//nx66fPnz/9/MOvX3/56eO/fv/6kS3x/70E+ecfM//u382FFf3zu5e4hJnxzX86C3H9Rp1CpX/+yUX6Lw==",
      "is_unconstrained": true,
      "name": "add_member_internal"
    },
    {
      "abi": {
        "error_types": {
          "12164607307181823186": {
            "error_kind": "string",
            "string": "cannot cancel"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "cancel"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "for_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "against_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "abstain_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "cast_fractional_vote",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "support",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "cast_vote",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "support",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "_reason_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "cast_vote_with_reason",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "governance_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "voting_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "voting_period",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "proposal_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "quorum_numerator",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "quorum_denominator",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "late_quorum_extension",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "timelock_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "proposal_guardian",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "membership_mode",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "token_gate_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "erc20_token_address_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "erc20_min_balance",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "cloak_mode",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "council_members",
            "type": {
              "kind": "array",
              "length": 12,
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            "visibility": "private"
          },
          {
            "name": "council_count",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "council_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "emergency_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "is_publicly_viewable",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_initializer"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "12510611782093430208": {
            "error_kind": "string",
            "string": "not a council member"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2514106658851063029": {
            "error_kind": "string",
            "string": "council approval not available in this mode"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8717548249808531313": {
            "error_kind": "string",
            "string": "already approved"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "council_approve"
    },
    {
      "abi": {
        "error_types": {
          "10581129473648605397": {
            "error_kind": "string",
            "string": "Function create_proposal_internal can only be called by the same contract"
          },
          "11835668458991423142": {
            "error_kind": "string",
            "string": "below proposal threshold"
          },
          "12510611782093430208": {
            "error_kind": "string",
            "string": "not a council member"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "proposer",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "actions_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "description_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "target_count",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "proposal_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tZ3bjiW3rYbfZa59oRN1yKsEgeE4TjDAwA4cewMbgd99iz8psmY2Si33qr6Z9fU/vVg6UBJ1qv7vp3/89Pff//X955//+ct/Pv3lr//99PdfP3/58vlf33/55ccffvv8y89T/e+nwP/EPD79JX/3KZby6S+NP+fPZX5S1s8un1V/rk0+W9TPKp9df+6kn2pnFP2Un1PI+il2Ukz6qT+nqJ9iJ+Wgn+tntVPUTpH0JU1vIrVT1U6V9CVNb2pqp6mdXvRTfx5qZ4idHJJ+6s8x6qfYySno5/pZ7OSc9VPSlzW9uagdUjsk6cua3lzVTlU7rein/tzVTlc7Q9On6S0h6qfYKTHo5/pZ7JSU9VPSVzS9JaudonaKpK9oegupHVI7tein/tzUTlM7Pemn/jzUzhA7FIJ+rp/FDsWsn5I+0vRSEjuUo35K+kjTS0XtqB8TFf3Un9WPSf2YWtJP/Vn9mNSPaWj6VnrZj2P87lMN03AsDKzMplPZhWOfkJICO6/A/HZKE8pUEn+L0ykw9L84pQKs1AlctgJL4VQCuFgFZv4TP50LVmAINE5hrgxDgQtVoCukpaSl5KWwJwC4aAWqAoUFtIAfwQ/tYUFZsP5rLGWo0kNZ0BW4OxBoCtwhCFSFHBbQAjZIE7iVCXQFSguqArc0AVqwvs6NTWApfRlk/wUMNTi4JeUxAWUI6Ap5KXkpZSnc/gHcoASqQg0LaAE7bZiAVgVoCvBTBnSs021iQBfKfXlAJypERmMRmrpQX1S4GRCoLkKTFzKtmlZNa6Y109DsK6guQtMXWlpE8xciI04pj0URnYBQW4S8gTA0dFAx6ouQowFqi9B5gbishbpWSIwjGmmVxBSiES2KwahIJUzqi7jxK9VFPLiijlJNWuIyMIFaMCpGq2ZSz0ZNSzeNaLRKPIdoZFo0LZqWTENXyiWeczRaNZOLaWXVTKZgVLQWMgIEEPImVBfxcEsRNGuVuAwy9wxC3JaUmhIGLOKIAUMTcUpLTkZ1EfekSsVoLOJwgBDPcEAgxOlTMq2Z1kzrpnXTOCwgxElIKRNxiSuREaeA/Y/YN5RmPiqXAQaxKtHV/G4l0FiEEIz9hbicWwLRomoadw8NT2PPEerzGQ2WuUw7nsa+AaqcUiXTomnRNA5mlIrRWMT9hlJfxK2sJ1BdxP2GkmnVtGoap16pGI1F7PdKfdGwp3EtgBryFkC0iH1IqRj1RVwLSm1RNivsYULFrBSzwh4mhHwgAkY+hGhRN62bNkzjkVCpK3UOjJXaIh4Nlfhp7CUddSRUjPoi1AJ7bOfgoXdQX8TerlQXIaVCZDRzOTiXnf1eqSuNkI1Mi6ZF05Jp7EOD/QUjo1JfVEzjnlqIh22lmdLBNY3xUakY9UXcfge3BQyNSmTEKZB5SBFKgUN7pbYoac1M6otyNjKtJKO2CH5PIDIaizjwFOL0cR2lwGM3l/gcUrJRW4QWKkSLUjAqUrqT+qKcjUwrphXTyDQyDWUaQX1Ry0am9WTUFvF4xLUwiYyGEqZ8QuzPo4K4VrkMMOFTGot4PBeCRwwm7vVmuAAchpzChc2QS3hhNeT2N+MgYHEcC3Mojq5GV6OryVWOQ0YHFaO+iD1FCUnJmMxGR+SLHSPX4OiqZFGw8+SDM4NBdAZDwGE4XJV8cWEXroAZ1ACbIVfGQleTq8lV7h4XkiF3kAuL4zBkP5suC2yGPA4vdLW52lxFTSqSIWpSsTiOhRSyYzeUHHdgNUzRkRyHYS6O3bC4sdIMyY2RG0PFCkreuIZI8iZYDYerw1SM4AvJcRjCSxW7YcqOeDC7XEVtKpLjMJTKYperDb9QgcOwZ8dmKEkXrAtbQGV1YHEchtHV6GpyNbmaXYX3pQEsjsOQXKVuWLMjJz2zazSewywkx2HIQcgMoxk5CllYF3ZkMycgGfK4uLAbZqvCnq0KeymOrlJ2tIrt0oYysBq24FgMkV7U5ohhVcuQUhfshmj+ilaFI0dHWhUwslXLKMXRVXKVXK2uVlfFzwbQqnD04ujqyI6rYjOGc1TWxGqIHCsWQ7SLLOt7cAJizMkQzqVIhqgAXnHImOrOUZaxB8fi2A3FYQTbwogmzfPDjLmvItKr6GpyNbmaXc2uFrhyBZLjMIRHKXJySmSERyly3njOmbHMu9BVZFOR7RZkiMf+OQPComhwdBV549ngRDJMrnIko8ihzEJOJHF6seobeVaVsfCrSK6ihoj9IaGhK7qKXAii00VtSmigWByturEMPGdPjMmqG4u+itlV9FE84Zs4DIurSHpNjFIX+BqZa2AmvdBV6aMEzftyd7V7clAtgsMf4d5XglkoyBD3DxOLYzfMyZG/VrnmC60OJBcahtVVlHqVRe/s6GpHocKujSK52CgycXVBmUJ0JEPrzyZeVEsOpexoj6DsxopbIMs8kWWeanKshuhpUQ6YequF4U8bplbxHSzqI/wSjK4iGEE51GQpq8kyJOvIihfVsllLcXSVsqNlHlPxhW6suQXOEMfcGfNtpaqE4VwJHs1faRg2OMrOmFMrZlfFb7gpYTl5oauEAu1Asq/RMIRjKbpq8f/Ebthd7Z6cER39EcOMYRVakTPEc7SMZWchrgWlYgRv5uLAAjNPzTJWmJVMg8M02MZQJ9hdRZ/aInCsb41spJP4PNZUcVJbFJORaSkakdGyjIm4ULHv0soqptpKxagvQqiOTI8R1peHPqSEEIyKZm/iMIyuIvLgTBcMyfKt1BblZGRaiUZ1EZlGlgoai6pZrmal2XeHrqFNQroqNs1QLx1IhtFV9Da8HDeRc9bZgozNbQCh4nfRZDs239BkB34XY3PH76LJDvwufH/Ihh3v4wT8LtrpwO9iKyjgd9mP5voDkNWI3+1Q8bsdKn6XaydF2QDEhhP/LsbmxFO1iVD5dzE2p4TNQc7bHIoZE1T8boKK38XGVpYNxWHI3dFCV8lVcpVrZ2EzZBdbWA15rFvoD+YaXOiPGPaIHLJjN4zJ0R6M5fGF9mCM7gvJ0R/hOcborkj+YPJHVH9w9Uc0f0TzRwxYGNiQ5ZRxiFewmduwO8utRiivcKdgDzfxGv+clvP3eSl+YjckVwlqxE4vp4sX4QuG7kSwyz3sQlc7LHQgP00ejNRWGOP+ShCT8YVQZT8ZKgG7YXKVB+mFXEw80hTs8y50Fa6lOAzhWmjb2O5VhGsputpd7a7KpqogLazcOywsjsMQeUO1YFNYMSVHV7Or2VVkU5EMKTgWx2FY/cGoQkHJcQJWQzQmRXIchmhMin1hC8mxGcboaMZaCoaSN66WJnkTrIbkKrlaXa3kOAxbceyGcE9FPJh9vUltCpLjWNilstiVMUVPvNJfMEVXRHNSbIZIumI15DE08R5FwVr8wmHYXG2udle7q8PUAe/DeDPgfYrDMLqKliWIlqWIpOMUBhqZIjkOQ/QavG5dsCa/sBpKNiuQDNFrKHbDYVU4xqpCCqE4uhqzYzeUNtSA1RDds2IxRHq5Nimgc+VqmVgcuyGav2I1HNGRtAIIq/aCMRRHV6Or0dXkanJVSj0Dh2Epjq5SduyG6LY7zspgOBGUHAsWQ7QLjkoIq/eJ4485XUoLkziXIBmiAnipf/bP/AhezaeEsyyKxbEbogIUmyGa9MBZHjiMINKr6Gp3tbs6XB2mYgM88V7GRHIchvAoRSSHGOFRisgb+w52xBe6KtkU5NMfvP5P2AtfCDXjXFJxhIpEcrtY2A27q93V4SpP3AVxwGthNcSZBEVytAdjZr/QHoGgYaE/gmcEC/0R5A8mf0T1B1d/hOe4eI6L5xhT/4X2YMzsM+9ZkAQCHBMTJu6Zg1tCTLCwGhZXi6vkKtKrOAyRXsVuiPQq4sFIWY+O1XC4OkzFWv1CchyGsTh2QxwjUrQHIzxYiEewn+EY2UJyHIaUHbthTY5urEVHN9bcGI5yAZvkrQLJEN6n6GpyNV3UYQjvU+yG8D7FZii12YDkOAxrNpTK4p5Ljprx7g9hg31hM+TAZSEZIumKnHledCdssysi6YquFleLq+QquQrv42kYYYNeEd6n6Cpai2IzhPfxPG0iOY6FQ3IMxLk6XrqaWA0lm4JITgUOQ3QKgqgWQbIqHDU7WhWO5mqzKhw9OdZVWVhBWFgcu+JsTVVrs2JwR7XUIKUOlJQJVkMKjuQ4tAIqlgUWdsPmanO1u9pdHa5KqWc+BRqyYzeMrsZmmJJj1cqqWNdfWBy7IdoFT9ZrRLvgafnEaijOJTgMUQG8W1UxzmfejJpYHLshHEaxGuIwpiIXKk9SK9YDFJFeRVeLq8VVcpVcxeFH3qWp2OdXRLUoNkM0dN6aqVjMV4RH8bJ9RXggmENw7IaoFj6aV7G5nzNO66Ir5uOBFYfkFNEVK7paXC2uoloUyRCDpWJxHIbIJm+WTGyGqDdFV4erw1QJDxTJEB20YnEchik7dkPJcQdWQwy3iuQ4DFGxit2wurHaDJsba24Mp4gFJW9cQyR5E6yG0dXoanIVnqo4DOGpit1QDhAL4sHcNiWUUCTHYSiVRTi8jV+owLGwolNQbIaSdMFqiF6Zt7MqjuEtHIbZ1exqcbW4Sq7C+3ihpuJk+cJh2FxF3ycoR6AFcSScXQN7/QvJcSxsaGS86jPji+RYDZFN3gWrEh4IyvFzwW5IVoUy5AvW4uhqy45WsU3aUAZWQ3QVimWhHEJHbcpZc1RLl1IX7IZo/opWhZ2iI60K6GTVIqO/oqvN1eZqd7W7Kn42gFaFWBFY6GrMjlax2OuXysJevyJyrFgM0S544a7KCXZel6tYEVCEcymSISqgyq0EPKLzdQR0xYrFsRuKwwg2Q7kJEIBkKLcBBF0trhZXyVVyFRcCeMVwIjkOQ3iUIq4lREZ4lCKuJmRctYiOpka56CDIdnkToWETIfMSXcM6QeYFldlYsmM3zK5mV4urqBZBeJ9iNUQNKZIjHsx5w2m/hd2wu9pdHa6igwbKaXnFaojBR5Ec7cEJvZwiHlFwMyU5NkMMPopkiIpVLI5uDMGeohtrbqxVQ8lbB7aFOAGw0NXoanQVnqpIhvBUxeI4DKU2B7AZSm0KkiEqi5dkWpZ7CwlIjmMhzv8tbIZIuiLuO3DmcRhgIRlmV7OrxdXiKrkqV1sIV4eCIxk2V9H3KQ5DeB8fGW2yTiAoORakhYRGxqszDfsMipJNQSSHi1rCA8VhiGoRJKtCGfIFa3C8qFaF1IpjX5WFzYWF1RCDD7BKerk2K7piVEuVUhcsjt2wJEer2Co3iwrQqkVGf0VXm6vN1e5qd1VKnYBWhTgPsPCiWhXieN/CvioLJwYWVkPJseDg2zPcQTfcnQwR2A1xKUkQt5IEcYWGl90azukVXlhqOKcniHN6C4tjN8SlI0XctuLk4BrawmqYXc2uFleLq+QqLqnyimHrknRBchyGcvULF+lwKUgQ96t4l7dhRUBxmDokm4Jsl5eQ5gYIP40PEE+EytWCZYCFrmZXcatKEHURYRd1wdPfhpN+haf2E6FyBWBxoGQ8DdctBXHjUtHV7mp3FRedFEmxI35YWByHIaqQJ7pdL8UBcTNL0dXsanYVVahIhrj/pFgch2H1B9duiBzzFLzLDTlB3OBTJMdhiKvTin1hDMmxGcboaMZwbFBR8pYZJW+C1ZBcJVerq3BPxWEoV9YEu6FcWhPEgwuj1KYgOY6FcgmcTyZ2ue8t9z7REwjC+xSboSRdsBriih9vnU8sjsOwudpc7a52V4epWEgovA/fcWFg4TCMruJaoCAuMCty0nnPvcvNO0VyHIZoZLxAMXckk2M1RDb5LGaXu+OC6DUUu+GwKszDqrCE4uhqzI5WsUXaUAFWQ3QVisUQ6UVtFrni2IDFsRtK8xe0KpTL4oq0KqAMqxYKxdHV6Gp0NbmaXJVSD0CrQlzFW+gqZUerWBwQlMrCAUFF5FixGKJdFFxHRrvgy5QdV/YEqziXIBmKG3VGDDO8WNSxCbCwOHZDcRjBZihXeCOQDJFeRVe7q93V4eowFVsDhQ+V9CZJFxyG8ChFXGVl/0UgsBCXVNl3cB9voavIpiL6SSCqhae0HYsDpSI5aPOKULkkG/pflCSu6C0sjlbUEj/w5LX3aEWNXQLF5Cqci6epE4dhdhVDaMXvohOTrxWrlu6V1b2yJDxQtJrvzdXmyUEnJtj9Ed2NDbOAiwDSNoe0FsFumJIjbvOyr+OcvzRInPNXJFflNjCXuoz+iq5iLOQjIV1Hf3ytR0dr/sObv47+E4eO/oIXdRjG7NgMUzTMbqGszE/shtZzDbn6LoielsthBOu5Ruj+tO4qfIdzPHDkX1DGbsWq5TBk7MbXZOwWTMHxolo25dK7oqs2Qo5oI+SI5I8gN1bdgoSWmVFCS8FqiDavyF/jxYwhb2/hWHnI2C2YXBXfAaJJK7qKTqwRkOxrcC5BKo6u1uzYDZurzZMjr0oQ9Ed0NzbMgszneSI2sswWgTIpFiyO8Gp2DVztw+xryHRd0VXxnQYkw+YqBgleFhq5Dftaz47dcLg61rRvlJAcXY3RkRztEbLyL5jdQrHM63xesDh2Q7n3z+Ug6/ZiofvThqviOw04FsowrthXOeCEoHyNomWIUnJ0NUdHK3U5GKBIjpZ5jOgL3Vh1C8hQRcqwDKvYDbELowivHvzejriWNScOw+QqfIdPFg1cq1/oKl5fwXfsh0zt5WtwLsVqWF2VBUxgC44X1ZMD51L0Rwwz1myddsgknpfEh0ziBVNyrIbyXg4uvlbWQvnAKL3QVfgOn2MauI2n2FzFgM3rckO29eVrnQxHcLyoa+tlyEtmFF2N2bEZpuhoxnzlf+h7ZTib+mYZQct8l00WwbLKQTbwxUL3pw1X4TvI8UAcpegqBmyUA2bu8jV5B41gKo6u5uxopS6r+YqWnGGbFhP9EeTGqluwreQhe/mCsvMqWBzh1XgtTLC95Mm2mcx80cV/qjA5l4uOcRsvOpg8/LvwssXduV50LAArt3Thi94vaYOzLb48a7hNjOyL7cDCZDkDo1wu3J2xAoEXL4RopxaYybledPEr+S5CW+V20TGeD/n9nv27vTmPdGHXZRV/cXWOFz3ShYdzyhe+2MwXO+RlIqv1i71MkpxUUq5WPpidLzv98txx0cXf8F0c/Te+6AhcpHxk4V6+Kyv3iz3NmKcbe95zCRe+6p62TPnCl2fVi812sYPZCF5+EXCPr+AFFwGX+wteZxFk+i4s8/fFqHd5kRMCe7z0ImBTP4lNDPPG1VnOcyrju2hrci9A0oCd+8XtoqObHmiPuLNvfNERQo4uTP5dnKcVRiRgfNHl7KZyd04XPXna5PLAYrrwxWa52KnrrDBzdcax1MXlwihn4bEODM+gPsQLX3S81Sgok3O66Nw/UIjCw7+b84W7c7nodhp9MqULX/R6SZsc1Va+PKtdbPaLneFl0kK4cLlwd5b2JZyD2WnZn4sL/MbFygFT+8V00bl/0PLBab/13ep5RORgfNF7vLDXSxsXfVzSNrxMcHDQ2G3inTyLM+oxCZNzuegFOtpp5/RTKMLduV10vJEqyOvUkDa8TCzIqX9lbgt4W1bAjH1hNUTCFFGWaNPYucebsiY2w+oqNwIKaLiDlxuML3pH5row2Ve5z1LkLmvhUnlUd+yG0dXYDLlDXkiObiy7BUzbk2A1xNRLsTii0AdYlhyAsuQgaCquAxJvm0R5T93ieNHxvi9+MyTzsK9i2VexG2ZXZWEeiJhf0VWKjuToj6hurLmFbiUgc3fF4tgXJo5etDCSrDsI2uPkNayKxTKNpfnF5aJz16qFIW9mla+S5cpfhBdTdbVFRyt+mcArepK6lYC8tFXRjMl78PIff3z3ab339vvffv3pJ37t7eVFuH/976d///DrTz//9ukvP//+5ct3n/7nhy+/45f+8+8ffsbnbz/8Ov935uynn/8xP6fBf37+8hPTH9/5t8P9VxO2efHt2XCHGZi19JWJeG8i8o6S2uBXhDUz0vJXNtK9jcwvpVEbk1u8s7HLSo8rGXPsjLdZKRsTBe+D0OKIzQu01a9s0APFUT+2OPjSqprgO563xdE3WUm8vCg5mftXFxPxKxPjgdKI4YHi2OUFNyckHTnn27zE9ERm8gdnBlcXtWLGfcXEjZ/OYGPlZe4nlNus7Nw017JsTB6vZmXauM3K1j1KswKt6b4P2/jpnO7F5euJLxfdtfy0Scicq7p/8ALRbU8Yd7mpKXl28r2T7bPDG0yanTlHuc3OzlPL8tMyh0KzQO+ql3bfIaedl9bVaq/FWdK70tDvx7fduBK8Vidfmht97aJp4+Z8t01tTO/yOk3h6+JMm0rlk/dqgw/L39rIu/IIZfnF3EYY9zY2HjqnHWuQnB2i5yV/Uy1505U2L9M5A6J7Gzv/pGT+6ZUyo7qvLezG+zislaRL9PP/bGw8lNIKoCiH91kYVq2XkvhT+UgexeWQ7m3sOmJKq1YjXT30T9mow2z08T4bOZiN2WRvbZSNh7ayPKOV+i4Lw/q+uafyLgu8zLjyMVc77m1s6nUuWFkXPFf1vfcaf6I4+QFanPTOas3moRP7u2w8kZVo/c6chvb3tZTmw3zbtFcKH2sj1mp5qa2/z0ZrFtLOEO7eRn61pewsnLWUnYXTlkL1ZffaFufwjmcuWd0mYztEl+pD9LVKvhle6YkpU31iyrTPTaqWG6Lb3NT08jSj5gemGecB2H3gs7VBNoecm/Kb8qi7+U734e0acpSvA3P2o/sgbuTVqU++1My3pdp3RpKX6tyyunezsQvBqqdkbk/cG9lnJ12yc111+dpI2wWlbbl7H24g9z8R5vdBFubPpey7MH9nIwXrQybH/i4bydexUiq30422DUrjCmz5tSaX7vBrT211G8xZcXhPNvcDv7bQXg/yW381yG/j9SC/h1eD/K2FoyB/m4/DIL/n14P8vY2zIH9r4zDI7/XV0GVn4Sx02Vk4DV36eDl02RfnWZC/t3EW5O9sPJGVwyB/21IOA/RBH2vjNMjf2jgM8kd/taXsLJy1lJ2F05YSQ3zZv7bleRjlb0dXvBJZR9eWbkfXGMrWOaxia784WGjvDBUu4/w3oQL+2sbOihm5+sc3CYnhiZA0hidi0hieCErfytFZVBrjdnN02BbauCzD/5nANOGFfFpB+WLk21rebTudRoQxlldDwrjddjqMCeN24+koKIyxvR4V4o+jvBYW7k0cxYX7rBwGhnG37XQaGb5h5Cw03Bs5jA1jKq8OeVsTZ2Pe1sTxoJfay4PeG2V6FiC+YeQsQtwaeSQ3hzHivtUcBnhxtwX1iJHTMHFv5DBOxJ9XebHV5JfnVFsTx60mvz6r2pfpYay4H3hPg8WSPjpYvIYR6XZtKpbyQLBY6IlgsdQngsXSnggW38jRYbBYxkcHi5cpQb50SX9mBTJbhzT5/sBDpPSAp+y2hs49hcoTnkL0hKe8kaNDT6H2wZ6Cl6WsCiq369377j6skGCk944YdXVLo9HLg87OxDbaO8vI1sRZRg5jzo2J7UrNUT62Fo6ycbhatLHQX3ar/rJX9ZedarujNLpFh3x14LaFtSf60fZIP9oe6UfbI/1oe6Qf3e1Qvb5ryDeHrI7nD/d1PB6o4x6eqOMen6jjnh6o423RYlq8inazutmfCFj7IwFrfyRg7e3Di7ZbqcypNt0X7RNeOx7x2vGI144P99qUyYv2csT226IdT3jteMRrxyNeOz7cay8LnXNp8H4hfDzgtSk84bUpPOG1KXy41+biw1hut8NYCuWJoqVHirY+UrQf7rW+bJpiyfG+aJ/w2viI18ZHvDZ+uNfiBW+raPvtMJbiE14bH/Ha+IjXxg/3Wtzv1qKlPO6L9gmvTY94bXrEa9OHey2RD2M0boexlJ7w2vSI16ZHvDZ9uNfW6MNYLf2+aJ/w2vyI1+ZHvDZ/uNdWvwUXW7j32vyE1+ZHvDY/4rX5w722de9rW2/vWbOfM09bs4+9x3et+1P0HSK6XxFOu3tPx1W82+86r+KSn6ji3ZbXcRW/laOz9aq02/OKNduOZL2Uyp9a9ydb9JrdergPmkp/opbHE7VM4YlapvhILY8nanl7IQp/7kNquYT3rUvyzXGv5Xo/Eu62vI5rmeojtdweqeX+RC2/kaPDWt5d0XqkllvwndqW7tvy7opW4r8TvayUXu8raHtLK3Xb7chphHeNhMlvi/GptvquUWxcnHZUeo+NjP1ksZHn0v19uW5c9vTIZar7K9UrIZsjl2l3Sev0yGVqu1726Mhl2l3ROj1ymXbbYWdHLvcmjo5c7rNyeOQy7TbCTo9cvmHk7Mjl3sjhkcvUXr5lsDVxdnhsa+L08Fjqrx9SfKNMz45cvmHk7Mjl1sgjuTk8crlvNYenJVNvH2zk9Mjl3sjhkcu02/86bDU7E4etZmfiuNWM129/7cv09BL+duA9PHKZxnaq9fqRy6/CiHR/OCDtTtOkNmxNq8dxH4Tvdr3mbln16Czfv5oq77a9Yml+e730y+u6Mn37DqLd+e3UrWivry/7NvLdGmmtWFDTNiZ22aEQrI+mcHG3b7PzVtlaUDKZ4n3Z7la15tqlvfeL1zHfEz/n5Ecm8uZCWA4PxK05vBy35vBA3Jrjy3Frjg/ErTm+HLfuTZy9Jyo+ELfm+EDc+oaRw1dFxQfi1hxfjlu3Js5G4K2J0xE4P3C55o0yPXxhVHwgbt0aeSQ3p++Mig/ErTm1DzZyGrfujRzGrTm/HLduTRy2mvxA3Jrz63HrvkwP49b9wHsYt+b80XHrV2FEv13+yvmBuDXnR2KrsgsC5oalRb+xUbu3st0iaHZIanIv74rQcrA9tjwTfVu05YHL3Lm8fJk7lwcuc+fy8mXuXB64zJ3Ly5e59yYO3+T5wGXuTA9c5n7DyGGERg9c5s708mXurYnDsYYeuMyd6fXL3G+U6WGERg9c5t4aeSQ3x2/1fCK4qvmDjRxHaPWBy9y5vnyZe2visNXUBy5z5/r6Ze59mZ5GaOWBy9y5ffBl7q/DiPvt/dzKAxHa9jrXcYS2e9ngeYTW2odHaH43ZsaD98Hv7kbXcYTWw8sRWo8PRGj721xHEdrutW7HEdruLtdhhLY1cRahbbNy/LL19kCEtjdy+rr19kCE9vouVn59Fys/sYuVH9jFeqNMT1+63h6I0Hr74NycRmj9ieBqjA82chyhbY0cRmhld3Pr8M8U7Ewc/p2CnYnjP1QQHlir3ZbpaYS2HXgPI7Sy3bx6JEK7hhHldu+3xPB6hFa2F7ZOI7SyvbB1GqGV7V+/eiRCw9+O1aKlcBuh7W34eflpL99XT32ietoDW/Nlu39E2f5oAF2q+NsN8beScugp6YnV1pI+fLW12l+wm0zveh97ptHdRr49T1pSeX0+UBK9Oh8ou7tap/OBsr+qdTIfKLs/pXA6HyhpvDof2Js4mg/ss3I4Hyi7K1qn84E3jJzNB/ZGTv/+0u6K1mFkszNxGNnsTBxHNg/84aI3yvRsPvCGkbP5wNbII7k5nA/sW81hKF9K+WAjp/OBvZHT+cBuFfuw1exMHLaanYnjVrO7lHXqZ9syPZwP7Afe0/kA5Q+eD9Tmw0S7f+VOeeJCVnnkQlZ55EJWeeRCVnnkQlbZXsh64KWKXweL95ePyvZC1um0Yn8f6zSWr+WJWL7SA7H8vm87eing3sTRWwFPe9idiW1oc5aRrYmzjBwGWDsT29Wns4xsTZxl5HANrNE7F5+PMrI3cZSR0yXwnYn68osz9ybOMnK4b7wzQS+/j3Vv4iwjh8dGdiby666VX3et/LprxZffLLs3cZaRw6PWOxP7mxbNXtE3udzGP29ZsSn7S1b8D5TP8bW+18rhKD3KA6N0er0rTa93pen1rnR/GfUsI+1lfz+9EvvOtxDHHi9vhonvfLuM/13L2HN5n43rG2ra/Rsptid5rTjmZsXl9QBfWdj+ueKjWt1aOKrUwz+ZvIt54suBV3w57orvysXf5o8//Pj51++//PLjD799/uXn/8zv/cGmfv38w9+//KQ//vP3n3+8/O9v//vv9T9///Xzly+f//X9v3/95cef/vH7rz+xJf6/T0H/+Wsqc4UhlVz+9t2nKELIUwidhQhhdq3zn/G3PzhJ/wc=",
      "is_unconstrained": true,
      "name": "create_proposal_internal"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "delegatee",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "delegate",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2633295041654830480": {
            "error_kind": "string",
            "string": "Function delegate_internal can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "delegator",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "delegatee",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "delegate_internal"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16238081572903391961": {
            "error_kind": "string",
            "string": "insufficient council approvals to cancel"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4756330914173469558": {
            "error_kind": "string",
            "string": "emergency cancel only in hybrid mode"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "900405183110375111": {
            "error_kind": "string",
            "string": "already executed"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "emergency_cancel"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15312957078770032001": {
            "error_kind": "string",
            "string": "insufficient emergency approvals"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2547213599764567162": {
            "error_kind": "string",
            "string": "emergency execute only in hybrid mode"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7715731631402574514": {
            "error_kind": "string",
            "string": "proposal canceled"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "900405183110375111": {
            "error_kind": "string",
            "string": "already executed"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "emergency_execute"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4422981737823726437": {
            "error_kind": "string",
            "string": "timelock not elapsed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5846850200630327512": {
            "error_kind": "string",
            "string": "not queued"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "execute"
    },
    {
      "abi": {
        "error_types": {
          "14487322055111218121": {
            "error_kind": "string",
            "string": "Function get_cloak_mode can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZlRbhs5DIbv4uc8iBIpSrnKoijc1C0MGE7gJgssitx9SYnU2AFGcB33Jf6Gk/lNUpREjX9vvu++vf38uj/+eP61efzn9+bbaX847H9+PTw/bV/3z0ex/t4E/cN585geNgU2jywfcgXwsKlyCSifei12CChQFKoBsEGMm8cICmKJUSCRAcpXJL2F5FANCB3ckt2S3cLJgQ1KdMgG6mkH/Qr50gjZIAYHv5XcktyCbkF0KAaUHNggRwf/CgYHFQwK1aCgQzGo0YE7pAAO9niC4DAsJphicjDBlNyS9SlUQIdqwG5htxS3NMcUmmMNuAM2xxpkg+YYKaBDMdACaNCSKdWCpLekNrBlrEE24OCADtWgSDgYFNhAHetgFgrRwS3gFnCLJgpBgQ1SdHALgkM2IHEMowI6FAONooEONyYFcqgGzXlUKAY6dxSyJrNBG8EGlvmcooNlPqNb0DKfCRyo5zm3KaOQkwMbFOpDwCH1rLImqgGAAzlY5jmiQ+k55BQdLKuMbkG3kFvILdktufSsMkcHyzwXtxTLPFdwoJ5nrrVD0Sg6sIHObswCOrtRlyyd3Q10OnQoBpo6rLqsiSCJY0WXlA5soCtfBzKowUHSQvqltXSo6k8Ht4BbwC3RLdEtSSuqKBSDlswG2UDLj5ICOajPWddgdUOiqJrMLI7VEhzkn7OMe9UcZlbIHSAEGMQ9DRAABtGg6qSe57bIoyVFKDvRsKmLuT2hC4/RYhM9bv+nU7w/wcWppEHDptPcyEYFIMRB7gFAGISDXKVtP53Ue50E0PedTtWpreud5AmGtpfZlBC5MGixaUS6n4FWhJHbotYEp0a27EGEOIid4rDF7JRg0LBhGISDhjINlTyeZY+y7z6NShrETlokLd4UbOZDAhw0bFoHLba21XRKw6YrQos3ofuS0L1PBIOGLYdBntPEw8bDA/YoUxnKZai0Db68vz9svIv5+nra7bSJOWtrpNl52Z52x9fN4/HtcHjY/Ls9vLV/+vWyPbbP1+1J7kql7I7f5VMEf+wPO6X3h+XpsP5oTKXa0zJadQhIpVxIwLqE1JnOtKYhzDxEOF1oxHWNFInINIQZ1jRmoRRwN6Q/gdVQcCKBQGGkA3hJKOcLDbpDOvLfTQdGXTGbBCbi1XSUSSgylT2SSPlMAi4k6h2yAeEO6ZjFkiC5H7ICrMYC8R7BpL8cTNT1ywamrg8MTOpUmhaPhWvE1VBmZSpNumsI18+GIhqroczKg3Qn6F5QLetr2KROY01pzHzpcvLqIjZzJKU4PEkJ8YZpex5MDmE1mIlE1ibFNLI2HUOELnMaJ2VKGF2DEJdKj4EuNSbLqRwFfAnKctha15iUaQo48iHH6XWNSZ1K7+1jKzN4iUV2/UsNnkwXXqZLAVrXKLOx9VJHWAZFTueXCrMylZcEXqXxbLv+qJEm5UHRd3xK4TaFOob1LBN/FEdc2o4U4roXkwoFij6q8gqGb9TIdWiUepuGtKBjBYtlXWNSoYxeGYz5JoWKvqlUus0HOaeMlVjOQOsak3HFAu4GFlrGFeofpFNfMFg66cZhTaNCBctNGvcIBca6I6e2cttMYfAeLPJkviL9XQ3IecSSudymwTx6MOk51jXKZ2fKTOG6mTJTuHamEHy6vKbprMvCU+N6OqdbNOZliz4fkg/bK+Ed2mKiO7TF82hiHtEQrUfDn+6LqdyhL76+AZs0PjMNGocekhe9qxp5drxftmrd6RYNvDwS59nxPtTki7rw2ch8PBPPDk4hLlkN8i5oVQRnLVhePKGc10Xm4cSzcM5fE3wQmTWl7OUub2mXdrKU6xey4FO3xhuXwuzrWGX67GI6UZg2LldFMVW4Koorm6ePCl/kcvu0P1383viuUqf99tthZ5c/3o5PZ3df/3vxO/575cvp+Wn3/e20U6XlR0v5808K+UHWvC/62lguY8WHWKtegt6Nerd8eVdn/gc=",
      "is_unconstrained": true,
      "name": "get_cloak_mode"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5874306019897513529": {
            "error_kind": "string",
            "string": "Function get_council_approval_count can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndThw7DMffZa/3InZiO+FVjqqK0m2FtAK0hSMdVbz7sTN2ZhdpIrrQG/ith/mPv+Jklt+774dvLz+/3j/8ePy1u/nn9+7b6f54vP/59fh4d/t8//ig1t+7ZD+q/sz7XaXdjex3TT8B6G/9CGW/g2QGMagKVQGyA0IA725Qb4KsFkSD5lCKQjNoDpQDqgOHhcMiYRFxqBDADubpAhSgj8hpv0NMASUgLuWw5LCUsJTqQBggDgwB7CDxCKEAC1CzgTUHVIeGAbxAThBAAX57hhIQFswB4pAxICxsUaBBdbAcLhCWGpYaFnNsAV6gmGMLkAOkAHtENqgOiAHs0JNJCmyX2IAdesY6lIDq0B3rYAnXcEqDAF6AEgSEBcICYcGwWKKytgRZQy7ADiUshRwoBahjJRlUB4tiAXawchcwaA7m/AL60KKJIsuqAdvaWYAc0BPO3UODDAFeAi5hKV4CphTgJWDyEjBjgJeAq5dAkpdAkpdAIAWUAC+BYA7wEkiGAE+vlLCUsFBYKCwcFvYSiECAl0BqWKqXQFoK8BJI8xLUhAFeggqWzGJgJdBIqy3zDrYuFhAHS13R8VVtXRR1rAoGsINNwAVKQHNomhayhzZZoJk/C4QFwgJhwbBgWLI1CRuIgyVzAQrQh1IfvSVAfSatabMJuUBYzPkOlkyqBqrM9ixrvwXcojNclixAskXjRINakHUB2yBP3b3aiYNo2EjvZRvvidOg1aZ6nI2kxB1Sg/p6WWjYGg4SJ0g4KDwASIPKoFABHPf2TqVONKgF2Q7kZBmyXQ76GGejmgatNouo32EN6hQ2TJY17uTLSbdGHCRBOGzIQX2VLTRsJQ0qg4YyDRUe90pE2XehhWoeJEE2Vnu8fbvp9+aYBdA3nIV6H1CnGpSHzXq4x5tL+JJLeJ8JBg0bp0GR0yzDJsOD2BEg16Fch0rr976+7ndxivn6fDoc7BBzdqzRw87T7enw8Ly7eXg5Hve7f2+PL/2Pfj3dPvTfz7cnvaor4/DwXX+r4I/748Hodb/enbZvxVyb363VakNAO+VCArYltM+4uoayyBCRfKGB2xoZicg1lAW2NGahVAg39JwCm6GUiUQBSiMdIGtChS806BPSwX83HXqUEZcomWQzHXUSClq7LpEg8ZkEXEi0T8gGpE9IxyyWDDn80AmwGQvgZwST/3IwKDgK07YLA5M+lTpikYZlM5RZm+phPTSU20dDUY3NUGbtoUkML6jV7Rk26VPUg81Y+U03gc0hNnNEX2eGJzmXcsWyPQ9Gj92bwUwk9ADeoiysb09rm9JlTnHSpvoKEn6Q7s+rH40uNSbjFCjGByYcCrpfXirMmlTWJtXj8qpR8FJj1qUUDVZgLSvSm7rKpDmgRS70jbxta9RZPmOfpZyuU2gxz/ksE38UB66bfT6ryFuNPNvtCWOdABW5UoPb0KjtOg09+I25gXVbY9KfUqIzpPBVCq3EKNdXnKsU9O1gzD9989jWmNS1VAg3SiU8W6t/kE57EfV00pVlzaNDFetVGp8RCoxJru9K9bqVIjBGl0zWa8l/VwOYRyws9ToNkXHy0Z1+W4M/ulJmCu9bKTOF966U0j7cXtN0tnXw6Pcj2+0121yBaWyugpubK+G0NUZZuZ61V5IrDwpEWwcFmr0zIa6b43lzvPGDJtu8zvIc40f5zJE3Byea7fMJ19No0u8KNkVkdljg1RP9snRbZB4OnoVz/hr5RmTSqlWiRWpbBfQb7/cvuRTjuOGVi5ZjxTWhjy77icJ0i31XFFOFd0Xxzm3+rcIX/Xh7d3+6+H/Uq0md7m+/HQ/+8cfLw93Z1ef/nuJK/D/r6fR4d/j+cjqY0vpPLf3xT9YUZOQv9rWifsRG+5ySfQS7ina1fXk1Z/4H",
      "is_unconstrained": true,
      "name": "get_council_approval_count"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8799882153436241657": {
            "error_kind": "string",
            "string": "Function get_council_count can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAD8vCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQV6H3Yx3N3e+TwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4LGJT+Zej40f4lKdhvdj3V5vH6J4e4hTVzdN/X5sbueyr28tjz6Emh4OREFSOCsKJ4XnHgC33AUtRZj6PB4Ct14KUHoOAGPgRIE8BZBHEDkgFQPDAc8GrWLAXAwcGIjBc2QcpYi5HfuuqqbUNsmyhHvZVW0vinZoGik+y2Z4/ujjXrbPti87fqukqNoLtwy81k01RaNcZ6v0VCQf5tmoVVgAAH6HgDQCvLJ+ZnDs3AJxtGNgmkFojJkZHDtIMXJSPMQ0MCAkpegMQoNRix3gVkOd3THMC+yw/2uHRutmhCbjknb4jBQkG5WgsRsE7BDhBW6AeoEdOS0EFPMgoqQWwFeIoX8Wgw6XhQnphYFMnTq/aHEBdVJKrkzJ6sjgOPxVCjOSUnLlwSbGLEzw6TMsU6cYiJadH0jb5CGWS4QIl0yItP7Ftt2KsUolxWQQFhGipxzrtdjN3lPMlCniIoURqx2o3J6ROU5JsZNRjArGJE01OQiuRabQpz8vuUo1ds3EWJuG5OXgRs726/ADkql37+Lm92EFkOfVPXC3PNfd7sIyTqiuLk9NNXevQ3vevO2/7vFNvPDcu9u5ugxdNZHWWw/w841QkjtMV5ip46VWh3H6628=",
      "is_unconstrained": true,
      "name": "get_council_count"
    },
    {
      "abi": {
        "error_types": {
          "13770014322479677326": {
            "error_kind": "string",
            "string": "Function get_council_member can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQcAEREAi0IRAElAAAASiUAAABLLQIBRScCAgRFJwIDBAE7DgADAAImJQAAAwoeAgADAB4CAAQAHgIABQAeAgAGADMqAAUABgAHJwIFAQEkAgAHAAAAfiUAAAMwHgIABgkkAgAGAAAAkCUAAANCJwIFAgAKKgEFBiQCAAYAAALxIwAAAKcnAgQCAQoqAQQFJAIABQAAAtQjAAAAvicCBQICCioBBQYkAgAGAAACtyMAAADVJwIGAgMKKgEGByQCAAcAAAKaIwAAAOwnAgcCBAoqAQcIJAIACAAAAn0jAAABAycCCAIFCioBCAkkAgAJAAACYCMAAAEaJwIJAgYKKgEJCiQCAAoAAAJDIwAAATEnAgoCBwoqAQoLJAIACwAAAiYjAAABSCcCCwIICioBCwwkAgAMAAACCSMAAAFfJwIMAgkKKgEMDSQCAA0AAAHsIwAAAXYnAg0CCgoqAQ0OJAIADgAAAc8jAAABjScCDgILCioBDg8kAgAPAAABsiMAAAGkJwIBAAAtCgENIwAAAcYnAgEAPi8KAAEADi0KDg0jAAABxi0KDQwjAAAB4ycCAQA9LwoAAQANLQoNDCMAAAHjLQoMCyMAAAIAJwIBADwvCgABAAwtCgwLIwAAAgAtCgsKIwAAAh0nAgEAOy8KAAEACy0KCwojAAACHS0KCgkjAAACOicCAQA6LwoAAQAKLQoKCSMAAAI6LQoJCCMAAAJXJwIBADkvCgABAAktCgkIIwAAAlctCggHIwAAAnQnAgEAOC8KAAEACC0KCAcjAAACdC0KBwYjAAACkScCAQA3LwoAAQAHLQoHBiMAAAKRLQoGBSMAAAKuJwIBADYvCgABAAYtCgYFIwAAAq4tCgUEIwAAAssnAgEANS8KAAEABS0KBQQjAAACyy0KBAMjAAAC6CcCAQA0LwoAAQAELQoEAyMAAALoLQoDAiMAAAMFJwIBADMvCgABAAMtCgMCIwAAAwUtCgIBJigAAAQEeEYMAAAEAyQAAAMAAAMvKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQW/GOsR03E/jjwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnfauM8EMXfxde5kGY0f9RXWUpJ23QJhLRkmw8+St59Z1LZShZkFq98kxxb9s+a4+ORwV/D6+75/PNpf3x7/zU8/Pgank/7w2H/8+nw/rL93L8fbe/XEPxH7Rc3g9LwIJsh21aM9m+bMW2GGHyHuFATaiJiERBHwcMD2EkRbQ+Ai1xESibQRS6CxYSTBYrwawK5oG8BfglgF1oE+iVsGpBiEeRAuzpwKkIdmF3It8BgQAwmYigCDIg2VUQsggyI4IKLEAMiushFZAOiTTUFKAL9mOwiF8EGTD7EWkS2g5MP+ekuyB2j5IKLIJsY+RBREX5R9iFN34LdebYhdluuAg0oPpSgCDag+JDEItxMtSHxO3gVYEDNLnIRZMDsQ6QuLpfNMAbk6fO023k+bhJjOfrYnnbHz+HheD4cNsN/28P5etCvj+3x+v+5PdmoOb07vtq/Ad/2h52ry6aeHdqnAvrMrmdDCnkCxKh3iNhGRA2shWFaZIII3jGgzUCwO1IYpiW2GHOlaBynARlis5Q0g0iRwmRHlGqo8B2DOtjB69qRgKUgEpI07dCZUqwPjJUA8Q0i3iFyBzdi6GDHXC0YcZyHdaNmLRF6FIMrFwMC043J7RsTZ3IqOtUiGVKzlLmYIqeRYTr/aynGaJYyFw8zcZwFZW33sJmcQkacnvyMiZtNbG4iiDDNBDGlBY/tbTEcQrOYGQSbpyPDtNbbQvHvGYh5YmDKixgpyMSwdrqMIVQZSosYlHBiEOEiBsfqKcMyT1mqp6zLPJVUPRVa5qnG6qnCMk9Vq6eal3maqXqaGZYwIEyPnGlcyECqjJtV/w8GzrRTgGkeADftw3j3jLl+GrK/7X4//CETtfoHyhwEalMO9nLehOhcF+I6E2KWBZ3Mb+mNraFpawr/bmuKHWxN0MHWhGvbqpnrU4NtWzukNfVIa+qR1rR6WhW0NrR2M6IOaaUeaaUeaaXV0yoc6nqVU9PWDmmlHmmlHmml1dPKGaqtwC1buUNauUdauUdaefW0MqT6hkbatLVDWrlHWrlHWnn1tBLVJYtyc8mSDmmVHmmVHmmV1dOatC5ZBM0lSzqkVXqkVXqkVVZPa4K6ZCVqLlnaIa3aI63aI626elqR6pKF2lyytENatUdatUdadfW0gtYlC2Nzycod0pp7pDX3SGtenNZH29q+7E933+YuTjvtt8+HXdl8Ox9fbkY///8YR8Zvex+n95fd6/m0c1L9wOffvn74ZwRb9B79+911k21THy9++d8=",
      "is_unconstrained": true,
      "name": "get_council_member"
    },
    {
      "abi": {
        "error_types": {
          "11891137193966797764": {
            "error_kind": "string",
            "string": "Function get_council_threshold can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAEAvCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWlBc5GpdODxDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4LGJT+Zej40f4lKdhvdj3V5vH6J4e4hTVzdN/X5sbueyr28tjz6Emh4OREFSOCsKJ4XnHgC33AUtRZj6PB4Ct14KUHoOAGPgRIE8BZBHEDkgFQPDAc8GrWLAXAwcGIjBc2QcpYi5HfuuqqbUNsmyhHvZVW0vinZoGik+y2Z4/ujjXrbPti87fqukqNoLtwy81k01RaNcZ6v0VCQf5tmoVVgAAH6HgDQCvLJ+ZnDs3AJxtGNgmkFojJkZHDtIMXJSPMQ0MCAkpegMQoNRix3gVkOd3THMC+yw/2uHRutmhCbjknb4jBQkG5WgsRsE7BDhBW6AeoEdOS0EFPMgoqQWwFeIoX8Wgw6XhQnphYFMnTq/aHEBdVJKrkzJ6sjgOPxVCjOSUnLlwSbGLEzw6TMsU6cYiJadH0jb5CGWS4QIl0yItP7Ftt2KsUolxWQQFklHTznelKnZe4qZMkVcpCBu7EDl9ozMcUqKnYxiVDAmaarJQXAtMoU+/XnJVaqxaybG2jQkLwc3crZfhx+QTL17Fze/DyuAPK/ugbvlue52F5ZxQnV1eWqquXsd2vPmbf91j2/ihefe3c7VZeiqibTeeoCfb4SS3GG6wkwdL7U6jNNffwM=",
      "is_unconstrained": true,
      "name": "get_council_threshold"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "342064996362527420": {
            "error_kind": "string",
            "string": "Function get_delegate can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "account",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZzRblw3Dobfxde+EClRlPIqi6JIU7cwYDiBmyywKPLuK1IkNU4xyqnP+CbzzW8fjkhRIqUJ/Pfd7w+/ffvz18fnPz7/dffhP3/f/fby+PT0+OevT58/ffz6+Pl5qH/fJfmnlbsP+f6u9bsPfH/Xx7syXpq+QMr2au8B7bXOVwR7tfd5mAQQoAGiFFFYYJiANoCyQQWH8TTKUzwURIFuIKNDeVzGp9CHZez3d5iSgyt1/E6uAzg7NIPmSnOlu9J5Qk7gUA0gOZCDfMQYRsbs0AyyK9mV4kphAwKHalCTAzn4R3BxEIM0oKEDG3RwoAlFwjKhONjjBbKDPV4QHKqBTFMewSyEDmxQXamusCtcDVpyIIduIKk1QZIp3d9RQodqIAFXkKiWkQBU5EcjP4mSQ3FoBjKwCWwgiVRIgAxkYBNc6a50U2pKDq6A2KkCZIDJIZRukIuDDGxMXC3oUA3UCwV5aiR/rdmBDXTwXaAayCqY0CdwsoAzJAcLOKMrWBxsClhSVMLLmQ0KOJCBjmdEnhvMYLJGTKEbyNqZYAFvCR3qDF2D5GDBbOgKupJdya4UVzRiI5iNkoMFvFVXanGwKWiy8CW8jdlAvVAgA8lDAoExTTQ87bLLKch0T6gGEjqSDVGWMI2BdVnCE8ihG0joJjQDWSAk26pMpYKMZ4Ir3ZVuCqQEQaHJ1ktZqTpJRI1KkHx20707B43B1yQkGWkUmjgySSJbSWl8RtXPlWw0Ck2cqKA0nuVZIbqTBNjINUglKDTZjozYCTGoOmUIkk8jpe5USlBoFBqFJpNjxE4yPUbVSXwzik+TrcJILGelZoSSPkbsJJlkVJ1ktoxKUHfKYSWHFZmtSeoHa6XNQc2JQ+PQWmhSLCZJqhlVoyybnhEFyadJ5mSdo0nsJEVjksxCS1rux0+bFn6p6kYU1J1kpEbNSapay0rVSUZq5FpJEBQahAahSQ417T0khyZJDhmFJnuNEQXJSGWmi7QpRuykvimxPFuVSlBzUo9m08NOUmWUSCI+CXxmCCHIZ4ZyaNlnhkoKKjYLJCV7ktRso+qk45M5oo4WcdKYCmnJMypBPjMVchBbdCtCkEe85tByaCW0EhqFpjGViNcKQT4zWgGNfGZqS0HFZqFKMzdJfZtUjVjyuXWlMatdYsBQnCRLjNhJotu1/5TeostIWZoLo+oks29UgrqTrLyuI5DZnyTjM3JNa6ZRaBAahCatZgcldpKIG1GQjEDyr0luGIkfkgdN8tkoNPVISSI+6oQiC+onSx47LrWrquY7O/YUapfS7yjngKR9O6aFS5Vtz1DaZY2+FttJkjFGFNTlERl2l7Fq0HvDoNC6OtUVqyFqcXWUcUASBJvSQSWoO2Fo2Jxk5EahFQyqThSWKazUeFY8aDoCKTxGFNSdpOUCOVqN0mI7LOoxbBKGprEFFJynsYkXqoQP5MO1ds6nSnOiHBRaxSB24tA4RtFSUFhuYaX7s1od1S0ECnJXUfLdiN1pLOQPUwpaWnf3UJpCx6VydqfRCw9iw6AYWg/NN0nUg6FRaJCCSpBbzuhWco5nxQNpJQd1Jwm2ETvpsRgU2TpLzBJPo9BmSkxsjiXlhRo+OeMW7R5V1O5RCSEoNEkZI3IqoZUS1JwoLFNYqfGseCCnCSwtB7GTLFAjzc+xDSCBHS4GNScMbaZEE8y4cKlFw9cVqz/lh8dB5FRDqyWoO3FoHKNoGBSWe1jp/qyWTXVLy+YkhCAK6u50LewPEwaFNlOiKdZAXiqTO611cj7VSlAMrYfW3S1OOSg0wCB3VQ+WRm5lniiVCttGjiyb9mhPFSlQ4u24VF4qX6g9UPLGsQVqDTJkx6Zbu9wSDaRALUeGS8Wl4oXaA7UyGbbAggs5kNYHyyownB6TYlnYA3VXMuRArbqGNbAvY7pYDMOYnmIdW+D0rSv2wFwWLrUstSxV7+sMObDiwhqoKWkoH5yTYg/U2TRkwzzrcEZB1F/Iihwou6gjLeyBOnRDcV7vxJKsJUcOrEutS+Wl8lLbUjX75v2gZp8hO0LChTUQYKEOnRV74PR4IgdmtdAE9QrVsCzU4XS9nMyBulMY1sDmUziQAzsuDBUTLKyBuoZ0shDKwhaIGDjHK7OJ1HxacEZ9Yg3U5W9YFsbE4kwYUoxpwY4LQ80JFy4VlgpLnVGvijGFOePCpRZYGBObKflkZSoLW+D0WFHXRQFFvRlHvSdOC1uglnVFPeeOOReULRfkZmxgC9TxGtZAnQBDWihBLXodrQlj2ALrUutSeam81LbUpnZlssoc+kR2JM0oQx1O05vwtFB8o6TYA3Gp6qah2JXeIuu5d0ZHD76OETOt8I5qTOZNq/gMCWlGTexL1bMCzct5WLhUHbrcrGW9F56PVR36xDVZs8ZP1IJiGFNYy1JLDEdPyo7rI2gZq8vC3KNQsQb2tLAslMdIlrQW9rnIGGHhUvX4IBeDAymwLFV3I7kHHBgrlikvjOWv18qOsa8z48KltjWcRgvXR/Qw1lJYaBDOz+JuWBa2wJlREodGsQXpFbNhXarmjno8a/dEXqquC41Da2tkLRyaJ2bDUHuChRH1DksFWhjO91Uh+6qQfdaL/P37/Z1/x/fr15eHB/mK7+JLv/FV4JePLw/PX+8+PH97erq/++/Hp2/6S399+fisr18/voyfDscenn8fr8PgH49PD0Lf79fT6fqjckaxp0ct6GFg9KqvTMB1E+MkWZvZkOsRDiOcX9nA6zayNPtmYzDDNRs7Vxr4MEbNgauulI2JojuXhWPcRa1h1Fc26AbhqO8bjnFQZDMxzod8NRxt4wpK9ZyejPPWhQl4ZaLfIBqQbhCOnS9ZbhTmOEbDcNUXwFs4k9/ZmXGsi4np1ycGNnnKLXwZJ7Ry1ZVdmo4y6DYG97OuDBtXXdmlxwiij4J6u76HbfJ0nK1yrPxx5KpXN7HdQEZPGiMZ/Wd5w7K9dGbc+F91Zrfyx0z4pj74Yu3T65jiJk3HIcHHMS70VjjGLehrG5vtdJy4cnFn0rgVvhpU2hnBlWTjSvd6edllKtU1Ehpf3181sncHL9y5rA4/GNnkewXflWvGMDA6kMOzywl8Vx58kWQ/zG7eGBnfYfnsji+xLmplp9c2dnWffBjjpn15wq97j7zZT5nXFjSue5aNgq9t7LZT8u1j3JauLKXXM5J3RR/6yvSLFugfNmgXT19wlNPbLPTIi4tI/Cs/cLVy+WJG/mFjtxsT+i44vqvkN9qoPWy0/jYbOYWNcZlw1UbZ5CcXzwwu9U0WevFC3eltYxj3TFHdUr0+r2Uzr6WBD6M0wou1+i/CWUqEk944rTkydGB7k41buAJRp8cXL+1tK4VjBx234tfXK6X3tTGu/cKXyu1tNpijrx193HUb+exK2Vk4tlJ2Fo6uFKqn02sbzr42no6bTXRXXKFSFFfGq8WV+jY1YlrH10RX26/jjcL1NrDC+Taw4g3awJpv0AbWcoM28CfuHGsDa90dJXscrTvkNzaC3GJ+4aJz+XF+2/lGsPazjSCn840gw9lGkPF8I8j5bCO4tXCoEdz6cbAR5Hq+EdzbONYIbm0cbAS5ny1vOwvHytvOwtHy1vB0eduH81gjuLdxrBHk+r6uHGwEtyvlYBPX2vvaONoIbm0cbAT76SNTP31k6jc4MvXzR6ZtOA82gtvierARlPX0vo3gZaNw4cwPjULv5xtBSOkGnSAkuEErOFLpBr3gzzw61gxCKu/dDV50+4BXrwW3NiCW7+CLdvDHRNntAMmrQ8c37iHVN4DOdHYX2ljYVvxDXmwtHPLiYNexsbA9lh/yYmvhkBcHrwY2FsrpjCqnM6qczqjt2kLMsbbwomGhH7+AvMG9PeDpi3vAG9zcA56+uge8wd094OnL+72JQ4e2vSsHT22AN7i//4mRY+e2vZGDBzfIp/vRrYljDenWxNGOFPL5lvQnMT12evuJkWPHt62Rm3hz8AC3XzUHT19Q0jsbOXqG2xs5eIjT/6J5ctWU0/f5WxOHV005f0+wj+nBk9y+8B48ykF570v9V21EvXqWA7rBrT7QLa71gW5xrw90i4v9fdYfajT3Jg51mkfX3s5EPt0x700ccyS/rWf+Zbz9+Onx5dXfuPkupl4eP/729GBv//j2/Onip1//98V/4n8j58vL508Pv397eRBL6w/ljH/+08ZSbLX9cn8H+jbzfSsob0HeMt035l++y2D+Dw==",
      "is_unconstrained": true,
      "name": "get_delegate"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "account",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_effective_votes"
    },
    {
      "abi": {
        "error_types": {
          "11805838585384935243": {
            "error_kind": "string",
            "string": "Function get_emergency_threshold can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAEEvCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWj1sOktXgfSzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4LGJT+Zej40f4lKdhvdj3V5vH6J4e4hTVzdN/X5sbueyr28tjz6Emh4OREFSOCsKJ4XnHgC33AUtRZj6PB4Ct14KUHoOAGPgRIE8BZBHEDkgFQPDAc8GrWLAXAwcGIjBc2QcpYi5HfuuqqbUNsmyhHvZVW0vinZoGik+y2Z4/ujjXrbPti87fqukqNoLtwy81k01RaNcZ6v0VCQf5tmoVVgAAH6HgDQCvLJ+ZnDs3AJxtGNgmkFojJkZHDtIMXJSPMQ0MCAkpegMQoNRix3gVkOd3THMC+yw/2uHRutmhCbjknb4jBQkG5WgsRsE7BDhBW6AeoEdOS0EFPMgoqQWwFeIoX8Wgw6XhQnphYFMnTq/aHEBdVJKrkzJ6sjgOPxVCjOSUnLlwSbGLEzw6TMsU6cYiJadH0jb5CGWS4QIl0yItP7Ftt2KsUolxWQQFrWLy2LRgFkgZu8pZsoUcZGCuLEDldszMscpKXYyilHBmKSpJgfBtcgU+vTnJVepxq6ZGGvTkLwc3MjZfh1+QDL17l3c/D6sAPK8ugfulue6211YxgnV1eWpqebudWjPm7f91z2+iReee3c7V5ehqybSeusBfr4RSnKH6QozdbzU6jBOf/0N",
      "is_unconstrained": true,
      "name": "get_emergency_threshold"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16651589314398098717": {
            "error_kind": "string",
            "string": "Function get_erc20_config can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "field"
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgEEACcCAgQAHwoAAQACAEQlAAAARSUAAABGLQIBRC0CAkUnAgMERCcCBAQCOw4ABAADJiUAAAC5HgIAAQAeAgACAB4CAAMAHgIABAAzKgADAAQABScCAwEBJAIABQAAAHklAAAA3x4CAAQJJAIABAAAAIslAAAA8ScCAwAdLwoAAwAEJwIDAB4vCgADAAUcCgUGBhwKBgMAHAoDBQYtCgQBLQoFAiYoAAAEBHhGDAAABAMkAAADAAAA3ioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEF5xZUQe5jlR08BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVbbbqMwEP0XP/PgmfE1v1JFEUlIhYRIRGGlVcS/7zgLBirZlVr6gs/Y8cmc4/HlKa7VeXg/1e3t/iEOb09x7uqmqd9Pzf1S9vW95d6nkOFjtThQIRwHlhuOAArhOQTFbYi5HyQxcAG4CYCZAII4IATAPYgMSM3AMwjTlZqAZmIKQ1pPwPB0UgGYCdhXzzgWYk731HdVFbJd5c+qHmVXtb04tEPTFOJP2QyvH308yvbV9mXHo7IQVXvllglvdVMFNBbLbJmeiuT8NBuV9JEAwG0oIE0BTho3cTC2NpJY2nBgmoNQaz1xMLaQ4shJcTCngR4hKUVlKBQvX7QD7GKoNRsOvYMd5nftUGjsRKFI26QdLiMFycxKUJsVBWwo/A5ugNzBjpwWAprzIKKkFsA9xNAvi0GLcWF8emEgU6fWRS3Wo0pKyZUpGTVzMPY/lcIcSSm58mAT5yy0d+kzLFOn6InizvekTPIQyyVChDETIqW+sW3XYoyUSTG5ne9d1MLYYiTRW08xU6aIUQriyg6UdsuROU5J+nDd/RcjvdZJU3WOBJcik+jS10uuUrVZMtHG2O8cqGylibZ6gKStbgdb/Q62ktzBVoIdbP1CDq7krC/dT5lQ7mj28arysBzv5HjbHDksL3W3eRyOgayry3NTTeFtaC+r0f7vYx6ZH5eP7n6prkNXBablhQn8feOrUsExPBs5UFgodRzDX/8D",
      "is_unconstrained": true,
      "name": "get_erc20_config"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17908124404890989986": {
            "error_kind": "string",
            "string": "Function get_governance_token can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABHLQIBRCcCAgREJwIDBAE7DgADAAInAEMEAyYlAAAFch4CAAEAHgIAAgAeAgADAB4CAAQAMyoAAwAEAAUnAgMBASQCAAUAAAB6JQAABZgeAgAECSQCAAQAAACMJQAABaonAgQAAC0IAQUnAgYEBAAIAQYBJwMFBAEAIgUCBi0KBgctDgQHACIHAgctDgQHACIHAgctDgQHKwIABgAAAAAAAAAAAgAAAAAAAAAALQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS0OBAkAIgkCCS0OBAkAIgkCCS0OBAkAIgkCCS0OBgktCAEGAAABAgEtDgUGLQgBBQAAAQIBLQ4HBS0IAQgAAAECAScCCQQALQ4JCC0IAQoAAAECAScCCwEALQ4LCicCDAAGJwINBAEkAgALAAABryMAAAFoLQgBAScCAgQEAAgBAgEnAwEEAQAiAQICLQoCDi0ODA4AIg4CDi0OBA4AIg4CDi0OBA4tDgEGLQ4HBS0ODQgtDgsKIwAAAjstCgkBIwAAAbgMIgFDAiQCAAIAAATsIwAAAcotCwYBLQsFAi0LCgQtCwIHACIHAgctDgcCLQgBBycCDgQFAAgBDgEnAwcEAQAiAgIOJwIPBAQAIgcCED8PAA4AEC0CAQMnAAQEBCUAAAW8LQgFAgAqAg0OLQ4MDi0OAgYtDgcFLQ4NCC0OBAojAAACOy0LBgEtCwUCLQsKBAoqBAsHJAIABwAAAl0nAgwEADwGDAEnAgQAECQCAAsAAAKkIwAAAm8nAgcEAi0CAQMnAAQEBCUAAAW8LQgFDAAqDAcOLQ4EDi0ODAYtDgIFLQ4HCC0OCwojAAADMC0KCQEjAAACrQwiAUMCJAIAAgAABGYjAAACvy0LBgEtCwUCLQsKBy0LAgwAIgwCDC0ODAItCAEMJwIOBAUACAEOAScDDAQBACICAg4nAg8EBAAiDAIQPw8ADgAQLQIBAycABAQEJQAABbwtCAUCACoCDQ4tDgQOLQ4CBi0ODAUtDg0ILQ4HCiMAAAMwLQsKAgoqAgsHJAIABwAAA0onAgwEADwGDAEtCgkBIwAAA1MMIgFDAiQCAAIAAAPgIwAAA2UtCwYBLQsFAi0LCActCwIJACIJAgktDgkCLQgBCScCCwQFAAgBCwEnAwkEAQAiAgILJwIMBAQAIgkCDj8PAAsADi0OAQYtDgkFLQ4HCC0OAwoAKgkNAi0LAgEeAgACADMqAAEAAgAFJAIABQAAA9klAAAGGy8KAAQAASYtCwYCLQsFBy0LCAktCwoLDCoBCQwkAgAMAAAEAiMAAARYACIHAg4AKg4BDy0LDwwAIgICDwAqDwEQLQsQDgAqDA4PLQIHAycABAQFJQAABbwtCAUMACIMAg4AKg4BEC0ODxAtDgIGLQ4MBS0OCQgtDgsKIwAABFgAKgENAi0KAgEjAAADUy0LBgItCwUHLQsIDC0LCg4MKgEMDyQCAA8AAASIIwAABN4AIgcCEAAqEAERLQsRDwAiAgIRACoRARItCxIQACoPEBEtAgcDJwAEBAUlAAAFvC0IBQ8AIg8CEAAqEAESLQ4REi0OAgYtDg8FLQ4MCC0ODgojAAAE3gAqAQ0CLQoCASMAAAKtLQsGAi0LBQQtCwgHLQsKDgwqAQcPJAIADwAABQ4jAAAFZAAiBAIQACoQAREtCxEPACICAhEAKhEBEi0LEhAAKg8QES0CBAMnAAQEBSUAAAW8LQgFDwAiDwIQACoQARItDhESLQ4CBi0ODwUtDgcILQ4OCiMAAAVkACoBDQItCgIBIwAAAbgoAAAEBHhFDAAABAMkAAADAAAFlyoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEF+IZwQ9MH9aI8BAIBJi0BAwYKAAYCByQAAAcAAAXSIwAABdstAAMFIwAABhotAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAGFS0BCggtBAgLAAAKAgoAAAsCCyMAAAXxJwEFBAEmKgEAAQVyMQyWM6ynPzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnbbhs5DIbfxde5EI+S8iqLokhTtwhgJIGbLLAo8u5LakSNHWCE1HFv4m84md8kReow/r37vv/2+vPrw+OPp1+7239+774dHw6Hh59fD0/3dy8PT49m/b1L/ifr7pZudgV2t9k+7ArgZlftEtg+/drskNigONQOkDsg7m4RHMyCaEDSge0ryG+xBNQOwgFh0bBoWDIF5A4FA7SDe7qAf4V9KYJ2wBQQtygsFBYOC3NA6SAUkDsoBsRXZAhwweRQOxQOKB0qBuQFKEFAf5wgBQxLFySkgC5IFBb1p9iBA2qHHJYclhKW5phDc6xBXoCbYw20Q3NMHDigdPACaNCSadXC4resNrhlrIF2yCmAA2qHYuFwcsgd3LEFukUSBoQFwgJh8UQxOOQOhAFhYQjQDmKOMTpwQOngUTTw4WZykIDaoTnPDqWD946DejIbtBFs0DOvhAE988ph4Z55FQiQJc/aWsZBKSB3KLIMQU60ZDV7ohoABEhAz3xGDihLDjNhQM9q5rBwWCQsEhYNi5YlqzljQM98LmEpPfO5QoAsec61LlA8igVyB+9uVgPvbvYpy7u7gbfDAqWDp46rT2smKOZY8SllgdzBZ74FpENNAZYW8S+tZYHq/iwQFggLhAXDgmEhr6jiUDq0ZDbQDl5+Qg4S4D6rz8HuhkVRPZlqjtWSAuyf1ca9tk7x/2lVV32iTmkQDzIHVJ1QlyAhEQwaNu9kXeZ9CZJh8w7RthhIjSeUBpWgPGyRbUg+/J2GrQ4PqgwKZUihAhDPgnvvZQ5AaRAPKkGeZ/XIQfu8YyRBedh8MspN2Rt6oTJs3tLZ1xioFE/U3laACQcNW/QaLKvRskwOG8qgGkQ0aKjweFYjSlQeFFGi10Un7fFi5Xi2xndQ4kGlx0Zev52GzSf0Fi9h+EIEg8Ir4mHjiIgkDVptwwOlQUM5D5XSnn17u9nFPuXry3G/923KycbFtjPPd8f948vu9vH1cLjZ/Xt3eG3/9Ov57rF9vtwd7a7Fsn/8bp8m+OPhsHd6u1mfTtuPIpXan7YtQh0CVgtnErAtASV5jzQN45yHSKYzDdzWIBSRrmGcYUtjFkqBcMN2ILAZCk8kGCSNdFjbrG7omYZcIR36d9PB6HNYk2CSvJmOMgkFSSMSFD2RgDOJeoVsQLpCOmax2AQQfth+cjMWwGsEQ385GJsJx8DU7YGBSZ3atiRiyRV5M5RZmdo2PDSM62dDMY3NUGblIT6HL15ILdtz2KROsRKNzrd9jG5OYjNHiHB4QsR8QdueBqMpbQYz6/zKfqRdWr8yrxmR85zipEyFMYZWmNdKxyTnGpPp1Db7MQWpubStMSlTW8tHPuzAvK0xqVPbXcfYWgevsRDjuUaetEte26WAbGuU2dhGqTOsBWbn73OFWZnaa4CoUjxZrt9r0KQ8BGPFF0qXKdQxrCeZ+KM4cN12UMJtLyYVCoIxqvaSJV+ooXVolHqZBqWhYa8stjUmFZo5KiOzXqRQORaVKpf5YEelMRMn3R5XmowrFwg3uMg6rlD/IJ3MI51y4bDSqFDDcpHGNUKBMe/YCa1c1ikZYg+GedKvLH9XA1RHLJrLZRo5jz2Y7Tm2NcpnO2Wm8LFOmSl8tFMEPl1e03TWdeKpuJ3O6RLNui7Rp0PybnkVvsK2WOQK2+J5NKgjGpHtaPKn98VSrrAv/vgGbLLxmWnIOPSIvcrd1NDZ8X5dqn2lWzX4/Eiss+N9qhSTuvHJyLw/E88OTgnXrCYs2wdrnm3BdPVEVDdFpjNIip6peOEcpDGB1CyfncUmCtMdw4eimCp8KIoP7lreK3yxy7v7h+PZT3lvLnV8uPt22PfLH6+P9yd3X/57jjvxU+Dz8el+//31uHel9fdA+/MPJbqxl4Bf/D2sXaJtru047Zfgd9Hvypc3d+Z/",
      "is_unconstrained": true,
      "name": "get_governance_token"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15875601676199201871": {
            "error_kind": "string",
            "string": "Function get_is_publicly_viewable can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAEQvCgADAAQcCgQFARwKBQMAHAoDBAEtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQXcUXecqXMMTzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4LEdn8y9Howf4lKdhvdj3V5vH6J4e4hTVzdN/X5sbueyr28tjz6Emh4OREFSOCsKJ4XnHgC33AUtRZj6PB4Ct14KUHoOAGPgRIG8BJBHEDkgFQPDAa8GrWLAXAwcGIjBc2QcpYi5HfuuqqbUNsmyhHvZVW0vinZoGik+y2Z4/ujjXrbPti87nlVSVO2FWwZe66aaolGuq1V6KZIP82rUKiwAAL9DQBoBXlk/Mzh2boE42jEwzSA0xswMjh2kGDkpHmIaGBCSUnQGocGoxQ5wq6HO7hjmBXbY/7VDo3UzQpNxSTt8RgqSjUrQ2A0CdojwAjdAvcCOnBYCinkQUVIL4CvE0D+LQYfLxoT0xkCmTp1ftLiAOiklV6ZkdWRwHP4qhRlJKbnyYBNjFib49BmWqVMMRMubH0jb5CGWS4QIl0yItP7Fa7sVY5VKiskgrFY6auHYrY6YvaeYKVPERQrixg5Ubs/IHKek2MkoRgVjkqaaHATXIlPo05+XXKUau2ZirE1D8nJwI2f7dfgBydS7hXgqW8IFQJ5398Dd8lx3uwvLOKG6ujw11dy9Du15M9t/3eNMvPDcu9u5ugxdNZHWWw/w841QkjtMV5ip46VWh3H6628=",
      "is_unconstrained": true,
      "name": "get_is_publicly_viewable"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4989124741311061979": {
            "error_kind": "string",
            "string": "Function get_late_quorum_extension can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAgvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVFPO6EyfVf2zwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4LGJT+Zej40f4lKdhvdj3V5vH6J4e4hTVzdN/X5sbueyr28tjz6Emh4OREFSOCsKJ4XnHgC33AUtRZj6PB4Ct14KUHoOAGPgRIE8BZBHEDkgFQPDAc8GrWLAXAwcGIjBc2QcpYi5HfuuqqbUNsmyhHvZVW0vinZoGik+y2Z4/ujjXrbPti87fqukqNoLtwy81k01RaNcZ6v0VCQf5tmoVVgAAH6HgDQCvLJ+ZnDs3AJxtGNgmkFojJkZHDtIMXJSPMQ0MCAkpegMQoNRix3gVkOd3THMC+yw/2uHRutmhCbjknb4jBQkG5WgsRsE7BDhBW6AeoEdOS0EFPMgoqQWwFeIoX8Wgw6XhQnphYFMnTq/aHEBdVJKrkzJ6sjgOPxVCjOSUnLlwSbGLEzw6TMsU6cYiJadH0jb5CGWS4QIl0yItP7Ftt2KsUolxeR2vg9Bx60f1KbYzd5TzJQp4iIFcWMHKrdnZI5TUuxkFKOCMUlTTQ6Ca5Ep9OnPS65SjV0zMdamIXk5uJGz/Tr8gGTPIR8ZfENYEeR5fQ/cLc91t7uyjBOsq8tTU83d69CeN2/7r3t8E6889+52ri5DV02k9d4D/HwjlOQO0yVm6nip1WGc/vob",
      "is_unconstrained": true,
      "name": "get_late_quorum_extension"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5227616292269356710": {
            "error_kind": "string",
            "string": "Function get_membership_mode can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDABsvCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVIjDlSGsJ2pjwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4LGJT+Zej40f4lKdhvdj3V5vH6J4e4hTVzdN/X5sbueyr28tjz6Emh4OREFSOCsKJ4XnHgC33AUtRZj6PB4Ct14KUHoOAGPgRIE8BZBHEDkgFQPDAc8GrWLAXAwcGIjBc2QcpYi5HfuuqqbUNsmyhHvZVW0vinZoGik+y2Z4/ujjXrbPti87fqukqNoLtwy81k01RaNcZ6v0VCQf5tmoVVgAAH6HgDQCvLJ+ZnDs3AJxtGNgmkFojJkZHDtIMXJSPMQ0MCAkpegMQoNRix3gVkOd3THMC+yw/2uHRutmhCbjknb4jBQkG5WgsRsE7BDhBW6AeoEdOS0EFPMgoqQWwFeIoX8Wgw6XhQnphYFMnTq/aHEBdVJKrkzJ6sjgOPxVCjOSUnLlwSbGLEzw6TMsU6cYiJadH0jb5CGWS4QIl0yItP7Ftt2KsUolxeR2fjA6VhjHbnXE7D3FTJkiLlIQN3agcntG5jglxU5GMSoYkzTV5CC4FplCn/685CrV2DUTY20akpeDGznbr8MPSKbevYtL48MKIM+re+Buea673YVlnFBdXZ6aau5eh/a8edt/3eObeOG5d7dzdRm6aiKttx7g5xuhJHeYrjBTx0utDuP0198=",
      "is_unconstrained": true,
      "name": "get_membership_mode"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8418147970250171169": {
            "error_kind": "string",
            "string": "Function get_name can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnbbhs5DIbfxde5EI+S8iqLokhTtwhgJIGbLLAo8u5LakSNHWCE1HFv4m84md8kReow/r37vv/2+vPrw+OPp1+7239+774dHw6Hh59fD0/3dy8PT49m/b1L/ifr7pZudgV2t9k+7ArgZlftEtg+/drskNigONQOkDsg7m4RHMyCaEDSge0ryG+xBNQOwgFh0bBoWDIF5A4FA7SDe7qAf4V9KYJ2wBQQtygsFBYOC3NA6SAUkDsoBsRXZAhwweRQOxQOKB0qBuQFKEFAf5wgBQxLFySkgC5IFBb1p9iBA2qHHJYclhKW5phDc6xBXoCbYw20Q3NMHDigdPACaNCSadXC4resNrhlrIF2yCmAA2qHYuFwcsgd3LEFukUSBoQFwgJh8UQxOOQOhAFhYQjQDmKOMTpwQOngUTTw4WZykIDaoTnPDqWD946DejIbtBFs0DOvhAE988ph4Z55FQiQJc/aWsZBKSB3KLIMQU60ZDV7ohoABEhAz3xGDihLDjNhQM9q5rBwWCQsEhYNi5YlqzljQM98LmEpPfO5QoAsec61LlA8igVyB+9uVgPvbvYpy7u7gbfDAqWDp46rT2smKOZY8SllgdzBZ74FpENNAZYW8S+tZYHq/iwQFggLhAXDgmEhr6jiUDq0ZDbQDl5+Qg4S4D6rz8HuhkVRPZlqjtWSAuyf1ca9tk7x/2lVV32iTmkQDzIHVJ1QlyAhEQwaNu9kXeZ9CZJh8w7RthhIjSeUBpWgPGyRbUg+/J2GrQ4PqgwKZUihAhDPgnvvZQ5AaRAPKkGeZ/XIQfu8YyRBedh8MspN2Rt6oTJs3tLZ1xioFE/U3laACQcNW/QaLKvRskwOG8qgGkQ0aKjweFYjSlQeFFGi10Un7fFi5Xi2xndQ4kGlx0Zev52GzSf0Fi9h+EIEg8Ir4mHjiIgkDVptwwOlQUM5D5XSnn17u9nFPuXry3G/923KycbFtjPPd8f948vu9vH1cLjZ/Xt3eG3/9Ov57rF9vtwd7a7Fsn/8bp8m+OPhsHd6u1mfTtuPIpXan7YtQh0CVgtnErAtASV5jzQN45yHSKYzDdzWIBSRrmGcYUtjFkqBcMN2ILAZCk8kGCSNdFjbrG7omYZcIR36d9PB6HNYk2CSvJmOMgkFSSMSFD2RgDOJeoVsQLpCOmax2AQQfth+cjMWwGsEQ385GJsJx8DU7YGBSZ3atiRiyRV5M5RZmdo2PDSM62dDMY3NUGblIT6HL15ILdtz2KROsRKNzrd9jG5OYjNHiHB4QsR8QdueBqMpbQYzk6iao/WN6zqry3lOcVKmwhhDK8xrpWOSc43JdGqb/fBD7Ti1rTEpU1vLRz7swLytMalT213H2FoHr7EQ47lGnrRLXtulgGxrlNnYRqkzrAVm5+9zhVmZ2muAqFI8Wa7fa9CkPARjxRdKlynUMawnmfijOHDddlDCbS8mFQqCMar2kiVfqKF1aJR6mQaloWGvLLY1JhWaOSojs16kUDkWlSqX+WBHpTETJ90eV5qMKxcIN7jIOq5Q/yCd/gqhp1MuHFYaFWpYLtK4Rigw5h07oZXLOiVD7MEwT/qV5e9qgOqIRXO5TCPnsQezPce2Rvlsp8wUPtYpM4WPdorAp8trms66TjwVt9M5XaJZ1yX6dEjeLa/CV9gWi1xhWzyPBnVEI7IdTf70vljKFfbFH9+ATTY+Mw0Zhx6xV7mbGjo73q9Lta90qwafH4l1drxPlWJSNz4Zmfdn4tnBKeGa1YRl+2DNsy2Yrp6I6qbIdAZJ0TMVL5yDNCaQmuWzs9hEYbpj+FAUU4UPRfHBXct7hS92eXf/cDz7Ke/NpY4Pd98O+3754/Xx/uTuy3/PcSd+Cnw+Pt3vv78e9660/h5of/6hRDf2EvCLv4e1S7TNtR2n/RL8Lvpd+fLmzvwP",
      "is_unconstrained": true,
      "name": "get_name"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6937048942020234009": {
            "error_kind": "string",
            "string": "Function get_past_votes can only be called statically"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "account",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_past_votes"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14397635560847713499": {
            "error_kind": "string",
            "string": "Function get_proposal can only be called statically"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "proposer",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "eta",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "start_block",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_block",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "canceled",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "executed",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "actions_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "description_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "target_count",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              },
              {
                "name": "proposal_type",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ],
            "kind": "struct",
            "path": "types::proposal::GovernorProposal"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_proposal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3905717565539885644": {
            "error_kind": "string",
            "string": "Function get_proposal_count can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAwvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQU2M+VutwIiTDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4LGJT+Zexo+HuFSn4f1Yt9fbhyjeHuLU1U1Tvx+b27ns61vLow+hpocDUZAUzorCSeG5B8Atd0FLEaY+j4fArZcClJ4DwBg4USBPAeQRRA5IxcBwwLNBqxgwFwMHBmLwHBlHKWJux76rqim1TbIs4V52VduLoh2aRorPshmeP/q4l+2z7cuO3yopqvbCLQOvdVNN0SjX2So9FcmHeTZqFRYAgN8hII0Ar6yfGRw7t0Ac7RiYZhAaY2YGxw5SjJwUDzENDAhJKTqD0GDUYge41VBndwzzAjvs/9qh0boZocm4pB0+IwXJRiVo7AYBO0R4gRugXmBHTgsBxTyIKKkF8BVi6J/FoMPlw4T0h4FMnTq/aHEBdVJKrkzJ6sjgOPxVCjOSUnLlwSbGLEzw6T0sU6cYiJaVH0jb5CaWS4QIl0yItP7Fst2KsUolxeQQwYW4bil4XB0xe08xU6aIixTEjR2o3J6R2U5JsZMxERWMSZpqchBci0yhTx8vuUo1ds3EWJuG5OXgRs72dPgBydW7pXjggt04Qp6/74G75bnudleWcYJ1dXlqqrl7Hdrz5m3/dY9v4pXn3t3O1WXoqom03nuAn2+EktxhusRMHS+1OozTX38D",
      "is_unconstrained": true,
      "name": "get_proposal_count"
    },
    {
      "abi": {
        "error_types": {
          "14586830951621773200": {
            "error_kind": "string",
            "string": "Function get_proposal_guardian can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDAAovCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQXKbtV3VhbHkDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZZNjqMwEIXv4rUXrir/cpVWFJGEtJAQiWgYaRRx9yla2MDCXkynN7hsxx/1HmXHL3FrLtPnue3vjy9RfbzEZWi7rv08d49rPbaPnkdfQi0PB6IiKZwVlZPCcw+AW+6CliIsfR4PgVsvBSi9BoAxcKJCXgLII4gckIqB4YBXg15G3DxLERM4j0PTLO/fZcR5Puuh6UdR9VPXSfGn7qbvH3096/67HeuBZ5UUTX/jloH3tmuWaJbbapVfiuTDuhq1CgkA4A8IyCPAK+tXBsfOJYijAwPzDEJjzMrg2EGOUZLiIaaBASErRRcQGoxKdoDbDHX2wDBvsMP+rh0arVsRmozL2uELUpBsVILG7hBwQIQ3uAHqDXaUtBBQzIOIsloA3yGGflkMOkwfJuQ/DBTq1PmkxQXUWSmlMiWrI4Pj8FMpzMhKKZUHmxizMMHnz7BCnWIgSjs/kLbZQ6yUCBGmTIi0/o9tuxdjlcqKKe38gImhA6lNizl6ioUyRUxSEHd2oHJHRuE4JcVORjEqGJM11ZQguBWZQp//eylVqrFbJsbaI+TEvfraDofrwLzQhra+dM3avU/9dTc7/n3GmXideA6Pa3ObhmYhbXcK4OcHBkn6tFwQuENGkjvNy6v/AQ==",
      "is_unconstrained": true,
      "name": "get_proposal_guardian"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6759925772054572743": {
            "error_kind": "string",
            "string": "Function get_proposal_threshold can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAUvCgADAAQcCgQFBhwKBQMAHAoDBAYtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVd0BSsj1IuxzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjqswDIbfJessYjvXvsqoqmhLR0iIVgwc6aji3Y+pSIAjJYuZzobYSfPVv+NcnuJan8fPU9Pd7l/i8PEU575p2+bz1N4v1dDcO+59CjV/HIgDSeGsODgpPHsA3LILWoow+9wfArdeClB6MQCj4cQBeQog9yCyQSoahg2eDVpFg7kY2DAQjVfPNEkRYzsNfV3PoW2CZQmPqq+7QRy6sW2l+FO14+tHX4+qe7VD1fOokqLurtwy8Na09WxNcp2t8lORfFhmo1YhAQD8DgF5BHhl/cJg27kEcbRjYJ5BaIxZGGw7yDFKUjzEMDAgZKXoAkKDUSkd4NaEOrtjmDekw/5uOjRatyA0GZdNhy9IQbJRCRq7QcAOEd6QDVBvSEdJCwHFOIgoqwXwHWLol8Wgw7QwIb8wUKhT55MWF1BnpZTKlKyODLbDT6UwIyulVB6cxBiFCT5/hhXqFANR2vmBtM0eYqVAiDBFQqT1N7btVoxVKiumtPO9Cjpufc83U4KYfU6xUKaISQriJh2o3J5ROE5JcSajGBWMySbVlCC4FplCn79eSpVq7BqJsTYPKcvBjZzt7fAfpFTvPqQzNcB6DpHn9T2yW12afvdkmWZY31Tntl7c29hdNqPD30cciU+eR3+/1Nexr2fS+u4B/n4QSnLH+REzO15qdZzmv/4H",
      "is_unconstrained": true,
      "name": "get_proposal_threshold"
    },
    {
      "abi": {
        "error_types": {
          "13971371060846917075": {
            "error_kind": "string",
            "string": "Function get_quorum_denominator can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAcvCgADAAQcCgQFBhwKBQMAHAoDBAYtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQXB5Ef00vP10zwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbfjqsgEMbfhWsumBn+9lU2TWNbuzExtnH1JCeN737GRlBPAhe73RsZsPw638eAPMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FGp+OBAHksJZcXBSeO4BcMtd0FKEuc/jIXDrpQCllwAwBk4ckKcA8ggiB6RiYDjg2aBVDJiLgQMDMXiNTJMUMbfT0Nf1nNomWZbwqPq6G8ShG9tWij9VO75+9PWoulc7VD2/VVLU3ZVbBt6atp6jSa6zVX4qkg/LbNQqJACA3yEgjwCvrF8YHDuXII52DMwzCI0xC4NjBzlGSYqHmAYGhKwUXUBoMCrZAW411Nkdw7zBDvu7dmi0bkFoMi5rhy9IQbJRCRq7QcAOEd7gBqg32FHSQkAxDyLKagF8hxj6ZTHoMC1MyC8MFOrU+aTFBdRZKaUyJasjg+PwUynMyEoplQebGLMwwefPsEKdYiBKOz+QttlDrJQIEaZMiLT+xrbdirFKZcWUdr4nG/et9lphgpi9p1goU8QkBXFjByq3ZxSOU1LsZBSjgjFZU00JgmuRKfT5z0upUo1dMzHW5iFlObiRs/06/Acp1bsP6UwNsJ5D5Hl9j9ytLk2/u7JMM6xvqnNbL93b2F02b4e/j/gmXnke/f1SX8e+nknrvQf4+UEoyR3nS8zc8VKr4zT/9T8=",
      "is_unconstrained": true,
      "name": "get_quorum_denominator"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "9496969216608950819": {
            "error_kind": "string",
            "string": "Function get_quorum_numerator can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAYvCgADAAQcCgQFBhwKBQMAHAoDBAYtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWDzAMvdsvaIzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbfjqsgEMbfhWsumBn+9lU2TWNbuzExtnH1JCeN737GRlBPAhe73Rv5wPLrfMOAPMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FGp+OBAHksJZcXBSeO4BcMtd0FKEuc/jIXDrpQClFwEYhRMH5CmAPILIglQUhgXPBq2iYC4GFgaieI1MkxQxttPQ1/Uc2iZYtvCo+robxKEb21aKP1U7vn709ai6VztUPb9VUtTdlVsG3pq2ntUk19kqPxXJh2U2ahUSAMDvEJBHgFfWLwzWziWIox0D8wxCY8zCYO0gxyhZ8RDDwICQtaILCA1GpXSAWxPq7I5h3pAO+7vp0GjdgtBkXDYdvmAFyUYnaOwGATtEeEM2QL0hHSUvBBTjIKKsF8B3mKFfNoMO08KE/MJAoU6dT15cQJ21UipTsjoyWIefWmFG1kqpPDiJMQoTfP4MK9QpBqK08wNpmz3ESoEQYYqESOtvbNutGatU1kxp53tMXljbNQyzzykWyhQxWUHcpAOV2zMKxykpzmQ0o4Ix2aSaEgTXIlPo85+XUqUau0ZirM1DynZwY2f7dfgPUqp3H9KZGmA9h8jz+h65W12afndlmWZY31Tntl66t7G7bN4Ofx/xTbzyPPr7pb6OfT2T1nsP8PODUJI7zpeYueOlVsdp/ut/",
      "is_unconstrained": true,
      "name": "get_quorum_numerator"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6026731864439116519": {
            "error_kind": "string",
            "string": "Function get_timelock_delay can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAkvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVTo0CzIGvS5zwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbfjqsgEMbfhWsumBn+9lU2TWNbuzExtnH1JCeN737GRlBPAhe73Rv5wPLrfMOAPMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FGp+OBAHksJZcXBSeO4BcMtd0FKEuc/jIXDrpQClFwEYhRMH5CmAPILIglQUhgXPBq2iYC4GFgaieI1MkxQxttPQ1/Uc2iZYtvCo+robxKEb21aKP1U7vn709ai6VztUPb9VUtTdlVsG3pq2ntUk19kqPxXJh2U2ahUSAMDvEJBHgFfWLwzWziWIox0D8wxCY8zCYO0gxyhZ8RDDwICQtaILCA1GpXSAWxPq7I5h3pAO+7vp0GjdgtBkXDYdvmAFyUYnaOwGATtEeEM2QL0hHSUvBBTjIKKsF8B3mKFfNoMO08KE/MJAoU6dT15cQJ21UipTsjoyWIefWmFG1kqpPDiJMQoTfP4MK9QpBqK08wNpmz3ESoEQYYqESOtvbNutGatU1kxp5wdIXlhbTBCzzykWyhQxWUHcpAOV2zMKxykpzmQ0o4Ix2aSaEgTXIlPo85+XUqUau0ZirM1DynZwY2f7dfgPUjyHfGTwDWFFkOf1PXK3ujT97soyzbC+qc5tvXRvY3fZvB3+PuKbeOV59PdLfR37eiat9x7g5wehJHecLzFzx0utjtP81/8A",
      "is_unconstrained": true,
      "name": "get_timelock_delay"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5366287459706263972": {
            "error_kind": "string",
            "string": "Function get_token_gate_address can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDABwvCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVKeOIDRmzZpDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjuMgEEX/hTULqoqnf6UVRU7itCxZTuS2RxpF/vcpWsaPBSym0xtT4HBc91IQXuLWXKbPc9vfH1+i+niJy9B2Xft57h7XemwfPY++hIoPB6IiKZwVlZPCcw+AW+6CliLEPo+HwK2XApReAsAUOFEhTwHkEUQOSKXAcMCzQccRN89SpATO49A08fu7jDjPZz00/Siqfuo6Kf7U3fT9o69n3X+3Yz3wWyVF09+4ZeC97ZoYzXKbrfJTkXxYZqNWYQUA+AMC8gjwyvqFwbFzK8TRgYF5BqExZmFw7CDHKEnxkNLAgJCVogsIDUatdoDbDHX2wDBvsMP+rh0arVsQmozL2uELUpBsUoLG7hBwQIQ3uAHqDXaUtBBQyoOIsloA3yGGflkMOlwXJuQXBgp16vyqxQXUWSmlMiWrE4Pj8FMpzMhKKZUHm5iyMMHnz7BCnWIgWnd+IG2zh1gpESJcMyHS+j+27V6MVSorprTzg/VpWXRwu7U1R0+xUKaIqxTEnR2o3JFROE5JsZNJjArGZE01JQhuRabQ5/9eSpVq7JaJsfYIOXGvvrbD4TowR9rQ1peuWbr3qb/u3o5/n+lNuk48h8e1uU1DE0nbnQL4+YFBkj7FCwJ3yEhypzl++h8=",
      "is_unconstrained": true,
      "name": "get_token_gate_address"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3257802692136877625": {
            "error_kind": "string",
            "string": "Function get_total_voting_power can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_total_voting_power"
    },
    {
      "abi": {
        "error_types": {
          "13064617634155564349": {
            "error_kind": "string",
            "string": "Function get_votes can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "account",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_votes"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6704778553435785618": {
            "error_kind": "string",
            "string": "Function get_voting_delay can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAMvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVdDCiSJzKJkjwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4GsTn8wdj40f4lKdhvdj3V5vH6J4e4hTVzdN/X5sbueyr28tjz6Emh4OREFSOCsKJ4XnHgC33AUtRZj6PB4Ct14KUHoWgFE4USBPAeQRRBakojAseDZoFQVzMbAwEMVzZByliLEd+66qptA2wbKFe9lVbS+KdmgaKT7LZnj+6ONets+2Lzt+q6So2gu3DLzWTTWpUa6zVXoqkg/zbNQqLAAAv0NAGgFeWT8zWDu3QBztGJhmEBpjZgZrBylGzoqHGAYGhKQVnUFoMGpJB7g1oc7uGOYF6bD/mw6N1s0ITcYl0+EzVpBsdILGbhCwQ4QXZAPUC9KR80JAMQ4iSnoBfIUZ+mcz6HBZmJBeGMjUqfOLFxdQJ63kypSsjgzW4a9WmJG0kisPTmKMwgSfPsMydYqBaNn5gbRNHmK5QIhwiYRI619s260Zq1TSTG7nO0+xwlhbs0DMPqeYKVPExQriJh2o3J6ROU5JcSajGRWMSSbV5CC4FplCn/685CrV2DUSY20akreDGzvbr8MPSPYc8pHBN4QVQZ7X98Dd8lx3uyvLOMG6ujw11dy9Du1587b/usc38cpz727n6jJ01URa7z3AzzdCSe4wXWKmjpdaHcbpr78B",
      "is_unconstrained": true,
      "name": "get_voting_delay"
    },
    {
      "abi": {
        "error_types": {
          "11721653196875790723": {
            "error_kind": "string",
            "string": "Function get_voting_period can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAQvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWiq616hBp5gzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLboMwEEX/xWsvPDN+8itVFJGEVEiIRBQqVRH/3iHCPCrZizbd4GsTn8wdj40f4lKdhvdj3V5vH6J4e4hTVzdN/X5sbueyr28tjz6Emh4OREFSOCsKJ4XnHgC33AUtRZj6PB4Ct14KUHoWgFE4USBPAeQRRBakojAseDZoFQVzMbAwEMVzZByliLEd+66qptA2wbKFe9lVbS+KdmgaKT7LZnj+6ONets+2Lzt+q6So2gu3DLzWTTWpUa6zVXoqkg/zbNQqLAAAv0NAGgFeWT8zWDu3QBztGJhmEBpjZgZrBylGzoqHGAYGhKQVnUFoMGpJB7g1oc7uGOYF6bD/mw6N1s0ITcYl0+EzVpBsdILGbhCwQ4QXZAPUC9KR80JAMQ4iSnoBfIUZ+mcz6HBZmJBeGMjUqfOLFxdQJ63kypSsjgzW4a9WmJG0kisPTmKMwgSfPsMydYqBaNn5gbRNHmK5QIhwiYRI619s260Zq1TSTG7nu2Ajg3XABWL2OcVMmSIuVhA36UDl9ozMcUqKMxnNqGBMMqkmB8G1yBT69OclV6nGrpEYa9OQvB3c2Nl+HX5AsueQjwy+IawI8ry+B+6W57rbXVnGCdbV5amp5u51aM+bt/3XPb6JV557dztXl6GrJtJ67wF+vhFKcofpEjN1vNTqME5//Q0=",
      "is_unconstrained": true,
      "name": "get_voting_period"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1940413677172494365": {
            "error_kind": "string",
            "string": "Function hash_proposal can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "actions_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "description_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZjdbuM4DIXfJde9kEjqr68yKIq0TQcBgrTItAssir77kooOnSzGBsbt3CSfj+0jUj+U4I/N0+7h/ef9/vj88mtz++Nj83DaHw77n/eHl8ft2/7lqOrHJthPzLy55Rv9r5vbov9Fr2M0UCGKQjXFbrWoUA3yGSgIoG1uSd+iqAqRAhGgDOAIyAMEikBJUFICtAEZzhYpJQUL9QxlQCUAlAalDYVDBKQBMQAE0AYQA0ajzASAocCwZ2GQYJhgmGBo3U3ZoAwoBIBSoVQo1vNnSGeQEAACaAMiA+oAIsAwFI6APEBgKGhCYJjQRIIhshBkIQWGBYbVDHVupFgGdJ8ObYBNJIPMDBgPZyEAlAQlQckRkAaUABDAaCtXNFHrgAbDNgxLiIARWOl5NYWqPhwUmi2YaFDPUAMDyoBIACgUAXkAB0ACtAEiACgJTSQ0mtFENkNdF9VyZ13KrYdh0MPokAf0MDpAYbzVw+jQBhQ8U/FWxTMNbzVXxlsx2IwcVEE2JwcVEJGTaxydMkiCkzlLpwrqPXMm17Jr2bXiWnGtulahxR5fMurxdepR5U4ZJK7ZgpFgZOt+kGlWRWM2jTqZZnlEGynprRXTehu2XAZVkE21QRqVWGsUyCmP1ihGJ9fINXLNClTqZHU2xU4NZAV2kPWGVXyy4pSoUwHZbBiUQc01mxCd2ErUoElrIKu1gyrIqu0g15icEAGLa4IIes1N3CmBsmt50hrISsQg16prNgpnslEYBE0COxWQjUKSTglEwWnSGojFyTVhpwKyyjfIteytWQE4U3GteGvVI6jeWvXWmms9N6MU2Mm1SE69tc/Pmw0OE/dvp93OzhIXpws9c7xuT7vj2+b2+H443Gz+2R7e+0O/XrfH/v+2PeldnY2745P+q+Hz/rAz+ryZ3g7zrxLXNt4m3f3cQFfQlUWct9BVl+vwUC7FTQpfedC8B+tZJQ0P5RLnPJZSqRFh6IklzqYiCxY664J3h5aYKYx85ZG+oTvy3+0OoVyGhXAqs91RF1IhK87nTCjlC4t4ZdG+oTdi+IbuWMqFIyMOZp7NJdJ3JMN/ORndU3xg2vzAxIV5WqrnUhrJbCpL05SzwEO5fTUV9ZhNZWl6aCciitTqfA1bmKfUmH3lN90SZ4vYUiC60XokzCIrlu1lMjmE2WQWLFLQ+jc8dCNKk0m67lNamKZE1asp08W4tGuLpWqaCBVIsa6yyAGrVo9WtMqi+MKnUsOsRVkaE/n9mPxJFM332brSomXxGVpknUXwKFpsayw4RuwJWlHTOosQ3CLyOotpRPRc/1ULWjkiVcgHNa20IJks4pwFl6WN3teIkMyuVF4owlMQVS7Wabk2WCifOWNS5JLWGBTPocSwzgBDUWg+gqVuZEp+Xsq8aiQ4tq9bxK9aiJ8vRGpeZZGaT6lMs3VCyuLa4Gliz04qqUv7x2SRssxaLB0/9SuHHy/0S8bFzKh/EAfLFEeei2N5mfuw6oqP6ypF8d20rit5+q1hiuJ/O8idXm0f96erz9uf5nXabx8Ou3H5/H58vLj79u8r7uDz+Ovp5XH39H7amdP0jVx/flAJNxr7nX0ssstUbyizXUa71O2Ncr77tGD+Aw==",
      "is_unconstrained": true,
      "name": "hash_proposal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1839173940655436289": {
            "error_kind": "string",
            "string": "Function is_council_member can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "addr",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEUlAAAARi0CAUUnAgIERScCAwQBOw4AAwACJiUAAAJFHgIAAwAeAgAEAB4CAAUAHgIABgAzKgAFAAYABycCBQEBJAIABwAAAHklAAACax4CAAYJJAIABgAAAIslAAACfScCBgA/LwoABgAHHAoHCAIcCggGABwKBgcCJwIGADMvCgAGAAgnAgYANC8KAAYACScCBgA1LwoABgAKJwIGADYvCgAGAAsnAgYANy8KAAYADCcCBgA4LwoABgANJwIGADkvCgAGAA4nAgYAOi8KAAYADycCBgA7LwoABgAQJwIGADwvCgAGABEnAgYAPS8KAAYAEicCBgA+LwoABgATLQgBBicCFAQNAAgBFAEnAwYEAQAiBgIULQoUFS0OCBUAIhUCFS0OCRUAIhUCFS0OChUAIhUCFS0OCxUAIhUCFS0ODBUAIhUCFS0ODRUAIhUCFS0ODhUAIhUCFS0ODxUAIhUCFS0OEBUAIhUCFS0OERUAIhUCFS0OEhUAIhUCFS0OExUtCAEIAAABAgEnAgkBAC0OCQgnAgkEACcCCgQMJwILBAEtCgkCIwAAAdYMKgIKAyQCAAMAAAHtIwAAAegtCwgBJhwKAgQCHAoEAwQcCgMEAgwqBAcDJAIAAwAAAg4jAAACNwAiBgIEACoEAgktCwkDCioDAQQkAgAEAAACLiMAAAI3LQ4FCCMAAAI3ACoCCwMtCgMCIwAAAdYoAAAEBHhGDAAABAMkAAADAAACaioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFGYYO9GTsMgE8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnfauM8EMXfxde5kEYz+pNXWUpJW3cJhLRkkw8+St59ZxqN7RQklnZ8Ux9L9bHm6Cc7WB/Dy/h0+f24P76+/Rm2vz6Gp9P+cNj/fjy8Pe/O+7cjt34MTv4kGrZhM2Q+SXzgM+83Q+FTj3yUc273LrDIInIVPlYBftiCF8EtACwCqigs5HLEKoiNoYigKqK2RBkJ39Mnp4INg3RlryINW5SuAip4PMhdICO8Cb4pcRd4rALYkKQLqIrAhlG6QqwC2TBKF6YqiA2TdFGuIrJhkq5YqpD0snRJfjfBhlm6ilfBhpk2Q3BeRazCa4vXFtAWGepNlCok1ZvIVWBQobcgUKGGUQ2jGkq8N6GGSW+R1TDrLYoaahWoVaBWgd6pIBXVEAFVVEMMoEINUVtkYMWxkLsXJgoLj6eAiHwT5IIKaWFwSagrnDzJnN6EtqAYsjNRNaSYRFyvm0FXwuP5NI6yEBZLgxfM++40Hs/D9ng5HDbDf7vD5fOf/rzvjp/H8+7EvTzY8fjCRzZ83R9GUdfNfLVrXwpB4Pi8GtCVycD7fGfh2xY+u5irB+uUJpMU7jyg7cGcEVUP1sm3PHqlZK/DgAK+WQp2LJgdN8XBT4B5GPHOgwziiOvGgRBTtcBAqRlH7pTCzyWtBCguLPydRTFIwzuDOHq1BB90HCGEZi0eLIoJKxcDCaaJKe2J8R1OU55qSQWwWUoP0xBRPViXn5bCHs1SenhwiDoKKrn9DOtwCiWEaeWXgLH5EOsNJASYRsIvSvzGsl0WE51rFtOxiBCzEhYh+bkWus8UOpgCTKUALOIAl+49Oo/T4Ir8gLoV4wpRM1TqmcAMmYPcfr30SKU4j4RibJv0y4FFOcu3wxeTDu856dTkMhvwL51/n91EcZ7dhcmX2Q3u57MbvMHsBjCY3RAMZrcbKz/cp1gztmMlg1ijRazJIta8eqwLWnObVjSgFS1oRQtacXVay4LW0qYVDWhFC1rRglZcndayoLW0aSUDWsmCVrKgldamNbiZ1uDatJIBrWRBK1nQSnn1WGkRa5vWaEBrtKA1WtAaV6fVL2j1bVqjAa3RgtZoQWtcnVa/oNW3aU0GtCYLWpMFrWl1WmFBK7RpTQa0JgtakwWtaXVaYUErLD5tfIk1G9CaLWjNFrTm1WkNLk2xBoRmrAa0ZgtaswWteXVa0eUpVt4JacXa94jz1GD+pgeU2SPEb3osakH6eS2LD7VfPEpv5aF+qUHeU5wdrtcHPtk97093+5hXcTrtd0+HsZ6+Xo7Pi97z/+/ao/ug76e35/HlchrFad4MlZ2sX54/3npwD7LHKafMPH+Pf7jK7f8C",
      "is_unconstrained": true,
      "name": "is_council_member"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "verified_balance",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "proof_nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "join_with_erc20_proof",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "balance_commitment",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "join_with_token_proof",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15596384838086695822": {
            "error_kind": "string",
            "string": "Function proposal_deadline can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_deadline"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3107034805524995561": {
            "error_kind": "string",
            "string": "Function proposal_eta can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_eta"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16563349372015579773": {
            "error_kind": "string",
            "string": "Function proposal_proposer can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_proposer"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15233556076734149416": {
            "error_kind": "string",
            "string": "Function proposal_snapshot can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_snapshot"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          },
          "8683601360157590068": {
            "error_kind": "string",
            "string": "Function proposal_state can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_state"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7356147743016370783": {
            "error_kind": "string",
            "string": "Function proposal_votes can only be called statically"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_votes"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "actions_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "description_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "target_count",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "proposal_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "propose",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16760049438223524684": {
            "error_kind": "string",
            "string": "not succeeded"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "queue"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14998324759555969432": {
            "error_kind": "string",
            "string": "Function quorum can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "quorum"
    },
    {
      "abi": {
        "error_types": {
          "14841998807667105483": {
            "error_kind": "string",
            "string": "member not found"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6131004256053116395": {
            "error_kind": "string",
            "string": "Function remove_council_member can only be called by the same contract"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "remove_council_member"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2109216859304865091": {
            "error_kind": "string",
            "string": "Function replace_council_member can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7200582709595251003": {
            "error_kind": "string",
            "string": "old member not found"
          }
        },
        "parameters": [
          {
            "name": "old_member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "new_member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABEcnAgMEAicCBAQAHwoAAwAEAEUtCEUBLQhGAiUAAABFJQAAAHAnAgEERycCAgQAOw4AAgABLAAAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACcARAQDJiUAAASQHgIABAAeAgAFAC0IAQYAAAECAScCBwAzLQ4HBi0IAQgAAAECAScCCQA0LQ4JCC0IAQoAAAECAScCCwA1LQ4LCi0IAQwAAAECAScCDQA2LQ4NDC0IAQ4AAAECAScCDwA3LQ4PDi0IARAAAAECAScCEQA4LQ4REC0IARIAAAECAScCEwA5LQ4TEi0IARQAAAECAScCFQA6LQ4VFC0IARYAAAECAScCFwA7LQ4XFi0IARgAAAECAScCGQA8LQ4ZGC0IARoAAAECAScCGwA9LQ4bGi0IARwAAAECAScCHQA+LQ4dHB4CAB4AHgIAHwAzKgAeAB8AICcCHgEBJAIAIAAAAXslAAAEth4CAB8BCiIfQyAWCiAhHAohIgAEKiIfIScCHwEACiogHyIkAgAiAAABricCIwQAPAYjAQoqIQUgJAIAIAAAAcAlAAAEyCcCBQA/LwoABQAgHAogIQIcCiEFABwKBSACLwoABwAFLwoACQAHLwoACwAJLwoADQALLwoADwANLwoAEQAPLwoAEwARLwoAFQATLwoAFwAVLwoAGQAXLwoAGwAZLwoAHQAbLQgBHScCIQQNAAgBIQEnAx0EAQAiHQIhLQohIi0OBSIAIiICIi0OByIAIiICIi0OCSIAIiICIi0OCyIAIiICIi0ODSIAIiICIi0ODyIAIiICIi0OESIAIiICIi0OEyIAIiICIi0OFSIAIiICIi0OFyIAIiICIi0OGSIAIiICIi0OGyItCAEFAAABAgEtDh0FLQgBBwAAAQIBLQ4fBycCCQQAJwILBAwnAg0EAS0KCQMjAAAC1wwqAwsEJAIABAAABBAjAAAC6S0LBwEkAgABAAAC+iUAAATaLQsGAS0LBQIAKgINBC0LBAMwCgADAAEtCwgBJwIDBAIAKgIDBS0LBQQwCgAEAAEtCwoBACICRAQtCwQDMAoAAwABLQsMAScCAwQEACoCAwUtCwUEMAoABAABLQsOAScCAwQFACoCAwUtCwUEMAoABAABLQsQAScCAwQGACoCAwUtCwUEMAoABAABLQsSAScCAwQHACoCAwUtCwUEMAoABAABLQsUAScCAwQIACoCAwUtCwUEMAoABAABLQsWAScCAwQJACoCAwUtCwUEMAoABAABLQsYAScCAwQKACoCAwUtCwUEMAoABAABLQsaAScCAwQLACoCAwUtCwUEMAoABAABLQscAQAqAgsELQsEAzAKAAMAASYcCgMJAhwKCQQEHAoECQIMKgkgBCQCAAQAAAQxIwAABIItCwUEACIEAg8AKg8DES0LEQkKKgkBDyQCAA8AAARVIwAABIItAgQDJwAEBA0lAAAE7C0IBQkAIgkCDwAqDwMRLQ4CES0OCQUtDh4HIwAABIIAKgMNBC0KBAMjAAAC1ygAAAQEeEcMAAAEAyQAAAMAAAS1KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQUdRXGO9SGtQzwEAgEmKgEAAQVj7ZvS9T6hOzwEAgEmLQEDBgoABgIHJAAABwAABQIjAAAFCy0AAwUjAAAFSi0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAVFLQEKCC0ECAsAAAoCCgAACwILIwAABSEnAQUEASY=",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "replace_council_member"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15633945201989994891": {
            "error_kind": "string",
            "string": "Function tally_fractional_internal can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16924088179346899272": {
            "error_kind": "string",
            "string": "no voting power"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2824004376206972765": {
            "error_kind": "string",
            "string": "voting not started"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7715731631402574514": {
            "error_kind": "string",
            "string": "proposal canceled"
          },
          "8841046534072300904": {
            "error_kind": "string",
            "string": "weights must equal total power"
          },
          "8927709774589806846": {
            "error_kind": "string",
            "string": "voting ended"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "for_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "against_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "abstain_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "voter",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "tally_fractional_internal"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14926441384389269437": {
            "error_kind": "string",
            "string": "invalid vote support"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16924088179346899272": {
            "error_kind": "string",
            "string": "no voting power"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2824004376206972765": {
            "error_kind": "string",
            "string": "voting not started"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4351000660496471192": {
            "error_kind": "string",
            "string": "Function tally_vote_internal can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7715731631402574514": {
            "error_kind": "string",
            "string": "proposal canceled"
          },
          "8927709774589806846": {
            "error_kind": "string",
            "string": "voting ended"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "support",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "voter",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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ISAtCw4kLQsiJS0LIyYMKgolJyQCACcAAEZwIwAARsYAIiQCKAAqKAopLQspJwAiIAIpACopCiotCyooAConKCktAiQDJwAEBAUlAABUwS0IBScAIicCKAAqKAoqLQ4pKi0OICEtDicOLQ4lIi0OJiMjAABGxgAqChsgLQogCiMAAD2LLQshJC0LDiUtCyImLQsjJwwqICYoJAIAKAAARvYjAABHTAAiJQIpACopICotCyooACIkAioAKiogKy0LKykAKigpKi0CJQMnAAQEBSUAAFTBLQgFKAAiKAIpACopICstDiorLQ4kIS0OKA4tDiYiLQ4nIyMAAEdMACogGyQtCiQgIwAAPKAtCyAfLQsNIy0LISQtCyIlDCoKJCYkAgAmAABHfCMAAEfSACIjAicAKicKKC0LKCYAIh8CKAAqKAopLQspJwAqJicoLQIjAycABAQFJQAAVMEtCAUmACImAicAKicKKS0OKCktDh8gLQ4mDS0OJCEtDiUiIwAAR9IAKgobHy0KHwojAAA6/S0LIB8tCw0jLQshJC0LIiUMKgokJiQCACYAAEgCIwAASFgAIiMCJwAqJwooLQsoJgAiHwIoACooCiktCyknAComJygtAiMDJwAEBAUlAABUwS0IBSYAIiYCJwAqJwopLQ4oKS0OHyAtDiYNLQ4kIS0OJSIjAABIWAAqChsfLQofCiMAADpXLQsgIy0LDSQtCyElLQsiJgwqHyUnJAIAJwAASIgjAABI3gAiJAIoACooHyktCyknACIjAikAKikfKi0LKigAKicoKS0CJAMnAAQEBSUAAFTBLQgFJwAiJwIoACooHyotDikqLQ4jIC0OJw0tDiUhLQ4mIiMAAEjeACofGyMtCiMfIwAAOWwtCyAfLQsLIy0LISQtCyIlDCoKJCYkAgAmAABJDiMAAElkACIjAicAKicKKC0LKCYAIh8CKAAqKAopLQspJwAqJicoLQIjAycABAQFJQAAVMEtCAUmACImAicAKicKKS0OKCktDh8gLQ4mCy0OJCEtDiUiIwAASWQAKgobHy0KHwojAAA30i0LIB8tCwsjLQshJC0LIiUMKgokJiQCACYAAEmUIwAASeoAIiMCJwAqJwooLQsoJgAiHwIoACooCiktCyknAComJygtAiMDJwAEBAUlAABUwS0IBSYAIiYCJwAqJwopLQ4o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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "tally_vote_internal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "364683654084256882": {
            "error_kind": "string",
            "string": "Function update_council_threshold can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5069332423914220509": {
            "error_kind": "string",
            "string": "threshold exceeds council size"
          },
          "6257422783282464658": {
            "error_kind": "string",
            "string": "threshold must be positive"
          }
        },
        "parameters": [
          {
            "name": "new_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREAi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAT0eAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAFjHgIABQEKIgVDBhYKBgccCgcIAAQqCAUHJwIFAQAKKgYFCCQCAAgAAADSJwIJBAA8BgkBCioHAwYkAgAGAAAA5CUAAAF1JwIDAD8vCgADAAYcCgYHAhwKBwMAHAoDBgIMKgYBAwoqAwUGJAIABgAAARUlAAABhycCAwIADCoDAQUkAgAFAAABLCUAAAGZHAoBAwAnAgEAQDAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABYioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFBQ+d2ekVZHI8BAIBJioBAAEFRlni+yfG6908BAIBJioBAAEFVtbU3j78x5I8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVdbbuMwDLyLv/MhkhIp5SqLonBTtzBgOIGbLLAocvelGsmPAtKi3fQnHtPRmEOOHn5vnruny+tjP74c35r9r/fmaeqHoX99HI6H9twfR42+Nyb+AFCzp51efbMXvaLeA0SgAbAKKEbiIwsKfAScgLMZhGaPqIA1gnEUhwSE0iPxCfgY4Qh8AiFF0EAGnABomigRuARihjegw0kJMWZ4A/pS0peitRnkSEyVXAQhAc4RwQxEQXypxwxyJLgbIKP5WBOBRqxWjmKGlq7XXZPL+3ieui5Wd1Vv7cKpnbrx3OzHyzDsmt/tcPn409upHT+u53bSp8rdjc96VcKXfugiuu6W0aY8FMmHNBqtCTOBNndDAWUK8IZ94lAsMpMIbTiwzEHonEscigVKHDUpHnIaGBCKUmyFwoIzczlAloIKbzjcHcrBP1sOiyyJwpKTYjl8RQpG/96UoOMVBWwowh2qAeYO5ahpIaCcBxEVtQDeQwz9sBhdgObGhHJjoOJT8bMWCWiLUmo2JbaZQ3H4XynKUZRStYeVuaCM5TWs4lNd7CF7XbHl0szHSiIQZPFHEOHiSgg1NYy4yKGyyepyGGY5Dqgop+ZUm31qARct7lt9kfKCjDWXcp6163Ja/FYOvry/VSjYuLmWisNiMLe1KFZsjohzP3DlLjSy5ag0lUyI55KbGBOcKzmDagUxuMxZo6eVIknNo46XTBxzecuvy8GVnPVm+ymTike9ZI/6sBCQ/0J3GZbu8mpncPAFDu9mDjH4LQ6xtHBIKHGQVFwmIXPoaSgUXUa+NmOIeZ4yVF7EqNJbkdxZWTnsc1v+kQaGJQ1X3Ftszad6hJu1gLiiT23tbOqWzij2263yQe/aQz9tPpSukW3q26ehS7cvl/Gwenr+c8pP8ofWaToeuufL1EWm1deW/v5ydufCQ/zk0hsOO4GHa3z1Xw==",
      "is_unconstrained": true,
      "name": "update_council_threshold"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2923981031069933752": {
            "error_kind": "string",
            "string": "Function update_late_quorum_extension can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_extension",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBC0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEACDAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFKJQRQX7nYLg8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVZbjuIwELxLvvORfthtc5URQgHCKFIUUAZWWiHuvu1ZOyHS2tLOMD9xuY2Lrnb5ca+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgX6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19asdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JlA67yigDwFuMa6yKFYZCYRWnFgnoPQGBM5FAvkOEpSHKQ00CNkpXCBgsE0czlAloKKXXGYF5TD/mw5GK1ECiYj2XK4ghQkm5SgsU8UsKLwL6gGNC8oR0kLAaU8iCirBfAVYuiHxaDgvDA+vzBQ8Km4WYt45KyUkk3JcuJQ7L8rRTmyUor2YJkLajF/hhV8ioYheV0x29zOx0Ii4GXxhxex2ZMQSmos4iKH8iYry7EwyzFAWTklp3LyKQMuWsyX1kXyBzKWXGrTrn0uJ+OXcnD5+61E4cTNG9Y5NEsl1hbFgs1RfBKi99SSBzay5vAlLWTtLIby9qKSR9HRv44OVfY/iaBfEjHZfU+lK1+v11kNiMn6nEoWNcJJjmK3Psa22msP/bR6Tz4C29S3+6GL3dNtPDyNXn9f0kh6j16m86E73qYuMD09SvX7xlCz3YaXaehIzX77CH/9Bw==",
      "is_unconstrained": true,
      "name": "update_late_quorum_extension"
    },
    {
      "abi": {
        "error_types": {
          "1211138418200096620": {
            "error_kind": "string",
            "string": "Function update_proposal_guardian can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_guardian",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEElAAAAZycCAQRFJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJiUAAADrHgIAAgAeAgADAB4CAAQAHgIABQAzKgAEAAUABicCBAEBJAIABgAAAJolAAABER4CAAQBCiIEQwUWCgUGHAoGBwAEKgcEBicCBAEACioFBAckAgAHAAAAzScCCAQAPAYIAQoqBgMEJAIABAAAAN8lAAABIycCAwAKMAoAAQADJigAAAQEeEUMAAAEAyQAAAMAAAEQKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQUQztP5dqUvbDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tZZNjuMgEIXvwtoLqgooyFVGUeQkTsuS5UTueKRR5LtP0WP8s4BFT3oTP0N45iueMS91bc7jx6ntb/dPdfj1Uueh7br249TdL/WzvffS+lI6/oD26kCVAiB14HiVewARKA1googtsYucCC/CQBJhFtaoA2IU0oJxlDNJ+LmLKYnY4kR4SiK1BPdPoIYkrAh5OoJOws8izpAwisiA01SpBHh6Dk0T+TbEUodHPTT9Ux36sesq9bvuxq8/fT7q/uv6rAfp1ZVq+qtcxfDWdk1UU7WO1vmhSD7Mo9HosBhIWXcWkLcAr52fPUQzLyZMOw/MexBaa2cP0Qw5jxKKhzQNDAhZFFOwMGD1Ug7gtaDsdh72DeVwP1sOg45nC0OWs+XwBRQkl0jQuo0F7CzCG6oB+g3lKLEQUJoHEWVZAN8BQz8Mg4zLwoT8wkAhp+wXFg5osiilmJIzyUN0+F8U8ciiFONheCmow/weVsgpWgMp66KNy735WJgIBF7zEZhddieEEo1DXHEoH7IyjoMFxwJlcUpJNSmnBnBlsd9aF85vyFhKqUtv7bacBr81B5//vpUsfHDLgvgQ/FqJfUSxEHPkkEDkO7XOAzXvPUKJhTAsMGSzrxuVaOSrloIu2mbjRaWMWjYJR7Tf7x5Huasv7bA7vU3RbWjrc9fMt7exv2x6n38eqSed/h7D/dJcx6GJTtsjoJyNKFTGHOP5T24kqIaPU3z0Xw==",
      "is_unconstrained": true,
      "name": "update_proposal_guardian"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2456261804207466482": {
            "error_kind": "string",
            "string": "Function update_proposal_threshold can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEABTAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFIhZlGNslZ/I8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVbLjuIwEPyXnHNIP+y2+ZURQgHCKFIUUAZWWiH+fduzdkIOtjQzzCUut3HR1S4/7tWx29/ed/14On9Um7d7tZ/6Yejfd8P50F7786jRe9WEDwBVG6q1ddVGtEXtAwSgAWAFFCJhiEGBC8BGYDgBX20QFViNYJhlfQRCcUhcBC5EbAAuAh8j2EACNgLQNFECMBGEDP8DnU6aKoYMiQMIEX486iop3V2nrgtCn6RrQS7t1I3XajPehqGu/rTD7fNHH5d2/Gyv7aSjTV1141FbJTz1QxfQo15mN/mpmoqPs5EbPxNonVcUkKcA11gXORSLzCRCKw7McxAaYyKHYoEcR0mKg5QGeoSsFC5QMJhmLgfIUlCxKw7zgnLY3y0Ho5VIwWQkWw5XkIJkkxI09okCVhT+BdWA5gXlKGkhoJQHEWW1AL5CDP2yGBScF8bnFwYKPhU3axGPnJVSsilZThyK/U+lKEdWStEeLHNBLebPsIJP0TAkrytmm9v5WEgEvCz+8CI2exJCSY1FXORQ3mRlORZmOQYoK6fkVE4+ZcBFi/nWukj+QMaSS23atc/lZPxWDi5/v5UoHDXJGop5qaVZWxQLNkfxSYjeU0se2Miaw5e0kJ0TQcrbi0oeFW+WI8zNFOTcVxJBvyRisvueSle+Xq+zGhCT9TmVLGqEU10Vu/UxttVee+in1XvyEdimvt0PXeyebuPhafT695JG0nv0Mp0P3fE2dYHp6VGq3zeGmu02vExDR2r220f4638=",
      "is_unconstrained": true,
      "name": "update_proposal_threshold"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7929560158224637595": {
            "error_kind": "string",
            "string": "Function update_quorum_numerator can only be called by the same contract"
          },
          "9481540185426775687": {
            "error_kind": "string",
            "string": "numerator exceeds denominator"
          }
        },
        "parameters": [
          {
            "name": "new_numerator",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAASYeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAFMHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwUkAgAFAAAA5CUAAAFeJwIDAAcvCgADAAUcCgUGBhwKBgMAHAoDBQYMKgUBAwoqAwQFJAIABQAAARUlAAABcBwKAQMAJwIBAAYwCgADAAEmKAAABAR4RQwAAAQDJAAAAwAAAUsqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBW4LdPOIEd6bPAQCASYqAQABBYOVMpAz9E6HPAQCASY=",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVdBbuMwDPyLzzmYpERK+UpRFG7qFgYMJ3CTBRZF/r5UI8n2AtKi2/QSj6VozKHGpPzRvPTPl7enYXo9vjf7h4/meR7GcXh7Go+H7jwcJx39aNrwA0DNnnZ6dc1e9Ip6DxCADoBRQGEkTBlQ4ALgCKxJwDd7RAWsIxhWsY9AKE6Ji8CFEQ7AReDjCLaQAEcAGiZKADaCEOEN6HJSQgwR3oA+lPShaEwCaSSESjYAHwGnEcEERIFX4HTEBEInAVyvuyal7uk8933I3CqXmuFTN/fTudlPl3HcNb+68fL5p/dTN31ez92ss+2u6acXvSrh6zD2AV13y+q2vBTJ+bgaTeszgW7chgLKFOBadpFDsUgmEdpwYJmD0FobORQLlDhqUhykMNAjFKWYCoUB2+Z0gCwJFd5w2Dukg382HQZZIoUhK8V0uIoUJE5K0PKKAjYU/g7ZgPYO6ahpIaAUBxEVtQDeQwz9sBgtLnljfHljoOJTcVmLeDRFKTWbEpvEodh/V4pyFKVU7WEkJ5SxXMMqPtVCDsnrig2X3nysBAJeFn94ES5WQqipYcRFDpVNVpfDkOVYoKKcmlNN8qkBXLTY/9oXKRdkrLmU01u7Tudn7/x6DK7c32oUzvjUFMjZdSa2FsWKzREx7weu3IWtbDkqm0qtD2eOWyCtt7bkDKqpaXF5Z1s9iRRJah61vERimcstvy4HV3LWzfavSKhWkn1uUX5lc3Jf2F+bja5YqLS/VQ6G7DPHFkscVCmnKD6ZXc8yvugRkprfiTkbnsoliGo1Wbxd2pwrJvUfgaBfArHF3mBqadUjWFYDYos+M1WziqFsVnHbVveod91hmDcfMdfANg/d89jH29fLdFjNnn+f0kz6CDrNx0P/cpn7wLT6EtLfBz1UWvsYPof0hnHH5vEaHv0H",
      "is_unconstrained": true,
      "name": "update_quorum_numerator"
    },
    {
      "abi": {
        "error_types": {
          "14822583465815270620": {
            "error_kind": "string",
            "string": "Function update_timelock_delay can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBC0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEACTAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFzbRlIPV/ZNw8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVZbjuIwELxLvvORfthtc5URQgHCKFIUUAZWWiHuvu1ZOyHS2tLOMD9xuY2Lrnb5ca+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgX6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19asdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JlA67yigDwFuMa6yKFYZCYRWnFgnoPQGBM5FAvkOEpSHKQ00CNkpXCBgsE0czlAloKKXXGYF5TD/mw5GK1ECiYj2XK4ghQkm5SgsU8UsKLwL6gGNC8oR0kLAaU8iCirBfAVYuiHxaDgvDA+vzBQ8Km4WYt45KyUkk3JcuJQ7L8rRTmyUor2YJkLajF/hhV8ioYheV0x29zOx0Ii4GXxhxex2ZMQSmos4iKH8iYry7EwyzFAWTklp3LyKQMuWsyX1kXyBzKWXGrTrn0uJ+OXcnD5+61E4QHSHanYLAYza4tiweYoPgnRe2rJAxtZc/iSFrJ2FkN5e1HJo+joX0cHOfc/iaBfEjHZfU+lK1+v11kNiMn6nEoWNcJJjmK3Psa22msP/bR6Tz4C29S3+6GL3dNtPDyNXn9f0kh6j16m86E73qYuMD09SvX7xlCz3YaXaehIzX77CH/9Bw==",
      "is_unconstrained": true,
      "name": "update_timelock_delay"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2123312137687235394": {
            "error_kind": "string",
            "string": "Function update_visibility can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "is_publicly_viewable",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREAS0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEARDAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFHXeFI7Ife0I8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVZdj+ogEP0vPPehMwMM+Fc2xlStmyZNNV29yY3xv99hL1D7AMnuui/lMMhxznD4uKtjv7+974bpdP5Qm7e72s/DOA7vu/F86K7DeZLoXbXhA0BqQ420Tm1YWpQ+QAASAC2AQiQMaRDgArARGJ2AVxtEAVYiGGZZHwFTHGIXgQsRG4CLwMcItpCAjQAkTeQATAQhw/9AppOkiiFD0gGEiH48GpWU7q5z3wehT9KlIJdu7qer2ky3cWzUn268ff7o49JNn+21m2W0bVQ/HaUVwtMw9gE9mmV2W54qqfg4G3XrM4HUeUUBZQpwrXWRQzBzJmFacWCZg9AYEzkEM5Q4alIcpDTQIxSl6AqFBtPmcgAvBWW74jAvKIf93XJotBwpNBkulsNVpCDZpASNfaKAFYV/QTWgfUE5aloIKOVBREUtgK8QQ78sBhnzwvjywkDFp+yyFvaoi1JqNiWrE4dg/1MpwlGUUrWH5lxQi+UzrOJTNBqS1wVrW9r5WEkEPC/+8My2eBJCTY1FXORQ2WR1ORayHANUlFNzqk4+1YCLFvOtdeHygYw1l9q0a5/LqfFbObjy/Vaj8MjZ5Z5gWRCztihWbI7skxC5p5Y8sOU1h69pIWuzGCrbiypqDKRFNegyATn3lTTQL2mY4q6n2oUvl2vWAmyKLqeaQQ3rVFXBbn2IbaXXHYZ59Zp8BLZ56PZjH7un23R4Gr3+vaSR9Bq9zOdDf7zNfWB6epLK901Do+02vEtDhxvtt4/w1/8A",
      "is_unconstrained": true,
      "name": "update_visibility"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4461576865508125763": {
            "error_kind": "string",
            "string": "Function update_voting_delay can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBC0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEAAzAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFPeq0hU62bEM8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVZbjuIwELxLvvORfthtc5URQgHCKFIUUAZWWiHuvu1ZOyHS2tLOMD9xuY2Lrnb5ca+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgX6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19asdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JlA67yigDwFuMa6yKFYZCYRWnFgnoPQGBM5FAvkOEpSHKQ00CNkpXCBgsE0czlAloKKXXGYF5TD/mw5GK1ECiYj2XK4ghQkm5SgsU8UsKLwL6gGNC8oR0kLAaU8iCirBfAVYuiHxaDgvDA+vzBQ8Km4WYt45KyUkk3JcuJQ7L8rRTmyUor2YJkLajF/hhV8ioYheV0x29zOx0Ii4GXxhxex2ZMQSmos4iKH8iYry7EwyzFAWTklp3LyKQMuWsyX1kXyBzKWXGrTrn0uJ+OXcnD5+61EId7PHK5Bt1RibVEs2BzFJyF6Ty15YCNrDl/SQtbOYihvLyp5FB396+gg5/4nEfRLIia776l05ev1OqsBMVmfU8miRjjJUezWx9hWe+2hn1bvyUdgm/p2P3Sxe7qNh6fR6+9LGknv0ct0PnTH29QFpqdHqX7fGGq22/AyDR2p2W8f4a//AA==",
      "is_unconstrained": true,
      "name": "update_voting_delay"
    },
    {
      "abi": {
        "error_types": {
          "14445691148362705718": {
            "error_kind": "string",
            "string": "Function update_voting_period can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_period",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBC0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEABDAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFyHlnkBkp6zY8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVZbjuIwELxLvvORfthtc5URQgHCKFIUUAZWWiHuvu1ZOyHS2tLOMD9xuY2Lrnb5ca+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgX6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19asdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JlA67yigDwFuMa6yKFYZCYRWnFgnoPQGBM5FAvkOEpSHKQ00CNkpXCBgsE0czlAloKKXXGYF5TD/mw5GK1ECiYj2XK4ghQkm5SgsU8UsKLwL6gGNC8oR0kLAaU8iCirBfAVYuiHxaDgvDA+vzBQ8Km4WYt45KyUkk3JcuJQ7L8rRTmyUor2YJkLajF/hhV8ioYheV0x29zOx0Ii4GXxhxex2ZMQSmos4iKH8iYry7EwyzFAWTklp3LyKQMuWsyX1kXyBzKWXGrTrn0uJ+OXcnD5+61E4fQhkTicPg+WSqwtigWbo/gkRO+pJQ9sZM3hS1rIzokg5e1FJY+io38dHeTc/ySCfknEZPc9la58vV5nNSAm63MqWdQIJzmK3foY22qvPfTT6j35CGxT3+6HLnZPt/HwNHr9fUkj6T16mc6H7nibusD09CjV7xtDzXYbXqahIzX77SP89R8=",
      "is_unconstrained": true,
      "name": "update_voting_period"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6504742485148360234": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "10581129473648605397": {
            "error_kind": "string",
            "string": "Function create_proposal_internal can only be called by the same contract"
          },
          "10807032649822229906": {
            "error_kind": "string",
            "string": "not aztec-token mode"
          },
          "10958896161817881596": {
            "error_kind": "string",
            "string": "insufficient balance"
          },
          "11721653196875790723": {
            "error_kind": "string",
            "string": "Function get_voting_period can only be called statically"
          },
          "11805838585384935243": {
            "error_kind": "string",
            "string": "Function get_emergency_threshold can only be called statically"
          },
          "11835668458991423142": {
            "error_kind": "string",
            "string": "below proposal threshold"
          },
          "11891137193966797764": {
            "error_kind": "string",
            "string": "Function get_council_threshold can only be called statically"
          },
          "1211138418200096620": {
            "error_kind": "string",
            "string": "Function update_proposal_guardian can only be called by the same contract"
          },
          "12164607307181823186": {
            "error_kind": "string",
            "string": "cannot cancel"
          },
          "12510611782093430208": {
            "error_kind": "string",
            "string": "not a council member"
          },
          "13064617634155564349": {
            "error_kind": "string",
            "string": "Function get_votes can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13770014322479677326": {
            "error_kind": "string",
            "string": "Function get_council_member can only be called statically"
          },
          "13971371060846917075": {
            "error_kind": "string",
            "string": "Function get_quorum_denominator can only be called statically"
          },
          "14397635560847713499": {
            "error_kind": "string",
            "string": "Function get_proposal can only be called statically"
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14445691148362705718": {
            "error_kind": "string",
            "string": "Function update_voting_period can only be called by the same contract"
          },
          "14487322055111218121": {
            "error_kind": "string",
            "string": "Function get_cloak_mode can only be called statically"
          },
          "14586830951621773200": {
            "error_kind": "string",
            "string": "Function get_proposal_guardian can only be called statically"
          },
          "14822583465815270620": {
            "error_kind": "string",
            "string": "Function update_timelock_delay can only be called by the same contract"
          },
          "14841998807667105483": {
            "error_kind": "string",
            "string": "member not found"
          },
          "14926441384389269437": {
            "error_kind": "string",
            "string": "invalid vote support"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14998324759555969432": {
            "error_kind": "string",
            "string": "Function quorum can only be called statically"
          },
          "15233556076734149416": {
            "error_kind": "string",
            "string": "Function proposal_snapshot can only be called statically"
          },
          "15312957078770032001": {
            "error_kind": "string",
            "string": "insufficient emergency approvals"
          },
          "15596384838086695822": {
            "error_kind": "string",
            "string": "Function proposal_deadline can only be called statically"
          },
          "15633945201989994891": {
            "error_kind": "string",
            "string": "Function tally_fractional_internal can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15875601676199201871": {
            "error_kind": "string",
            "string": "Function get_is_publicly_viewable can only be called statically"
          },
          "16238081572903391961": {
            "error_kind": "string",
            "string": "insufficient council approvals to cancel"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16563349372015579773": {
            "error_kind": "string",
            "string": "Function proposal_proposer can only be called statically"
          },
          "16651589314398098717": {
            "error_kind": "string",
            "string": "Function get_erc20_config can only be called statically"
          },
          "16760049438223524684": {
            "error_kind": "string",
            "string": "not succeeded"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "16924088179346899272": {
            "error_kind": "string",
            "string": "no voting power"
          },
          "17278438487631839627": {
            "error_kind": "string",
            "string": "Function add_council_member can only be called by the same contract"
          },
          "17625130927896797776": {
            "error_kind": "string",
            "string": "council full"
          },
          "17908124404890989986": {
            "error_kind": "string",
            "string": "Function get_governance_token can only be called statically"
          },
          "1839173940655436289": {
            "error_kind": "string",
            "string": "Function is_council_member can only be called statically"
          },
          "1940413677172494365": {
            "error_kind": "string",
            "string": "Function hash_proposal can only be called statically"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2109216859304865091": {
            "error_kind": "string",
            "string": "Function replace_council_member can only be called by the same contract"
          },
          "2123312137687235394": {
            "error_kind": "string",
            "string": "Function update_visibility can only be called by the same contract"
          },
          "2456261804207466482": {
            "error_kind": "string",
            "string": "Function update_proposal_threshold can only be called by the same contract"
          },
          "2514106658851063029": {
            "error_kind": "string",
            "string": "council approval not available in this mode"
          },
          "2547213599764567162": {
            "error_kind": "string",
            "string": "emergency execute only in hybrid mode"
          },
          "2633295041654830480": {
            "error_kind": "string",
            "string": "Function delegate_internal can only be called by the same contract"
          },
          "2824004376206972765": {
            "error_kind": "string",
            "string": "voting not started"
          },
          "2923981031069933752": {
            "error_kind": "string",
            "string": "Function update_late_quorum_extension can only be called by the same contract"
          },
          "3107034805524995561": {
            "error_kind": "string",
            "string": "Function proposal_eta can only be called statically"
          },
          "3257802692136877625": {
            "error_kind": "string",
            "string": "Function get_total_voting_power can only be called statically"
          },
          "342064996362527420": {
            "error_kind": "string",
            "string": "Function get_delegate can only be called statically"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "364683654084256882": {
            "error_kind": "string",
            "string": "Function update_council_threshold can only be called by the same contract"
          },
          "3905717565539885644": {
            "error_kind": "string",
            "string": "Function get_proposal_count can only be called statically"
          },
          "3975253606477278659": {
            "error_kind": "string",
            "string": "Function add_member_internal can only be called by the same contract"
          },
          "4351000660496471192": {
            "error_kind": "string",
            "string": "Function tally_vote_internal can only be called by the same contract"
          },
          "4422981737823726437": {
            "error_kind": "string",
            "string": "timelock not elapsed"
          },
          "4461576865508125763": {
            "error_kind": "string",
            "string": "Function update_voting_delay can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4756330914173469558": {
            "error_kind": "string",
            "string": "emergency cancel only in hybrid mode"
          },
          "4989124741311061979": {
            "error_kind": "string",
            "string": "Function get_late_quorum_extension can only be called statically"
          },
          "5069332423914220509": {
            "error_kind": "string",
            "string": "threshold exceeds council size"
          },
          "5227616292269356710": {
            "error_kind": "string",
            "string": "Function get_membership_mode can only be called statically"
          },
          "5366287459706263972": {
            "error_kind": "string",
            "string": "Function get_token_gate_address can only be called statically"
          },
          "5836097838366868111": {
            "error_kind": "string",
            "string": "not erc20-token mode"
          },
          "5846850200630327512": {
            "error_kind": "string",
            "string": "not queued"
          },
          "5874306019897513529": {
            "error_kind": "string",
            "string": "Function get_council_approval_count can only be called statically"
          },
          "6026731864439116519": {
            "error_kind": "string",
            "string": "Function get_timelock_delay can only be called statically"
          },
          "6131004256053116395": {
            "error_kind": "string",
            "string": "Function remove_council_member can only be called by the same contract"
          },
          "6257422783282464658": {
            "error_kind": "string",
            "string": "threshold must be positive"
          },
          "6704778553435785618": {
            "error_kind": "string",
            "string": "Function get_voting_delay can only be called statically"
          },
          "6759925772054572743": {
            "error_kind": "string",
            "string": "Function get_proposal_threshold can only be called statically"
          },
          "6937048942020234009": {
            "error_kind": "string",
            "string": "Function get_past_votes can only be called statically"
          },
          "7200582709595251003": {
            "error_kind": "string",
            "string": "old member not found"
          },
          "7220720865510965904": {
            "error_kind": "string",
            "string": "nullifier already used"
          },
          "7356147743016370783": {
            "error_kind": "string",
            "string": "Function proposal_votes can only be called statically"
          },
          "7715731631402574514": {
            "error_kind": "string",
            "string": "proposal canceled"
          },
          "7929560158224637595": {
            "error_kind": "string",
            "string": "Function update_quorum_numerator can only be called by the same contract"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8288633154968149222": {
            "error_kind": "string",
            "string": "Function add_erc20_member_internal can only be called by the same contract"
          },
          "8398157739290454474": {
            "error_kind": "string",
            "string": "closed cloak: caller must be a member"
          },
          "8418147970250171169": {
            "error_kind": "string",
            "string": "Function get_name can only be called statically"
          },
          "8683601360157590068": {
            "error_kind": "string",
            "string": "Function proposal_state can only be called statically"
          },
          "8717548249808531313": {
            "error_kind": "string",
            "string": "already approved"
          },
          "8799882153436241657": {
            "error_kind": "string",
            "string": "Function get_council_count can only be called statically"
          },
          "8841046534072300904": {
            "error_kind": "string",
            "string": "weights must equal total power"
          },
          "8927709774589806846": {
            "error_kind": "string",
            "string": "voting ended"
          },
          "900405183110375111": {
            "error_kind": "string",
            "string": "already executed"
          },
          "9481540185426775687": {
            "error_kind": "string",
            "string": "numerator exceeds denominator"
          },
          "9496969216608950819": {
            "error_kind": "string",
            "string": "Function get_quorum_numerator can only be called statically"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6504742485148360234": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "governor_bravo_cloak.GovernorBravoCloak",
  "noir_version": "1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "GovernorBravoCloak"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_delay",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_period",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "quorum_numerator",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "quorum_denominator",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "late_quorum_extension",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timelock_delay",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_guardian",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_for_votes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_against_votes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_abstain_votes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "governance_token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply_snapshot",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_power",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "delegated_power",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "delegates",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_voting_power",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_power_checkpoints",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "latest_checkpoint_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "membership_mode",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_gate_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "erc20_token_address_hash",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "erc20_min_balance",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "used_nullifiers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_membership",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_proposals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_voting",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_treasury",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_identity",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_delegation",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000025"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_execution",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000026"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_quorum",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000027"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000028"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_guardian",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000029"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_timelock",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_fractional",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_late_quorum",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_storage",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timelock_proposer",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timelock_executor",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timelock_canceller",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000030"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "cloak_mode",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000031"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_0",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000033"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000034"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000035"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000036"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000037"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000038"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000039"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000040"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "emergency_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000041"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_approvals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000042"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_approval_counts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000043"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "is_publicly_viewable",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000044"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::add_council_member_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::add_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_verified_balance",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_proof_nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::add_erc20_member_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::add_erc20_member_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_balance_commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::add_member_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::add_member_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::cancel_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::cancel_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_for_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_against_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_abstain_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::cast_fractional_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::cast_fractional_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_support",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::cast_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::cast_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_support",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "__reason_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::cast_vote_with_reason_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::cast_vote_with_reason_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "_governance_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_voting_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_voting_period",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_proposal_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_quorum_numerator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_quorum_denominator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_late_quorum_extension",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_timelock_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_proposal_guardian",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_membership_mode",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_token_gate_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_erc20_token_address_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_erc20_min_balance",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_cloak_mode",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_council_members",
                    "type": {
                      "kind": "array",
                      "length": 12,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "_council_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_council_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_emergency_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_is_publicly_viewable",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::council_approve_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::council_approve_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposer",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_actions_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_description_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_target_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::create_proposal_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::create_proposal_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_delegatee",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::delegate_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::delegate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_delegator",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_delegatee",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::delegate_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::delegate_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::emergency_cancel_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::emergency_cancel_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::emergency_execute_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::emergency_execute_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::execute_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::execute_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_cloak_mode_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_cloak_mode_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_approval_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_approval_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_index",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_member_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_account",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_delegate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_delegate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_account",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_effective_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_effective_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_emergency_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_emergency_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_erc20_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "field"
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_erc20_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_governance_token_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_governance_token_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_is_publicly_viewable_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_is_publicly_viewable_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_late_quorum_extension_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_late_quorum_extension_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_membership_mode_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_membership_mode_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_account",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_past_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_past_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "proposer",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "eta",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "start_block",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_block",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "canceled",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "executed",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "actions_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "description_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "target_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::proposal::GovernorProposal"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_guardian_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_guardian_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_quorum_denominator_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_quorum_denominator_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_quorum_numerator_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_quorum_numerator_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_timelock_delay_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_timelock_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_token_gate_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_token_gate_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_total_voting_power_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_total_voting_power_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_account",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_voting_delay_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_voting_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_voting_period_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_voting_period_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_actions_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_description_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::hash_proposal_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::hash_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_addr",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::is_council_member_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::is_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_verified_balance",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_proof_nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::join_with_erc20_proof_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::join_with_erc20_proof_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_balance_commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::join_with_token_proof_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::join_with_token_proof_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_deadline_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_deadline_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_eta_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_eta_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_proposer_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_proposer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_snapshot_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_snapshot_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_state_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_caller",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_actions_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_description_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_target_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::propose_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::propose_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::queue_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::queue_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::quorum_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::quorum_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::remove_council_member_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::remove_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_old_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_new_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::replace_council_member_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::replace_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_for_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_against_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_abstain_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_voter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::tally_fractional_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::tally_fractional_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_support",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_voter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::tally_vote_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::tally_vote_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_council_threshold_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_council_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_extension",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_late_quorum_extension_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_late_quorum_extension_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_guardian",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_proposal_guardian_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_proposal_guardian_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_proposal_threshold_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_proposal_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_numerator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_quorum_numerator_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_quorum_numerator_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_timelock_delay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_timelock_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_is_publicly_viewable",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_visibility_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_visibility_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_voting_delay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_voting_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_period",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_voting_period_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_voting_period_abi"
        }
      ]
    }
  },
  "transpiled": true
}
