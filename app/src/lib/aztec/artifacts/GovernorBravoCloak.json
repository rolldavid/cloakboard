{
  "file_map": {
    "101": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "103": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "120": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "124": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "126": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/calls_generation/external_functions_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, serialized_args_array_len_quote, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n    let serialized_args_array_len: u32 =\n        unquote!(quote { ($serialized_args_array_len_quote) as u32 });\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        serialized_args_array_len, fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\npub(crate) comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::UtilityCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::UtilityCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\n// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf and EnqueueSelfStatic structs\n\n// Note: Unlike for the call registry, the self-call registry stubs directly perform the call instead of returning a\n// call interface struct.\n// TODO(F-131): This ^ is confusing and should be reflected in the naming.\n\n/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private\n/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).\npub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let args_hash = aztec::hash::hash_args($serialized_args_array_name);\n            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);\n            let returns_hash = self.context.call_private_function_with_args_hash(\n                self.address,\n                selector,\n                args_hash,\n                $is_static\n            );\n            returns_hash.get_preimage()\n        }\n    }\n}\n\n// TODO(F-131): Drop the use of the Call in the following 4 functions - it doesn't make sense to not not\n// perform the call directly using the context. I tried doing this already but it became a lot of pain due to the use of\n// slices and them being illegal to return from unconstrained functions. Makes sense to tackle this when cleaning up the\n// call interface code.\n// Note: Once we get rid of the structs we will be able to merge some of the static and non-static stub functions.\n\n/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)\npub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).call(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)\npub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicStaticCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).view(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicStaticCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue_view(self.context);\n        }\n    }\n}\n\n/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue(self.context);\n        }\n    }\n}\n"
    },
    "129": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr",
      "source": "use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "132": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "138": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/private.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, create_message_discovery_call, get_abi_relevant_attributes,\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, fn_has_nophasecheck, is_fn_initializer,\n        is_fn_only_self, is_fn_view, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn generate_private_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n\n    let original_params_quotes = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    let params = quote { inputs: aztec::context::inputs::private_context_inputs::PrivateContextInputs, $original_params_quotes };\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let storage_init = if module_has_storage {\n        // Contract has Storage defined so we initialize it.\n        quote {\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            $args_serialization\n            let args_hash = aztec::hash::hash_args($serialized_args_name);\n            let mut context = aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<&mut aztec::context::private_context::PrivateContext> = CallSelf { address: self_address, context: &mut context };\n            let enqueue_self: EnqueueSelf<&mut aztec::context::private_context::PrivateContext> = EnqueueSelf { address: self_address, context: &mut context };\n            let call_self_static: CallSelfStatic<&mut aztec::context::private_context::PrivateContext> = CallSelfStatic { address: self_address, context: &mut context };\n            let enqueue_self_static: EnqueueSelfStatic<&mut aztec::context::private_context::PrivateContext> = EnqueueSelfStatic { address: self_address, context: &mut context };\n            let internal: CallInternal<&mut aztec::context::private_context::PrivateContext> = CallInternal { context: &mut context };\n            aztec::contract_self::ContractSelf::new_private(&mut context, storage, call_self, enqueue_self, call_self_static, enqueue_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(*self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Phase checks are skipped in functions that request to manually handle phases\n    let initial_phase_store = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote { let within_revertible_phase: bool = self.context.in_revertible_phase(); }\n    };\n\n    let no_phase_change_check = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote {   \n            assert_eq(\n                within_revertible_phase,\n                self.context.in_revertible_phase(),\n                f\"Phase change detected on function with phase check. If this is expected, use #[nophasecheck]\",\n            ); \n        }\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            self.context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { self.context.finish() };\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $initial_phase_store\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let body_quote = body.map(|expr| expr.quoted()).join(quote { });\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $no_phase_change_check\n        $context_finish\n    };\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n        $abi_relevant_attributes\n        fn $fn_name($params) -> return_data aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n            $to_prepend\n            $body_quote\n            $to_append\n        }\n    }\n}\n"
    },
    "139": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n"
    },
    "149": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "150": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "151": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n"
    },
    "152": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "153": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n"
    },
    "154": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "156": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "173": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "193": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "194": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "195": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "196": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "197": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "202": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "203": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "205": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "207": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            owner,\n            storage_slot,\n            randomness,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _owner: AztecAddress,\n    _storage_slot: Field,\n    _randomness: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _owner: Option<AztecAddress>,\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    owner: Option<AztecAddress>,\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            owner,\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "210": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "212": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "216": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "226": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::state_variable::StateVariable,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> StateVariable<M + 1, Context> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "228": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "253": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "256": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "257": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "259": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "260": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "263": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "267": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "274": {
      "path": "/Users/rolldavid/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "294": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "353": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "363": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "376": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "377": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "378": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "379": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "386": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "391": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "407": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "409": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "410": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "415": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "419": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "432": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "437": {
      "path": "/Users/rolldavid/Documents/Projects/priv_ideas/private-dao/contracts/governor_bravo/src/governor_bravo_cloak.nr",
      "source": "/// Governor Bravo Cloak Contract -- Full Privacy Implementation\n///\n/// Implements all OpenZeppelin Governor features with full privacy on Aztec:\n/// - GovernorCore: propose, execute, cancel, castVote, state machine\n/// - GovernorSettings: governance-updatable votingDelay, votingPeriod, proposalThreshold\n/// - GovernorVotes + GovernorVotesQuorumFraction: dynamic quorum as fraction of total supply\n/// - GovernorCountingSimple: For/Against/Abstain with private voting\n/// - GovernorCountingFractional: split voting power across choices\n/// - GovernorTimelockControl: timelock queue/execute\n/// - GovernorStorage: on-chain proposal detail storage\n/// - GovernorPreventLateQuorum: extend deadline if quorum reached late\n/// - GovernorProposalGuardian: designated guardian can cancel proposals\n/// - Multi-target proposals: batched protocol upgrades\n/// - Private delegation: delegate voting power without revealing relationships\n///\n/// Privacy Architecture:\n/// - Private token gating (token-only, no admin invite)\n/// - Private proposal threshold proof (ZK range proof)\n/// - Fully private voting (nullifier-based, voter identity never stored)\n///\n/// NOTE: All helper function logic has been inlined at call sites because\n/// Aztec Noir v3 contract functions annotated with #[external(\"public\")] or\n/// #[internal(\"public\")] return PublicCall<...> objects that cannot be used\n/// synchronously from other contract functions.\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract GovernorBravoCloak {\n    use dep::aztec::{\n        keys::getters::get_public_keys,\n        macros::{functions::{initializer, external, view, only_self, internal}, storage::storage},\n        protocol_types::{address::AztecAddress, traits::{Hash, ToField, FromField}},\n        state_vars::{Map, PublicMutable, PublicImmutable},\n    };\n    use dep::compressed_string::FieldCompressedString;\n    use crate::types::proposal::GovernorProposal;\n\n    // ===== PROPOSAL STATES (Governor Bravo / OZ compatible) =====\n    global STATE_PENDING: u8 = 0;\n    global STATE_ACTIVE: u8 = 1;\n    global STATE_CANCELED: u8 = 2;\n    global STATE_DEFEATED: u8 = 3;\n    global STATE_SUCCEEDED: u8 = 4;\n    global STATE_QUEUED: u8 = 5;\n    global STATE_EXPIRED: u8 = 6;\n    global STATE_EXECUTED: u8 = 7;\n\n    // ===== VOTE SUPPORT =====\n    global VOTE_AGAINST: u8 = 0;\n    global VOTE_FOR: u8 = 1;\n    global VOTE_ABSTAIN: u8 = 2;\n\n    // ===== STORAGE =====\n\n    #[storage]\n    struct Storage<Context> {\n        // ===== CONFIGURATION (immutable after init or governance-updatable) =====\n        name: PublicImmutable<FieldCompressedString, Context>,\n\n        // GovernorSettings (updatable via governance only)\n        voting_delay: PublicMutable<u32, Context>,\n        voting_period: PublicMutable<u32, Context>,\n        proposal_threshold: PublicMutable<u128, Context>,\n\n        // GovernorVotesQuorumFraction\n        quorum_numerator: PublicMutable<u128, Context>,\n        quorum_denominator: PublicMutable<u128, Context>,\n\n        // GovernorPreventLateQuorum\n        late_quorum_extension: PublicMutable<u32, Context>,\n\n        // GovernorTimelockControl\n        timelock_delay: PublicMutable<u32, Context>,\n\n        // GovernorProposalGuardian\n        proposal_guardian: PublicMutable<AztecAddress, Context>,\n\n        // ===== PROPOSALS (GovernorStorage) =====\n        proposals: Map<Field, PublicMutable<GovernorProposal, Context>, Context>,\n        proposal_count: PublicMutable<u64, Context>,\n\n        // Vote tallies (public aggregates only -- voter identity never stored)\n        proposal_for_votes: Map<Field, PublicMutable<u128, Context>, Context>,\n        proposal_against_votes: Map<Field, PublicMutable<u128, Context>, Context>,\n        proposal_abstain_votes: Map<Field, PublicMutable<u128, Context>, Context>,\n\n        // ===== TOKEN / VOTING POWER =====\n        governance_token: PublicImmutable<AztecAddress, Context>,\n        token_address: PublicImmutable<AztecAddress, Context>,\n        total_supply_snapshot: Map<Field, PublicMutable<u128, Context>, Context>,\n\n        // Voting power (private state managed via token proofs)\n        voting_power: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        delegated_power: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        delegates: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        total_voting_power: PublicMutable<u128, Context>,\n\n        // Checkpoint: account -> block -> voting power at that block\n        voting_power_checkpoints: Map<AztecAddress, Map<Field, PublicMutable<u128, Context>, Context>, Context>,\n        // Track latest checkpoint block per account (for writes)\n        latest_checkpoint_block: Map<AztecAddress, PublicMutable<u32, Context>, Context>,\n\n        // ===== TOKEN GATING (token-only, no admin invite) =====\n        // mode: 0 = aztec-token, 1 = erc20-token\n        membership_mode: PublicMutable<u8, Context>,\n        token_gate_address: PublicMutable<AztecAddress, Context>,\n        erc20_token_address_hash: PublicMutable<Field, Context>,\n        erc20_min_balance: PublicMutable<u128, Context>,\n        used_nullifiers: Map<Field, PublicMutable<bool, Context>, Context>,\n\n        // ===== PRIVACY CONFIG =====\n        privacy_membership: PublicMutable<u8, Context>,\n        privacy_proposals: PublicMutable<u8, Context>,\n        privacy_voting: PublicMutable<u8, Context>,\n        privacy_treasury: PublicMutable<u8, Context>,\n        privacy_identity: PublicMutable<u8, Context>,\n        privacy_delegation: PublicMutable<u8, Context>,\n        privacy_execution: PublicMutable<u8, Context>,\n        privacy_quorum: PublicMutable<u8, Context>,\n        privacy_threshold: PublicMutable<u8, Context>,\n        privacy_guardian: PublicMutable<u8, Context>,\n        privacy_timelock: PublicMutable<u8, Context>,\n        privacy_fractional: PublicMutable<u8, Context>,\n        privacy_late_quorum: PublicMutable<u8, Context>,\n        privacy_storage: PublicMutable<u8, Context>,\n\n        // ===== TIMELOCK ROLES =====\n        timelock_proposer: PublicMutable<AztecAddress, Context>,\n        timelock_executor: PublicMutable<AztecAddress, Context>,\n        timelock_canceller: PublicMutable<AztecAddress, Context>,\n\n        // ===== CLOAK MODE =====\n        // 0 = token-holder, 1 = multisig, 2 = hybrid\n        cloak_mode: PublicImmutable<u8, Context>,\n\n        // ===== COUNCIL (mode 1 = multisig signers, mode 2 = security council) =====\n        council_member_0: PublicMutable<AztecAddress, Context>,\n        council_member_1: PublicMutable<AztecAddress, Context>,\n        council_member_2: PublicMutable<AztecAddress, Context>,\n        council_member_3: PublicMutable<AztecAddress, Context>,\n        council_member_4: PublicMutable<AztecAddress, Context>,\n        council_member_5: PublicMutable<AztecAddress, Context>,\n        council_member_6: PublicMutable<AztecAddress, Context>,\n        council_member_7: PublicMutable<AztecAddress, Context>,\n        council_member_8: PublicMutable<AztecAddress, Context>,\n        council_member_9: PublicMutable<AztecAddress, Context>,\n        council_member_10: PublicMutable<AztecAddress, Context>,\n        council_member_11: PublicMutable<AztecAddress, Context>,\n        council_count: PublicMutable<u8, Context>,\n        council_threshold: PublicMutable<u8, Context>,       // M-of-N for normal ops\n        emergency_threshold: PublicMutable<u8, Context>,     // higher threshold, mode 2 only\n\n        // Per-proposal council approval tracking\n        council_approvals: Map<Field, Map<AztecAddress, PublicMutable<bool, Context>, Context>, Context>,\n        council_approval_counts: Map<Field, PublicMutable<u8, Context>, Context>,\n    }\n\n    // ===== INITIALIZER =====\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(\n        name: str<31>,\n        governance_token: AztecAddress,\n        voting_delay: u32,\n        voting_period: u32,\n        proposal_threshold: u128,\n        quorum_numerator: u128,\n        quorum_denominator: u128,\n        late_quorum_extension: u32,\n        timelock_delay: u32,\n        proposal_guardian: AztecAddress,\n        membership_mode: u8,\n        token_gate_address: AztecAddress,\n        erc20_token_address_hash: Field,\n        erc20_min_balance: u128,\n        cloak_mode: u8,\n        council_members: [AztecAddress; 12],\n        council_count: u8,\n        council_threshold: u8,\n        emergency_threshold: u8,\n    ) {\n        self.storage.name.initialize(FieldCompressedString::from_string(name));\n        self.storage.cloak_mode.initialize(cloak_mode);\n\n        // Token fields (mode 0 and 2)\n        self.storage.governance_token.initialize(governance_token);\n        self.storage.token_address.initialize(governance_token);\n\n        // GovernorSettings\n        self.storage.voting_delay.write(voting_delay);\n        self.storage.voting_period.write(voting_period);\n        self.storage.proposal_threshold.write(proposal_threshold);\n\n        // GovernorVotesQuorumFraction\n        self.storage.quorum_numerator.write(quorum_numerator);\n        self.storage.quorum_denominator.write(if quorum_denominator == 0 { 100 } else { quorum_denominator });\n\n        // GovernorPreventLateQuorum\n        self.storage.late_quorum_extension.write(late_quorum_extension);\n\n        // GovernorTimelockControl\n        self.storage.timelock_delay.write(timelock_delay);\n\n        // GovernorProposalGuardian\n        self.storage.proposal_guardian.write(proposal_guardian);\n\n        // Token gating\n        self.storage.membership_mode.write(membership_mode);\n        self.storage.token_gate_address.write(token_gate_address);\n        self.storage.erc20_token_address_hash.write(erc20_token_address_hash);\n        self.storage.erc20_min_balance.write(erc20_min_balance);\n\n        // Initialize counters\n        self.storage.proposal_count.write(0);\n        self.storage.total_voting_power.write(0);\n\n        // Council storage\n        self.storage.council_count.write(council_count);\n        self.storage.council_threshold.write(council_threshold);\n        self.storage.emergency_threshold.write(emergency_threshold);\n\n        // Store council members\n        self.storage.council_member_0.write(council_members[0]);\n        self.storage.council_member_1.write(council_members[1]);\n        self.storage.council_member_2.write(council_members[2]);\n        self.storage.council_member_3.write(council_members[3]);\n        self.storage.council_member_4.write(council_members[4]);\n        self.storage.council_member_5.write(council_members[5]);\n        self.storage.council_member_6.write(council_members[6]);\n        self.storage.council_member_7.write(council_members[7]);\n        self.storage.council_member_8.write(council_members[8]);\n        self.storage.council_member_9.write(council_members[9]);\n        self.storage.council_member_10.write(council_members[10]);\n        self.storage.council_member_11.write(council_members[11]);\n\n        // Mode 1: give each council member voting_power = 1\n        if cloak_mode == 1 {\n            let mut total: u128 = 0;\n            for idx in 0..12 {\n                if idx < council_count as u32 {\n                    let member = council_members[idx];\n                    if !member.is_zero() {\n                        self.storage.voting_power.at(member).write(1);\n                        total += 1;\n                    }\n                }\n            }\n            self.storage.total_voting_power.write(total);\n        }\n\n        // Default privacy config (all private)\n        self.storage.privacy_membership.write(2);\n        self.storage.privacy_proposals.write(2);\n        self.storage.privacy_voting.write(2);\n        self.storage.privacy_treasury.write(1);\n        self.storage.privacy_identity.write(2);\n        self.storage.privacy_delegation.write(2);\n        self.storage.privacy_execution.write(1);\n        self.storage.privacy_quorum.write(1);\n        self.storage.privacy_threshold.write(2);\n        self.storage.privacy_guardian.write(1);\n        self.storage.privacy_timelock.write(1);\n        self.storage.privacy_fractional.write(2);\n        self.storage.privacy_late_quorum.write(1);\n        self.storage.privacy_storage.write(1);\n\n        // Timelock roles default to deployer (msg_sender)\n        let deployer = self.msg_sender().unwrap();\n        self.storage.timelock_proposer.write(deployer);\n        self.storage.timelock_executor.write(deployer);\n        self.storage.timelock_canceller.write(deployer);\n    }\n\n    // =========================================================================\n    // PRIVATE TOKEN GATING (Membership -- Token-Only, No Admin Invite)\n    // =========================================================================\n\n    /// Join with Aztec token proof (mode 0).\n    #[external(\"private\")]\n    fn join_with_token_proof(balance_commitment: Field) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([\n            balance_commitment,\n            secret\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.add_member_internal(sender, balance_commitment);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_member_internal(member: AztecAddress, balance_commitment: Field) {\n        let mode = self.storage.membership_mode.read();\n        assert(mode == 0, \"not aztec-token mode\");\n\n        let current = self.storage.voting_power.at(member).read();\n        if current == 0 {\n            self.storage.voting_power.at(member).write(1);\n            let total = self.storage.total_voting_power.read();\n            self.storage.total_voting_power.write(total + 1);\n\n            // Checkpoint: write effective votes at current block\n            let effective = 1 + self.storage.delegated_power.at(member).read();\n            let current_block = self.context.block_number();\n            self.storage.voting_power_checkpoints.at(member).at(current_block as Field).write(effective);\n            self.storage.latest_checkpoint_block.at(member).write(current_block);\n        }\n    }\n\n    /// Join with ERC20 proof (mode 1).\n    #[external(\"private\")]\n    fn join_with_erc20_proof(verified_balance: u128, proof_nullifier: Field) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([proof_nullifier, secret]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.add_erc20_member_internal(sender, verified_balance, proof_nullifier);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_erc20_member_internal(member: AztecAddress, verified_balance: u128, proof_nullifier: Field) {\n        let mode = self.storage.membership_mode.read();\n        assert(mode == 1, \"not erc20-token mode\");\n        assert(verified_balance >= self.storage.erc20_min_balance.read(), \"insufficient balance\");\n        assert(!self.storage.used_nullifiers.at(proof_nullifier).read(), \"nullifier already used\");\n\n        self.storage.used_nullifiers.at(proof_nullifier).write(true);\n\n        let current = self.storage.voting_power.at(member).read();\n        if current == 0 {\n            self.storage.voting_power.at(member).write(verified_balance);\n            let total = self.storage.total_voting_power.read();\n            self.storage.total_voting_power.write(total + verified_balance);\n\n            // Checkpoint: write effective votes at current block\n            let effective = verified_balance + self.storage.delegated_power.at(member).read();\n            let current_block = self.context.block_number();\n            self.storage.voting_power_checkpoints.at(member).at(current_block as Field).write(effective);\n            self.storage.latest_checkpoint_block.at(member).write(current_block);\n        }\n    }\n\n    // =========================================================================\n    // PRIVATE DELEGATION\n    // =========================================================================\n\n    /// Delegate voting power privately.\n    #[external(\"private\")]\n    fn delegate(delegatee: AztecAddress) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([\n            delegatee.to_field(),\n            secret,\n            0xDE1E6A7E\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.delegate_internal(sender, delegatee);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn delegate_internal(delegator: AztecAddress, delegatee: AztecAddress) {\n        let power = self.storage.voting_power.at(delegator).read();\n\n        let old_delegate = self.storage.delegates.at(delegator).read();\n        if !old_delegate.is_zero() {\n            let old_power = self.storage.delegated_power.at(old_delegate).read();\n            self.storage.delegated_power.at(old_delegate).write(old_power - power);\n        }\n\n        self.storage.delegates.at(delegator).write(delegatee);\n        if !delegatee.is_zero() {\n            let new_power = self.storage.delegated_power.at(delegatee).read();\n            self.storage.delegated_power.at(delegatee).write(new_power + power);\n        }\n\n        // Checkpoint all affected accounts\n        let current_block = self.context.block_number();\n\n        // Checkpoint delegator\n        let delegator_effective = self.storage.voting_power.at(delegator).read()\n            + self.storage.delegated_power.at(delegator).read();\n        self.storage.voting_power_checkpoints.at(delegator).at(current_block as Field).write(delegator_effective);\n        self.storage.latest_checkpoint_block.at(delegator).write(current_block);\n\n        // Checkpoint old delegatee\n        if !old_delegate.is_zero() {\n            let old_effective = self.storage.voting_power.at(old_delegate).read()\n                + self.storage.delegated_power.at(old_delegate).read();\n            self.storage.voting_power_checkpoints.at(old_delegate).at(current_block as Field).write(old_effective);\n            self.storage.latest_checkpoint_block.at(old_delegate).write(current_block);\n        }\n\n        // Checkpoint new delegatee\n        if !delegatee.is_zero() {\n            let new_effective = self.storage.voting_power.at(delegatee).read()\n                + self.storage.delegated_power.at(delegatee).read();\n            self.storage.voting_power_checkpoints.at(delegatee).at(current_block as Field).write(new_effective);\n            self.storage.latest_checkpoint_block.at(delegatee).write(current_block);\n        }\n    }\n\n    /// Get effective voting power (own + delegated)\n    #[external(\"public\")]\n    fn get_effective_votes(account: AztecAddress) -> u128 {\n        let own = self.storage.voting_power.at(account).read();\n        let delegated = self.storage.delegated_power.at(account).read();\n        own + delegated\n    }\n\n    // =========================================================================\n    // PRIVATE PROPOSING (with ZK threshold proof)\n    // =========================================================================\n\n    /// Create a new proposal with private threshold proof.\n    #[external(\"private\")]\n    fn propose(\n        actions_hash: Field,\n        description_hash: Field,\n        target_count: u8,\n        proposal_type: u8,\n    ) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([\n            actions_hash,\n            description_hash,\n            secret\n        ]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.create_proposal_internal(\n            sender, actions_hash, description_hash, target_count, proposal_type\n        );\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn create_proposal_internal(\n        proposer: AztecAddress,\n        actions_hash: Field,\n        description_hash: Field,\n        target_count: u8,\n        proposal_type: u8,\n    ) {\n        let mode = self.storage.cloak_mode.read();\n\n        // Mode 1 (multisig): require caller is council member, no token threshold\n        if mode == 1 {\n            // Inline _is_council_member_check\n            let council_count = self.storage.council_count.read();\n            let council_members = [\n                self.storage.council_member_0.read(),\n                self.storage.council_member_1.read(),\n                self.storage.council_member_2.read(),\n                self.storage.council_member_3.read(),\n                self.storage.council_member_4.read(),\n                self.storage.council_member_5.read(),\n                self.storage.council_member_6.read(),\n                self.storage.council_member_7.read(),\n                self.storage.council_member_8.read(),\n                self.storage.council_member_9.read(),\n                self.storage.council_member_10.read(),\n                self.storage.council_member_11.read(),\n            ];\n            let mut is_member = false;\n            for i in 0..12 {\n                if (i as u8) < council_count {\n                    if council_members[i].eq(proposer) {\n                        is_member = true;\n                    }\n                }\n            }\n            assert(is_member, \"not a council member\");\n        } else {\n            // Mode 0 and 2: verify proposer has sufficient voting power\n            // Inline _get_effective_votes_internal\n            let voting_power = self.storage.voting_power.at(proposer).read()\n                + self.storage.delegated_power.at(proposer).read();\n            let threshold = self.storage.proposal_threshold.read();\n            assert(voting_power >= threshold, \"below proposal threshold\");\n        }\n\n        let proposal_id = self.storage.proposal_count.read();\n        let voting_delay = self.storage.voting_delay.read();\n        let voting_period = self.storage.voting_period.read();\n        let current_block = self.context.block_number();\n\n        let proposal = GovernorProposal {\n            id: proposal_id,\n            proposer,\n            eta: 0,\n            start_block: current_block + voting_delay,\n            end_block: current_block + voting_delay + voting_period,\n            canceled: false,\n            executed: false,\n            actions_hash,\n            description_hash,\n            target_count,\n            proposal_type,\n        };\n\n        self.storage.proposals.at(proposal_id as Field).write(proposal);\n        self.storage.proposal_for_votes.at(proposal_id as Field).write(0);\n        self.storage.proposal_against_votes.at(proposal_id as Field).write(0);\n        self.storage.proposal_abstain_votes.at(proposal_id as Field).write(0);\n        self.storage.proposal_count.write(proposal_id + 1);\n\n        // Snapshot total supply at proposal creation for quorum calculation\n        self.storage.total_supply_snapshot.at(current_block as Field).write(\n            self.storage.total_voting_power.read()\n        );\n    }\n\n    /// Cancel a proposal. Guardian or proposer (if below threshold) can cancel.\n    #[external(\"public\")]\n    fn cancel(proposal_id: Field) {\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        let caller = self.msg_sender().unwrap();\n\n        let guardian = self.storage.proposal_guardian.read();\n        // Inline _get_effective_votes_internal\n        let proposer_votes = self.storage.voting_power.at(proposal.proposer).read()\n            + self.storage.delegated_power.at(proposal.proposer).read();\n        let threshold = self.storage.proposal_threshold.read();\n\n        assert(\n            caller.eq(guardian) | (caller.eq(proposal.proposer) & (proposer_votes < threshold)),\n            \"cannot cancel\"\n        );\n\n        proposal.canceled = true;\n        self.storage.proposals.at(proposal_id).write(proposal);\n    }\n\n    // =========================================================================\n    // FULLY PRIVATE VOTING (GovernorCountingSimple)\n    // =========================================================================\n\n    /// Cast a private vote.\n    #[external(\"private\")]\n    fn cast_vote(proposal_id: Field, support: u8) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([proposal_id, secret]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.tally_vote_internal(proposal_id, support, sender);\n    }\n\n    /// Cast vote with reason (reason is off-chain only for privacy)\n    #[external(\"private\")]\n    fn cast_vote_with_reason(proposal_id: Field, support: u8, _reason_hash: Field) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([proposal_id, secret]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.tally_vote_internal(proposal_id, support, sender);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn tally_vote_internal(proposal_id: Field, support: u8, voter: AztecAddress) {\n        let proposal = self.storage.proposals.at(proposal_id).read();\n\n        assert(!proposal.canceled, \"proposal canceled\");\n        assert(self.context.block_number() >= proposal.start_block, \"voting not started\");\n        assert(self.context.block_number() <= proposal.end_block, \"voting ended\");\n\n        // Use snapshot voting power from proposal start block\n        let votes = self.storage.voting_power_checkpoints\n            .at(voter).at(proposal.start_block as Field).read();\n        // Fallback to current power if no checkpoint exists at snapshot block\n        let effective_votes = if votes > 0 {\n            votes\n        } else {\n            self.storage.voting_power.at(voter).read()\n                + self.storage.delegated_power.at(voter).read()\n        };\n        assert(effective_votes > 0, \"no voting power\");\n\n        // Tally votes -- only aggregates updated, no per-voter record\n        if support == VOTE_AGAINST {\n            let current = self.storage.proposal_against_votes.at(proposal_id).read();\n            self.storage.proposal_against_votes.at(proposal_id).write(current + effective_votes);\n        } else if support == VOTE_FOR {\n            let current = self.storage.proposal_for_votes.at(proposal_id).read();\n            self.storage.proposal_for_votes.at(proposal_id).write(current + effective_votes);\n        } else if support == VOTE_ABSTAIN {\n            let current = self.storage.proposal_abstain_votes.at(proposal_id).read();\n            self.storage.proposal_abstain_votes.at(proposal_id).write(current + effective_votes);\n        } else {\n            assert(false, \"invalid vote support\");\n        }\n\n        // Inline _check_late_quorum_internal\n        let mut lq_proposal = self.storage.proposals.at(proposal_id).read();\n        let extension = self.storage.late_quorum_extension.read();\n\n        if extension != 0 {\n            let current_block = self.context.block_number();\n            let extension_threshold = lq_proposal.end_block - extension;\n\n            if current_block >= extension_threshold {\n                let lq_for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n                let lq_abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n                // Inline _quorum_at_block_internal\n                let lq_total = self.storage.total_supply_snapshot.at(lq_proposal.start_block as Field).read();\n                let lq_numerator = self.storage.quorum_numerator.read();\n                let lq_denominator = self.storage.quorum_denominator.read();\n                let lq_quorum = if (lq_total == 0) | (lq_denominator == 0) {\n                    0\n                } else {\n                    (lq_total * lq_numerator) / lq_denominator\n                };\n\n                if lq_for_votes + lq_abstain_votes >= lq_quorum {\n                    let new_end = current_block + extension;\n                    if new_end > lq_proposal.end_block {\n                        lq_proposal.end_block = new_end;\n                        self.storage.proposals.at(proposal_id).write(lq_proposal);\n                    }\n                }\n            }\n        }\n    }\n\n    // =========================================================================\n    // FRACTIONAL VOTING (GovernorCountingFractional)\n    // =========================================================================\n\n    /// Cast a fractional vote: split voting power across For/Against/Abstain.\n    #[external(\"private\")]\n    fn cast_fractional_vote(\n        proposal_id: Field,\n        for_weight: u128,\n        against_weight: u128,\n        abstain_weight: u128,\n    ) {\n        let sender = self.msg_sender().unwrap();\n        let msg_sender_npk_m_hash = get_public_keys(sender).npk_m.hash();\n        let secret = self.context.request_nsk_app(msg_sender_npk_m_hash);\n\n        let nullifier = std::hash::pedersen_hash([proposal_id, secret]);\n        self.context.push_nullifier(nullifier);\n\n        self.enqueue_self.tally_fractional_internal(\n            proposal_id, for_weight, against_weight, abstain_weight, sender\n        );\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn tally_fractional_internal(\n        proposal_id: Field,\n        for_weight: u128,\n        against_weight: u128,\n        abstain_weight: u128,\n        voter: AztecAddress,\n    ) {\n        let proposal = self.storage.proposals.at(proposal_id).read();\n\n        assert(!proposal.canceled, \"proposal canceled\");\n        assert(self.context.block_number() >= proposal.start_block, \"voting not started\");\n        assert(self.context.block_number() <= proposal.end_block, \"voting ended\");\n\n        // Use snapshot voting power from proposal start block\n        let snapshot_power = self.storage.voting_power_checkpoints\n            .at(voter).at(proposal.start_block as Field).read();\n        let total_power = if snapshot_power > 0 {\n            snapshot_power\n        } else {\n            self.storage.voting_power.at(voter).read()\n                + self.storage.delegated_power.at(voter).read()\n        };\n        assert(total_power > 0, \"no voting power\");\n        assert(for_weight + against_weight + abstain_weight == total_power, \"weights must equal total power\");\n\n        if for_weight > 0 {\n            let current = self.storage.proposal_for_votes.at(proposal_id).read();\n            self.storage.proposal_for_votes.at(proposal_id).write(current + for_weight);\n        }\n        if against_weight > 0 {\n            let current = self.storage.proposal_against_votes.at(proposal_id).read();\n            self.storage.proposal_against_votes.at(proposal_id).write(current + against_weight);\n        }\n        if abstain_weight > 0 {\n            let current = self.storage.proposal_abstain_votes.at(proposal_id).read();\n            self.storage.proposal_abstain_votes.at(proposal_id).write(current + abstain_weight);\n        }\n\n        // Inline _check_late_quorum_internal\n        let mut lq_proposal = self.storage.proposals.at(proposal_id).read();\n        let extension = self.storage.late_quorum_extension.read();\n\n        if extension != 0 {\n            let current_block = self.context.block_number();\n            let extension_threshold = lq_proposal.end_block - extension;\n\n            if current_block >= extension_threshold {\n                let lq_for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n                let lq_abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n                // Inline _quorum_at_block_internal\n                let lq_total = self.storage.total_supply_snapshot.at(lq_proposal.start_block as Field).read();\n                let lq_numerator = self.storage.quorum_numerator.read();\n                let lq_denominator = self.storage.quorum_denominator.read();\n                let lq_quorum = if (lq_total == 0) | (lq_denominator == 0) {\n                    0\n                } else {\n                    (lq_total * lq_numerator) / lq_denominator\n                };\n\n                if lq_for_votes + lq_abstain_votes >= lq_quorum {\n                    let new_end = current_block + extension;\n                    if new_end > lq_proposal.end_block {\n                        lq_proposal.end_block = new_end;\n                        self.storage.proposals.at(proposal_id).write(lq_proposal);\n                    }\n                }\n            }\n        }\n    }\n\n    // =========================================================================\n    // TIMELOCK (GovernorTimelockControl)\n    // =========================================================================\n\n    /// Queue a succeeded proposal for execution after timelock delay.\n    #[external(\"public\")]\n    fn queue(proposal_id: Field) {\n        // Inline _get_state_internal\n        let st_proposal = self.storage.proposals.at(proposal_id).read();\n        let st_for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n        let st_against_votes = self.storage.proposal_against_votes.at(proposal_id).read();\n        let st_abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n        // Inline _quorum_at_block_internal\n        let st_total = self.storage.total_supply_snapshot.at(st_proposal.start_block as Field).read();\n        let st_numerator = self.storage.quorum_numerator.read();\n        let st_denominator = self.storage.quorum_denominator.read();\n        let st_quorum = if (st_total == 0) | (st_denominator == 0) {\n            0\n        } else {\n            (st_total * st_numerator) / st_denominator\n        };\n\n        let state = if st_proposal.canceled {\n            STATE_CANCELED\n        } else if self.context.block_number() < st_proposal.start_block {\n            STATE_PENDING\n        } else if self.context.block_number() <= st_proposal.end_block {\n            STATE_ACTIVE\n        } else if (st_for_votes <= st_against_votes) | ((st_for_votes + st_abstain_votes) < st_quorum) {\n            STATE_DEFEATED\n        } else if st_proposal.eta == 0 {\n            STATE_SUCCEEDED\n        } else if st_proposal.executed {\n            STATE_EXECUTED\n        } else if self.context.block_number() > st_proposal.eta + 14400 {\n            STATE_EXPIRED\n        } else {\n            STATE_QUEUED\n        };\n\n        assert(state == STATE_SUCCEEDED, \"not succeeded\");\n\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        let timelock_delay = self.storage.timelock_delay.read();\n        proposal.eta = self.context.block_number() + timelock_delay;\n        self.storage.proposals.at(proposal_id).write(proposal);\n    }\n\n    /// Execute a queued proposal after timelock has elapsed.\n    #[external(\"public\")]\n    fn execute(proposal_id: Field) {\n        // Inline _get_state_internal\n        let st_proposal = self.storage.proposals.at(proposal_id).read();\n        let st_for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n        let st_against_votes = self.storage.proposal_against_votes.at(proposal_id).read();\n        let st_abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n        // Inline _quorum_at_block_internal\n        let st_total = self.storage.total_supply_snapshot.at(st_proposal.start_block as Field).read();\n        let st_numerator = self.storage.quorum_numerator.read();\n        let st_denominator = self.storage.quorum_denominator.read();\n        let st_quorum = if (st_total == 0) | (st_denominator == 0) {\n            0\n        } else {\n            (st_total * st_numerator) / st_denominator\n        };\n\n        let state = if st_proposal.canceled {\n            STATE_CANCELED\n        } else if self.context.block_number() < st_proposal.start_block {\n            STATE_PENDING\n        } else if self.context.block_number() <= st_proposal.end_block {\n            STATE_ACTIVE\n        } else if (st_for_votes <= st_against_votes) | ((st_for_votes + st_abstain_votes) < st_quorum) {\n            STATE_DEFEATED\n        } else if st_proposal.eta == 0 {\n            STATE_SUCCEEDED\n        } else if st_proposal.executed {\n            STATE_EXECUTED\n        } else if self.context.block_number() > st_proposal.eta + 14400 {\n            STATE_EXPIRED\n        } else {\n            STATE_QUEUED\n        };\n\n        assert(state == STATE_QUEUED, \"not queued\");\n\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        assert(self.context.block_number() >= proposal.eta, \"timelock not elapsed\");\n\n        proposal.executed = true;\n        self.storage.proposals.at(proposal_id).write(proposal);\n\n        // In production: iterate targets[], call each with value and calldata\n    }\n\n    // =========================================================================\n    // GOVERNANCE PARAMETER UPDATES (self-governing -- via proposals only)\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_voting_delay(new_delay: u32) {\n        self.storage.voting_delay.write(new_delay);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_voting_period(new_period: u32) {\n        self.storage.voting_period.write(new_period);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_proposal_threshold(new_threshold: u128) {\n        self.storage.proposal_threshold.write(new_threshold);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_quorum_numerator(new_numerator: u128) {\n        let denominator = self.storage.quorum_denominator.read();\n        assert(new_numerator <= denominator, \"numerator exceeds denominator\");\n        self.storage.quorum_numerator.write(new_numerator);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_late_quorum_extension(new_extension: u32) {\n        self.storage.late_quorum_extension.write(new_extension);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_proposal_guardian(new_guardian: AztecAddress) {\n        self.storage.proposal_guardian.write(new_guardian);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_timelock_delay(new_delay: u32) {\n        self.storage.timelock_delay.write(new_delay);\n    }\n\n    // =========================================================================\n    // VIEW FUNCTIONS\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[view]\n    fn get_name() -> pub FieldCompressedString {\n        self.storage.name.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_count() -> pub u64 {\n        self.storage.proposal_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal(proposal_id: Field) -> pub GovernorProposal {\n        self.storage.proposals.at(proposal_id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_state(proposal_id: Field) -> pub u8 {\n        // Inline _get_state_internal\n        let proposal = self.storage.proposals.at(proposal_id).read();\n        let for_votes = self.storage.proposal_for_votes.at(proposal_id).read();\n        let against_votes = self.storage.proposal_against_votes.at(proposal_id).read();\n        let abstain_votes = self.storage.proposal_abstain_votes.at(proposal_id).read();\n\n        // Inline _quorum_at_block_internal\n        let total = self.storage.total_supply_snapshot.at(proposal.start_block as Field).read();\n        let numerator = self.storage.quorum_numerator.read();\n        let denominator = self.storage.quorum_denominator.read();\n        let quorum = if (total == 0) | (denominator == 0) {\n            0\n        } else {\n            (total * numerator) / denominator\n        };\n\n        if proposal.canceled {\n            STATE_CANCELED\n        } else if self.context.block_number() < proposal.start_block {\n            STATE_PENDING\n        } else if self.context.block_number() <= proposal.end_block {\n            STATE_ACTIVE\n        } else if (for_votes <= against_votes) | ((for_votes + abstain_votes) < quorum) {\n            STATE_DEFEATED\n        } else if proposal.eta == 0 {\n            STATE_SUCCEEDED\n        } else if proposal.executed {\n            STATE_EXECUTED\n        } else if self.context.block_number() > proposal.eta + 14400 {\n            STATE_EXPIRED\n        } else {\n            STATE_QUEUED\n        }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_votes(proposal_id: Field) -> pub (u128, u128, u128) {\n        (\n            self.storage.proposal_for_votes.at(proposal_id).read(),\n            self.storage.proposal_against_votes.at(proposal_id).read(),\n            self.storage.proposal_abstain_votes.at(proposal_id).read(),\n        )\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_snapshot(proposal_id: Field) -> pub u32 {\n        self.storage.proposals.at(proposal_id).read().start_block\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_deadline(proposal_id: Field) -> pub u32 {\n        self.storage.proposals.at(proposal_id).read().end_block\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_eta(proposal_id: Field) -> pub u32 {\n        self.storage.proposals.at(proposal_id).read().eta\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn proposal_proposer(proposal_id: Field) -> pub AztecAddress {\n        self.storage.proposals.at(proposal_id).read().proposer\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_votes(account: AztecAddress) -> pub u128 {\n        // Inline _get_effective_votes_internal\n        self.storage.voting_power.at(account).read()\n            + self.storage.delegated_power.at(account).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_past_votes(account: AztecAddress, block_number: u32) -> pub u128 {\n        let checkpoint = self.storage.voting_power_checkpoints\n            .at(account).at(block_number as Field).read();\n        if checkpoint > 0 {\n            checkpoint\n        } else {\n            // Fallback to current effective votes if no checkpoint at that block\n            self.storage.voting_power.at(account).read()\n                + self.storage.delegated_power.at(account).read()\n        }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_delegate(account: AztecAddress) -> pub AztecAddress {\n        self.storage.delegates.at(account).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_voting_delay() -> pub u32 {\n        self.storage.voting_delay.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_voting_period() -> pub u32 {\n        self.storage.voting_period.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_threshold() -> pub u128 {\n        self.storage.proposal_threshold.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_quorum_numerator() -> pub u128 {\n        self.storage.quorum_numerator.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_quorum_denominator() -> pub u128 {\n        self.storage.quorum_denominator.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn quorum(block_number: u32) -> pub u128 {\n        // Inline _quorum_at_block_internal\n        let total = self.storage.total_supply_snapshot.at(block_number as Field).read();\n        let numerator = self.storage.quorum_numerator.read();\n        let denominator = self.storage.quorum_denominator.read();\n\n        if (total == 0) | (denominator == 0) {\n            0\n        } else {\n            (total * numerator) / denominator\n        }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_late_quorum_extension() -> pub u32 {\n        self.storage.late_quorum_extension.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_timelock_delay() -> pub u32 {\n        self.storage.timelock_delay.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_proposal_guardian() -> pub AztecAddress {\n        self.storage.proposal_guardian.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_governance_token() -> pub AztecAddress {\n        self.storage.governance_token.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_membership_mode() -> pub u8 {\n        self.storage.membership_mode.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_token_gate_address() -> pub AztecAddress {\n        self.storage.token_gate_address.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_erc20_config() -> pub (Field, u128) {\n        (self.storage.erc20_token_address_hash.read(), self.storage.erc20_min_balance.read())\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_total_voting_power() -> pub u128 {\n        self.storage.total_voting_power.read()\n    }\n\n    // =========================================================================\n    // HASH PROPOSAL (deterministic proposal ID from targets/values/calldatas)\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[view]\n    fn hash_proposal(actions_hash: Field, description_hash: Field) -> pub Field {\n        std::hash::pedersen_hash([actions_hash, description_hash])\n    }\n\n    // =========================================================================\n    // MULTISIG VOTING (mode 1)\n    // =========================================================================\n\n    /// Council member approves a proposal (1-person-1-vote).\n    #[external(\"public\")]\n    fn council_approve(proposal_id: Field) {\n        let mode = self.storage.cloak_mode.read();\n        assert((mode == 1) | (mode == 2), \"council approval not available in this mode\");\n\n        let caller = self.msg_sender().unwrap();\n\n        // Inline _is_council_member_check\n        let council_count = self.storage.council_count.read();\n        let council_members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n        let mut is_member = false;\n        for i in 0..12 {\n            if (i as u8) < council_count {\n                if council_members[i].eq(caller) {\n                    is_member = true;\n                }\n            }\n        }\n        assert(is_member, \"not a council member\");\n\n        // Prevent double approval\n        let already_approved = self.storage.council_approvals.at(proposal_id).at(caller).read();\n        assert(!already_approved, \"already approved\");\n\n        self.storage.council_approvals.at(proposal_id).at(caller).write(true);\n\n        let current_count = self.storage.council_approval_counts.at(proposal_id).read();\n        self.storage.council_approval_counts.at(proposal_id).write(current_count + 1);\n    }\n\n    // =========================================================================\n    // EMERGENCY FUNCTIONS (mode 2)\n    // =========================================================================\n\n    /// Emergency execute: bypasses timelock, requires emergency_threshold council approvals.\n    #[external(\"public\")]\n    fn emergency_execute(proposal_id: Field) {\n        let mode = self.storage.cloak_mode.read();\n        assert(mode == 2, \"emergency execute only in hybrid mode\");\n\n        let approval_count = self.storage.council_approval_counts.at(proposal_id).read();\n        let threshold = self.storage.emergency_threshold.read();\n        assert(approval_count >= threshold, \"insufficient emergency approvals\");\n\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        assert(!proposal.canceled, \"proposal canceled\");\n        assert(!proposal.executed, \"already executed\");\n\n        proposal.executed = true;\n        self.storage.proposals.at(proposal_id).write(proposal);\n    }\n\n    /// Emergency cancel: council cancels malicious proposals, requires council_threshold.\n    #[external(\"public\")]\n    fn emergency_cancel(proposal_id: Field) {\n        let mode = self.storage.cloak_mode.read();\n        assert(mode == 2, \"emergency cancel only in hybrid mode\");\n\n        let approval_count = self.storage.council_approval_counts.at(proposal_id).read();\n        let threshold = self.storage.council_threshold.read();\n        assert(approval_count >= threshold, \"insufficient council approvals to cancel\");\n\n        let mut proposal = self.storage.proposals.at(proposal_id).read();\n        assert(!proposal.executed, \"already executed\");\n\n        proposal.canceled = true;\n        self.storage.proposals.at(proposal_id).write(proposal);\n    }\n\n    // =========================================================================\n    // COUNCIL MANAGEMENT (governance proposals only -- #[only_self])\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[only_self]\n    fn replace_council_member(old_member: AztecAddress, new_member: AztecAddress) {\n        let count = self.storage.council_count.read();\n\n        // Read all 12 members into array\n        let mut members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n\n        let mut replaced = false;\n        for i in 0..12 {\n            if (i as u8) < count {\n                if members[i].eq(old_member) {\n                    members[i] = new_member;\n                    replaced = true;\n                }\n            }\n        }\n        assert(replaced, \"old member not found\");\n\n        // Write all 12 back\n        self.storage.council_member_0.write(members[0]);\n        self.storage.council_member_1.write(members[1]);\n        self.storage.council_member_2.write(members[2]);\n        self.storage.council_member_3.write(members[3]);\n        self.storage.council_member_4.write(members[4]);\n        self.storage.council_member_5.write(members[5]);\n        self.storage.council_member_6.write(members[6]);\n        self.storage.council_member_7.write(members[7]);\n        self.storage.council_member_8.write(members[8]);\n        self.storage.council_member_9.write(members[9]);\n        self.storage.council_member_10.write(members[10]);\n        self.storage.council_member_11.write(members[11]);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn add_council_member(new_member: AztecAddress) {\n        let count = self.storage.council_count.read();\n        assert(count < 12, \"council full\");\n\n        // Read all 12 members into array\n        let mut members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n\n        members[count as u32] = new_member;\n\n        // Write all 12 back\n        self.storage.council_member_0.write(members[0]);\n        self.storage.council_member_1.write(members[1]);\n        self.storage.council_member_2.write(members[2]);\n        self.storage.council_member_3.write(members[3]);\n        self.storage.council_member_4.write(members[4]);\n        self.storage.council_member_5.write(members[5]);\n        self.storage.council_member_6.write(members[6]);\n        self.storage.council_member_7.write(members[7]);\n        self.storage.council_member_8.write(members[8]);\n        self.storage.council_member_9.write(members[9]);\n        self.storage.council_member_10.write(members[10]);\n        self.storage.council_member_11.write(members[11]);\n\n        self.storage.council_count.write(count + 1);\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn remove_council_member(member: AztecAddress) {\n        let count = self.storage.council_count.read();\n\n        // Read all 12 members into array\n        let mut members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n\n        let mut found_index: u8 = 255;\n        for i in 0..12 {\n            if (i as u8) < count {\n                if members[i].eq(member) {\n                    found_index = i as u8;\n                }\n            }\n        }\n        assert(found_index != 255, \"member not found\");\n\n        // Shift remaining members down\n        let mut i = found_index;\n        for _ in 0..11 {\n            if i + 1 < count {\n                members[i as u32] = members[(i + 1) as u32];\n                i += 1;\n            }\n        }\n        // Zero out last slot\n        members[(count - 1) as u32] = AztecAddress::from_field(0);\n\n        // Write all 12 back\n        self.storage.council_member_0.write(members[0]);\n        self.storage.council_member_1.write(members[1]);\n        self.storage.council_member_2.write(members[2]);\n        self.storage.council_member_3.write(members[3]);\n        self.storage.council_member_4.write(members[4]);\n        self.storage.council_member_5.write(members[5]);\n        self.storage.council_member_6.write(members[6]);\n        self.storage.council_member_7.write(members[7]);\n        self.storage.council_member_8.write(members[8]);\n        self.storage.council_member_9.write(members[9]);\n        self.storage.council_member_10.write(members[10]);\n        self.storage.council_member_11.write(members[11]);\n\n        self.storage.council_count.write(count - 1);\n\n        // Ensure threshold does not exceed new count\n        let threshold = self.storage.council_threshold.read();\n        if threshold > count - 1 {\n            self.storage.council_threshold.write(count - 1);\n        }\n    }\n\n    #[external(\"public\")]\n    #[only_self]\n    fn update_council_threshold(new_threshold: u8) {\n        let count = self.storage.council_count.read();\n        assert(new_threshold <= count, \"threshold exceeds council size\");\n        assert(new_threshold > 0, \"threshold must be positive\");\n        self.storage.council_threshold.write(new_threshold);\n    }\n\n    // =========================================================================\n    // COUNCIL VIEW FUNCTIONS\n    // =========================================================================\n\n    #[external(\"public\")]\n    #[view]\n    fn get_cloak_mode() -> pub u8 {\n        self.storage.cloak_mode.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_council_member(index: u8) -> pub AztecAddress {\n        // Inline _get_council_member_by_index\n        if index == 0 { self.storage.council_member_0.read() }\n        else if index == 1 { self.storage.council_member_1.read() }\n        else if index == 2 { self.storage.council_member_2.read() }\n        else if index == 3 { self.storage.council_member_3.read() }\n        else if index == 4 { self.storage.council_member_4.read() }\n        else if index == 5 { self.storage.council_member_5.read() }\n        else if index == 6 { self.storage.council_member_6.read() }\n        else if index == 7 { self.storage.council_member_7.read() }\n        else if index == 8 { self.storage.council_member_8.read() }\n        else if index == 9 { self.storage.council_member_9.read() }\n        else if index == 10 { self.storage.council_member_10.read() }\n        else if index == 11 { self.storage.council_member_11.read() }\n        else { AztecAddress::from_field(0) }\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_council_count() -> pub u8 {\n        self.storage.council_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_council_threshold() -> pub u8 {\n        self.storage.council_threshold.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_emergency_threshold() -> pub u8 {\n        self.storage.emergency_threshold.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn is_council_member(addr: AztecAddress) -> pub bool {\n        // Inline _is_council_member_check\n        let count = self.storage.council_count.read();\n        let members = [\n            self.storage.council_member_0.read(),\n            self.storage.council_member_1.read(),\n            self.storage.council_member_2.read(),\n            self.storage.council_member_3.read(),\n            self.storage.council_member_4.read(),\n            self.storage.council_member_5.read(),\n            self.storage.council_member_6.read(),\n            self.storage.council_member_7.read(),\n            self.storage.council_member_8.read(),\n            self.storage.council_member_9.read(),\n            self.storage.council_member_10.read(),\n            self.storage.council_member_11.read(),\n        ];\n        let mut found = false;\n        for i in 0..12 {\n            if (i as u8) < count {\n                if members[i].eq(addr) {\n                    found = true;\n                }\n            }\n        }\n        found\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_council_approval_count(proposal_id: Field) -> pub u8 {\n        self.storage.council_approval_counts.at(proposal_id).read()\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "84": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "85": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/calls.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata_array};\nuse crate::oracle::execution_cache;\n\n// PrivateCall\n\n#[must_use = \"Your private call needs to be passed into the `self.call(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_private_function(...args))`\"]\npub struct PrivateCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T>\nwhere\n    T: Deserialize,\n{\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_private_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\n// PrivateStaticCall\n\n#[must_use = \"Your private static call needs to be passed into the `self.view(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_private_static_function(...args))`\"]\npub struct PrivateStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_private_static_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\n// PublicCall\n\n#[must_use = \"Your public call needs to be passed into the `self.call(...)`, `self.enqueue(...)` or `self.enqueue_incognito(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_public_function(...args))`\"]\npub struct PublicCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    gas_opts: GasOpts,\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PublicCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub unconstrained fn call(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\n// PublicStaticCall\n\n#[must_use = \"Your public static call needs to be passed into the `self.view(...)`, `self.enqueue_view(...)` or `self.enqueue_view_incognito(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_public_static_function(...args))`\"]\npub struct PublicStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    return_type: T,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, let N: u32, T> PublicStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub unconstrained fn view(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view_incognito(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\n// UtilityCall\n\npub struct UtilityCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> UtilityCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n"
    },
    "93": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{\n        inputs::PrivateContextInputs, note_hash_read::NoteHashRead, returns_hash::ReturnsHash,\n    },\n    hash::{hash_args, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter, notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, find_first_index, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // Incrementing the side effect counter when ending setup ensures non\n        // ambiguity for the counter where we change phases.\n        self.side_effect_counter += 1;\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardize on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact approach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n        let side_effect = Scoped::new(\n            Counted::new(note_hash, self.next_counter()),\n            contract_address,\n        );\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Asserts that a NoteHashRead has been requested to the kernel by this context.\n    /// Asserts instead of returning a boolean to save on gates.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash read to assert that has been requested.\n    ///\n    pub fn assert_has_been_requested(self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n\n        // Safety: The index is constrained by the checks below.\n        let hinted_index = unsafe {\n            find_first_index(\n                self.note_hash_read_requests.storage(),\n                |r| (r.contract_address == contract_address) & (r.innermost() == note_hash),\n            )\n        };\n        // This assertion is not necessary, since the .get would fail. But it enables us to have a more explicit error message.\n        assert(\n            hinted_index != self.note_hash_read_requests.max_len(),\n            \"Note hash read has not been requested\",\n        );\n\n        let request = self.note_hash_read_requests.get(hinted_index);\n        assert_eq(request.contract_address, contract_address);\n        assert_eq(request.innermost(), note_hash);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    /// * `contract_address` - The contract address that emitted the nullifier\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the nullifier is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(\n        &mut self,\n        nullifier: Field,\n        contract_address: AztecAddress,\n    ) {\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incoming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes) or that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "94": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "96": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "97": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr",
      "source": "use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17278438487631839627": {
            "error_kind": "string",
            "string": "Function add_council_member can only be called by the same contract"
          },
          "17625130927896797776": {
            "error_kind": "string",
            "string": "council full"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEUtCEUBJQAAAEElAAAAbCcCAQRGJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAMmJQAAA2YeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAOMHgIABQEKIgVDBhYKBgccCgcIAAQqCAUHJwIFAQAKKgYFCCQCAAgAAADSJwIJBAA8BgkBCioHAwUkAgAFAAAA5CUAAAOeJwIDAD8vCgADAAUcCgUHAhwKBwYAHAoGBQInAgcCDAwqBQcIJAIACAAAARUlAAADsCcCBwAzLwoABwAIJwIJADQvCgAJAAonAgsANS8KAAsADCcCDQA2LwoADQAOJwIPADcvCgAPABAnAhEAOC8KABEAEicCEwA5LwoAEwAUJwIVADovCgAVABYnAhcAOy8KABcAGCcCGQA8LwoAGQAaJwIbAD0vCgAbABwnAh0APi8KAB0AHi0IAR8nAiAEDQAIASABJwMfBAEAIh8CIC0KICEtDgghACIhAiEtDgohACIhAiEtDgwhACIhAiEtDg4hACIhAiEtDhAhACIhAiEtDhIhACIhAiEtDhQhACIhAiEtDhYhACIhAiEtDhghACIhAiEtDhohACIhAiEtDhwhACIhAiEtDh4hHAoGCAQnAgYEDAwqCAYKJAIACgAAAjglAAADwi0CHwMnAAQEDSUAAAPULQgFBAAiBAIKACoKCAwtDgEMJwIBBAEAKgQBCi0LCggwCgAIAAcnAgEEAgAqBAEILQsIBzAKAAcACQAiBEQHLQsHATAKAAEACycCAQQEACoEAQgtCwgHMAoABwANJwIBBAUAKgQBCC0LCAcwCgAHAA8nAgEEBgAqBAEILQsIBzAKAAcAEScCAQQHACoEAQgtCwgHMAoABwATJwIBBAgAKgQBCC0LCAcwCgAHABUnAgEECQAqBAEILQsIBzAKAAcAFycCAQQKACoEAQgtCwgHMAoABwAZJwIBBAsAKgQBCC0LCAcwCgAHABsAKgQGBy0LBwEwCgABAB0nAgECAQAqBQEEDioFBAYkAgAGAAADWiUAAAQzHAoEAQAwCgABAAMmKAAABAR4RgwAAAQDJAAAAwAAA4sqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBe/JWEJou8GLPAQCASYqAQABBfSZCzJtCiJQPAQCASYqAQABBeQIUEUCtYwfPAQCASYtAQMGCgAGAgckAAAHAAAD6iMAAAPzLQADBSMAAAQyLQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAABC0tAQoILQQICwAACgIKAAALAgsjAAAECScBBQQBJioBAAEF0Afr9MvGZ5A8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_council_member"
    },
    {
      "abi": {
        "error_types": {
          "10958896161817881596": {
            "error_kind": "string",
            "string": "insufficient balance"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5836097838366868111": {
            "error_kind": "string",
            "string": "not erc20-token mode"
          },
          "7220720865510965904": {
            "error_kind": "string",
            "string": "nullifier already used"
          },
          "8288633154968149222": {
            "error_kind": "string",
            "string": "Function add_erc20_member_internal can only be called by the same contract"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "verified_balance",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "proof_nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_erc20_member_internal"
    },
    {
      "abi": {
        "error_types": {
          "10807032649822229906": {
            "error_kind": "string",
            "string": "not aztec-token mode"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3975253606477278659": {
            "error_kind": "string",
            "string": "Function add_member_internal can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "balance_commitment",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_member_internal"
    },
    {
      "abi": {
        "error_types": {
          "12164607307181823186": {
            "error_kind": "string",
            "string": "cannot cancel"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "cancel"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "for_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "against_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "abstain_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "tVzRbmQnD36XXOcC22BgX6WqqnSbVpGi7CrdrfSr2nf/MQd8yKTHYTizN7FnMuc7YLANNvjfuz8ef//+129PL39++fvu0y//3v3++vT8/PTXb89fPj98e/ryUr79987JH/B3nwh+3N9B/cTlkyufUD5hvvsEeH9HrlFoFBulRn2joVAqlBuNjaZCfaF5o941KnihUGxU8LhQ36jgxUK50dio4KVC80aDa1TwcqHYKDVa8NAVGhoteAiFxkZTowUPSz/YNQqNFjws/WBq1DcqeKUfzI0KXukHp0bzRqPglf5EaBQbFbzSn+gbDY0KXulPjI0KXulHzBtNgpfLKFEfs/ISiBspvy3QUH5akLD8MpYf+v7DtP0LZIxD/VI+yfizzobyIcoHGT7cRg/Ld0l//qN86jPpt2+vj4/yn2FqlQn39eH18eXb3aeX78/P93f/PDx/rz/6++vDS6XfHl7Lf8tYPL78UWgB/PPp+VG4H/f70+74UR9ze5jr9N0eh+xnAULEDgBxAOBZAMyRGgI5CAqBLs5CJJk1FSH5tLfh7fP++Hlm7n2IYeH56HoPIril57sMIx6+3+h/Fq2vz2eEledD6s/HfPR8Pn4ewPneg8Lz0Ic02wbi3gePbpgEOD2TPXSAjAMATc9k7qNY5vQSQIwdIPEKADtQXXJnAcISgMqA12TAKgNek0HULsQ1GYwASzKIKoO4JoOoMohrMkjahbQmgxFgSQaJFSCutSB2dU5pqQXZda+W12QwAqy1IHWbltcMCmYePBuueFdw0Aei2NVhMsG0XUwhqndkGlw0vbXNhAZGVlGQX2kEInRRIMYdguJbJ0OGl0Sm3hFkv3fEw/RqBz10T4ee6VgWbGG4HWNcLlxMDIqWflKfnMnx3hXiC4xkWRlOamaGGf4Ow3DcFPq4ehgmV3w7P705sKkvIJEcHmOAtXzgffUwWotrMMj1dgBhOsYgQ+G9LqPCGgI4xF1djZ4EYx2TdDXnUxitxkpHYlgb1gh9SYyR3DGGMUEh6sIeYjamRj49JPm0LPL5QQ14flAtceZ9hmc8Fqdp/nJvBYbBm1yavxAsaQTV+CKOvM+NTFeAxOgUpJjAIxBrtU266wsUjM4YMqWhHeQShcPOmCBJVwpUHDYvgQAQKAjkuCARn1k3IG5Ql0uJsDFRgV2XKjANm0F66+vZMD++qLtXv5IAjvrC3lq2MHbzUfhBZ/IVCzDSdWzh4z4ynt6uO5gtZx3CvhwfBuYCwvD3pEbIA+6tCIsdGXzku47kuY3NIIr5RVz2qPYj+yHUctmKaHpqZPXUw+YC0M1jeNBZ6sdwwyUGWb3RSVpW53s76GKmR2tJSvvqx7t9PUnpbfgrhvNL48iW1ubd1QYDw5ijXo3HGD+hmK6Qhud9ZYzH0sjnV8bJnV8ZJzi7Mk54fmWc6PzK2MSYXBmncHYZlsL5RVSKpxdRkx0xVoPmsHJyugvNdIiR3fkhyXB2SCYRLFlYSpKTKsmiNCf3GTmc32dkPi1NC8FFjcHzEsKsiuR8WkVMcU7uMyzfSk6D8YSD7bv0reDwvCsAR+d9ATh/1hmUndF5b1BG/rw7sFsyqXLgbrC3B3d6c29CzOoMAJxWGlsgt9AaDLvW5HCsNWDNVVBDROCHpTFfYJgmIOjo5niY0TQxcB8ZdD4cY0QroUb/kQ+7yCl+0ApVf3QZjluRf2orYFd+HIIdV8kTEt0Aw53GIM1IIIXjuYHeWv9oHKrs5GgNw9O+BfS3wIiLGKq0ZSvKqxgaDSvG6HxfVjGC5g0hgDuPQasYfsdgf4hBdFZr7VaoxpWo2PHIUjjZCtsnEO0+gY99gpVuCs7r0QY3hBgufYKNobGf4Ia09jsMa3Ua9rgg+1tg5COMWZmSO478gLcCpV79bFG9dNgXK0/DEfW0RBztzzUYSX01p0hrGDnpItlhXsKISfPtMXk4xojW+tZrqLU4IZdugQKw1p9MKpPMvIihoc6CsTa+KWuoM+VwPDZW9mlerlegHMvVjv7mOBO5nQ9DDzK5DEMX52EIVo+spRAPY5UQLJuo27FilA5DphBukMWHcDqNX5zYDfanfINEvt2S2f2plYKa3p9aKajJ/akFMb0/tRJQs/tTUyA3yB5nn/QATg7DgaZ3emdlocqPVfMKz4fZQYjmuWWnaZPCUzxGgdMKHPEGCmyuSOYU2Ey+IO97u2iozRVSPU66foCSQ9YJ61xcQynxP9pRgjtGSdYCXFPiw/b//Qjns4kxuxVz88yKtU/PMyvcPjnPrHTStHlO/gbm+XxSCm6RlYIbpKVsgUya52s0ZjjfeJ3egQql8PFY76zkEufYpyvnQfP4moYQ72ZkvBVwzQmQXfXK9tkZa8VsGlfdICEN6Z3LIbbyKrjfUsEU4BjDWgmg3jTx6HkNg3T17Gk8A3sVBuQbYMBpjH1H4n1alEfQsxOex83vWwy0UlWYNMBSxvbwChJamSrkHYNDOMbwpwP3JsZk4B6tRNVU2OuDVkwF7tGln9qKucD9Rxh0Awx3GmMucF9PI50M3NsYc4H7KzDiIsZU4P4jjJnA/XxfVjHmAvfzGLSKMRW4R8SzWmu3Yipwj1bwf9J2mPZcr9YiGxYM+bw9tzBm7TmetqR2K+bsObmf2opJe/4BBt0Aw53GmLTnVnpq1p6bGJP2fB4jLmLM2fMPMKbs+XRfVjEm7fk0Bq1izNlzf9qS2q2Ys+eef6o9jyFq4CMfy9O8wzOpbybGpL7NY8RFjDl9+wBjSt+m+7KKMalv0xi0ijGnb+HsoakPWjGnb+H0oSkzXrKHxDBDXoq5EGhSWi5YLWLsZ1nHe1mrGDicOLjAsO+Swy6O8fDEZSAL2TwBVqZ3hymz7fDCG1oJqRKo7os5SDzEXt1VTWE9/VB474+bYszV21wT431xmuOQ2H4nWyteCUUh9GYT8jjdkC9grJyU3+81+uEgRQoXGMYeip0eTmHn3TGGdYCKqU+4N3Kla5qR9nokYDTDmia85xs4DWbAXTbEvMI3d5QcrQtSsxkYtDJBcxkYtPJRs6l6tO5IzabqbZDJeyxo5aTm0jgmxGwaB60UzGQaZ7YvxpUae3Qn7xehlZKaH5h0fmDSeXlYCjN1x8gW6WTKEjOeT1liPl1hwoaYumdkQkyrSz5/KMWW6WTW03YygE6dzGDbL52MdW2K9hTQm6waX9OMvfJViSweNYOcleMvPlcPDBane5jAJfPe1OyS6IO2RK0KF0M+vsRPVtIhD15mqK5wTX3BoGdJwniE413JHisfNV3n4QOUlPaCTplwEWUP6kq5iPW2TBWdMFfPc9UfrXoRUzUF7J7coPJFCLohKZPkuK6TWUNSD7clchcQv5aPD5+fXt8WfpUaoXLgQop5SuxJqoRWCo2ilCYplBr1jQZZUhfKjUrJUakymhrNck5oqxdbKYh52erFVkqN+u33Ui+2fuZGC57svKTiaKVZzoZv9WIrhUZRzntv9WIr9VKAcqsXWyk3GhtNjWap6rbVi02tXmyl2Cg16hsNjXKjsdHUaMPjhscNjxseNzypF1s39FIwdmOkoq2UzJWSsRuTOlMLsvJWNRZkesRadtdtdWNBTGSshXfDVjl2Y2rpXb/Vjt2YWnyXt+qxG1PL77qtfixI6DNBZ7Az1Blfo1yFCZ3hzsTO1Lq+pYUpNya7GkQqDHQGO0PbIOQ2WLnillHP3BnBlXMRWXDl8FoWXNkfFaEpB8phXd0IR8pJs0Xm4EL108LJC3L9r1S0dfU7KWorbgRc7hw45aRQr9xFLSNSowPCUc0ACedl44/CScFeOeYOwMrJO2SQQNSscbWwsOChU64WFxZkUTeUur6AtcCwtEBUDmUYQZQOZfhA1K5x8g5fUZJy8g65XgCifo2Td0iJKBAVbJy8QzwkiBo2Tt4hxzBBVLFxsUutFgCuUiOVlVdZeVAOu9Q8damJam5S86FLzausfFROZeVz54LKKoBy2KUmyrpJrZZ3rlKrBZ6r1ILKqhZ53jiVVS30XDlWWdVizxunsqoFnzdOZVWLPm+cyqoWft44eYe4FqjFn2USw1b+WVC2AtCVk3ekWraZlPPKBeVYuahcUi53bisJLW8TnW4cigeTVolWk+QIQNS6cUG4+mwt+l2fiMql6qqFy50T5W4cKFffIT3KpJxXLijH1d0LJ++o80DUvHG5cehcax+KnhNUDpUj5bxyQZ9g5aJySZHrO2R9+8/D69PD78+P4gvFXX5/+dxdY/n47X9f+3961fSvr18+P/7x/fVR3OhQOr38/aVYagRxs7B/le/Ry1eoX5UNSTFc8h3pdyVahlm+8vtX8Z5Qvgr7V+GenHzF71+5VeneoMj/er/9u1h4H+TfaQeBe+Rff8h64P8=",
      "is_unconstrained": false,
      "name": "cast_fractional_vote",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "support",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "cast_vote",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "support",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "_reason_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "cast_vote_with_reason",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "governance_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "voting_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "voting_period",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "proposal_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "quorum_numerator",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "quorum_denominator",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "late_quorum_extension",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "timelock_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "proposal_guardian",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "membership_mode",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "token_gate_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "erc20_token_address_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "erc20_min_balance",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "cloak_mode",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "council_members",
            "type": {
              "kind": "array",
              "length": 12,
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            "visibility": "private"
          },
          {
            "name": "council_count",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "council_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "emergency_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_initializer"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "12510611782093430208": {
            "error_kind": "string",
            "string": "not a council member"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2514106658851063029": {
            "error_kind": "string",
            "string": "council approval not available in this mode"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8717548249808531313": {
            "error_kind": "string",
            "string": "already approved"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEUtCEUBJQAAAEElAAAAbCcCAQRGJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAMmJQAAJPEeAgACAB4CAAMALQgBBAAAAQIBJwIFADMtDgUELQgBBQAAAQIBJwIGADQtDgYFLQgBBgAAAQIBJwIHADUtDgcGLQgBBwAAAQIBJwIIADYtDggHLQgBCAAAAQIBJwIJADctDgkILQgBCQAAAQIBJwIKADgtDgoJLQgBCgAAAQIBJwILADktDgsKLQgBCwAAAQIBJwIMADotDgwLLQgBDAAAAQIBJwINADstDg0MLQgBDQAAAQIBJwIOADwtDg4NLQgBDgAAAQIBJwIPAD0tDg8OLQgBDwAAAQIBJwIQAD4tDhAPLQgBEAAAAQIBJwIRAD8tDhEQLQgBEQAAAQIBJwISAEItDhIRLQgBEgAAAQIBJwITAEMtDhMSHgIAEwAeAgAUADMqABMAFAAVJwITAQEkAgAVAAABrSUAACUXJwIUAAAtCAEVJwIWBAQACAEWAScDFQQBACIVAhYtChYXLQ4UFwAiFwIXLQ4UFwAiFwIXLQ4UFysCABYAAAAAAAAAAAIAAAAAAAAAAC0IARcnAhgEBQAIARgBJwMXBAEAIhcCGC0KGBktDhQZACIZAhktDhQZACIZAhktDhQZACIZAhktDhYZLQgBGAAAAQIBLQ4VGC0IARUAAAECAS0OFxUtCAEZAAABAgEnAhoEAC0OGhktCAEbAAABAgEnAhwBAC0OHBsnAh0ABicCHgQBJAIAHAAAAtAjAAACiS0IAQInAgMEBAAIAQMBJwMCBAEAIgICAy0KAx8tDh0fACIfAh8tDhQfACIfAh8tDhQfLQ4CGC0OFxUtDh4ZLQ4cGyMAAANcLQoaAiMAAALZDCICRAMkAgADAAAkayMAAALrLQsYAi0LFQMtCxsXLQsDHwAiHwIfLQ4fAy0IAR8nAiAEBQAIASABJwMfBAEAIgMCICcCIQQEACIfAiI/DwAgACItAgIDJwAEBAQlAAAlKS0IBQMAKgMeIC0OHSAtDgMYLQ4fFS0OHhktDhcbIwAAA1wtCxgCLQsVAy0LGxcKKhccHSQCAB0AAAN+JwIfBAA8Bh8BJwIXADEnAh0EAiQCABwAAAPFIwAAA5UtAgIDJwAEBAQlAAAlKS0IBR8AKh8dIC0OFyAtDh8YLQ4DFS0OHRktDhwbIwAABFEtChoCIwAAA84MIgJEAyQCAAMAACPlIwAAA+AtCxgCLQsVAy0LGx8tCwMgACIgAiAtDiADLQgBICcCIQQFAAgBIQEnAyAEAQAiAwIhJwIiBAQAIiACIz8PACEAIy0CAgMnAAQEBCUAACUpLQgFAwAqAx4hLQ4XIS0OAxgtDiAVLQ4eGS0OHxsjAAAEUS0LGwMKKgMcHyQCAB8AAARrJwIgBAA8BiABLQoaAiMAAAR0DCICRAMkAgADAAAjXyMAAASGLQsYAy0LFR8tCxkgLQsfIQAiIQIhLQ4hHy0IASEnAiIEBQAIASIBJwMhBAEAIh8CIicCIwQEACIhAiQ/DwAiACQtDgMYLQ4hFS0OIBktDhMbACohHhUtCxUDHgIAFQAzKgADABUAGCQCABgAAAT6JQAAJYgvCgAXAAMcCgMXAhwKFxUAHAoVAwInAhUCAQoqAxUXJwIYAgIKKgMYGRIqFxkDJAIAAwAABTUlAAAlmh4CAAMBCiIDQxcWChcYHAoYGQAEKhkDGAoqFxwDJAIAAwAABWMnAhkEADwGGQEtCxADLwoAAwAQHAoQFwIcChcDABwKAxACLQsEAy8KAAMABC0LBQMvCgADAAUtCwYDLwoAAwAGLQsHAy8KAAMABy0LCAMvCgADAAgtCwkDLwoAAwAJLQsKAy8KAAMACi0LCwMvCgADAAstCwwDLwoAAwAMLQsNAy8KAAMADS0LDgMvCgADAA4tCw8DLwoAAwAPLQgBAycCFwQNAAgBFwEnAwMEAQAiAwIXLQoXGS0OBBkAIhkCGS0OBRkAIhkCGS0OBhkAIhkCGS0OBxkAIhkCGS0OCBkAIhkCGS0OCRkAIhkCGS0OChkAIhkCGS0OCxkAIhkCGS0ODBkAIhkCGS0ODRkAIhkCGS0ODhkAIhkCGS0ODxktCAEEAAABAgEtDhwEJwIFBAwtChoCIwAABpIMKgIFBiQCAAYAACMHIwAABqQtCwQCJAIAAgAABrUlAAAlrC0LEQItCAEDJwIEBAQACAEEAScDAwQBACIDAgQtCgQFLQ4UBQAiBQIFLQ4UBQAiBQIFLQ4UBS0IAQQnAgUEBQAIAQUBJwMEBAEAIgQCBS0KBQYtDhQGACIGAgYtDhQGACIGAgYtDhQGACIGAgYtDhYGLQgBBQAAAQIBLQ4DBS0IAQMAAAECAS0OBAMtCAEGAAABAgEtDhoGLQgBBwAAAQIBLQ4cByQCABwAAAeuIwAAB2ctCAEIJwIJBAQACAEJAScDCAQBACIIAgktCgkKLQ4CCgAiCgIKLQ4UCgAiCgIKLQ4UCi0OCAUtDgQDLQ4eBi0OHAcjAAAIOi0KGgQjAAAHtwwiBEQIJAIACAAAIoEjAAAHyS0LBQQtCwMILQsHCS0LCAoAIgoCCi0OCggtCAEKJwILBAUACAELAScDCgQBACIIAgsnAgwEBAAiCgINPw8ACwANLQIEAycABAQEJQAAJSktCAUIACoIHgstDgILLQ4IBS0OCgMtDh4GLQ4JByMAAAg6LQsFAi0LAwQtCwcICioIHAkkAgAJAAAIXCcCCgQAPAYKASQCABwAAAiZIwAACGktAgIDJwAEBAQlAAAlKS0IBQgAKggdCS0OAQktDggFLQ4EAy0OHQYtDhwHIwAACSUtChoCIwAACKIMIgJEBCQCAAQAACH7IwAACLQtCwUCLQsDBC0LBwgtCwQJACIJAgktDgkELQgBCScCCgQFAAgBCgEnAwkEAQAiBAIKJwILBAQAIgkCDD8PAAoADC0CAgMnAAQEBCUAACUpLQgFBAAqBB4KLQ4BCi0OBAUtDgkDLQ4eBi0OCAcjAAAJJS0LBwQKKgQcCCQCAAgAAAk/JwIJBAA8BgkBLQoaAiMAAAlIDCICRAQkAgAEAAAhdSMAAAlaLQsFAi0LAwQtCwYILQsECQAiCQIJLQ4JBC0IAQknAgoEBQAIAQoBJwMJBAEAIgQCCicCCwQEACIJAgw/DwAKAAwtDgIFLQ4JAy0OCAYtDhMHACoJHgMtCwMCCioCFAMKKgMcBCQCAAQAAAnLJQAAJb4tCAEDJwIEBAQACAEEAScDAwQBACIDAgQtCgQFLQ4UBQAiBQIFLQ4UBQAiBQIFLQ4UBS0IAQQnAgUEBQAIAQUBJwMEBAEAIgQCBS0KBQYtDhQGACIGAgYtDhQGACIGAgYtDhQGACIGAgYtDhYGLQgBBQAAAQIBLQ4DBS0IAQMAAAECAS0OBAMtCAEGAAABAgEtDhoGLQgBBwAAAQIBLQ4cByQCABwAAArAIwAACnktCAEIJwIJBAQACAEJAScDCAQBACIIAgktCgkKLQ4CCgAiCgIKLQ4UCgAiCgIKLQ4UCi0OCAUtDgQDLQ4eBi0OHAcjAAALTC0KGgQjAAAKyQwiBEQIJAIACAAAIO8jAAAK2y0LBQQtCwMILQsHCS0LCAoAIgoCCi0OCggtCAEKJwILBAUACAELAScDCgQBACIIAgsnAgwEBAAiCgINPw8ACwANLQIEAycABAQEJQAAJSktCAUIACoIHgstDgILLQ4IBS0OCgMtDh4GLQ4JByMAAAtMLQsFAi0LAwQtCwcICioIHAkkAgAJAAALbicCCgQAPAYKASQCABwAAAurIwAAC3stAgIDJwAEBAQlAAAlKS0IBQgAKggdCS0OGAktDggFLQ4EAy0OHQYtDhwHIwAADDctChoCIwAAC7QMIgJEBCQCAAQAACBpIwAAC8YtCwUCLQsDBC0LBwgtCwQJACIJAgktDgkELQgBCScCCgQFAAgBCgEnAwkEAQAiBAIKJwILBAQAIgkCDD8PAAoADC0CAgMnAAQEBCUAACUpLQgFBAAqBB4KLQ4YCi0OBAUtDgkDLQ4eBi0OCAcjAAAMNy0LBwQKKgQcCCQCAAgAAAxRJwIJBAA8BgkBLQoaAiMAAAxaDCICRAQkAgAEAAAf4yMAAAxsLQsFAi0LAwQtCwYILQsECQAiCQIJLQ4JBC0IAQknAgoEBQAIAQoBJwMJBAEAIgQCCicCCwQEACIJAgw/DwAKAAwtDgIFLQ4JAy0OCAYtDhMHACoJHgMtCwMCCioCFAMKKgMcBCQCAAQAAAzdJQAAJb4vCgACAAMcCgMEARwKBAIAHAoCAwEKKgMcAiQCAAIAAA0EJQAAJdAtCxECLQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OFAUAIgUCBS0OFAUAIgUCBS0OFAUtCAEEJwIFBAUACAEFAScDBAQBACIEAgUtCgUGLQ4UBgAiBgIGLQ4UBgAiBgIGLQ4UBgAiBgIGLQ4WBi0IAQUAAAECAS0OAwUtCAEDAAABAgEtDgQDLQgBBgAAAQIBLQ4aBi0IAQcAAAECAS0OHAckAgAcAAAN/SMAAA22LQgBCCcCCQQEAAgBCQEnAwgEAQAiCAIJLQoJCi0OAgoAIgoCCi0OFAoAIgoCCi0OFAotDggFLQ4EAy0OHgYtDhwHIwAADoktChoEIwAADgYMIgRECCQCAAgAAB9dIwAADhgtCwUELQsDCC0LBwktCwgKACIKAgotDgoILQgBCicCCwQFAAgBCwEnAwoEAQAiCAILJwIMBAQAIgoCDT8PAAsADS0CBAMnAAQEBCUAACUpLQgFCAAqCB4LLQ4CCy0OCAUtDgoDLQ4eBi0OCQcjAAAOiS0LBQItCwMELQsHCAoqCBwJJAIACQAADqsnAgoEADwGCgEkAgAcAAAO6CMAAA64LQICAycABAQEJQAAJSktCAUIACoIHQktDgEJLQ4IBS0OBAMtDh0GLQ4cByMAAA90LQoaAiMAAA7xDCICRAQkAgAEAAAe1yMAAA8DLQsFAi0LAwQtCwcILQsECQAiCQIJLQ4JBC0IAQknAgoEBQAIAQoBJwMJBAEAIgQCCicCCwQEACIJAgw/DwAKAAwtAgIDJwAEBAQlAAAlKS0IBQQAKgQeCi0OAQotDgQFLQ4JAy0OHgYtDggHIwAAD3QtCwcECioEHAgkAgAIAAAPjicCCQQAPAYJAS0KGgIjAAAPlwwiAkQEJAIABAAAHlEjAAAPqS0LBQItCwMELQsGCC0LBAkAIgkCCS0OCQQtCAEJJwIKBAUACAEKAScDCQQBACIEAgonAgsEBAAiCQIMPw8ACgAMLQ4CBS0OCQMtDggGLQ4TBwAqCR4DLQsDAgoqAhQDCioDHAQkAgAEAAAQGiUAACW+LQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OFAUAIgUCBS0OFAUAIgUCBS0OFAUtCAEEJwIFBAUACAEFAScDBAQBACIEAgUtCgUGLQ4UBgAiBgIGLQ4UBgAiBgIGLQ4UBgAiBgIGLQ4WBi0IAQUAAAECAS0OAwUtCAEDAAABAgEtDgQDLQgBBgAAAQIBLQ4aBi0IAQcAAAECAS0OHAckAgAcAAARDyMAABDILQgBCCcCCQQEAAgBCQEnAwgEAQAiCAIJLQoJCi0OAgoAIgoCCi0OFAoAIgoCCi0OFAotDggFLQ4EAy0OHgYtDhwHIwAAEZstChoEIwAAERgMIgRECCQCAAgAAB3LIwAAESotCwUELQsDCC0LBwktCwgKACIKAgotDgoILQgBCicCCwQFAAgBCwEnAwoEAQAiCAILJwIMBAQAIgoCDT8PAAsADS0CBAMnAAQEBCUAACUpLQgFCAAqCB4LLQ4CCy0OCAUtDgoDLQ4eBi0OCQcjAAARmy0LBQItCwMELQsHCAoqCBwJJAIACQAAEb0nAgoEADwGCgEkAgAcAAAR+iMAABHKLQICAycABAQEJQAAJSktCAUIACoIHQktDhgJLQ4IBS0OBAMtDh0GLQ4cByMAABKGLQoaAiMAABIDDCICRAQkAgAEAAAdRSMAABIVLQsFAi0LAwQtCwcILQsECQAiCQIJLQ4JBC0IAQknAgoEBQAIAQoBJwMJBAEAIgQCCicCCwQEACIJAgw/DwAKAAwtAgIDJwAEBAQlAAAlKS0IBQQAKgQeCi0OGAotDgQFLQ4JAy0OHgYtDggHIwAAEoYtCwcECioEHAgkAgAIAAASoCcCCQQAPAYJAS0KGgIjAAASqQwiAkQEJAIABAAAHL8jAAASuy0LBQItCwMELQsGCC0LBAkAIgkCCS0OCQQtCAEJJwIKBAUACAEKAScDCQQBACIEAgonAgsEBAAiCQIMPw8ACgAMLQ4CBS0OCQMtDggGLQ4TBwAqCR4DLQsDAgoqAhQDCioDHAQkAgAEAAATLCUAACW+JwIDAAEwCgADAAItCxICLQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OFAUAIgUCBS0OFAUAIgUCBS0OFAUtCAEEJwIFBAUACAEFAScDBAQBACIEAgUtCgUGLQ4UBgAiBgIGLQ4UBgAiBgIGLQ4UBgAiBgIGLQ4WBi0IAQUAAAECAS0OAwUtCAEDAAABAgEtDgQDLQgBBgAAAQIBLQ4aBi0IAQcAAAECAS0OHAckAgAcAAAUMCMAABPpLQgBCCcCCQQEAAgBCQEnAwgEAQAiCAIJLQoJCi0OAgoAIgoCCi0OFAoAIgoCCi0OFAotDggFLQ4EAy0OHgYtDhwHIwAAFLwtChoEIwAAFDkMIgRECCQCAAgAABw5IwAAFEstCwUELQsDCC0LBwktCwgKACIKAgotDgoILQgBCicCCwQFAAgBCwEnAwoEAQAiCAILJwIMBAQAIgoCDT8PAAsADS0CBAMnAAQEBCUAACUpLQgFCAAqCB4LLQ4CCy0OCAUtDgoDLQ4eBi0OCQcjAAAUvC0LBQItCwMELQsHCAoqCBwJJAIACQAAFN4nAgoEADwGCgEkAgAcAAAVGyMAABTrLQICAycABAQEJQAAJSktCAUIACoIHQktDgEJLQ4IBS0OBAMtDh0GLQ4cByMAABWnLQoaAiMAABUkDCICRAQkAgAEAAAbsyMAABU2LQsFAi0LAwQtCwcILQsECQAiCQIJLQ4JBC0IAQknAgoEBQAIAQoBJwMJBAEAIgQCCicCCwQEACIJAgw/DwAKAAwtAgIDJwAEBAQlAAAlKS0IBQQAKgQeCi0OAQotDgQFLQ4JAy0OHgYtDggHIwAAFactCwcECioEHAgkAgAIAAAVwScCCQQAPAYJAS0KGgIjAAAVygwiAkQEJAIABAAAGy0jAAAV3C0LBQItCwMELQsGCC0LBAkAIgkCCS0OCQQtCAEJJwIKBAUACAEKAScDCQQBACIEAgonAgsEBAAiCQIMPw8ACgAMLQ4CBS0OCQMtDggGLQ4TBwAqCR4DLQsDAgoqAhQDCioDHAQkAgAEAAAWTSUAACW+LwoAAgADHAoDBAIcCgQCABwKAgMCLQsSAi0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQYtDhQGACIGAgYtDhQGACIGAgYtDhQGLQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy0OFAcAIgcCBy0OFAcAIgcCBy0OFAcAIgcCBy0OFgctCAEGAAABAgEtDgQGLQgBBAAAAQIBLQ4FBC0IAQcAAAECAS0OGgctCAEIAAABAgEtDhwIJAIAHAAAF1sjAAAXFC0IAQknAgoEBAAIAQoBJwMJBAEAIgkCCi0KCgstDgILACILAgstDhQLACILAgstDhQLLQ4JBi0OBQQtDh4HLQ4cCCMAABfnLQoaBSMAABdkDCIFRAkkAgAJAAAapyMAABd2LQsGBS0LBAktCwgKLQsJCwAiCwILLQ4LCS0IAQsnAgwEBQAIAQwBJwMLBAEAIgkCDCcCDQQEACILAg4/DwAMAA4tAgUDJwAEBAQlAAAlKS0IBQkAKgkeDC0OAgwtDgkGLQ4LBC0OHgctDgoIIwAAF+ctCwYCLQsEBS0LCAkKKgkcCiQCAAoAABgJJwILBAA8BgsBJAIAHAAAGEYjAAAYFi0CAgMnAAQEBCUAACUpLQgFCQAqCR0KLQ4BCi0OCQYtDgUELQ4dBy0OHAgjAAAY0i0KGgIjAAAYTwwiAkQFJAIABQAAGiEjAAAYYS0LBgItCwQFLQsICS0LBQoAIgoCCi0OCgUtCAEKJwILBAUACAELAScDCgQBACIFAgsnAgwEBAAiCgINPw8ACwANLQICAycABAQEJQAAJSktCAUFACoFHgstDgELLQ4FBi0OCgQtDh4HLQ4JCCMAABjSLQsIAgoqAhwFJAIABQAAGOwnAgkEADwGCQEtChoBIwAAGPUMIgFEAiQCAAIAABmbIwAAGQctCwYBLQsEAi0LBwUtCwIJACIJAgktDgkCLQgBCScCCgQFAAgBCgEnAwkEAQAiAgIKJwILBAQAIgkCDD8PAAoADC0OAQYtDgkELQ4FBy0OEwgAKgkeAi0LAgEKKgEUAgoqAhwEJAIABAAAGXglAAAlvgAqAxUCDioDAgQkAgAEAAAZjyUAACXiHAoCAwAwCgADAAEmLQsGAi0LBAUtCwcJLQsICgwqAQkLJAIACwAAGb0jAAAaEwAiBQIMACoMAQ0tCw0LACICAg0AKg0BDi0LDgwAKgsMDS0CBQMnAAQEBSUAACUpLQgFCwAiCwIMACoMAQ4tDg0OLQ4CBi0OCwQtDgkHLQ4KCCMAABoTACoBHgItCgIBIwAAGPUtCwYFLQsECS0LBwotCwgLDCoCCgwkAgAMAAAaQyMAABqZACIJAg0AKg0CDi0LDgwAIgUCDgAqDgIPLQsPDQAqDA0OLQIJAycABAQFJQAAJSktCAUMACIMAg0AKg0CDy0ODg8tDgUGLQ4MBC0OCgctDgsIIwAAGpkAKgIeBS0KBQIjAAAYTy0LBgktCwQKLQsHCy0LCAwMKgULDSQCAA0AABrJIwAAGx8AIgoCDgAqDgUPLQsPDQAiCQIPACoPBRAtCxAOACoNDg8tAgoDJwAEBAUlAAAlKS0IBQ0AIg0CDgAqDgUQLQ4PEC0OCQYtDg0ELQ4LBy0ODAgjAAAbHwAqBR4JLQoJBSMAABdkLQsFBC0LAwgtCwYJLQsHCgwqAgkLJAIACwAAG08jAAAbpQAiCAIMACoMAg0tCw0LACIEAg0AKg0CDi0LDgwAKgsMDS0CCAMnAAQEBSUAACUpLQgFCwAiCwIMACoMAg4tDg0OLQ4EBS0OCwMtDgkGLQ4KByMAABulACoCHgQtCgQCIwAAFcotCwUELQsDCC0LBgktCwcKDCoCCQskAgALAAAb1SMAABwrACIIAgwAKgwCDS0LDQsAIgQCDQAqDQIOLQsODAAqCwwNLQIIAycABAQFJQAAJSktCAULACILAgwAKgwCDi0ODQ4tDgQFLQ4LAy0OCQYtDgoHIwAAHCsAKgIeBC0KBAIjAAAVJC0LBQgtCwMJLQsGCi0LBwsMKgQKDCQCAAwAABxbIwAAHLEAIgkCDQAqDQQOLQsODAAiCAIOACoOBA8tCw8NACoMDQ4tAgkDJwAEBAUlAAAlKS0IBQwAIgwCDQAqDQQPLQ4ODy0OCAUtDgwDLQ4KBi0OCwcjAAAcsQAqBB4ILQoIBCMAABQ5LQsFBC0LAwgtCwYJLQsHCgwqAgkLJAIACwAAHOEjAAAdNwAiCAIMACoMAg0tCw0LACIEAg0AKg0CDi0LDgwAKgsMDS0CCAMnAAQEBSUAACUpLQgFCwAiCwIMACoMAg4tDg0OLQ4EBS0OCwMtDgkGLQ4KByMAAB03ACoCHgQtCgQCIwAAEqktCwUELQsDCC0LBgktCwcKDCoCCQskAgALAAAdZyMAAB29ACIIAgwAKgwCDS0LDQsAIgQCDQAqDQIOLQsODAAqCwwNLQIIAycABAQFJQAAJSktCAULACILAgwAKgwCDi0ODQ4tDgQFLQ4LAy0OCQYtDgoHIwAAHb0AKgIeBC0KBAIjAAASAy0LBQgtCwMJLQsGCi0LBwsMKgQKDCQCAAwAAB3tIwAAHkMAIgkCDQAqDQQOLQsODAAiCAIOACoOBA8tCw8NACoMDQ4tAgkDJwAEBAUlAAAlKS0IBQwAIgwCDQAqDQQPLQ4ODy0OCAUtDgwDLQ4KBi0OCwcjAAAeQwAqBB4ILQoIBCMAABEYLQsFBC0LAwgtCwYJLQsHCgwqAgkLJAIACwAAHnMjAAAeyQAiCAIMACoMAg0tCw0LACIEAg0AKg0CDi0LDgwAKgsMDS0CCAMnAAQEBSUAACUpLQgFCwAiCwIMACoMAg4tDg0OLQ4EBS0OCwMtDgkGLQ4KByMAAB7JACoCHgQtCgQCIwAAD5ctCwUELQsDCC0LBgktCwcKDCoCCQskAgALAAAe+SMAAB9PACIIAgwAKgwCDS0LDQsAIgQCDQAqDQIOLQsODAAqCwwNLQIIAycABAQFJQAAJSktCAULACILAgwAKgwCDi0ODQ4tDgQFLQ4LAy0OCQYtDgoHIwAAH08AKgIeBC0KBAIjAAAO8S0LBQgtCwMJLQsGCi0LBwsMKgQKDCQCAAwAAB9/IwAAH9UAIgkCDQAqDQQOLQsODAAiCAIOACoOBA8tCw8NACoMDQ4tAgkDJwAEBAUlAAAlKS0IBQwAIgwCDQAqDQQPLQ4ODy0OCAUtDgwDLQ4KBi0OCwcjAAAf1QAqBB4ILQoIBCMAAA4GLQsFBC0LAwgtCwYJLQsHCgwqAgkLJAIACwAAIAUjAAAgWwAiCAIMACoMAg0tCw0LACIEAg0AKg0CDi0LDgwAKgsMDS0CCAMnAAQEBSUAACUpLQgFCwAiCwIMACoMAg4tDg0OLQ4EBS0OCwMtDgkGLQ4KByMAACBbACoCHgQtCgQCIwAADFotCwUELQsDCC0LBgktCwcKDCoCCQskAgALAAAgiyMAACDhACIIAgwAKgwCDS0LDQsAIgQCDQAqDQIOLQsODAAqCwwNLQIIAycABAQFJQAAJSktCAULACILAgwAKgwCDi0ODQ4tDgQFLQ4LAy0OCQYtDgoHIwAAIOEAKgIeBC0KBAIjAAALtC0LBQgtCwMJLQsGCi0LBwsMKgQKDCQCAAwAACERIwAAIWcAIgkCDQAqDQQOLQsODAAiCAIOACoOBA8tCw8NACoMDQ4tAgkDJwAEBAUlAAAlKS0IBQwAIgwCDQAqDQQPLQ4ODy0OCAUtDgwDLQ4KBi0OCwcjAAAhZwAqBB4ILQoIBCMAAArJLQsFBC0LAwgtCwYJLQsHCgwqAgkLJAIACwAAIZcjAAAh7QAiCAIMACoMAg0tCw0LACIEAg0AKg0CDi0LDgwAKgsMDS0CCAMnAAQEBSUAACUpLQgFCwAiCwIMACoMAg4tDg0OLQ4EBS0OCwMtDgkGLQ4KByMAACHtACoCHgQtCgQCIwAACUgtCwUELQsDCC0LBgktCwcKDCoCCQskAgALAAAiHSMAACJzACIIAgwAKgwCDS0LDQsAIgQCDQAqDQIOLQsODAAqCwwNLQIIAycABAQFJQAAJSktCAULACILAgwAKgwCDi0ODQ4tDgQFLQ4LAy0OCQYtDgoHIwAAInMAKgIeBC0KBAIjAAAIoi0LBQgtCwMJLQsGCi0LBwsMKgQKDCQCAAwAACKjIwAAIvkAIgkCDQAqDQQOLQsODAAiCAIOACoOBA8tCw8NACoMDQ4tAgkDJwAEBAUlAAAlKS0IBQwAIgwCDQAqDQQPLQ4ODy0OCAUtDgwDLQ4KBi0OCwcjAAAi+QAqBB4ILQoIBCMAAAe3HAoCBwIcCgcGBBwKBgcCDCoHEAYkAgAGAAAjKCMAACNRACIDAgcAKgcCCC0LCAYKKgYYByQCAAcAACNIIwAAI1EtDhMEIwAAI1EAKgIeBi0KBgIjAAAGki0LGAMtCxUfLQsZIC0LGyEMKgIgIiQCACIAACOBIwAAI9cAIh8CIwAqIwIkLQskIgAiAwIkACokAiUtCyUjACoiIyQtAh8DJwAEBAUlAAAlKS0IBSIAIiICIwAqIwIlLQ4kJS0OAxgtDiIVLQ4gGS0OIRsjAAAj1wAqAh4DLQoDAiMAAAR0LQsYAy0LFR8tCxkgLQsbIQwqAiAiJAIAIgAAJAcjAAAkXQAiHwIjACojAiQtCyQiACIDAiQAKiQCJS0LJSMAKiIjJC0CHwMnAAQEBSUAACUpLQgFIgAiIgIjACojAiUtDiQlLQ4DGC0OIhUtDiAZLQ4hGyMAACRdACoCHgMtCgMCIwAAA84tCxgDLQsVFy0LGR8tCxsgDCoCHyEkAgAhAAAkjSMAACTjACIXAiIAKiICIy0LIyEAIgMCIwAqIwIkLQskIgAqISIjLQIXAycABAQFJQAAJSktCAUhACIhAiIAKiICJC0OIyQtDgMYLQ4hFS0OHxktDiAbIwAAJOMAKgIeAy0KAwIjAAAC2SgAAAQEeEYMAAAEAyQAAAMAACUWKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmLQEDBgoABgIHJAAABwAAJT8jAAAlSC0AAwUjAAAlhy0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAACWCLQEKCC0ECAsAAAoCCgAACwILIwAAJV4nAQUEASYqAQABBXIxDJYzrKc/PAQCASYqAQABBSLj5q+YQwT1PAQCASYqAQABBa2enyG6ft3APAQCASYqAQABBbq7IdeCMxhkPAQCASYqAQABBXj68/IWKm9xPAQCASYqAQABBdAH6/TLxmeQPAQCASY=",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "council_approve"
    },
    {
      "abi": {
        "error_types": {
          "10581129473648605397": {
            "error_kind": "string",
            "string": "Function create_proposal_internal can only be called by the same contract"
          },
          "11835668458991423142": {
            "error_kind": "string",
            "string": "below proposal threshold"
          },
          "12510611782093430208": {
            "error_kind": "string",
            "string": "not a council member"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [
          {
            "name": "proposer",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "actions_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "description_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "target_count",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "proposal_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tZ3Zjl03robfxde50EQNeZVGI3DS7oYBwwncyQEOgrz7EX9S5CofbJVSe9WN91e/a3NpoCRqWvXnh399+vmP//z0+eu/f/3vhx//8eeHn799/vLl839++vLrLx9///zr16n++SHwPzGPDz/mHz7EUj782Phz/lzmJ2X97PJZ9efa5LNF/azy2fXnTvqpdkbRT/k5hayfYifFpJ/6c4r6KXZSDvq5flY7Re0USV/S9CZSO1XtVElf0vSmpnaa2ulFP/XnoXaG2Mkh6af+HKN+ip2cgn6un8VOzlk/JX1Z05uL2iG1Q5K+rOnNVe1UtdOKfurPXe10tTM0fZreEqJ+ip0Sg36un8VOSVk/JX1F01uy2ilqp0j6iqa3kNohtVOLfurPTe00tdOTfurPQ+0MsUMh6Of6WexQzPop6SNNLyWxQznqp6SPNL1U1I76MVHRT/1Z/ZjUj6kl/dSf1Y9J/ZiGpm+ll/04xh8+1DANx8LAymw6lV049gkpKbDzCsxvpzShTCXxtzidAkP/i1MqwEqdwGUrsBROJYCLVWDmP/HTuWAFhkDjFObKMBS4UAW6QlpKWkpeCnsCgItWoCpQWEAL+BH80B4WlAXrv8ZShio9lAVdgbsDgabAHYJAVchhAS1ggzSBW5lAV6C0oCpwSxOgBevr3NgEltKXQfZfwFCDg1tSHhNQhoCukJeSl1KWwu0fwA1KoCrUsIAWsNOGCWhVgKYAP2VAxzrdJgZ0odyXB3SiQmQ0FqGpC/VFhZsBgeoiNHkh06pp1bRmWjMNzb6C6iI0faGlRTR/ITLilPJYFNEJCLVFyBsIQ0MHFaO+CDkaoLYInReIy1qoa4XEOKKRVklMIRrRohiMilTCpL6IG79SXcSDK+oo1aQlLgMTqAWjYrRqJvVs1LR004hGq8RziEamRdOiack0dKVc4jlHo1UzuZhWVs1kCkZFayEjQAAhb0J1EQ+3FEGzVonLIHPPIMRtSakpYcAijhgwNBGntORkVBdxT6pUjMYiDgcI8QwHBEKcPiXTmmnNtG5aN43DAkKchJQyEZe4EhlxCtj/iH1DaeajchlgEKsSXc3vVgKNRQjB2F+Iy7klEC2qpnH30PA09hyhPp/RYJnLtONp7BugyilVMi2aFk3jYEapGI1F3G8o9UXcynoC1UXcbyiZVk2rpnHqlYrRWMR+r9QXDXsa1wKoIW8BRIvYh5SKUV/EtaDUFmWzwh4mVMxKMSvsYULIByJg5EOIFnXTumnDNB4JlbpS58BYqS3i0VCJn8Ze0lFHQsWoL0ItsMd2Dh56B/VF7O1KdRFSKkRGM5eDc9nZ75W60gjZyLRoWjQtmcY+NNhfMDIq9UXFNO6phXjYVpopHVzTGB+VilFfxO13cFvA0KhERpwCmYcUoRQ4tFdqi5LWzKS+KGcj00oyaovg9wQio7GIA08hTh/XUQo8dnOJzyElG7VFaKFCtCgFoyKlO6kvytnItGJaMY1MI9NQphHUF7VsZFpPRm0Rj0dcC5PIaChhyifE/jwqiGuVywATPqWxiMdzIXjEYOJeb4YLwGHIKVzYDLmEF1ZDbn8zDgIWx7Ewh+LoanQ1uppc5ThkdFAx6ovYU5SQlIzJbHREvtgxcg2OrkoWBTtPPjgzGERnMAQchsNVyRcXduEKmEENsBlyZSx0NbmaXOXucSEZcge5sDgOQ/az6bLAZsjj8EJXm6vNVdSkIhmiJhWL41hIITt2Q8lxB1bDFB3JcRjm4tgNixsrzZDcGLkxVKyg5I1riCRvgtVwuDpMxQi+kByHIbxUsRum7IgHs8tV1KYiOQ5DqSx2udrwCxU4DHt2bIaSdMG6sAVUVgcWx2EYXY2uJleTq9lVeF8awOI4DMlV6oY1O3LSM7tG4znMQnIchhyEzDCakaOQhXVhRzZzApIhj4sLu2G2KuzZqrCX4ugqZUer2C5tKAOrYQuOxRDpRW2OGFa1DCl1wW6I5q9oVThydKRVASNbtYxSHF0lV8nV6mp1VfxsAK0KRy+Oro7suCo2YzhHZU2shsixYjFEu8iyvgcnIMacDOFcimSICuAVh4yp7hxlGXtwLI7dUBxGsC2MaNI8P8yY+yoivYquJleTq9nV7GqBK1cgOQ5DeJQiJ6dERniUIueN55wZy7wLXUU2FdluQYZ47J8zICyKBkdXkTeeDU4kw+QqRzKKHMos5EQSpxervpFnVRkLv4rkKmqI2B8SGrqiq8iFIDpd1KaEBorF0aoby8Bz9sSYrLqx6KuYXUUfxRO+icOwuIqk18QodYGvkbkGZtILXZU+StC8L3dXuycH1SI4/BHufSWYhYIMcf8wsTh2w5wc+WuVa77Q6kByoWFYXUWpV1n0zo6udhQq7NookouNIhNXF5QpREcytP5s4kW15FDKjvYIym6suAWyzBNZ5qkmx2qInhblgKm3Whj+tGFqFd/Boj7CL8HoKoIRlENNlrKaLEOyjqx4US2btRRHVyk7WuYxFV/oxppb4AxxzJ0x31aqShjOleDR/JWGYYOj7Iw5tWJ2VfyGmxKWkxe6SijQDiT7Gg1DOJaiqxb/T+yG3dXuyRnR0R8xzBhWoRU5QzxHy1h2FuJaUCpG8GYuDiww89QsY4VZyTQ4TINtDHWC3VX0qS0Cx/rWyEY6ic9jTRUntUUxGZmWohEZLcuYiAsV+y6trGKqrVSM+iKE6sj0GGF9eehDSgjBqGj2Jg7D6CoiD850wZAs30ptUU5GppVoVBeRaWSpoLGomuVqVpp9d+ga2iSkq2LTDPXSgWQYXUVvw8txEzlnnS3I2NwGECp+F022Y/MNTXbgdzE2d/wumuzA78L3h2zY8T5OwO+inQ78LraCAn6X/WiuPwBZjfjdDhW/26Hid7l2UpQNQGw48e9ibE48VZsIlX8XY3NK2BzkvM2hmDFBxe8mqPhdbGxl2VAchtwdLXSVXCVXuXYWNkN2sYXVkMe6hf5grsGF/ohhj8ghO3bDmBztwVgeX2gPxui+kBz9EZ5jjO6K5A8mf0T1B1d/RPNHNH/EgIWBDVlOGYd4BZu5Dbuz3GqE8gp3CvZwE6/xz2k5f5+X4id2Q3KVoEbs9HK6eBG+YOhOBLvcwy50tcNCB/LT5MFIbYUx7q8EMRlfCFX2k6ESsBsmV3mQXsjFxCNNwT7vQlfhWorDEK6Fto3tXkW4lqKr3dXuqmyqCtLCyr3DwuI4DJE3VAs2hRVTcnQ1u5pdRTYVyZCCY3EchtUfjCoUlBwnYDVEY1Ikx2GIxqTYF7aQHJthjI5mrKVgKHnjammSN8FqSK6Sq9XVSo7DsBXHbgj3VMSD2deb1KYgOY6FXSqLXRlT9MQr/QVTdEU0J8VmiKQrVkMeQxPvURSsxS8chs3V5mp3tbs6TB3wPow3A96nOAyjq2hZgmhZikg6TmGgkSmS4zBEr8Hr1gVr8guroWSzAskQvYZiNxxWhWOsKqQQiqOrMTt2Q2lDDVgN0T0rFkOkl2uTAjpXrpaJxbEbovkrVsMRHUkrgLBqLxhDcXQ1uhpdTa4mV6XUM3AYluLoKmXHbohuu+OsDIYTQcmxYDFEu+CohLB6nzj+mNOltDCJcwmSISqAl/pn/8yP4NV8SjjLolgcuyEqQLEZokkPnOWBwwgivYqudle7q8PVYSo2wBPvZUwkx2EIj1JEcogRHqWIvLHvYEd8oauSTUE+/cHr/4S98IVQM84lFUeoSCS3i4XdsLvaXR2u8sRdEAe8FlZDnElQJEd7MGb2C+0RCBoW+iN4RrDQH0H+YPJHVH9w9Ud4jovnuHiOMfVfaA/GzD7zngVJIMAxMWHinjm4JcQEC6thcbW4Sq4ivYrDEOlV7IZIryIejJT16FgNh6vDVKzVLyTHYRiLYzfEMSJFezDCg4V4BPsZjpEtJMdhSNmxG9bk6MZadHRjzY3hKBewSd4qkAzhfYquJlfTRR2G8D7FbgjvU2yGUpsNSI7DsGZDqSzuueSoGe/+EDbYFzZDDlwWkiGSrsiZ50V3wja7IpKu6GpxtbhKrpKr8D6ehhE26BXhfYquorUoNkN4H8/TJpLjWDgkx0Ccq+Olq4nVULIpiORU4DBEpyCIahEkq8JRs6NV4WiuNqvC0ZNjXZWFFYSFxbErztZUtTYrBndUSw1S6kBJmWA1pOBIjkMroGJZYGE3bK42V7ur3dXhqpR65lOgITt2w+hqbIYpOVatrIp1/YXFsRuiXfBkvUa0C56WT6yG4lyCwxAVwLtVFeN85s2oicWxG8JhFKshDmMqcqHyJLViPUAR6VV0tbhaXCVXyVUcfuRdmop9fkVUi2IzREPnrZmKxXxFeBQv21eEB4I5BMduiGrho3kVm/s547QuumI+HlhxSE4RXbGiq8XV4iqqRZEMMVgqFsdhiGzyZsnEZoh6U3R1uDpMlfBAkQzRQSsWx2GYsmM3lBx3YDXEcKtIjsMQFavYDasbq82wubHmxnCKWFDyxjVEkjfBahhdja4mV+GpisMQnqrYDeUAsSAezG1TQglFchyGUlmEw9v4hQocCys6BcVmKEkXrIbolXk7q+IY3sJhmF3NrhZXi6vkKryPF2oqTpYvHIbNVfR9gnIEWhBHwtk1sNe/kBzHwoZGxqs+M75IjtUQ2eRdsCrhgaAcPxfshmRVKEO+YC2OrrbsaBXbpA1lYDVEV6FYFsohdNSmnDVHtXQpdcFuiOavaFXYKTrSqoBOVi0y+iu62lxtrnZXu6viZwNoVYgVgYWuxuxoFYu9fqks7PUrIseKxRDtghfuqpxg53W5ihUBRTiXIhmiAqrcSsAjOl9HQFesWBy7oTiMYDOUmwABSIZyG0DQ1eJqcZVcJVdxIYBXDCeS4zCERyniWkJkhEcp4mpCxlWL6GhqlIsOgmyXNxEaNhEyL9E1rBNkXlCZjSU7dsPsana1uIpqEYT3KVZD1JAiOeLBnDec9lvYDbur3dXhKjpooJyWV6yGGHwUydEenNDLKeIRBTdTkmMzxOCjSIaoWMXi6MYQ7Cm6sebGWjWUvHVgW4gTAAtdja5GV+GpimQIT1UsjsNQanMAm6HUpiAZorJ4SaZlubeQgOQ4FuL838JmiKQr4r4DZx6HARaSYXY1u1pcLa6Sq3K1hXB1KDiSYXMVfZ/iMIT38ZHRJusEgpJjQVpIaGS8OtOwz6Ao2RREcrioJTxQHIaoFkGyKpQhX7AGx4tqVUitOPZVWdhcWFgNMfgAq6SXa7OiK0a1VCl1weLYDUtytIqtcrOoAK1aZPRXdLW52lztrnZXpdQJaFWI8wALL6pVIY73LeyrsnBiYGE1lBwLDr49wx10w93JEIHdEJeSBHErSRBXaHjZreGcXuGFpYZzeoI4p7ewOHZDXDpSxG0rTg6uoS2shtnV7GpxtbhKruKSKq8Yti5JFyTHYShXv3CRDpeCBHG/ind5G1YEFIepQ7IpyHZ5CWlugPDT+ADxRKhcLVgGWOhqdhW3qgRRFxF2URc8/W046Vd4aj8RKlcAFgdKxtNw3VIQNy4VXe2udldx0UmRFDvih4XFcRiiCnmi2/VSHBA3sxRdza5mV1GFimSI+0+KxXEYVn9w7YbIMU/Bu9yQE8QNPkVyHIa4Oq3YF8aQHJthjI5mDMcGFSVvmVHyJlgNyVVytboK91QchnJlTbAbyqU1QTy4MEptCpLjWCiXwPlkYpf73nLvEz2BILxPsRlK0gWrIa748db5xOI4DJurzdXuand1mIqFhML78B0XBhYOw+gqrgUK4gKzIied99y73LxTJMdhiEbGCxRzRzI5VkNkk89idrk7LoheQ7EbDqvCPKwKSyiOrsbsaBVbpA0VYDVEV6FYDJFe1GaRK44NWBy7oTR/QatCuSyuSKsCyrBqoVAcXY2uRleTq8lVKfUAtCrEVbyFrlJ2tIrFAUGpLBwQVESOFYsh2kXBdWS0C75M2XFlT7CKcwmSobhRZ8Qww4tFHZsAC4tjNxSHEWyGcoU3AskQ6VV0tbvaXR2uDlOxNVD4UElvknTBYQiPUsRVVvZfBAILcUmVfQf38Ra6imwqop8Eolp4StuxOFAqkoM2rwiVS7Kh/0VJ4orewuJoRS3xA09ee49W1NglUEyuwrl4mjpxGGZXMYRW/C46MflasWrpXlndK0vCA0Wr+d5cbZ4cdGKC3R/R3dgwC7gIIG1zSGsR7IYpOeI2L/s6zvlLg8Q5f0VyVW4Dc6nL6K/oKsZCPhLSdfTH13p0tOY/vPnr6D9x6OgveFGHYcyOzTBFw+wWysr8xG5oPdeQq++C6Gm5HEawnmuE7k/rrsJ3OMcDR/4FZexWrFoOQ8ZufE3GbsEUHC+qZVMuvSu6aiPkiDZCjkj+CHJj1S1IaJkZJbQUrIZo84r8NV7MGPL2Fo6Vh4zdgslV8R0gmrSiq+jEGgHJvgbnEqTi6GrNjt2wudo8OfKqBEF/RHdjwyzIfJ4nYiPLbBEok2LB4givZtfA1T7MvoZM1xVdFd9pQDJsrmKQ4GWhkduwr/Xs2A2Hq2NN+0YJydHVGB3J0R4hK/+C2S0Uy7zO5wWLYzeUe/9cDrJuLxa6P224Kr7TgGOhDOOKfZUDTgjK1yhahiglR1dzdLRSl4MBiuRomceIvtCNVbeADFWkDMuwit0QuzCK8OrB7+2Ia1lz4jBMrsJ3+GTRwLX6ha7i9RV8x37I1F6+BudSrIbVVVnABLbgeFE9OXAuRX/EMGPN1mmHTOJ5SXzIJF4wJcdqKO/l4OJrZS2UD4zSC12F7/A5poHbeIrNVQzYvC43ZFtfvtbJcATHi7q2Xoa8ZEbR1Zgdm2GKjmbMV/6HvleGs6lvlhG0zHfZZBEsqxxkA18sdH/acBW+gxwPxFGKrmLARjlg5i5fk3fQCKbi6GrOjlbqspqvaMkZtmkx0R9Bbqy6BdtKHrKXLyg7r4LFEV6N18IE20uebJvJzBdd/KcKk3O56Bi38aKDycO/Cy9b3J3rRccCsHJLF77o/ZI2ONviy7OG28TIvtgOLEyWMzDK5cLdGSsQePFCiHZqgZmc60UXv5LvIrRVbhcd4/mQ3+/Zv9ub80gXdl1W8RdX53jRI114OKd84YvNfLFDXiayWr/YyyTJSSXlauWD2fmy0y/PHRdd/A3fxdF/44uOwEXKRxbu5buycr/Y04x5urHnPZdw4avuacuUL3x5Vr3YbBc7mI3g5RcB9/gKXnARcLm/4HUWQabvwjJ/X4x6lxc5IbDHSy8CNvWT2MQwb1yd5TynMr6Ltib3AiQN2Llf3C46uumB9og7+8YXHSHk6MLk38V5WmFEAsYXXc5uKnfndNGTp00uDyymC19sloudus4KM1dnHEtdXC6MchYe68DwDOpDvPBFx1uNgjI5p4vO/QOFKDz8uzlfuDuXi26n0SdTuvBFr5e0yVFt5cuz2sVmv9gZXiYthAuXC3dnaV/COZidlv25uMBvXKwcMLVfTBed+wctH5z2W9+tnkdEDsYXvccLe720cdHHJW3DywQHB43dJt7JszijHpMwOZeLXqCjnXZOP4Ui3J3bRccbqYK8Tg1pw8vEgpz6V+a2gLdlBczYF1ZDJEwRZYk2jZ17vClrYjOsrnIjoICGO3i5wfiid2SuC5N9lfssRe6yFi6VR3XHbhhdjc2QO+SF5OjGslvAtD0JVkNMvRSLIwp9gGXJAShLDoKm4jog8bZJlPfULY4XHe/74jdDMg/7KpZ9FbthdlUW5oGI+RVdpehIjv6I6saaW+hWAjJ3VyyOfWHi6EULI8m6g6A9Tl7Dqlgs01iaX1wuOnetWhjyZlb5Klmu/EV4MVVXW3S04pcJvKInqVsJyEtbFc2YvAcv//XXDx/We29/+v3bp0/82tvLi3D/8eeH3z5++/T19w8/fv3jy5cfPvzPxy9/4Jf++9vHr/j8/eO3+b8zZ5++/mt+ToP//vzlE9NfP/i3w+OvJmzz4tuz4Q4zMBduXpiIj01E3lFSG/yKsGZGRnlhIz22kfmlNGpjcouPbOyy0uNKxhw748OslI2JgvdBaHHE5gU62gsbdENx1PctDr60qib4jufD4uibrCReXpSczP2ri4n0wsS4oTRiuKE4dnnBzQlJR875YV5iuiMz+Z0zg6uLWjHjccXEjZ/OYGPlZe4nlIdZ2blprmXZmDyezcq08TArW/cozQq0psd92MZP53QvLl9PfLnoUctPm4TMuar7By8QPewJ4y43NSXPTn7sZPvs8AaTZmfOUR5mZ+epZflpmUOhWaA31Ut73CGnnZfW1WqvxVne5hv98fi2G1fmXNQGljnPvCQjf1eYGz/ny21qZLqXV+rch3hpY1OrfPRebfBp+Yc28q5AQlmOMfcRxmMbGxed8441Ss4e0fOSa35pY9OXNm8qcwpEj23sHJSSOajXSmov20neDfhxWDNJl/Dn/9nYuCilFUFRDm+zMKxaLyXxt/KRPIzLIT22seuJKa1ajXT10L9low6z0cfbbORgNmabfWijbDy0leUZrdQ3WRjW+c1NlTdZ4HXGlY+53PHYxqZe54qV9cFzWd+7r/E3ipMfoMVJb6zWbB46sb/Jxh1ZidbvzHlof1tLaT7Ot017pfC+NmKtlpfa+ttstGYx7YzhHtvIz7aUnYWzlrKzcNpSqD7tXtviHN7xzDWrh8nYDtGl+hB9rZLvhle6Y85U75gz7XOTquWG6GFuanp6nlHzDfOM8wDsceCztUE2iZy78pvyqLsJT/fh7Rpy1JfBJPvR4yBu5NWpT77UzPel2ndGkpfq3LN67GZjF4JVT8ncn3hsZJ+ddMnOddnlpZG2C0rbcvc+3ACvaR3H+VTJ4vy5p/Iwzt8Z4T8UsIzwHwh4m5HebcYxI9THM462jUvjim351SbuaPGls7a6jeesRLwzy7MFvrDQno/zW382zm/j+Ti/h2fj/K2Fozh/m4/DOL/n5+P8vY2zOH9r4zDO7/XZ6GVn4Sx62Vk4jV76eDp62RfnWZy/t3EW5+9s3JGVwzh/21IOY/RB72vjNM7f2jiM80d/tqXsLJy1lJ2F05YSQ3zav7bleRjob0fXaMECzSXsh6NrDGXrHFaxtV8cbHaHb4sVcnwYK+BPbjweWJIPkFcH+S4lMdwRlsZwR1wawx2B6Ws5OotMY9zukA7bRxuXtfi/E5zyHx7yau75cTXvNp9OY8IYy7NBYdxuPh1GhXG7/XQUFsbYno8L8SdSngsM9yaOIsN9Vg5Dw7jbfDqNDV8xchYc7o0cRocxlWcHva2Js1Fva+J42Evt6WHvlTI9CxFfMXIWI26N3JKbwyhx32oOQ7y424e6xchpoLg3chgp4o+sPNlq8tOzqq2J41aTn59X7cv0MFrcD7yn4WJJ7xwuvogjxuP1qVjKDeFioTvCxVLvCBdLuyNcfCVHh+FiGe8cLl5mBSmE8KZlyOT7/JM3Bx8ipRt8ZbdFdO4rVO7wFaI7fOWVHB36CrX39ZUUPHKc84PH6977Lj+ssGCkt44adXVNo9HTA8/OxDbiO8vI1sRZRg7jzo2J7XrNUT62Fo6ycbhmtLHQn3ar/rRX9aedaru1VC9z5nrpd/5fE2t39KTtlp603dKTtlt60nZLT7rbqLph/7CVbJXc2q6Sxw2V3MMdldzjHZXc0w2VvC9bm3XO4Wq3ytnvCFv7LWFrvyVs7e29y7ZT9LLttCnbO/x23OK34xa/He/utyP4mYKRx+OyHXf47bjFb8ctfjve3W8HDS/bsVkSHzf4bQp3+G0Kd/htCu/tt3zp0ZYJQnk8lqVQ7ihbuqVs6y1l2969bO2MYOIrpZuyvcNv4y1+G2/x2/jufhu9VPhW6uOyjXf4bbzFb+Mtfhvf3W+jhcizIsPYlO0dfptu8dt0i9+md/fblPzYYKqPx7KU7vDbdIvfplv8Nr273+LP0WnZ5tg3ZXuH3+Zb/Dbf4rf53f02+924mNvGb/Mdfptv8dt8i9/md/fbQt7fFmpvWsOfa9C2hj/Hw/i2jQBM8LV+0maFOO0uRB3X8m4P7LyWS76jlne7YMe1/FqOzpav0m4bLNZsu5T1Gvf8nY2AZAudk9smeCr9jmoed1QzhTuqmeIt1TzuqObtVSn8JRCp5hLetk45Ryibf6TZfz+u5t0u2HE1U72lmtst1dzvqOZXcnRYzbvbW/dUc/Pd2zw2rXl3fSuVy+pg6fVxDW1vcKXe1wZITnNP5y3j4WwYvqdNm+3ovZHLib+a6W1GutXx5LKZCe2uPZ0exkx1f+Pa1sAeH8ZMuztcp4cxU9t1tUeHMdPuBtfpYcy02yM7O4y5N3F0GHOflcPDmGm3O3Z6GPMVI2eHMfdGDg9jpvb0DYStibNjZVsTp8fKUn/++OIrZXp2GPMVI2eHMbdGbsnN4WHMfas5PEeZentnI6eHMfdGDg9jpt2O2GGr2Zk4bDU7E8etZjx/M2xfpqd39LcD7+FhzDS2E67nD2O+jCM2JwbS7pBNasPWt3ocjyPx3TZYTvg7khqh5cfvrsq7fbBYmt9uL/3yPi+2+NLM7mi3r9i9eL/Z9+Hv1khrxaKatjGxyw6FYJ00hYu/fZ+d18rWopLJFB+X7W59K9ZoLwabnN8UQ3c/R5F2t8VyuCFyzeHpyDWHGyLXHJ+OXHO8IXLN8enIdW/i7EVS8YbINccbItdXjBy+SyreELnm+HTkujVxNgZvTZyOwfmGizevlOnhG6XiDZHr1sgtuTl9qVS8IXLNqb2zkdPIdW/kMHLN+enIdWvisNXkGyLXnJ+PXPdlehi57gfew8g153ePXK9xBD1eAcv5hsg151uiq7KLAmILFv/GRu2xle1WgZ8BntzLm2K0Ya/EnUNwfHx3J5cbrnrn8vRV71xuuOqdy9NXvXO54ap3Lk9f9d6bOHzZ5w1XvTPdcNX7FSOHMRrdcNU709NXvbcmDkcbuuGqd6bnr3q/UqaHMRrdcNV7a+SW3By/+POO8KrmdzZyHKPVG6565/r0Ve+ticNWU2+46p3r81e992V6GqOVG6565/bOV71fxhGbff7cyg0x2vai13GMtnsb4XmM1to7x2hzpS562fZN/Lu763Uco/XwdIzW4w0x2v6e11GMtnvx23GMtrvkdRijbU2cxWjbrBy/kb3dEKPtjZy+k73dEKM9v5eVn9/LynfsZeUb9rJeKdPTN7O3G2K03t45N6cxWr8jvBrjnY0cx2hbI4cxWtnd5zr8WwY7E4d/zGBn4vivGYQb1mu3ZXoao20H3sMYrWw3sG6I0V7EETE+3gEuMTwfo5XtLa7TGK1sb3Gdxmhl+0eybonRYi1etu1xjLY34ufnp8G8qaB6RwW1G7boy3YbyU9RvrwP8N3G+GtJOfSVdMeaa0nvveY69xBszMjXAOdv+UqyMJoNPj5bWlJ5flJQEj07KSi7G1ynk4Kyv8B1Mikouz+6cDopKGk8OynYmziaFOyzcjgpKLt7W6eTgleMnE0K9kZO/1LT7trWYXizM3EY3uxMHIc3N/yJo1fK9GxS8IqRs0nB1sgtuTmcFOxbzWE8X0p5ZyOnk4K9kdNJwW4x+7DV7EwctpqdieNWs7ukdepn2zI9nBTsB97TSQHld54U5OLDRN68kKfccUGr3HJBq9xyQavcckGr3HJBq2wvaN3w3sWX4eLmKlLZXtA6nVrs72edxvO13BHPV7ohnt/3bkfvDdybOHpx4GkfuzOxDW7OMrI1cZaRwxBrZ2K7CHWWka2Js4wcLoU1euMa9FFG9iaOMnK6Er4zUZ9+t+bexFlGDjeQdybo6Ve27k2cZeTw/MjORH7etfLzrpWfd6349Mtn9ybOMnJ46npnYn/romXyMa08DIBes2KT9qes+F8zn+NrfauVw1F6lBtG6fR8V5qe70rT813p/mbqWUba0/5+ej/2jS8qnpN0f11M6W9850y5/A1MCm/8Q5ovXlxTNm+p2B7rtRKZuxZeMfTCwvavGx9V7NbCUb0e/oXlXdgTn4694tOhV3xTLv45f/z4y+dvP3359ZePv3/+9et/5/f+YlPfPn/8+csn/fHff3z95fK/v//vb+t/fv72+cuXz//56bdvv/7y6V9/fPvElvj/PgT95x+pzGWGVHL55w8fogghTyF0FiKE2bvOf8Y//+Ik/R8=",
      "is_unconstrained": true,
      "name": "create_proposal_internal"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "delegatee",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "delegate",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2633295041654830480": {
            "error_kind": "string",
            "string": "Function delegate_internal can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "delegator",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "delegatee",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "delegate_internal"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16238081572903391961": {
            "error_kind": "string",
            "string": "insufficient council approvals to cancel"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4756330914173469558": {
            "error_kind": "string",
            "string": "emergency cancel only in hybrid mode"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "900405183110375111": {
            "error_kind": "string",
            "string": "already executed"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEElAAAARycCAQRFJwICBAA7DgACAAEnAEMEAyYlAAAXSB4CAAIAHgIAAwAtCAEEAAABAgEnAgUACy0OBQQtCAEFAAABAgEnAgYAQC0OBgUtCAEGAAABAgEnAgcAQy0OBwYeAgAHAB4CAAgAMyoABwAIAAknAgcBASQCAAkAAACwJQAAF24nAggAAC0IAQknAgoEBAAIAQoBJwMJBAEAIgkCCi0KCgstDggLACILAgstDggLACILAgstDggLKwIACgAAAAAAAAAAAgAAAAAAAAAALQgBCycCDAQFAAgBDAEnAwsEAQAiCwIMLQoMDS0OCA0AIg0CDS0OCA0AIg0CDS0OCA0AIg0CDS0OCg0tCAEMAAABAgEtDgkMLQgBCQAAAQIBLQ4LCS0IAQ0AAAECAScCDgQALQ4ODS0IAQ8AAAECAScCEAEALQ4QDycCEQAGJwISBAEkAgAQAAAB0yMAAAGMLQgBAicCAwQEAAgBAwEnAwIEAQAiAgIDLQoDEy0OERMAIhMCEy0OCBMAIhMCEy0OCBMtDgIMLQ4LCS0OEg0tDhAPIwAAAl8tCg4CIwAAAdwMIgJDAyQCAAMAABbCIwAAAe4tCwwCLQsJAy0LDwstCwMTACITAhMtDhMDLQgBEycCFAQFAAgBFAEnAxMEAQAiAwIUJwIVBAQAIhMCFj8PABQAFi0CAgMnAAQEBCUAABeALQgFAwAqAxIULQ4RFC0OAwwtDhMJLQ4SDS0OCw8jAAACXy0LDAItCwkDLQsPCwoqCxARJAIAEQAAAoEnAhMEADwGEwEnAgsAMScCEQQCJAIAEAAAAsgjAAACmC0CAgMnAAQEBCUAABeALQgFEwAqExEULQ4LFC0OEwwtDgMJLQ4RDS0OEA8jAAADVC0KDgIjAAAC0QwiAkMDJAIAAwAAFjwjAAAC4y0LDAItCwkDLQsPEy0LAxQAIhQCFC0OFAMtCAEUJwIVBAUACAEVAScDFAQBACIDAhUnAhYEBAAiFAIXPw8AFQAXLQICAycABAQEJQAAF4AtCAUDACoDEhUtDgsVLQ4DDC0OFAktDhINLQ4TDyMAAANULQsPAwoqAxATJAIAEwAAA24nAhQEADwGFAEtCg4CIwAAA3cMIgJDAyQCAAMAABW2IwAAA4ktCwwCLQsJAy0LDRMtCwMUACIUAhQtDhQDLQgBFCcCFQQFAAgBFQEnAxQEAQAiAwIVJwIWBAQAIhQCFz8PABUAFy0OAgwtDhQJLQ4TDS0OBw8AKhQSAy0LAwIeAgADADMqAAIAAwAJJAIACQAAA/0lAAAX3y8KAAsAAhwKAgkCHAoJAwAcCgMCAicCAwICCioCAwkkAgAJAAAEKSUAABfxLQsGAi0IAQMnAgYEBAAIAQYBJwMDBAEAIgMCBi0KBgktDggJACIJAgktDggJACIJAgktDggJLQgBBicCCQQFAAgBCQEnAwYEAQAiBgIJLQoJCy0OCAsAIgsCCy0OCAsAIgsCCy0OCAsAIgsCCy0OCgstCAEJAAABAgEtDgMJLQgBAwAAAQIBLQ4GAy0IAQsAAAECAS0ODgstCAEMAAABAgEtDhAMJAIAEAAABSIjAAAE2y0IAQ0nAg8EBAAIAQ8BJwMNBAEAIg0CDy0KDxMtDgITACITAhMtDggTACITAhMtDggTLQ4NCS0OBgMtDhILLQ4QDCMAAAWuLQoOBiMAAAUrDCIGQw0kAgANAAAVMCMAAAU9LQsJBi0LAw0tCwwPLQsNEwAiEwITLQ4TDS0IARMnAhQEBQAIARQBJwMTBAEAIg0CFCcCFQQEACITAhY/DwAUABYtAgYDJwAEBAQlAAAXgC0IBQ0AKg0SFC0OAhQtDg0JLQ4TAy0OEgstDg8MIwAABa4tCwkCLQsDBi0LDA0KKg0QDyQCAA8AAAXQJwITBAA8BhMBJAIAEAAABg0jAAAF3S0CAgMnAAQEBCUAABeALQgFDQAqDREPLQ4BDy0ODQktDgYDLQ4RCy0OEAwjAAAGmS0KDgIjAAAGFgwiAkMGJAIABgAAFKojAAAGKC0LCQItCwMGLQsMDS0LBg8AIg8CDy0ODwYtCAEPJwITBAUACAETAScDDwQBACIGAhMnAhQEBAAiDwIVPw8AEwAVLQICAycABAQEJQAAF4AtCAUGACoGEhMtDgETLQ4GCS0ODwMtDhILLQ4NDCMAAAaZLQsMBgoqBhANJAIADQAABrMnAg8EADwGDwEtCg4CIwAABrwMIgJDBiQCAAYAABQkIwAABs4tCwkCLQsDBi0LCw0tCwYPACIPAg8tDg8GLQgBDycCEwQFAAgBEwEnAw8EAQAiBgITJwIUBAQAIg8CFT8PABMAFS0OAgktDg8DLQ4NCy0OBwwAKg8SAy0LAwIKKgIIAwoqAxAGJAIABgAABz8lAAAYAy8KAAIAAxwKAwYCHAoGAgAcCgIDAi0LBQIvCgACAAUcCgUGAhwKBgIAHAoCBQIMKgMFAgoqAhADJAIAAwAAB4QlAAAYFS0LBAItCAEDJwIFBAQACAEFAScDAwQBACIDAgUtCgUGLQ4IBgAiBgIGLQ4IBgAiBgIGLQ4IBi0IAQUnAgYEBQAIAQYBJwMFBAEAIgUCBi0KBgktDggJACIJAgktDggJACIJAgktDggJACIJAgktDgoJLQgBBgAAAQIBLQ4DBi0IAQMAAAECAS0OBQMtCAEJAAABAgEtDg4JLQgBCwAAAQIBLQ4QCyQCABAAAAh9IwAACDYtCAEMJwINBAQACAENAScDDAQBACIMAg0tCg0PLQ4CDwAiDwIPLQ4IDwAiDwIPLQ4IDy0ODAYtDgUDLQ4SCS0OEAsjAAAJCS0KDgUjAAAIhgwiBUMMJAIADAAAE54jAAAImC0LBgUtCwMMLQsLDS0LDA8AIg8CDy0ODwwtCAEPJwITBAUACAETAScDDwQBACIMAhMnAhQEBAAiDwIVPw8AEwAVLQIFAycABAQEJQAAF4AtCAUMACoMEhMtDgITLQ4MBi0ODwMtDhIJLQ4NCyMAAAkJLQsGAi0LAwUtCwsMCioMEA0kAgANAAAJKycCDwQAPAYPASQCABAAAAloIwAACTgtAgIDJwAEBAQlAAAXgC0IBQwAKgwRDS0OAQ0tDgwGLQ4FAy0OEQktDhALIwAACfQtCg4CIwAACXEMIgJDBSQCAAUAABMYIwAACYMtCwYCLQsDBS0LCwwtCwUNACINAg0tDg0FLQgBDScCDwQFAAgBDwEnAw0EAQAiBQIPJwITBAQAIg0CFD8PAA8AFC0CAgMnAAQEBCUAABeALQgFBQAqBRIPLQ4BDy0OBQYtDg0DLQ4SCS0ODAsjAAAJ9C0LCwUKKgUQDCQCAAwAAAoOJwINBAA8Bg0BLQoOAiMAAAoXDCICQwUkAgAFAAASkiMAAAopLQsGBS0LAwwtCwkNLQsMDwAiDwIPLQ4PDC0IAQ8nAhMEBQAIARMBJwMPBAEAIgwCEycCFAQEACIPAhU/DwATABUtDgUGLQ4PAy0ODQktDgcLACoPEgUtCwUDCioDCAUKKgUQBiQCAAYAAAqaJQAAGAMtCAEFJwIGBAwACAEGAScDBQQBACIFAgYnAgkECwAqCQYJLQoGCw4qCQsMJAIADAAACtstDggLACILAgsjAAAKwC0IAQYAAAECAS0OBQYnAgUECy0KDgIjAAAK9gwqAgUJJAIACQAAEkwjAAALCC0LBgIAKgISBi0LBgMcCgMJBRwKCQYAHAoGAwUAKgIRCS0LCQYAIgJDCy0LCwkcCgkMBBwKDAsAHAoLCQQnAgsEBAAqAgsNLQsNDBwKDA0EHAoNCwAcCgsMBCcCCwQFACoCCw8tCw8NHAoNDwQcCg8LABwKCw0EJwILBAcAKgILEy0LEw8cCg8TARwKEwsAHAoLDwEnAgsECAAqAgsULQsUEycCCwQJACoCCxUtCxUUJwILBAoAKgILFi0LFhUcChUWAhwKFgsAHAoLFQIAKgIFFi0LFgscCgsWAhwKFgIAHAoCCwItCAECAAABAgEtCAEWAAABAgEtCAEXAAABAgEtCAEYAAABAgEtCAEZAAABAgEtCAEaAAABAgEtCAEbAAABAgEtCAEcAAABAgEtCAEdAAABAgEtCAEeAAABAgEtCAEfAAABAgEKKg8QICQCACAAAAxiJQAAGCctDgMCLQ4GFi0OCRctDgwYLQ4NGS0OBxotDhAbLQ4THC0OFB0tDhUeLQ4LHy0LBAMtCAEEJwIGBAQACAEGAScDBAQBACIEAgYtCgYJLQ4ICQAiCQIJLQ4ICQAiCQIJLQ4ICS0IAQYnAgkEBQAIAQkBJwMGBAEAIgYCCS0KCQstDggLACILAgstDggLACILAgstDggLACILAgstDgoLLQgBCQAAAQIBLQ4ECS0IAQQAAAECAS0OBgQtCAEKAAABAgEtDg4KLQgBCwAAAQIBLQ4QCyQCABAAAA2HIwAADUAtCAEMJwINBAQACAENAScDDAQBACIMAg0tCg0PLQ4DDwAiDwIPLQ4IDwAiDwIPLQ4IDy0ODAktDgYELQ4SCi0OEAsjAAAOEy0KDgYjAAANkAwiBkMMJAIADAAAEcYjAAANoi0LCQYtCwQMLQsLDS0LDA8AIg8CDy0ODwwtCAEPJwITBAUACAETAScDDwQBACIMAhMnAhQEBAAiDwIVPw8AEwAVLQIGAycABAQEJQAAF4AtCAUMACoMEhMtDgMTLQ4MCS0ODwQtDhIKLQ4NCyMAAA4TLQsJAy0LBAYtCwsMCioMEA0kAgANAAAONScCDwQAPAYPASQCABAAAA5yIwAADkItAgMDJwAEBAQlAAAXgC0IBQwAKgwRDS0OAQ0tDgwJLQ4GBC0OEQotDhALIwAADv4tCg4DIwAADnsMIgNDBiQCAAYAABFAIwAADo0tCwkDLQsEBi0LCwwtCwYNACINAg0tDg0GLQgBDScCDwQFAAgBDwEnAw0EAQAiBgIPJwIRBAQAIg0CEz8PAA8AEy0CAwMnAAQEBCUAABeALQgFBgAqBhIPLQ4BDy0OBgktDg0ELQ4SCi0ODAsjAAAO/i0LCwMKKgMQBiQCAAYAAA8YJwIMBAA8BgwBLQoOASMAAA8hDCIBQwMkAgADAAAQuiMAAA8zLQsJAy0LBAYtCwoMLQsGDQAiDQINLQ4NBi0IAQ0nAg8EBQAIAQ8BJwMNBAEAIgYCDycCEQQEACINAhM/DwAPABMtDgMJLQ4NBC0ODAotDgcLACoNEgQtCwQDCioDCAQKKgQQBiQCAAYAAA+kJQAAGAMtCwIELQsWAi0LFwYtCxgHLQsZCC0LGgktCxsKLQscCy0LHQwtCx4NLQsfDxwKBBAAHAoGBAAcCgcGABwKCAcAHAoJCAAcCgoJABwKDQoAHAoPDQAtCAEPJwIRBAwACAERAScDDwQBACIPAhEtChETLQ4QEwAiEwITLQ4CEwAiEwITLQ4EEwAiEwITLQ4GEwAiEwITLQ4HEwAiEwITLQ4IEwAiEwITLQ4JEwAiEwITLQ4LEwAiEwITLQ4MEwAiEwITLQ4KEwAiEwITLQ4NEy0KDgEjAAAQewwqAQUCJAIAAgAAEI4jAAAQjSYcCgECAAAqAwIEACIPAgYAKgYBBy0LBwIwCgACAAQAKgESAi0KAgEjAAAQey0LCQMtCwQGLQsKDC0LCw0MKgEMDyQCAA8AABDcIwAAETIAIgYCEQAqEQETLQsTDwAiAwITACoTARQtCxQRACoPERMtAgYDJwAEBAUlAAAXgC0IBQ8AIg8CEQAqEQEULQ4TFC0OAwktDg8ELQ4MCi0ODQsjAAARMgAqARIDLQoDASMAAA8hLQsJBi0LBAwtCwoNLQsLDwwqAw0RJAIAEQAAEWIjAAARuAAiDAITACoTAxQtCxQRACIGAhQAKhQDFS0LFRMAKhETFC0CDAMnAAQEBSUAABeALQgFEQAiEQITACoTAxUtDhQVLQ4GCS0OEQQtDg0KLQ4PCyMAABG4ACoDEgYtCgYDIwAADnstCwkMLQsEDS0LCg8tCwsTDCoGDxQkAgAUAAAR6CMAABI+ACINAhUAKhUGIC0LIBQAIgwCIAAqIAYhLQshFQAqFBUgLQINAycABAQFJQAAF4AtCAUUACIUAhUAKhUGIS0OICEtDgwJLQ4UBC0ODwotDhMLIwAAEj4AKgYSDC0KDAYjAAANkBwKAgkAACoDCQsvCgALAAktCwYLLQILAycABAQMJQAAF4AtCAUMACIMAg0AKg0CDy0OCQ8tDgwGACoCEgktCgkCIwAACvYtCwYFLQsDDC0LCQ0tCwsPDCoCDRMkAgATAAAStCMAABMKACIMAhQAKhQCFS0LFRMAIgUCFQAqFQIWLQsWFAAqExQVLQIMAycABAQFJQAAF4AtCAUTACITAhQAKhQCFi0OFRYtDgUGLQ4TAy0ODQktDg8LIwAAEwoAKgISBS0KBQIjAAAKFy0LBgUtCwMMLQsJDS0LCw8MKgINEyQCABMAABM6IwAAE5AAIgwCFAAqFAIVLQsVEwAiBQIVACoVAhYtCxYUACoTFBUtAgwDJwAEBAUlAAAXgC0IBRMAIhMCFAAqFAIWLQ4VFi0OBQYtDhMDLQ4NCS0ODwsjAAATkAAqAhIFLQoFAiMAAAlxLQsGDC0LAw0tCwkPLQsLEwwqBQ8UJAIAFAAAE8AjAAAUFgAiDQIVACoVBRYtCxYUACIMAhYAKhYFFy0LFxUAKhQVFi0CDQMnAAQEBSUAABeALQgFFAAiFAIVACoVBRctDhYXLQ4MBi0OFAMtDg8JLQ4TCyMAABQWACoFEgwtCgwFIwAACIYtCwkGLQsDDS0LCw8tCwwTDCoCDxQkAgAUAAAURiMAABScACINAhUAKhUCFi0LFhQAIgYCFgAqFgIXLQsXFQAqFBUWLQINAycABAQFJQAAF4AtCAUUACIUAhUAKhUCFy0OFhctDgYJLQ4UAy0ODwstDhMMIwAAFJwAKgISBi0KBgIjAAAGvC0LCQYtCwMNLQsLDy0LDBMMKgIPFCQCABQAABTMIwAAFSIAIg0CFQAqFQIWLQsWFAAiBgIWACoWAhctCxcVACoUFRYtAg0DJwAEBAUlAAAXgC0IBRQAIhQCFQAqFQIXLQ4WFy0OBgktDhQDLQ4PCy0OEwwjAAAVIgAqAhIGLQoGAiMAAAYWLQsJDS0LAw8tCwsTLQsMFAwqBhMVJAIAFQAAFVIjAAAVqAAiDwIWACoWBhctCxcVACINAhcAKhcGGC0LGBYAKhUWFy0CDwMnAAQEBSUAABeALQgFFQAiFQIWACoWBhgtDhcYLQ4NCS0OFQMtDhMLLQ4UDCMAABWoACoGEg0tCg0GIwAABSstCwwDLQsJEy0LDRQtCw8VDCoCFBYkAgAWAAAV2CMAABYuACITAhcAKhcCGC0LGBYAIgMCGAAqGAIZLQsZFwAqFhcYLQITAycABAQFJQAAF4AtCAUWACIWAhcAKhcCGS0OGBktDgMMLQ4WCS0OFA0tDhUPIwAAFi4AKgISAy0KAwIjAAADdy0LDAMtCwkTLQsNFC0LDxUMKgIUFiQCABYAABZeIwAAFrQAIhMCFwAqFwIYLQsYFgAiAwIYACoYAhktCxkXACoWFxgtAhMDJwAEBAUlAAAXgC0IBRYAIhYCFwAqFwIZLQ4YGS0OAwwtDhYJLQ4UDS0OFQ8jAAAWtAAqAhIDLQoDAiMAAALRLQsMAy0LCQstCw0TLQsPFAwqAhMVJAIAFQAAFuQjAAAXOgAiCwIWACoWAhctCxcVACIDAhcAKhcCGC0LGBYAKhUWFy0CCwMnAAQEBSUAABeALQgFFQAiFQIWACoWAhgtDhcYLQ4DDC0OFQktDhMNLQ4UDyMAABc6ACoCEgMtCgMCIwAAAdwoAAAEBHhFDAAABAMkAAADAAAXbSoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJi0BAwYKAAYCByQAAAcAABeWIwAAF58tAAMFIwAAF94tAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAX2S0BCggtBAgLAAAKAgoAAAsCCyMAABe1JwEFBAEmKgEAAQVyMQyWM6ynPzwEAgEmKgEAAQVCAeHELYTDdjwEAgEmKgEAAQW6uyHXgjMYZDwEAgEmKgEAAQXhWUEoUrkS2TwEAgEmKgEAAQUMfuG+VTbmxzwEAgEm",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "emergency_cancel"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15312957078770032001": {
            "error_kind": "string",
            "string": "insufficient emergency approvals"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2547213599764567162": {
            "error_kind": "string",
            "string": "emergency execute only in hybrid mode"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7715731631402574514": {
            "error_kind": "string",
            "string": "proposal canceled"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "900405183110375111": {
            "error_kind": "string",
            "string": "already executed"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "emergency_execute"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4422981737823726437": {
            "error_kind": "string",
            "string": "timelock not elapsed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5846850200630327512": {
            "error_kind": "string",
            "string": "not queued"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "execute"
    },
    {
      "abi": {
        "error_types": {
          "14487322055111218121": {
            "error_kind": "string",
            "string": "Function get_cloak_mode can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZlRbhs5DIbv4uc8iCIpSrnKoijc1C0MGE7gJgssitx9SUnU2AFGcB33JfnMyfwmKYriTH5vvu++vf38uj/+eP61efzn9+bbaX847H9+PTw/bV/3z0e1/t4E+yFp84gPmwybR9Ff+gngYVP0I5D+ts9qh0AK2aB0AOkQ4+YxgoFaYlRA7kD6FWiXiB1KByYHtyS3JLcIOkiHHB1SB/O0gX2FfmmE1CEGB7+EbkG3kFuIHHIHRgfpkKKDf4WAgwkGg9Ihk0PuUKKDNMAADv12hOAwLF0QIzp0QUS3JLuLDMihdBC3iFuyW6pjBtWxCtKAqmMVUofqGBuQQ+5gBVChJlOrhdguaW1QzViF1EGCAzmUDlnDoWAgHcyxBt3CITq4BdwCbrFEERhIB4wObiFwSB1YHaNoQA65g0VRwZab0IAdSofqPBnkDrZ3DJIls0JdwQo98wmjQ898IrdQz3xicOCW51S3jEFCB+mQuS2BBGxZFUtUBQAHduiZl0gOueVQMDr0rAq5hdzCbmG3JLek3LIqEh165iW7JffMSwEHbnmWUhpki6KBdLDdTUnBdjdZy7LdXcG2Q4PcwVJHxdqaCrI6lq2lNJAO1vkacIcSHDQtbF9acoNi/jRwC7gF3BLdEt2CVlHZIHeoyayQOlj5MRqwg/mcrAebGxpFsWQmdazk4KB/nHTdi+UwiUFqACHAIGlpgAAwiAcVJ/M81SZPPSlKyYmHzVxM9Q5rPJ0Wm+pJ/Tvb4u0OyU4ZBw2bbfNOfVUAQhzkHgCEQTTIVerx08i8t00A7dxpVJxqX2+kdwjUs6xvCZULgxabRWTnGVhFdHJbtJoQrNTbHkSIg8QpDltMTgiDho3CIBo0lHmopHGveJTt9KmUcZA4WZHUeDH0nQ8INGjYrA5qbPWoaYTDZh2hxovkviC598gwaNhSGOQ5RRk2GR6IR4l5KOehUg/4/P7+sPEp5uvrabezIeZsrNFh52V72h1fN4/Ht8PhYfPv9vBW/+jXy/ZYf79uT3pVK2V3/K6/VfDH/rAzen9Y7g7rt0bMpd+tq1WGgPp4IQHrElpnttOqhrLIECl0oRHXNTAyc9dQFljTmIWSwd3Q+QRWQ6GJBAGHkQ6QJaFFLjT4DulIfzcdFK1jVglCltV05EkoupU9ksjpTCJeSJQ7ZAPCHdIxiwUB3Q/tAKuxQLxHMPiXg4nWv/rClPWFgUmd6tDisUiJtBrKrEx1SHcN5fLZUFRjNZRZebCdBM0LLnm9h03qNBbEsfN1ykmrTWzmCGIcniAS3bBtz4NJIawGM5HgRMG3vjLyECG8bGNxUqdM0deWiZZS1yP/UmPST/VZwB1J+rS1rjGpUww0EqLP0+sak0LV4dsXV7fwEgsmvNSQyX6RZb9k4HWNPFtcr3WCpcKifCixWZ3qWwIv03h2Xn/UwFl9RD/yGcNtCmUs61km/iiOuMwdGOK6F5MKBY6+qvoORm7USGVo5HKbhs6go4XFvK4xqVAhrwyhdJNCIT9VCt/mgz6ojFasD0HrGpN1pQzuBmVe1hXKH6TT3jD0dPKNy4qjQhXzTRr3CAVG39HHtnzbThHwISzKZL8S/10NSGnEkiTfpiEyhjAdOtY18md3ykzhup0yU7h2pzB8urym6SxL4ylxPZ3TI5rSckSfL8mH45XpDnMx8x3m4nk0MY1omNejkU8PxpzvMBhfP4BNBp+ZBo+nHtY3vasaafZ8vxzVdtItGulymEyz5/tQ0Ju68tnKfHwonj05hbhkNejLoFURmo1gafGEU1oXmYcTz8I5f0/wQWQ2lIqXu76mXUb0UK5vZGPML/HGVpi8jxXhzzbTicJ0cLkqiqnCVVFcOTx9VPiiH7dP+9PFPxzfTeq033477PrHH2/Hp7Orr/+9+BX/h+XL6flp9/3ttDOl5b+W+uMfDOlBe94Xe2+sH2Ohh1iKfQS7Gu1q/vJuzvwP",
      "is_unconstrained": true,
      "name": "get_cloak_mode"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5874306019897513529": {
            "error_kind": "string",
            "string": "Function get_council_approval_count can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndThw7DMffZa/3InZiO+FVjqqK0m2FtAK0hSMdVbz7sTN2ZhdpIrrQG/ith/mPv+Jklt+774dvLz+/3j/8ePy1u/nn9+7b6f54vP/59fh4d/t8//ig1t+7ZD+q/sz7XaXdjex3TT8B6G/9CGW/g2QGMagKVQGyA0IA725Qb4KsFkSD5lCKQjNoDpQDqgOHhcMiYRFxqBDADubpAhSgj8hpv0NMASUgLuWw5LCUsJTqQBggDgwB7CDxCKEAC1CzgTUHVIeGAbxAThBAAX57hhIQFswB4pAxICxsUaBBdbAcLhCWGpYaFnNsAV6gmGMLkAOkAHtENqgOiAHs0JNJCmyX2IAdesY6lIDq0B3rYAnXcEqDAF6AEgSEBcICYcGwWKKytgRZQy7ADiUshRwoBahjJRlUB4tiAXawchcwaA7m/AL60KKJIsuqAdvaWYAc0BPO3UODDAFeAi5hKV4CphTgJWDyEjBjgJeAq5dAkpdAkpdAIAWUAC+BYA7wEkiGAE+vlLCUsFBYKCwcFvYSiECAl0BqWKqXQFoK8BJI8xLUhAFeggqWzGJgJdBIqy3zDrYuFhAHS13R8VVtXRR1rAoGsINNwAVKQHNomhayhzZZoJk/C4QFwgJhwbBgWLI1CRuIgyVzAQrQh1IfvSVAfSatabMJuUBYzPkOlkyqBqrM9ixrvwXcojNclixAskXjRINakHUB2yBP3b3aiYNo2EjvZRvvidOg1aZ6nI2kxB1Sg/p6WWjYGg4SJ0g4KDwASIPKoFABHPf2TqVONKgF2Q7kZBmyXQ76GGejmgatNouo32EN6hQ2TJY17uTLSbdGHCRBOGzIQX2VLTRsJQ0qg4YyDRUe90pE2XehhWoeJEE2Vnu8fbvp9+aYBdA3nIV6H1CnGpSHzXq4x5tL+JJLeJ8JBg0bp0GR0yzDJsOD2BEg16Fch0rr976+7ndxivn6fDoc7BBzdqzRw87T7enw8Ly7eXg5Hve7f2+PL/2Pfj3dPvTfz7cnvaor4/DwXX+r4I/748Hodb/enbZvxVyb363VakNAfbyQgG0J7TOurqEsMkRaudDAbY2MROQaygJbGrNQKoQbek6BzVDKRKIApZEOkDWhTS406BPSwX83HXqUEZcomWQzHXUSClq7LpEg8ZkEXki0T8gGpE9IxyyWDDn80AmwGQvgZwST/3IwKDgK07YLA5M+lTpikYZlM5RZm+phPTSU20dDUY3NUGbtoUkML6jV7Rk26VPUg81Y+U03gc0hNnNEX2eGJzmXcsWyPQ9Gj92bwUwkSI92sfSVeY2l5MsxhpM+1XeQcIR0gx4aCHypMZmnQDE/MOFQyNooFwqzLpW1S/W8vGpwvtSYtSlFhxVYc4HyprAy6Q5okQt9JW/bGnWWz9hoKafrFFpUlc8y8Udx4Lrb57OKvNXIs+2eMBYKUJErNbgNjdqu09CT3xgcWLc1Jv0pJTpDCl+l0ErMcn3HuUpBXw/GANRXj22NSV1LhXCjVFrrCu0P0mlvop5OurKseXSoYr1K4zNCgTHK9WWpXrdSBMboksl6LfnvagDziIWlXqchMo4+utVva/BHV8pM4X0rZabw3pVS2ofba5rOtg4e/YJku71mmyswjc1VcHNzJZy2xigr17P20mF43Umhls2TAs3emhDX3fG8O944QpN9Xod5jvmjTLR1dKLZRp9wPY8m/bZgU0RmpwVePdGvS7dF5uHgWTjnL5JvRCa9WiV6pLZVwN7S373mUlS34ZWrlmPJNaGPrvuJwnSPfVcUU4V3RfHOff6twhf9eHt3f7r4j9SrSZ3ub78dD/7xx8vD3dnV5/+e4kr8R+vp9Hh3+P5yOpjS+m8t/fFP1hRk5C/2xaJ+xEb7nJJ9BLuKdrV9eTVn/gc=",
      "is_unconstrained": true,
      "name": "get_council_approval_count"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8799882153436241657": {
            "error_kind": "string",
            "string": "Function get_council_count can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAD8vCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQV6H3Yx3N3e+TwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTVTQBhndGKwdrhANO23MSzUKeLiBXGTD0S/ZxT2U1KcyuRGBWOyWTUlCK5VptDnz5dSqRq7RmKszUPKdnBjZ3s8/AcpFLx3afX7sALi2TsduVtdmn53Y5kiqm+qc1vP3dvYXTZvh7+P9CbdeB79/VJfx76OpPXaA/z8IJTkjvEOEzteanWc4l//Aw==",
      "is_unconstrained": true,
      "name": "get_council_count"
    },
    {
      "abi": {
        "error_types": {
          "13770014322479677326": {
            "error_kind": "string",
            "string": "Function get_council_member can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQcAEREAi0IRAElAAAASiUAAABLLQIBRScCAgRFJwIDBAE7DgADAAImJQAAAwoeAgADAB4CAAQAHgIABQAeAgAGADMqAAUABgAHJwIFAQEkAgAHAAAAfiUAAAMwHgIABgkkAgAGAAAAkCUAAANCJwIFAgAKKgEFBiQCAAYAAALxIwAAAKcnAgQCAQoqAQQFJAIABQAAAtQjAAAAvicCBQICCioBBQYkAgAGAAACtyMAAADVJwIGAgMKKgEGByQCAAcAAAKaIwAAAOwnAgcCBAoqAQcIJAIACAAAAn0jAAABAycCCAIFCioBCAkkAgAJAAACYCMAAAEaJwIJAgYKKgEJCiQCAAoAAAJDIwAAATEnAgoCBwoqAQoLJAIACwAAAiYjAAABSCcCCwIICioBCwwkAgAMAAACCSMAAAFfJwIMAgkKKgEMDSQCAA0AAAHsIwAAAXYnAg0CCgoqAQ0OJAIADgAAAc8jAAABjScCDgILCioBDg8kAgAPAAABsiMAAAGkJwIBAAAtCgENIwAAAcYnAgEAPi8KAAEADi0KDg0jAAABxi0KDQwjAAAB4ycCAQA9LwoAAQANLQoNDCMAAAHjLQoMCyMAAAIAJwIBADwvCgABAAwtCgwLIwAAAgAtCgsKIwAAAh0nAgEAOy8KAAEACy0KCwojAAACHS0KCgkjAAACOicCAQA6LwoAAQAKLQoKCSMAAAI6LQoJCCMAAAJXJwIBADkvCgABAAktCgkIIwAAAlctCggHIwAAAnQnAgEAOC8KAAEACC0KCAcjAAACdC0KBwYjAAACkScCAQA3LwoAAQAHLQoHBiMAAAKRLQoGBSMAAAKuJwIBADYvCgABAAYtCgYFIwAAAq4tCgUEIwAAAssnAgEANS8KAAEABS0KBQQjAAACyy0KBAMjAAAC6CcCAQA0LwoAAQAELQoEAyMAAALoLQoDAiMAAAMFJwIBADMvCgABAAMtCgMCIwAAAwUtCgIBJigAAAQEeEYMAAAEAyQAAAMAAAMvKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQW/GOsR03E/jjwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZnRbqMwEEX/hec82DMez7i/sqqqtKVVpCit0mSlVZV/35nUYLIrI5Wal+SA4eK5XAYQn91z/3h+fdgdXt4+urtfn93jcbff714f9m9P29Pu7aBrPztnP6K/uOmEujvedEmXvNd/XfRh03lnK9hAFETBYwbwA8TuDnQnj7oGwCBlCEEBDVKGyAqmzJDBjglkQF8AdgiIBpIB7RA6DQg+A5mgHh1iyCAmmAz4C9CpIDoF7zKACqJOFREzkAoiGMQMrIKIBilDUkHUqQYHGdC2SQYpQ1TBYENRMiTdONiQ7W5A5hgFg5iBdGJkQ0QZ7KDRhiR8QTTnow5Fs+UKqIJsQwEyRBVkG2KfwcwUHWI7g1cAFZRkkDKQCiYbIjG4XDbdEJCH07HvLR+TxGiO3rfH/nDq7g7n/X7T/d7uz9eNPt63h+v/aXvUUXW6Pzzrvwq+7Pa90WVT9nb1XQFtZte9Ibg0CmikbiR8XcKLi5I1lJlHkWuJRQPqGgh6RrKGMvuaxlwp4odpQAJfLSXMSARPbrTDczE08Y0GNbAjrmtHgMhZIiBx1Q6ZKUX7wFAJUJxIwI1EauCGdw3smKsFPQ7z0G5UrcVDi2Jw5WKAYTwxqX5i/ExOWcZaOEGoljIXU4xh0FBOPy1FNaqlzMVDTRxmQUnqPWwmp5AQxys/YYjVJjY3EUQYZ4IYwoLLdlpMdK5azIwERd0xayj7IhKQvyEy5kOZZZkIjx1EeeLqt0TEhVFEfFgoMuZMWWCZSArF2ETLjNUnhNFYdl4WinAsIrLMWPZhNJY9LTOWwY/GMgAsFBFXRCaN5FsiSEUE41KRWDzBlKoiONNb1YbhIgaYpB5AbjXmmqtLOMxEmajWTJDnRKB0aKdP6lURmWtJsczEesGCtmZndeIr1H0N7ue+Bt/A1wANfA24uq9A5cqhGV8b5DW0yGtokdewel49cemNMx2JGuSVWuSVWuSVVs+rG1841VfAuq8N8kot8kot8kqr59WNlihPqvnX19ggr7FFXmOLvMa186qPeVge+SYT+c/XBnmNLfIaW+Q1rp1XfQan4quv37e4QV65RV65RV559byK5/KeQ/X7FjfIK7fIK7fIK6+eVw6pvMlK/b4lDfIqLfIqLfIqq+c1ii+++vp9SxrkVVrkVVrkVVbPa/TlvhVD/b6VGuQ1tchrapHXtDiv97q0fdodb77ZXUztuNs+7vu8+HI+PE1GT3/eh5Hhm9/78e2pfz4fe1MqH/7sm9gv+7zgie7tu951Meqi3F/s8H8B",
      "is_unconstrained": true,
      "name": "get_council_member"
    },
    {
      "abi": {
        "error_types": {
          "11891137193966797764": {
            "error_kind": "string",
            "string": "Function get_council_threshold can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAEAvCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWlBc5GpdODxDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTVTQBhnF4ZxTq1eNO23MSzUKeLiBXGTD0S/ZxT2U1KcyuRGBWOyWTUlCK5VptDnz5dSqRq7RmKszUPKdnBjZ3s8/AcpFLx3afX7sALi2TsduVtdmn53Y5kiqm+qc1vP3dvYXTZvh7+P9CbdeB79/VJfx76OpPXaA/z8IJTkjvEOEzteanWc4l//Aw==",
      "is_unconstrained": true,
      "name": "get_council_threshold"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "342064996362527420": {
            "error_kind": "string",
            "string": "Function get_delegate can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "account",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZldbhs7DIX34mc/SBRFSdlKURRu6hYGDCdwkwtcFNl7yRkejR1ghNRJXuLPdOYM/0Rp7D+bH/vvz7++HU4/H35v7r782Xw/H47Hw69vx4f73dPh4aTWP5tgf6r+TdtNzZu7st00fRejvurbyNtNDGYoBlWhKsTkQBEgmzvSi2JSC5FBc2BWaAbNISdAdRBYBJYCSykONQLEwTydIQP0FilsN0QBwAB8lGBJsDAsXB0yAYqDRIA4FNyiZIAFqNmgmgDVoRFAZkghAjLAL0+RAbBQAhSHRABYxKIgg+pgOZwBlgpLhcUcm0FmYHNshuwQA8BukQyqAxFAHKZkZgWxj8RAHKaMTcCA6jA5NoElXMPhFgEyQw4RAEuEJcJCsFiikrZEtoacQRwYFs4OOQDUMQ4G1cGimEEcrNwcDZqDOT+D3pQ1UdmyaiC2dmbIDuQJl8lDgxQBXgJhWNhLIDkAvASSvQQiBPASSPUSlOAlKMFLUGIAMMBLUCgBvAQlRYCntzAsDEuGJcMisIiXoJQI8BKUCkv1EpQWAF6C0rwENRDAS1CjJZMNrAQaabVlPoGtixmKg6WOdXxVWxesjtVCAHGwCTgDA5pD07Rku2krMzTzZwZYIiwRFoKFYEnWJGJQHCyZM2SA3jRPo5cB6nPWmjabkDPAYs5PYMnM6mqbus4muC0ZniZ2CJ24kynYtAzk8cdgpXbqNtZrJUyUQbnbzEWJEzVcYU46VVDpNpvkM1Xq1G2te2DT3AnK6hYo4tppz7E21+0odOJOFcR6hdhOFMW7XymDSrfZVJI0UQPVbrOJKbYdxpZwhbXERISVptRt03SaSUDUbZQ7NVBKnboK92sFUZJwJ0RJ1tRO4vFSY1zbcI8UuFP12JLt507dZh08xTvtOfMVKXaCV4m7jRFRyqHTYuseSOrUlUtXmQ4j8vKy3eCg8u3pvN/bOeXi5KLnmcfdeX962tydno/H7ea/3fF5+qffj7vT9Pq0O+un2qv70w99VcGfh+Pe6GW7XB3WL6VUm19NHFoX0KPNlURcl4g6s6prKJfSRRpfadC6RqKcs2sol7imMQqlRrihR5G4GgoPJDjm0NOhy2Zxo1xp5A9Ih3xuOvS0UlyCUy6r6aiDUMjadY6EslxI0JVE+4BsxPAB6RjFogMAfqSUVmOJ9BHBpE8ORidhL0xbL0wc9GmpPZbSiFdDGbWpnsehodzeG4pqrIYyag9NIrzIra7PsEGfkp5d+spviWV1iI0c0SeW7klKzDcs28tg9GS9Gsxw5deGnDLpea2LcLoeYzToU33MgCNZnwy7hm701xqDeRoz5oceHrpC0ka5Uhh1aVm6VI/Ei4aka41Rm+aejbjUlcqrwpZBd8SGXOhTd1vXqKN8YqPNKdym0DDQ5SIT/xQHLbt9uqjIa4002u4zYaHEzOVGDWldo7bbNPS7hD44qK5rDPqzMDqjsNyk0BizXB9jblLQJ5Q+AIOs1zUN6so1wg2uealrbP+QTnvY9HTmG8uaeocq1ps0PiKU2Ee5PhjV21ZKiX10lcF65fS5GlGkxyKl3qZRSj/66Fa/riHvXSkjhbetlJHCW1cKt3e31zCdbRk8+h3IenuNNld9OO+ba6HVzTXTsDV6WaVetJcOw9tOCimunhTy6KmJaNkdL7vjlSN5sM/rME+YP8o5rx2d8mijD7ScRwPV1fN5LqPTgiye6DeiqyLDZg8YhI1uXC6CwrSS37vgBgrDze1NUQwV3hTFGzfY1wpf9e3u/nC++rXnxaTOh933497f/nw+3V98+vT/Iz7Br0WP54f7/Y/n896Ulp+M9M8X/Sppq79MfLVv6vStfrGwpVbsbbRPyT6Vry/mzF8=",
      "is_unconstrained": true,
      "name": "get_delegate"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "account",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_effective_votes"
    },
    {
      "abi": {
        "error_types": {
          "11805838585384935243": {
            "error_kind": "string",
            "string": "Function get_emergency_threshold can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAEEvCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWj1sOktXgfSzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTVTQBjHtTkzWG/C0LTfxrBQp4iLF8RNPhD9nlHYT0lxKpMbFYzJZtWUILhWmUKfP19KpWrsGomxNg8p28GNne3x8B+kUPDepdXvwwqIZ+905G51afrdjWWKqL6pzm09d29jd9m8Hf4+0pt043n090t9Hfs6ktZrD/Dzg1CSO8Y7TOx4qdVxin/9Dw==",
      "is_unconstrained": true,
      "name": "get_emergency_threshold"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16651589314398098717": {
            "error_kind": "string",
            "string": "Function get_erc20_config can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "field"
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgEEACcCAgQAHwoAAQACAEQlAAAARSUAAABGLQIBRC0CAkUnAgMERCcCBAQCOw4ABAADJiUAAAC5HgIAAQAeAgACAB4CAAMAHgIABAAzKgADAAQABScCAwEBJAIABQAAAHklAAAA3x4CAAQJJAIABAAAAIslAAAA8ScCAwAdLwoAAwAEJwIDAB4vCgADAAUcCgUGBhwKBgMAHAoDBQYtCgQBLQoFAiYoAAAEBHhGDAAABAMkAAADAAAA3ioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEF5xZUQe5jlR08BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tVbbbqMwEP0XP/PgmfE1v1JFEUlIhYRIRGGlVcS/7zgLBirZlVr6gs/Y8cmcwzD2U1yr8/B+qtvb/UMc3p7i3NVNU7+fmvul7Ot7y7NPIcPDanGgQjgOLA8cARTCcwiKxxDzPEhi4AJwEwAzAQRxQAiAZxAZkJqBZxC2KzUBzcQUlrSegOHtpAIwE7CvmXEsxJzuqe+qKmS7yp9VPcquantxaIemKcSfshleP/p4lO1r7MuOV2UhqvbKIxPe6qYKaCyW3TK9Fcn5aTcq6SMBC9tQQJoCnDRu4mBsbSTxasOBaQ5CrfXEwdhCiiMnxcGcBnqEpBSVoVD8+qIdYBdDvd1w6B3sML9rh0JjJwpF2ibtcBkpSGZWgtqsKHBD4XdwA+QOduS0ENCcBxEltQDuIYZ+WQxajC/Gp18MZOrUuqjFelRJKbkyJaNmDsb+p1KYIyklVx5s4pyF9i7dwzJ1ip4ofvmelEk2sVwiRBgzIVLqG5/tWoyRMikm9+VrGdNgbJZiV7RtY5ipU8RIgrjyA9FtOTL9lKQP591/NdJrnXRV50hwqTKJLn2+5EpVmyUTbYz9TkdlL2NL1SAx7avbwVe/g68kd/CVYAdfv5CDKznrY/dTJpRrzj4eVh5WNc+3mvHIYXmpu831cAxkXV2em2oKb0N7Wa32fx/zyny9fHT3S3UduiowLXdM4OcbH5YKjuHiyIHCQqnjGP76Hw==",
      "is_unconstrained": true,
      "name": "get_erc20_config"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17908124404890989986": {
            "error_kind": "string",
            "string": "Function get_governance_token can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndbts6DMffJde9ED8l9VUOhqHrsqFA0BZZe4CDoe9+SFmUkwIWujS7aX6m639IiqRl5/fu+/7b68+vD48/nn7tbv/5vft2fDgcHn5+PTzd3708PD2a9fcu+Z+su1u62RXY3Wb7sCOAm121Q2D79GOzQ2KD4lA7QO6AuLtFcDALogFJB7avID/FElA7CAeERcOiYckUkDsUDNAO7ukC/hX2pQjaAVNAnKKwUFg4LMwBpYNQQO6gGBBfkSHABZND7VA4oHSoGJAXoAQB/XKCFDAsXZCQArogUVjUr2IHDqgdclhyWEpYmmMOzbEGeQFujjXQDs0xceCA0sELoEFLplULi5+y2uCWsQbaIacADqgdioXDySF3cMcW6BZJGBAWCAuExRPF4JA7EAaEhSFAO4g5xujAAaWDR9HAl5vJQQJqh+Y8O5QO3jsO6sls0FawQc+8Egb0zCuHhXvmVSBAljxraxkHpYDcociyBDnRktXsiWoAECABPfMZOaAsOcyEAT2rmcPCYZGwSFg0LFqWrOaMAT3zuYSl9MznCgGy5DnXukDxKBbIHby7WQ28u9lHlnd3A2+HBUoHTx1XH2smKOZY8ZGyQO7gk28B6VBTgKVF/EtrWaC6PwuEBcICYcGwYFjIK6o4lA4tmQ20g5efkIMEuM/qM9jdsCiqJ1PNsVpSgP2z2rrX1in+P63qqg/qlAbxIHNA1Ql1CRISwaBh807WZe5LkAybd4i2m4HUuEJpUAnKwxbZhuTL32nY6vCgyqBQhhQqAHEtuPde5gCUBvGgEuR5Vo8ctM8dIwnKw+bDKDdlb+iFyrB5S2e/x0CluKL2tgJMOGjYotdguRstt8lhQxlUg4gGDRUe12pEicqDIkr0uuikPV6sHNfW+A5KPKj02Mjrt9Ow+UBv8RKGL0QwKLwiHjaOiEjSoNU2PFAaNJTzUCnt2re3m13sU76+HPd736acbFxsO/N8d9w/vuxuH18Ph5vdv3eH1/ZPv57vHtvny93Rzlos+8fv9mmCPx4Oe6e3m/XqtH0pUqn9atsi1CEAVM8kYFsCSvIeaRrGOQ+RymcauK1BKCJdwzjDlsYslALhhu1AYDMUnkgwSBrpsLZZ3chnGnKFdOjfTQejz7AmwSR5Mx1lEgqSRiQoeiKBZxL1CtmAdIV0zGKxARB+2H5yMxbAawRDfzkYm4RjYer2wsCkTm1bErHkirwZyqxMbRseGsb1s6GYxmYos/IQn+GLF1LL9gyb1ClWotH5to/RzSE2c4QIhydEzBe07WkwmtJmMLPOZ01RYca0TnWm8zGGkzoVxlhbYV5LHVHPNSbz1Hb7MYPUnqe2NSZ1ajfzkRB7Yt7WmBSqba9jca2F11jsNn2ukSf9ktd+KSDbGmW2uFHrDGuFYX5XYrM6tfcAUaZ4cr9+r0GT+hCMW75QukyhjmU9ycQfxYHrvoMSbnsxqVAQjFW1tyz5Qg2tQ6PUyzQoDQ17Z7GtManQzFEZmfUihcrR81Uu88GelcYoTrq9rjRZVy4wRk+RdV2h/kE6/R1CT6dcuKw0KtSwXKRxjVBgzB17RCuXdUqG2IRhnvQry9/VANURi+ZymUbOYxNmm45tjfLZTpkpfKxTZgof7RSBT5fXNJ11HTwVt9M5vUWzrrfo0yV5d3sVvsK+WOQK++J5NKgjGpHtaPKnN8ZSrrAx/vgGbLLxmWnIeOoRe5e7qaGz5/v1Vu13ulVDzzeTOnu+T5ViqBufrMz7h+LZk1PCNasJy/aTNc+2YLp6IqqbItMJkqJnKl44gzQGSM3y2Sk2UZjuGD4UxVThQ1F8cNfyXuGLHd7dPxzPfst7c6njw923w74f/nh9vD85+/Lfc5yJ3wKfj0/3+++vx70rrT8I2p9/KNGNvQX84i9i7RBtc23P034Ifhb9rHx5c2f+Bw==",
      "is_unconstrained": true,
      "name": "get_governance_token"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4989124741311061979": {
            "error_kind": "string",
            "string": "Function get_late_quorum_extension can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAgvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVFPO6EyfVf2zwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuswDIbfxWsvLMnXvspQStqmQyCkJZMcOJS8+5FLnMsBezHT2cSSXX/VL8uXp7jW5/Hz1HS3+5c4fDzFuW/atvk8tfdLNTT3jnufQsWPA3EgKZwVByeFZw+AW3ZBSxGiz/0hcOulAKVnAzAZThyQpwByDyIbpJJh2ODZoFUymIuBDQPJePVMkxQpttPQ13UMbRMsS3hUfd0N4tCNbSvFn6odXz/6elTdqx2qnkeVFHV35ZaBt6atozXJdbbKT0XyYZ6NWoUFABR2CMgjwCvrZwbbzi2QoHcMzDMIjTEzg20HOUZJiocUBgaErBRdQGgwakkHuDWhwe0Y5g3psL+bDo3WzQhNxmXT4QtSkGxSgsZuELhDhDdkA9Qb0lHSQkApDiLKagF8hxj6ZTHocFmYkF8YKNSp84sWF1BnpZTKlKxODLbDT6UwIyulVB6cxBSFCT5/hhXqFAPRsvMDaZs9xEqBEOESCZHW39i2WzFWqayY0s7X4FOFaY2btdW0P8awUKeIixZGrPlA9HtG4TwlxalMalQwJptVU4LgWmUKff5+KZWqsWskxto8pCwHN3K218N/kOJB5BODnwgrIt6+05Hd6tL0uzfLFGF9U53benZvY3fZjA5/H2kkvXke/f1SX8e+jqT14QP8/SCU5I7xFRMdL7U6TvGv/wE=",
      "is_unconstrained": true,
      "name": "get_late_quorum_extension"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5227616292269356710": {
            "error_kind": "string",
            "string": "Function get_membership_mode can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDABsvCgADAAQcCgQFAhwKBQMAHAoDBAItCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVIjDlSGsJ2pjwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTVTWvnaLeuWtV13dU37bQwLdYq4eEHc5APR7xmF/ZQUpzK5UcGYbFZNCYJrlSn0+fOlVKrGrpEYa/OQsh3c2NkeD/9BCgXvXVr9PqyAePZOR+5Wl6bf3VimiOqb6tzWc/c2dpfN2+HvI71JN55Hf7/U17GvI2m99gA/PwgluWO8w8SOl1odp/jX/wA=",
      "is_unconstrained": true,
      "name": "get_membership_mode"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8418147970250171169": {
            "error_kind": "string",
            "string": "Function get_name can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndbts6DMffJde9ED8l9VUOhqHrsqFA0BZZe4CDoe9+SFmUkwIWujS7aX6m639IiqJp5/fu+/7b68+vD48/nn7tbv/5vft2fDgcHn5+PTzd3708PD2a9fcu+Z+su1u62RXY3Wb7sCOAm121Q2D79GOzQ2KD4lA7QO6AuLtFcDALogFJB7avID/FElA7CAeERcOiYckUkDsUDNAO7ukC/hX2pQjaAVNAnKKwUFg4LMwBpYNQQO6gGBBfkSHABZND7VA4oHSoGJAXoAQB/XKCFDAsXZCQArogUVjUr2IHDqgdclhyWEpYmmMOzbEGeQFujjXQDs0xceCA0sELoEFLplULi5+y2uCWsQbaIacADqgdioXDySF3cMcW6BZJGBAWCAuExRPF4JA7EAaEhSFAO4g5xujAAaWDR9HAl5vJQQJqh+Y8O5QOvncc1JPZoK1gg555JQzomVcOC/fMq0CALHnWtmUclAJyhyLLEuRES1azJ6oBQIAE9Mxn5ICy5DATBvSsZg4Lh0XCImHRsGhZspozBvTM5xKW0jOfKwTIkudc6wLFo1ggd/DdzWrgu5u9ZfnubuDbYYHSwVPH1duaCYo5VrylLJA7eOdbQDrUFGBpEf/SWhao7s8CYYGwQFgwLBgW8ooqDqVDS2YD7eDlJ+QgAe6zeg92NyyK6slUc6yWFGD/rLbute0U/59WddUbdUqDeJA5oOqEugQJiWDQsPlO1qXvS5AMm+8QbTcDqXGF0qASlIctsg3Jl7/TsNXhQZVBoQwpVADiWnDvvcwBKA3iQSXI86weOWjvO0YSlIfNm1Fuyr6hFyrD5ls6+z0GKsUVtW8rwISDhi32Gix3o+U2OWwog2oQ0aChwuNajShReVBEiV4XnbTHi5Xj2hrfQYkHlR4bef12GjZv6C1ewvCFCAaFV8TDxhERSRq02oYHSoOGch4qpV379naziznl68txv/cx5WRwsXHm+e64f3zZ3T6+Hg43u3/vDq/tn3493z22z5e7o521WPaP3+3TBH88HPZObzfr1Wn7UqRS+9U2ItQhAFTPJGBbAkryPdI0jHMeIpXPNHBbg1BEuoZxhi2NWSgFwg2bQGAzFJ5IMEga6bBts7qRzzTkCunQv5sORu9hTYJJ8mY6yiQUJI1IUPREAs8k6hWyAekK6ZjFYg0g/LB5cjMWwGsEQ385GOuEY2Hq9sLApE5tLIlYckXeDGVWpjaGh4Zx/WwoprEZyqw8xHv44oXUst3DJnWKlWjsfJtjdLOJzRwhwuEJEfMF2/Y0GE1pM5iZRAWMnBqfuMF03sZwUqfCGGsrzGupI+q5xqSf2rQfPUjteWpbY1KndjMfCbEn5m2NSaHaeB2La1t4jcVu0+caebJf8rpfCsi2RpktbqwLw1phmN+V2KxO7T1AlCme3K/fa9CkPgTjli+ULlOoY1lPMvFHceA6d1DCbS8mFQqCsar2liVfqKF1aJR6mQaloWHvLLY1JhWaOSojs16kUDnuKlUu88GelUYrTrq9rjRZVy4QbnCRdV2h/kE6/R1CT6dcuKw0KtSwXKRxjVBg9B17RCuX7ZQMMYRhnuxXlr+rAaojFs3lMo2cxxBmQ8e2RvnsTpkpfGynzBQ+ulMEPl1e03TWtfFU3E7n9BbNut6iT5fk3e1V+ApzscgV5uJ5NKgjGpHtaPKnB2MpVxiMPz6ATQafmYaMpx6xd7mbGjp7vl9v1X6nWzX0fJjU2fN9qhRN3fhkZd4/FM+enBKuWU1Ytp+seTaC6eqJqG6KTDtIij1T8cIepNFAapbPdrGJwnRi+FAUU4UPRfHBqeW9whc7vLt/OJ79lvfmUseHu2+HfT/88fp4f3L25b/nOBO/BT4fn+7331+Pe1dafxC0P/9Qoht7C/jFX8TaIdpwbc/Tfgh+Fv2sfHlzZ/4H",
      "is_unconstrained": true,
      "name": "get_name"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6937048942020234009": {
            "error_kind": "string",
            "string": "Function get_past_votes can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "account",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_past_votes"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14397635560847713499": {
            "error_kind": "string",
            "string": "Function get_proposal can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "id",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "proposer",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "eta",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "start_block",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_block",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "canceled",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "executed",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "actions_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "description_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "target_count",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              },
              {
                "name": "proposal_type",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ],
            "kind": "struct",
            "path": "types::proposal::GovernorProposal"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBQJwAABFAnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAG0lAAAAcy0CAUUtAgJGLQIDRy0CBEgtAgVJLQIGSi0CB0stAghMLQIJTS0CCk4tAgtPJwIMBEUnAg0ECzsOAA0ADCcAQwQDJiUAAAd2HgIAAgAeAgADAB4CAAQAHgIABQAzKgAEAAUABicCBAEBJAIABgAAAKYlAAAHnB4CAAUJJAIABQAAALglAAAHricCBQAALQgBBicCBwQEAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIggCCC0OBQgAIggCCC0OBQgrAgAHAAAAAAAAAAACAAAAAAAAAAAtCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkKLQ4FCgAiCgIKLQ4FCgAiCgIKLQ4FCgAiCgIKLQ4HCi0IAQcAAAECAS0OBgctCAEGAAABAgEtDggGLQgBCQAAAQIBJwIKBAAtDgoJLQgBCwAAAQIBJwIMAQAtDgwLJwINAAsnAg4EASQCAAwAAAHbIwAAAZQtCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMPLQ4NDwAiDwIPLQ4FDwAiDwIPLQ4FDy0OAgctDggGLQ4OCS0ODAsjAAACZy0KCgIjAAAB5AwiAkMDJAIAAwAABvAjAAAB9i0LBwItCwYDLQsLCC0LAw8AIg8CDy0ODwMtCAEPJwIQBAUACAEQAScDDwQBACIDAhAnAhEEBAAiDwISPw8AEAASLQICAycABAQEJQAAB8AtCAUDACoDDhAtDg0QLQ4DBy0ODwYtDg4JLQ4ICyMAAAJnLQsHAi0LBgMtCwsICioIDA0kAgANAAACiScCDwQAPAYPAScCCAQCJAIADAAAAssjAAACmy0CAgMnAAQEBCUAAAfALQgFDQAqDQgPLQ4BDy0ODQctDgMGLQ4ICS0ODAsjAAADVy0KCgIjAAAC1AwiAkMDJAIAAwAABmojAAAC5i0LBwItCwYDLQsLDS0LAw8AIg8CDy0ODwMtCAEPJwIQBAUACAEQAScDDwQBACIDAhAnAhEEBAAiDwISPw8AEAASLQICAycABAQEJQAAB8AtCAUDACoDDhAtDgEQLQ4DBy0ODwYtDg4JLQ4NCyMAAANXLQsLAgoqAgwDJAIAAwAAA3EnAg0EADwGDQEtCgoBIwAAA3oMIgFDAiQCAAIAAAXkIwAAA4wtCwcCLQsGAy0LCQ0tCwMPACIPAg8tDg8DLQgBDycCEAQFAAgBEAEnAw8EAQAiAwIQJwIRBAQAIg8CEj8PABAAEi0OAgctDg8GLQ4NCS0OBAsAKg8OAy0LAwIKKgIFAwoqAwwEJAIABAAAA/0lAAAIHy0IAQMnAgQEDAAIAQQBJwMDBAEAIgMCBCcCBgQLACoGBAYtCgQHDioGBwkkAgAJAAAEPi0OBQcAIgcCByMAAAQjLQgBBAAAAQIBLQ4DBCcCAwQLLQoKASMAAARZDCoBAwUkAgAFAAAFniMAAARrLQsEAQAqAQ4ELQsEAhwKAgUFHAoFBAAcCgQCBQAqAQgFLQsFBAAiAUMGLQsGBRwKBQcEHAoHBgAcCgYFBCcCBgQEACoBBggtCwgHHAoHCAQcCggGABwKBgcEJwIGBAUAKgEGCS0LCQgcCggJBBwKCQYAHAoGCAQnAgYEBgAqAQYKLQsKCRwKCQoBHAoKBgAcCgYJAScCBgQHACoBBgstCwsKHAoKCwEcCgsGABwKBgoBJwIGBAgAKgEGDC0LDAsnAgYECQAqAQYNLQsNDCcCBgQKACoBBg4tCw4NHAoNDgIcCg4GABwKBg0CACoBAw4tCw4GHAoGAwIcCgMBABwKAQMCLQoCAS0KBAItCgcELQoKBy0KDQotCgkGLQoMCS0KAw4tCgUDLQoIBS0KCwgtCg4LJhwKAQUAACoCBQYvCgAGAAUtCwQGLQIGAycABAQMJQAAB8AtCAUHACIHAgkAKgkBCi0OBQotDgcEACoBDgUtCgUBIwAABFktCwcCLQsGAy0LCQ0tCwsPDCoBDRAkAgAQAAAGBiMAAAZcACIDAhEAKhEBEi0LEhAAIgICEgAqEgETLQsTEQAqEBESLQIDAycABAQFJQAAB8AtCAUQACIQAhEAKhEBEy0OEhMtDgIHLQ4QBi0ODQktDg8LIwAABlwAKgEOAi0KAgEjAAADei0LBwMtCwYNLQsJDy0LCxAMKgIPESQCABEAAAaMIwAABuIAIg0CEgAqEgITLQsTEQAiAwITACoTAhQtCxQSACoREhMtAg0DJwAEBAUlAAAHwC0IBREAIhECEgAqEgIULQ4TFC0OAwctDhEGLQ4PCS0OEAsjAAAG4gAqAg4DLQoDAiMAAALULQsHAy0LBggtCwkPLQsLEAwqAg8RJAIAEQAABxIjAAAHaAAiCAISACoSAhMtCxMRACIDAhMAKhMCFC0LFBIAKhESEy0CCAMnAAQEBSUAAAfALQgFEQAiEQISACoSAhQtDhMULQ4DBy0OEQYtDg8JLQ4QCyMAAAdoACoCDgMtCgMCIwAAAeQoAAAEBHhQDAAABAMkAAADAAAHmyoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFx86tQrncJNs8BAIBJi0BAwYKAAYCByQAAAcAAAfWIwAAB98tAAMFIwAACB4tAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAIGS0BCggtBAgLAAAKAgoAAAsCCyMAAAf1JwEFBAEmKgEAAQW6uyHXgjMYZDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_proposal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3905717565539885644": {
            "error_kind": "string",
            "string": "Function get_proposal_count can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAwvCgADAAQcCgQFBRwKBQMAHAoDBAUtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQU2M+VutwIiTDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjuMgEEX/hTULqopnfqUVRU7itCxZTuS2RxpF/vcpIuPHSLDoTm9MgcNJ3UsZeIprfR4/T013u3+Jw8dTnPumbZvPU3u/VENz73j0KVR8OBAHksJZcXBSeO4BcMtd0FKE2OfxELj1UoDScwCYAicOyFMAeQSRA1IpMBzwbNAqBczFwIGBFLxGpkmKlNtp6Os6prZJliU8qr7uBnHoxraV4k/Vjq8ffT2q7tUOVc9vlRR1d+WWgbemrWM0yXW2yk9F8mGejVqFBQAUdgjII8Ar62cGx84tkKB3DMwzCI0xM4NjBzlGSYqHlAYGhKwUXUBoMGqxA9xqaHA7hnmDHfZ37dBo3YzQZFzWDl+QgmSTEjR2g8AdIrzBDVBvsKOkhYBSHkSU1QL4DjH0y2LQ4bIwIb8wUKhT5xctLqDOSimVKVmdGByHn0phRlZKqTzYxJSFCT6/hxXqFAPR8uUH0ja7iZUSIcIlEyKtv/HZbsVYpbJiSghezoUR0K3Frmm/jWGhThEXLYgbPxD9nlHYT0mxlSkTFYzJumpKEFyrTKHPny+lUjV2zcRYm4eU5eBGzvZ4+A9SKnhL6cQFu3Eknr7TkbvVpel3d5YpwvqmOrf13L2N3WXzdvj7SG/SnefR3y/1dezrSFovPsDPD0JJ7hhvMbHjpVbHKf71Pw==",
      "is_unconstrained": true,
      "name": "get_proposal_count"
    },
    {
      "abi": {
        "error_types": {
          "14586830951621773200": {
            "error_kind": "string",
            "string": "Function get_proposal_guardian can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDAAovCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQXKbtV3VhbHkDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjuMgEEX/hTULqoqnf6UVRU7itCxZTuS2RxpF/vcpWsaPBSym0xtTQDiue10QXuLWXKbPc9vfH1+i+niJy9B2Xft57h7XemwfPY++hIoPB6IiKZwVlZPCcw+AW+6CliLEPo+HwK2XApReAsAUOFEhLwHkEUQOSKXAcMCrQccRN89SpATO49A08f27jDjPZz00/Siqfuo6Kf7U3fT9o69n3X+3Yz3wrJKi6W/cMvDedk2MZrmtVvmlSD4sq1GrsAKAwgEBeQR4Zf3C4Ni5FRL0gYF5BqExZmFw7CDHKEnxkNLAgJCVogsIDUatdoDbDA3uwDBvsMP+rh0arVsQmozL2uELUpBsUoLG7hB4QIQ3uAHqDXaUtBBQyoOIsloA3yGGflkMOlw/TMh/GCjUqfOrFhdQZ6WUypSsTgyOw0+lMCMrpVQebGLKwgSfP8MKdYqBaN35gbTNHmKlRIhwzYRI6//YtnsxVqmsmNLO19omTzkOW5lqOh5jWKhTxFUL4s4PRH9kFM5TUmxlUqOCMVlXTQmCW5Up9Pn/l1KpGrtlYqw9Qk7cq6/tcLgPzJE2tPWla5bufeqvu9nx7zPNpPvEc3hcm9s0NJG0XSqAnx8YJOlTvCFwh4wkd5rjq/8B",
      "is_unconstrained": true,
      "name": "get_proposal_guardian"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6759925772054572743": {
            "error_kind": "string",
            "string": "Function get_proposal_threshold can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAUvCgADAAQcCgQFBhwKBQMAHAoDBAYtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVd0BSsj1IuxzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbNjqMwDMffJWcOsZ3PvsqoqmhLR0iIVgystKp493UqEmCl5DDTuRA7NL/6bxwnT3FtztPnqe1v9y9x+HiK89B2Xft56u6XemzvPc8+hQwPC+JAlbBGHGwlHHsAPLILqhI++DzvPY+uEiDVYgBGw4oD8hJAnkFkg2Q0NBu8GpSMBnPRs6EhGq+Zea5EjO00Dk0TQtsEyxIe9dD0ozj0U9dV4k/dTa8ffT3q/jWO9cBvZSWa/sojA29t1wRrrtbVMr8UyfllNSrpEwDI7xCQR4CTxi0Mtq1NEK92DMwzCLXWC4NtCzlGSYqDGAZ6hKwUVUAo0DKlA+yaUG93DP2GdJjfTYdCYxeEIm2z6XAFKUgmKkFtNgjcIfwbsgHyDekoaSGgGAcRZbUAvkMM/bIYtJg+jM9/GCjUqXVJi/WoslJKZUpGRQbb/qdSmJGVUioPTmKMQnuX72GFOkVPlHa+J2WyTawUCBGmSIiU+sa23YoxUmbFlHY+odNp69OmFSratzEs1Cli0oK4yQei2zMK/ZQkpzKqkV7rbFZ1CYJrlUl0+fOlVKrarJFoY/KQshzcyNkeD/9BSgXvfGqqHtZGFE7f+chufWmH3Z1lDrChrc9ds7i3qb9s3o5/H/FNvPM8hvuluU5DE0jrxQf4+UFYkT2GW0xwXKXkcQ5//Q8=",
      "is_unconstrained": true,
      "name": "get_proposal_threshold"
    },
    {
      "abi": {
        "error_types": {
          "13971371060846917075": {
            "error_kind": "string",
            "string": "Function get_quorum_denominator can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAcvCgADAAQcCgQFBhwKBQMAHAoDBAYtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQXB5Ef00vP10zwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuswDIbfxessLMk39VWGUtI2HQIhLZnkwKHk3Y9S4lwO2IuZziaW7Pqrflm+PNW1Og+fp7q93b/U4eOpzl3dNPXnqblfyr6+t9L7VHr6eFAHKpR36uALFcQDkFZcMIXiyZd+ZmlDoUCb2QCMhlcHlCmA0oMoBuloWDFkNhgdDeEii2EhGq+ecSxUjO3Ud1U1hbYJViQ8yq5qe3Voh6Yp1J+yGV4/+nqU7avty05GdaGq9iqtAG91U03WWKyzdXoqUuB5NhrNCwCIdwhIIyBoF2aG2N4vEDY7BqYZhNbamSG2hxQjJyVADAMZISnFZBAGrF7SAX5NKPsdw74hHe5302HQ+RlhyPpkOkJGCpKLStC6DQJ3CH5DNkC/IR05LQQU4yCipBbAd4ihXxaDHpeF4fTCQKZOfVi0eEaTlJIrU3ImMsTmn0oRRlJKrjwkiTEKyyF9hmXqFJlo2flMxiUPsVwgRLhEQmTMN7btVozTOikmt/PJ2s3W57XYDe2PMczUKeKiBXGTD8SwZ2TOU9KSyqhGs7XJrNocBNcq0xjS90uuVK1bI7HOpSF5ObiRs70e/oPkCj7wcqgybNZGbt/xKG55qbvdm2WcYF1dnptqdm9De9mM9n8fcSS+eR7d/VJdh66aSOvDB+T7QViQP06vmMkJhdHHcfrrfw==",
      "is_unconstrained": true,
      "name": "get_quorum_denominator"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "9496969216608950819": {
            "error_kind": "string",
            "string": "Function get_quorum_numerator can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAYvCgADAAQcCgQFBhwKBQMAHAoDBAYtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWDzAMvdsvaIzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLjqMwEEX/xWsWrio/8yutKCIJaSEhEtEw0iji36ccYQMt2Yvp9AZfm/ikblF+PMW1OU+fp7a/3b/E4eMpzkPbde3nqbtf6rG99zz6FDI8LIgDVcIacbCVcNwD4Ja7oCrhQ5/HvefWVQKkWgRgFFYckKcA8ggiC5JRaBY8G5SMgrnoWWiI4jUyz5WIsZ3GoWlCaJtg2cKjHpp+FId+6rpK/Km76fWjr0fdv9qxHvitrETTX7ll4K3tmqDmap0t81ORnF9mo5I+AYD8DgF5BDhp3MJgbW2CeLVjYJ5BqLVeGKwt5BglKw5iGOgRslZUAaFAy5QOsGtCvd0x9BvSYX43HQqNXRCKtM2mwxWsIJnoBLXZIHCH8G/IBsg3pKPkhYBiHESU9QL4DjP0y2bQYvowPv9hoFCn1iUv1qPKWimVKRkVGaz9T60wI2ulVB6cxBiF9i6/hxXqFD1RWvmelMluYqVAiDBFQqTUfyzbrRkjZdZMaeWTSmGw1jpBFO23MSzUKWKCIG7ygej2jMJ+SpJTGd1Iv4nke1Z1CYJrlUl0+fOlVKrarJFoY/KQsh3c2NkeD98gpYJ3Pm2qHtaNKJy+85G79aUddneWOcCGtj53zdK9Tf1l83b8+4hv4p3nMdwvzXUamkBaLz7Azw/Ciuwx3GJCx1VKHufw1/8A",
      "is_unconstrained": true,
      "name": "get_quorum_numerator"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6026731864439116519": {
            "error_kind": "string",
            "string": "Function get_timelock_delay can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAkvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVTo0CzIGvS5zwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTVTWvl6DYO1WYtd034bw0KdIi4QxE0+EP2eUdhPSXEqkxsVjMlm1ZQguFaZQp8/X0qlauwaibE2DynbwY2d7fHwH6S4EfnE4CvCioin73TkbnVp+t2dZYqwvqnObT13b2N32bwd/j7Sm3TnefT3S30d+zqS1osP8PODUJI7xltM7Hip1XGKf/0P",
      "is_unconstrained": true,
      "name": "get_timelock_delay"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5366287459706263972": {
            "error_kind": "string",
            "string": "Function get_token_gate_address can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAJceAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAAC9HgIABAkkAgAEAAAAhyUAAADPJwIDABwvCgADAAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAAC8KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVKeOIDRmzZpDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbNjqMwDMffJeccYjufvMqoqmhLR0iIVgystKp49zUjEuCQHHY6F2InzQ//jePmJW7NZfo8t/398SWqj5e4DG3XtZ/n7nGtx/bR8+xLqOXhQFQkhbOiclJ49gB4ZBe0FGHxeT4EHr0UoPRqAEbDiQp5CyDPILJBKhqGDd4Neplx8yxFDOA8Dk2zvH8XEcf5rIemH0XVT10nxZ+6m75/9PWs++9xrAdeVVI0/Y1HBt7brlmsWW67VX4rkg/rbtQqJABQOCAgjwCvrF8ZbDuXIEEfGJhnEBpjVgbbDnKMkhQPMQwMCFkpuoDQYFRKB7gtocEdGOYN6bC/mw6N1q0ITcZl0+ELUpBsVILG7hB4QIQ3ZAPUG9JR0kJAMQ4iymoBfIcY+mUx6DB9mJD/MFCoU+eTFhdQZ6WUypSsjgy2w0+lMCMrpVQenMQYhQk+38MKdYqBKJ38QNpmm1gpECJMkRBp/R/Hdi/GKpUVUzr52rvY1LUOYBJE07GNYaFOEZMWxF0+EP2RUeinpDiVUY0KxmSzakoQ3KpMoc//v5RK1dgtEmPtEXJir762w+E+MC+0oa0vXbO696m/7lbHv8+4Eu8Tz+FxbW7T0Cyk7VIB/PzAIEmflhsCO2QkudO8vPof",
      "is_unconstrained": true,
      "name": "get_token_gate_address"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3257802692136877625": {
            "error_kind": "string",
            "string": "Function get_total_voting_power can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDABgvCgADAAQcCgQFBhwKBQMAHAoDBAYtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQUtNgpJtSE+OTwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTVTWvkGVaow1nr9LJr22xgW6hRx8YK4yQei3zMK+ykpTmVyo4Ix2ayaEgTXKlPo8+dLqVSNXSMx1uYhZTu4sbM9Hv6DlAreh2VTDbBuRPH0nY7crS5Nv7uzTBHWN9W5refubewum7fD30d6k+48j/5+qa9jX0fSevEBfn4QSnLHeIuJHS+1Ok7xr/8B",
      "is_unconstrained": true,
      "name": "get_total_voting_power"
    },
    {
      "abi": {
        "error_types": {
          "13064617634155564349": {
            "error_kind": "string",
            "string": "Function get_votes can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "account",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZrdblu5DoXfxde52PohJfVVBoNBpk0HAYK0yLQHOCj67oekuGinwNbZtZOb+PNKRJMUJVHb+XH69PD393/+enz+/OXf04c/fpz+fnl8enr856+nLx/vvz1+eRb1x2nTH11+lrtTp9OHdnca8q7KS50vw17SVv21nz6kJJCKgCpJFRmXMgt0gZIAw6HK6Kyjqig5C1Bz4CwwFJpDSwB26FA6lAFlEGBMyOrphO6grk6QjyibQOkONQPwK4JCUBgKs0PbAAQYDr0C8BGjADRAyUbZEoAd0gaogOGQCwDDSwZAqTBYyYFgkKB0jSIrsIPmcIIrdUsAKOrYhAoYDurYhO6gjpWiwA51A1QHSyYJWNGxQgV0h5EBPIHMMQNNeFcYDuaYAZQMJUMpUAoUTVQZCsOBKgAKF0B3aOJY3RTYQaOYUB10umtSaBNYnZ8gH1olUaxZndAdNJkG5piB55mpAqBwAXjmuXnmuXnmuW8Az3zbPPMte+ZbrgDPfCsZ4JlvNQE88616DhtVABSGwlAalAale+Zb9zy3UQGu9K0APPM9eeZ78sz3vAE8871oDquCZl4i7bq6DXQ5TCAHTV2VXavrcqjiWLd9z6AC+oShqZvQHJKkhTYFclB/JkApUAqUCqVCIa0NViDAcNBZniAfSlI/Q2d5gvhMMqdDN8YJUNT5CWKHdO/dtOx4U9K6cwrN/LadXRPJzaiDNKdOodXQami6azoxiFMQgXTndNJPM/9aB/USFNoIbUBLOh9ODNIZcSKQxuZUgwbIYmOjBtKKcWKQFo8TBQ0QhxUtqUktrLSwolM1SeNomvuscTg1UAothZZD0zN2klaXEwUNkO63TvppevTayebEIN5AOgutKOmu27QiyrYF1aAOMk8nNVCWKBsbEcg8nRRaDa2GRqFRaFpDrRkRSGvI6awNkO53TurpbENyEDtVi22SjtUWomqj4NRAGlHfjBik54nTABFmpvIWhJmpLbRWgzBbVeveZqH2BtLT2YmcyPzTOSJtsSzjZDmdNEC6Qp0wM0Q5iD27xFsQMk4ttBZaD62HNkKznGrGeduCMDN21jnVIMyWnXs2C6ztzSSLbRKBtJ67tYtaz11zwFRAWiVODNLsdlLSg7irp01PYicKGiDNrlMH6crr3YhB6p9TaDW0GhqFRqFp+9OrEYM04041SD2wHlhrw0niGFoHTevZCVrXiCZpxgcbyWcM/dyuVewUmsYxrKvWOCbV0PSYn6Sr0TLZCTntuus5NZD27XLaKHYk1Q5TJ2hDj3c5ggx7YDqruvpkk1e0CbBRNgFGJQWFphuKE6Z2UGhUgzC1g8Myh5UWYzUCW2pjlKA2KW9aSE6krhpmX3XZzs9JJbRiMRnqIQM8q2TpI0PGKN6CCNRCazVogHpoPbwYOQiWE/Z2IYxN2UMVQqh2mXOioIGg7R43B3MOCm2WxEQO7Ge1E4JOIxwaNQiuZRxAOeMAynavcwot5yCEOo/KSWGlxliNQDtBGZCCKGiAmtUnK+rerG1gtrPSyC51ThaTjrF7HfBCtfTZ3+aKUbmDrI+dFFrNQQ1EoVF4wVtQWOaw0mKs3f3IiIKGU7X+e5LV57CbMs2bgKRuCzprGlOym7Tu1cCzqrt10icHgh2jOAc1UAutMainoNBGeDFqECzTBiuUMJYyQp03Q6NSghqoJgQ9L4M2mGtQaFYSaT4s6IH9rOqWPYOmEQ7hVpsZ11qh0NIWhORyDg1XNiGEyri0CYUVu63xz593Jzzu+evby8ODPu25eP4jT4W+3r88PH87fXj+/vR0d/rP/dN3+6N/v94/2+u3+xf5rQTz8PxJXsXg58enB6Wfd+fR2/5QedYyfLSU0wgDsom8MpH2Tcjhph272RBuLYyM+spG3rch/SiR2xBuac/GKpSe4EYeOe2GUhcmaqIt0iHdx9mN9soGvUE6+H3TIQ1xcxOyEbTddPRFKFnLdUYiC+vCRH5lYrxBNtL2BulYxVJSgR+yh+/GkvJbBFPeOZjcckzM2J+YtKjT1iMW6VjrbiirMpVjDDaEx62hiI3dUFblQXr/ml7Q6Pt72KJO5TlwiZU/SuXdTWzliDz8DU9KqfWKZXsZjNzYdoNZrvxUsKlX7ffCSC2vt7G8qFPKCY6QnHZhQwy+trHYT+XmipxuOSxIe/PawqpK27lKe6KzDS6vbazKlFBhNZ3nNbdfJrYtqiMN5EI63LFvo6/yiTmhsl1nYWBD54tM/FYc+Xzal4sZ+dVGWR33lLFQ9AHGlTZ4hI0+rrNRtrAh7fm+jUV9torKaJWvsjAq9nK5u15lQW7SsQHKNXLfxmJepQOHG7XTeV7T+I106sN5TyddOa0lKlSwX2XjLUJJsZXLg+J+3UppKbautlivtbyvDXlmFrFw69fZaC1aHznq923wrStlZeHYSllZOLpS6ri5vJbpHOeNRx6A7ZfX6nCV56NxuLa8e7hSXpZGTKt8oXi2IZvhdZ1CT7udAq1uTTmfT8fL6vjFEVqc87KZF+w/wkR7rROtDnr5kiz6UXnMt9ufU1t1C3z2hJj3jazDyRfhXF4kfzGyvDuNuH7J89fz3Gy/0wqOHhMsD8R2J5jT7a0g51tbQS63t4Jcb20FmW5vBZlvbQWXFg61gss4DraCPG5vBdc2jrWCSxsHW8GWbz3gVhaOHXArC0cPuEY3H3DrdB5rBdc2jrWCPN43lIOt4HKlHGzjenpfG0dbwaWNg61gv/nS1G++NPU3uDT12y9Ny3QebAWXh+vBVnBs790KXnYKtex2CiPf3gqO8gat4Khv0AoOeoNW8P+Ec6wVHO29W8GLXl++5tud4OXS3bCtyzf+1y1+xsqV7/Nv3T4WFpZH9aEolhYORXGwXVhYWN6oD0WxtHAoioO3+oWFcnNFlZsrqlxXUX/K2/uPjy+v/jH/p5p6ebz/++nB337+/vzx4rff/vsVv8E/9n99+fLx4dP3lwe1dP7vfvnxB7V6R6P8eXdK9lbiIW76Nulb2RhojD9/qjP/Aw==",
      "is_unconstrained": true,
      "name": "get_votes"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6704778553435785618": {
            "error_kind": "string",
            "string": "Function get_voting_delay can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAMvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQVdDCiSJzKJkjwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTVTWvmk0C5LX20Wrqb9NoaFOkVcvCBu8oHo94zCfkqKU5ncqGBMNqumBMG1yhT6/PlSKlVj10iMtXlI2Q5u7GyPh/8gxY3IJwZfEVZEPH2nI3erS9Pv7ixThPVNdW7ruXsbu8vm7fD3kd6kO8+jv1/q69jXkbRefICfH4SS3DHeYmLHS62OU/zrfw==",
      "is_unconstrained": true,
      "name": "get_voting_delay"
    },
    {
      "abi": {
        "error_types": {
          "11721653196875790723": {
            "error_kind": "string",
            "string": "Function get_voting_period can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgEEACcCAgQAHwoAAQACAEQlAAAAQSUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAKYeAgABAB4CAAIAHgIAAwAeAgAEADMqAAMABAAFJwIDAQEkAgAFAAAAdSUAAADMHgIABAkkAgAEAAAAhyUAAADeJwIDAAQvCgADAAQcCgQFBBwKBQMAHAoDBAQtCgQBJigAAAQEeEUMAAAEAyQAAAMAAADLKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQWiq616hBp5gzwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZbLiuMwEEX/RWstVFV65leaEJzEaQzGCW57YAj+9ykFy48BadGd3lhXcnRSt1x6PMW1Po+fp6a73b/E4eMpzn3Tts3nqb1fqqG5dzz6FCo+HIgDSeGsODgpPPcAuOUuaClC7PN4CNx6KUDpWQAm4cQBeQogjyCyIJWEYcGzQaskmIuBhYEkXiPTJEWK7TT0dR1D2wTLFh5VX3eDOHRj20rxp2rH14++HlX3aoeq57dKirq7csvAW9PWUU1yna3yU5F8mGejVmEBAIUdAvII8Mr6mcHauQUS9I6BeQahMWZmsHaQY5SseEhhYEDIWtEFhAajlnSAWxMa3I5h3pAO+7vp0GjdjNBkXDYdvmAFySYnaOwGgTtEeEM2QL0hHSUvBJTiIKKsF8B3mKFfNoMOlw8T8h8GCnXq/OLFBdRZK6UyJasTg3X4qRVmZK2UyoOTmKIwwef3sEKdYiBaVn4gbbObWCkQIlwiIdL6G8t2a8YqlTVTWvkEBpelD34tdk37bQwLdYq4eEHc5APR7xmF/ZQUpzK5UcGYbFZNCYJrlSn0+fOlVKrGrpEYa/OQsh3c2NkeD/9BihuRTwy+IqyIePpOR+5Wl6bf3VmmCOub6tzWc/c2dpfN2+HvI71Jd55Hf7/U17GvI2m9+AA/PwgluWO8xcSOl1odp/jX/wA=",
      "is_unconstrained": true,
      "name": "get_voting_period"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1940413677172494365": {
            "error_kind": "string",
            "string": "Function hash_proposal can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "actions_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "description_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZjdbuM4DIXfJde9kEjqr68yKIq0TQcBgrTItAssir77kooOnSzGBsbt3CSfT+IjUqJowR+bp93D+8/7/fH55dfm9sfH5uG0Pxz2P+8PL4/bt/3LUdWPTbCPmHlzyzf6XTe3Rb+LXsdooEIUhWqK/dSiQjXIZ6AggLa5Jb2LoipECkSAMoAjIA8QKAIlQUkJ0AZkOFuklBQs1DOUAZUAUBqUNhQOEZAGxAAQQBtADBiDMhMAhgLDnoVBgmGCYYKhTTdlgzKgEABKhVKh2MyfIZ1BQgAIoA2IDKgDiADDUDgC8gCBoWAIgWHCEAmGyEKQhRQYFhhWM9TaSLEM6D4d2gArJIPMDBh/zkIAKAlKgpIjIA0oASCAMVauGKLWAQ2GbRiWEAEjsNLzagpVfTgoNNsw0aCeoQYGlAGRAFAoAvIADoAEaANEAFAShkgYNGOIbIa6L6rlzrqVWw/DoIfRIQ/oYXSAwrirh9GhDSj4T8VdFf9puKu5Mu6KwSpyUAVZTQ4qICIn1zg6ZZAEJ3OWThXUZ+ZMrmXXsmvFteJada1Ciz2+ZNTj69Sjyp0ySFyzDSPByPb9INOsi8ZsGnUyzfKItlLSRyum9TFsuwyqICu1QRqV2GgUyCmP0ShGJ9fINXLNGlTqZH02xU4NZA12kM2GdXyy5pSoUwFZNQzKoOaaFUQnthY1aNIayHrtoAqybjvINSYnRMDimiCC3nMTd0qg7FqetAayFjHIteqarcKZbBUGQZPATgVkq5CkUwJRcJq0BmJxck3YqYCs8w1yLfto1gDOVFwrPlr1CKqPVn205lrPzSgFdnItklMf7fPzZoPDxP3babezs8TF6ULPHK/b0+74trk9vh8ON5t/tof3/qdfr9tj/37bnvRXrcbd8Um/1fB5f9gZfd5Md4f5W4lrG3eTPv3cQNfpyiLOW+iuy3V4KJfiJk2uPGjeg/WskoaHcolzHkup1Igw9MQSZ1ORBQutuuDToS1mCqNceaRvmI78d6dDKJdhIZzK7HTUhVTImvM5E0r5woKuLNo3zEYM3zAdS7lwZMTBzLO5RPqOZPgvJ6PPFF+YNr8wcaFOS/VcSiOZTWWpTDkLPJTbV1NRj9lUlspDJxFRpFbne9hCnVJj9p3f9JE428SWAtEHrUfCLLJi214mk0OYTWZp56fsYSiXqasLX7cxWqhTourtlOliYa7joKV2mggtSLGussgB21bPVrTKovjOp1LDrEVZWhT5/aL8SRTNH7R1pUXL4iVaZJ1F8ChabGssOEY8FLSlpnUWIbhF5HUW04rowf6rFrRyRaqQL2paaUEyWcQ5Cy5LT3rfI0Iyu1N5oQtPQVS52KfX3YIX+mfOKIpc0hqD4jmUGNYZYCkKzUewNI1MyQ9MmVetBMf2dYv4VQvxA4ZIzassUvOSyjTbJ6Qs7g2eCnu2qKQuPT8mi5Rl1mLp/KmvOfx8oa8yLiqj/kEcLFMceS6O5W3uy6o7Pq7rFMWfpnVdy9OXDVMU/3uC3OnV9nF/unq//Wlep/324bAbl8/vx8eLX9/+fcUveD/+enp53D29n3bmNL0k148fVMKNxn5nb4vsMtUbymyX0S718UY5331aMP8B",
      "is_unconstrained": true,
      "name": "hash_proposal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "1839173940655436289": {
            "error_kind": "string",
            "string": "Function is_council_member can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "addr",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEUlAAAARi0CAUUnAgIERScCAwQBOw4AAwACJiUAAAJFHgIAAwAeAgAEAB4CAAUAHgIABgAzKgAFAAYABycCBQEBJAIABwAAAHklAAACax4CAAYJJAIABgAAAIslAAACfScCBgA/LwoABgAHHAoHCAIcCggGABwKBgcCJwIGADMvCgAGAAgnAgYANC8KAAYACScCBgA1LwoABgAKJwIGADYvCgAGAAsnAgYANy8KAAYADCcCBgA4LwoABgANJwIGADkvCgAGAA4nAgYAOi8KAAYADycCBgA7LwoABgAQJwIGADwvCgAGABEnAgYAPS8KAAYAEicCBgA+LwoABgATLQgBBicCFAQNAAgBFAEnAwYEAQAiBgIULQoUFS0OCBUAIhUCFS0OCRUAIhUCFS0OChUAIhUCFS0OCxUAIhUCFS0ODBUAIhUCFS0ODRUAIhUCFS0ODhUAIhUCFS0ODxUAIhUCFS0OEBUAIhUCFS0OERUAIhUCFS0OEhUAIhUCFS0OExUtCAEIAAABAgEnAgkBAC0OCQgnAgkEACcCCgQMJwILBAEtCgkCIwAAAdYMKgIKAyQCAAMAAAHtIwAAAegtCwgBJhwKAgQCHAoEAwQcCgMEAgwqBAcDJAIAAwAAAg4jAAACNwAiBgIEACoEAgktCwkDCioDAQQkAgAEAAACLiMAAAI3LQ4FCCMAAAI3ACoCCwMtCgMCIwAAAdYoAAAEBHhGDAAABAMkAAADAAACaioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFGYYO9GTsMgE8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndbtswDIXfxde5kChSP3mVoSjSNh0CBGmRJQOGIu8+shEdZYOEoaNv6iOpPiKpT3Jgf0wv26fz98fd4fXtx7T+9jE9HXf7/e774/7teXPavR2492Ny8ifRtA6rKXMj8YVb3q+mwk2PfJU293sXWGQRuQofqwA/rcGL4B4AFgFVFBZyO2IVxMZQRFAVUXuiRMJz+uRUsGGQoexVpGmNMlRABceDPAQS4VXwpMRD4LEKYEOSIaAqAhtGGQqxCmTDKEOYqiA2TDJEuYrIhkmGYqlCqpdlSOp3FWyYZah4FWyYaTUF51XEKrz2eO0B7ZFQr6JUIVW9ilwFBhU6BYEKNYxqGNVQynsVaph0iqyGWacoaqhZoGaBmgV6p4JUVEMEVFENMYAKNUTtkcCKYyGzFyYKC8dTQES+CnJBhfQwuCTUFa48yZpehfagGLIzUTWkmERcLqtJd8Lj6bjdykZotgZvmPfNcXs4TevDeb9fTT83+/PnP/143xw+r6fNkUc52O3hha9s+Lrbb0VdVre7Xf9WCALH592ArswGvGfuLHzfwmcXc/VgndJsUvDOA/oezBlR9WCdfM9jlEr2GgYU8N1UcGDB7Li5HHwC3MJIdx5kUI64bDkQYqoWGCh1y5EHqfC5pJkAxcYC7iyKQTW8MyjHKJfgg8YRQujm4sEimbBwMpBgXpjSXxg/4DTlOZdUALupjDANEdWDdfnfVNijm8oIDy6iRkEl98+wAadQQph3fgkYu4fYKJAQYI6EH5T4hW3bJhOd6yYzsKDs5EfTpwdrpNmEn3b3yQw4BZhzAWjqAZDvPQbnaXAlaCSsibpVpZEJ3ChzkPvPlxGqFG+RUIx9k3E60KTTPh7+MBkAn5Pu/lxuBvLs/fflzTQvr/elu7zB/f/yBm+wvAEMljcEg+Ud1tWHpq5xUFcyqGu0qGuyqGtevK4NrzDgFQ14RQte0YJXXJxXaHiFAa9owCta8IoWvOLivELDaxjwSga8kgWvZMErLc5raHgNA17JgFey4JUseKXFeQ0NrzjgNRrwGi14jRa8xsV5xYZXHPAaDXiNFrxGC17j4rxiwysNeE0GvCYLXpMFr2lxXqnhlQa8JgNekwWvyYLXtDiv1PAawXXrmg14zRa8Zgte8+K8xvn1IuvmRdhfdTXgNVvwmi14zYvzmkKa65pC/xwYm5Tb4mT3VRPKt0gifdWkSSehRTqxa1JG+w/1HED+yjhb0OXywI3N8+5492XzIk7H3eZpv63N1/PhuRk9/XrXEf0y+n58e96+nI9bcbp9HpVvW988v8714B7kq6c0GXx+Q/9wkel/Aw==",
      "is_unconstrained": true,
      "name": "is_council_member"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "verified_balance",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "proof_nullifier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "join_with_erc20_proof",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "balance_commitment",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "join_with_token_proof",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15596384838086695822": {
            "error_kind": "string",
            "string": "Function proposal_deadline can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZndThw7DMffZa+5iJPYSXiVqqoo3VYrrRa0hSMdVbz7sRPbs8vRRDDQG/iNh/lP/BEnGf7sfuy/P//6djj9fPi9u/3yZ/f9fDgeD7++HR/u754ODye2/tkF+VH5Z7rZVdzdlptd4ysA/s2XkG92EMRQBCpDZYCkEMGAdreRH4LElhgFmkLODE2gKWAyqApkFjJLMUspChUMSEFGOgAN+BUp3OxiDAbZwG4lsySzZLPkqoDRoCgQGJBCsVcUNBAHORqxJoOq0KIBDUgBDNBAH0+QDcwSk0FRSNHALCReRIGqIDEcYJZqlmoWGdgAGpBlYANQAYKBvCIJVIUYDUihBxMZSG6RACn0iHXIBlWhD6yDBJzdyQ0MaAAGMDALmAXMEs0igUpcEigFOYAUslkyKmAw4IHlIFAVxIsBpCDpziDQFGTwA/ilmQOFElUBkrkzABWiBpz6CAUSGGgKKJslawoIg4GmgFBTQBQNNAVUNQUlaApK0BQUCAbZQFNQYjLQFJQEBhreks2SzYJmQbOQWUhTUAoYaApKNUvVFJQWDDQFpWkKaogGmoIKEswsIClgT6tM8w4yLwYUBQld5vZVZV5kHlgt0YAUpAMOyAZNoXFYUF7ayoAm4xlgFjALmCWaJZolSZGQQFGQYA5AA34p9tabDXjMyDlt0iEHmEUG30GCidK4JZgdJJgD1MI9PDi5DdwGi60ZSUgHSUyVyCiDk9vQ9dD1pAehrBBBJjS2TnyXZLHoS4vSYuMRUBKSGlVym7Rxyn0NkrvYSWzyNpBIEnVq+ra+2ihVI3KbFOkgqQolt1VwQiNZY6SeIIbkVIykJSnJWPra2FM/qBplt2V+lkS5rzpKbpPZVEInsidKcEKj6jYrYaZm1NzWbAQpRCdTThCc7Nkko5duAn2pGdT7wCB04idK3wL0iS9ZSCU6uU1iWvoOQRbyQc1tUhtFMp2Dtiqm7NSMwG3WwCBbB2NyW4pOZJRdObsK+rNkXuYCTujUjKTrd3/HwkSd7B1jaRqE6hvKpkRpsTX1F5ONBZONHnNychtGJ4spktvIR2CrLZMrF1fp6yy9vNzsbD/47em838t28GKDyNvGx7vz/vS0uz09H483u3/ujs/9j34/3p3676e7M9/lCt2ffvBvFvx5OO6FXm6Wp8P6ozwpmj4dOcEuwLVwJQHrEsBLQ1UN5lJcpOUrjbiukSIiqgZzgTWNmSsVbBi844NVV/JEIgMGDweUJaCtXGngJ4SD/m44eFNYVCInLKvhqBNXopTr8CQiXUjEK4n2CdGA8AnhmPmSINk4uKuu+gLxM5xJf9mZKP1LE9PWEwOTOi3VfSkt5lVXZmXKxx7TYG4fdYU1Vl2ZlQfKSjBGga2u97BJnUbeIvrMbynTahObDYQPhj6SlHLeMG0vneEDzKozs5kP2HzqA595XCSn6zYWJ3XKpzkbCPJGyDUi0LXGpJ/yimgxDcsoeMNxrTCr0rJUKZ88Fg1K1xqzMsW4RGPxo7xKbJlUBzSLBX/caOsadRZPW2gxhW0KnlW6iMS7/IjLap8uMvJaI82We4w2UXhjVDZqUHON2rZp8CcbbxyxrmtM6rNkq4ySaZNCy9bL+bS4SYHPet4AA63nNU3ymivYMHLFJa/Q3hFOOdNrOHFjWpNXKGPdpPEZroC3cj6K1m0zpYC3rjKZrzn9XQ0gcl+o1G0apfjWh5f6dQ366EyZKbxtpswU3jpTcvtweU3D2ZbG0+J6OKeLKxD64lri6uKKcVoanlaqF+XFzXDbTiGH1Z0Czk5NMS6r42V1vBoITtZ5bubJ+g8z4trWCWcLfQA/Agq3jSJeqcK0TSR6DxJeF5nHJF7E5PI0+uokGWZVgtUbOzeTi21YoXeoEC0q5WK5/Z/KrGLTMpR8sbeVDw/viGyhJbJ1a3oIPkFkOf2wyPpBf7o3paXu+fvRqsi0tQabxC1ubM5knbUV/Gh7nyhMt1Jv8mKq8CYv3ride63wlS/v7g/nq3/hvojU+XD3/bjXy5/Pp/uLu0//Ptod+xfw4/nhfv/j+bwXpeX/wPzjS+KP14noq3ynl0v+1plykEuQS5K77euLDOY/",
      "is_unconstrained": true,
      "name": "proposal_deadline"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3107034805524995561": {
            "error_kind": "string",
            "string": "Function proposal_eta can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_eta"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16563349372015579773": {
            "error_kind": "string",
            "string": "Function proposal_proposer can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_proposer"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15233556076734149416": {
            "error_kind": "string",
            "string": "Function proposal_snapshot can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_snapshot"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "8683601360157590068": {
            "error_kind": "string",
            "string": "Function proposal_state can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_state"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7356147743016370783": {
            "error_kind": "string",
            "string": "Function proposal_votes can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "proposal_votes"
    },
    {
      "abi": {
        "error_types": {
          "12236415031589006904": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8171600539936659379": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 92
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "actions_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "description_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "target_count",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "proposal_type",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+2dB3gUVbiGz2aXEHpHOkF6FaQrHRKadESREkKyQAATSKGJFHtX7L2jWLCLDeygCIgdu2LBgmJFEQv3+2EGTiab3Tkzmw+9987zvJnNnJl5/3PmzJk+E1AHuvpWPy0tfVF+OCMtOzctKzs/nJudPjsvLW1Obs6cnLzw0pBSC0IHRgyAoNVPAMmOYXZf/10lwnjVQB/HsJpgmWPYERGG1Yswv/oRhjWIMKxhhGHJERyNIgw7MsKwxhGGNYngaA6SHMNaWMOsoo3eBax+stVvnzk8d3uHm1s+PjJlzfLlJ05q0fHrQQufmLOi//bdl/2I9PuDh8aN0bXx43kgtqeUPu/y6lCGA1ac0m9q/d/M6st87fEexO+HwMPgkWDhmQcd8cboAs0Nxn0w6L4cHnVf3oU60/hbGIz7kEH8awzij7QcH7WW4xqr/7DVf0Rbjo/h9+PgCfCkYzkmWP1k5S6Easp93p5ym7fAqGX6CirT9VH+4myi3Me51v0yCOhx2tOF1KHGt8gEhnGvNawPdrfOuSVYZ1UECa6MOrzBPR30IXw6aD7dMwZroNe4ntHWpGTlvjN1rbNczhYrVr7WGZSBSXk9a7C2HPxjGHek/LopJ7fjmuT3uWDJLl+pS+uC5uX0vMctn2lLutagrF7w2JK+oLWk8WqsTMbVfS96bazsiU0L+EWDQltfwg2b/FnvocFdb1AZ/w0LeYOfhbzBQwFtMFhwUkAJqnABmbYO64ORp3OTP5fjqgra75cs38tWf6PVf8Xqb7L6m63+Fqv/qtXfavVfs/qvW/03rP6bzv2bjcGiR7ybIwzbGmHYG8Gitc+0gN9yX+M7+fG8HdtTQZ+38wDhLSuvL1n9l63+29oBwjv4vQ28C94LFp656WZ4o0Fr9o7BSvG+x82dafyvGMS/zSD+D0jxbzKI/12D+D/0eaD6vlXvPrD6H1r997R6+BF+fww+AZ/6rIebDcrhI4Ny2E5ajlsM4v/YIP7PSPG/ahD/Jwbxf+6zHm636t1nVv9zq/+pVg+/wO8vwQ7wlc96uNWgHL4wKIevScvxNYP4vzSI/xtS/K8bxL/DIP5vfdbDr616943V/9bqf6XVw534/R34HuzyWQ/fMCiHnQbl8IPPcvjByvd3Vv97q79LK4cf8fsn8DP4JVh0ntIlu4z3V/fxVvLj2R3bE9Tn7SyXX61y+NHqv2n1d2vl8ht+/w72gD+s4fY+rrNzxh+jC/xmsFwTtN97rVz96dxhl4RljmF/WsP0zrRi/2ZQWfcWP+5Ex7iBPw0KIKQOHbUV1yUXM9zp1dNMF9pew5XR7v5yLqy/gkVrkXPBmBR2FPfBANzO9++g68IslKe/XVS2WO4/DeI0ydM/UfLknFbP0z/aSpWk5UfPU4wuEGHchK3VJhck3j4po23zCik/1ap6+em9X7zwtN7N2xjM9+DKYK/89gpvEts+GR9rVsBxsdZ0uZkc1e0zWG4JIbNGIl7nvUy8ui8Y8iGUiU2nC4XcF6bXuEJa5UhW5p1pZTI5xFYG+S91mCpTKY+VKdFrZRJhoofKVLqEK5PEVdpjZfKyYpQOme9XJhkuLLuS7LO36JYzEIo+XDxlQFlQLkbrGyuMfUGzcrHHjVUW5UNmy8junFdoTMo81rgV3McU0JdP+dCh5aDHFnMm6sDWTfqbzLau+6eReCuCSqCyYzmbllPAoJyqGJRTpFhiTWPXX7fj2+Vguj5WJdXBzQZ7JdVKuGz31zcDhyzrqh7Ktrph2ZpuyKUzuaIqy2Cf4XKo7mE7ZzDugbZDFT534LzWszHCuYMa+FETHAFqhcx2KGLlu4a23FpN+mLJm+r+5o8l3n3LwKl/pV488a+aW5bX3DmrzAM/Z/a49QndVzvkQygTOytyLHltg0pcx+fOh5s81IlQWWLloY7hXqPcFhrpPIVpJa3hseFTZp5Ct+nWtf6pZ/XrW/0GWrkZF7xBARa6aaW+vcekiq6Bda20eqHC4+prYEPxgkbgSGugaUtsV5pkg7w2DJlvfQwWdqChYYWM1xnLpu7HLbQCNLbKvolj78d4N1cPIFaBNi5+oRU5E9nkMB0XNokS4+9br3n76rNfm37+ivs/yl5y5+26r2lxzbgbYdPYtbOIvKlB7Wzmsxl3k4dmsfd1iuShWQmtNc48JgdPa1C1b589W/NWzp285M6V0bzOafW1prm1kFuEVOHTrJKwzDGsRcj81Gu0QGMtuOYGa1cLgwKQvP4bzvM3NzwJYHctnQurZahoLTLdi44STJEK2tJgIbYKuS7MQnlqFfJ/nr+FQZwmeWptUNn0PLW28hRpzTfdZ5AVqbFBzDJ+k5C/zUesTl+h2lgtS1tnZW0ToWVpqy1s04JobDXV9vixCsJu2k33C5oYONoYtFxtDTcZ/4aWq43HlqudszK0i0PL1cag5WpnsBCP8thyHRWHlqutQZwmeWrvseVqr7VcxVXAktz8+fF4rawdnJW1Q4TKGjIMprnHViRKnAeDdTvfow3G1fN/dISKbZp/k02yyUpgkv+OhhXCzn/HKJtvfXyT8mjmftxCK10nq+A7hxwjmW7W9ABiFVwng81a58N0uNvZ4+FuF6+HuyLs4uFwt4vB4W5Xg9rtNQ9dPRzudj1Mh7tdPR7udrMWcndn094twk5p95D/w12TBdfNYO3q/h883O3mcTt8jHNhHROHncZuBtvWYwwW4rEedxqPjcNOY3eDOE3y1MPjTmOPOB7uyorUySBmGb9zyN/mI1anr1A9rZall7Oy9ozQsvTycbjbyWqq7fFjFYTdtJvuF3Q2cPQ0aLl6/QcPd3t6bLl6OytD7zi0XD0NWq7eBguxj8eWq08cWq5eBnGa5Kmvx5arbwkc7pps/vx4vFbWfs7K2i8Oh7vdPLYiUeI8GKzb+fb3eLjbPw6HuyabZJOVwCT/Azwe7g6IsvmOtcMe6Yp1Aw+b4wYeN8cp1oJKDfkM2HSz2cBgwaQYbDZTD9PhdKrHw+mBxRW8G+FAD4fTAw0OpwcZLCSveRjk4XB60GE6nB7k8XB6sLWQhzg3HYMj7PQOCfk/nDZZcIMN1q4h/8HD6cEet/NDnQtraBx2SgcbbLuHGizE4zzulB4Xh53SIQZxmuRpmMed0mFxPJyWFSnFIGYZPzXkb/MRq9NXqOFWyzLCWVmHR2hZRvg4nE6xmmp7/FgFYTftpvsFqQaO4QYt14j/4OH0cI8t10hnZRgZh5ZruEHLNdJgIY7y2HKNikPLNcIgTpM8jfbYco0ugcNpk82fH4/XyjrGWVnHxOFwerDHViRKnAeDdTvfsR4Pp8fG4XDaZJNsshKY5P94j4fTx4cKP+RdXhsv2eon9VpY5d3OZea1/DGxoMNfNV75e+Gq63Zt6n5J76wT2mTkDDlJH7fO0sl7Vy/tMLHpXbV+Kf/yto69N9+zaNvGStU/Xr52fYs/Lpukj+ums8ctNWTVzLxN53UaPXnC0+98cewttS86q1Ja95HNLp77ScqKdV8k6OMm37D1mTZ/nvDHb6GcAdvqbNi7J3fs/S/1WRzaObXO1LNfea6ZPq5JDPUG/LwyefHy5887vdHK5RO/frBD5SZPfV+tVu2n3t996+pVAwfp4wbv3tVlR79W9QMrMlptGH/tNztX3tvmiFUbk+/ucf/5567fs0of1ySGtnue6PPluRWHV5v/6Zi8vTuurV8wIqvzjjuXrZl2eX6Hn7ds0cdtt+Wc18dPXzvm8TNXtKtQ86z0sfeuufv5N/dMbv7Kkh8eeu6S0/VxY3VJVl/qSWOrzbBv3Otk9e0rGylW3z7NkaxcdUGDcU3mGxiHOE4AJ4YOrNuJKj5nIcZ5bOwPdqa7hS8YPB823uDMg94gRJrOWTCx3Ce5d7f245ng0tOv33MVvMxfOnmGz3Q5mTgmxmmPIZZnUmxPaX3ezqeOTrJW6glWf6LVnxQ6NN5k/EgDU0B6qPDM/TzwEmvcyQYbyqkey9vPHUyxxk0ziD+DFL/JRxWmGMSfabij4qyHU616l2H1M61+ulYPw/gxDUwHM3zWQ5OPM4QNyiHLZzlkWfmeZvWnW/0ZWjnMxI9ZYDY42RouK7n+9pzEYpzJKnZnt6v2vNxOJ6N7afdMHSZP7Xl1mNwq6dVhsC56dhjUc1+emeydpvEGK2W2x50mezpZwYr7/I9pQQXUv3uBmHrGkzxB5cFjnxYJRJqjYQDZhi273eU4z83khA6NYBqEfFni+aD5buIcwzO38bqiO8djoc0N+RDO9XDtINegOfEaV67WfiS7m27/wiirCp/FNF34xVWaWDG7rPGB4hKSlbtp9bzlWWWU71xr8kKHVmV7WL4WoNdCMd1xzHZXUS6V6xZ5BpUq37CwvVRwicf0NQ4meSgw2M4e/KPcTyMtZ0HIfFnPM9xGmcYl37t51kOrPN9nXLHm77W8FpTwcvS6FVtouBVzNpx2Z7oOmOw/zj8MjeYiq9E8xdloLorQaJ4SIcCQQ15SBRKrwVxk0NicUsINpqw8Eo/p9dAcgzyY5Hexz5XSTdyR8uumnNyOa5LfUw0bR9MDSNkozDesxws8NKZLSjgfsi4abOACkoeFHvKx1OOBnml+TD5CmBOnmNzs8ScrV12gpeLEFFDuY2qlODElKPcxtVacmAxOHATaKE4db6vcx/9Y0FtMptu7dorjOUpxPO0VZ1l2UO6X5VOkZXm04ng6Ko6nk+J4OiuOp4vieLoqjqeb4ni6K47nGMXxHKs4nh6K4+mpOJ5eiuPprTiePorj6as4nn6K4+mvOJ4BiuNJURxPquJ4BiqOZ5DieAYrjmeI4niGKo7nOMXxDFMcz3DF8YxQHM9IxfGMUhzPaMXxjFEcz1jF8RyvOJ5xiuM5QXE8JyqOZ7zieE5SHM8ExfFMVBzPJMXxTFYcT5rieKYojiddcTxTlTdPSV4DyFDxiSmWJ1O5j39t8N9XTmHFqSPTFMczXXE8MxTHk6U4npmK45mlOJ7ZiuM5WXE82YrjyVEczxzF8cxVHE+u4njyFMeTrzieAsXxzFMcz3zF8SxQHM9CxfEsUhzPKYrjWaw4nlMVx7NEcTxLFcezTHE8yxXHc5rieE5XHM8ZiuM5U3E8ZymO52zF8ZyjOJ5zFcdznuJ4zlcczwWK47lQcTwXKY7nYsXxXKI4nhWK47lUcTyXaeOWxJOL8nLiuiHz84CXG8RVt4Qf0JI81POQhyuU+zzUI+Shvoc8XKnc56E+IQ8NPOThKuU+Dw1C3tY705iudj9ue7ff2/5h377XC0kMY7pGcdqcaxXHc53ieK5XHM8NiuO5UXE8NymO52bF8dyiOJ5bFcdzm+J4blccz0rF8dyhOJ47FcezSnE8dymO527F8dyjOJ57FcezWnE89ymO537F8TygOJ4HFcfzkOJ4HlYczyOK43lUcTxrFMfzmOJ4HlcczxOK43lScTxPKY5nreJ41imO52nF8TyjOJ5nFcfznOJ4nlcczwuK43lRcTzrFcezQXE8LymO52XF8WxUHM8riuPZpDiezYrj2aI4nlcVx7NVcTyvKY7ndcXxvKE4njcVx/OW4njeVhzPO4rj2aY4nncVx/Oe4njeVxzPB4rj+VBxPB8pjudjxfF8ojieTxXHs11xPJ8pjudzZeYxnb9c164TMp/uC21cN/eseI3vS8Up5x2K4/lKcTxfK47nG8XxfKs4np2K4/lOcTzfK45nl+J4flAcz4+K4/lJcTw/K47nF8Xx/Ko4nt2K4/lNcTy/K45nj+J4/lAcz17F8fypOJ6/FMfzt+J4/lEczz7F8cgELsd1TGjmCZA8CSRPkOQJkTylPHpM74VODLg/nvP6eV3TvJcm5T3JIO8vkN7/XIZUv8qSPOVInvIkTwWSpyLJU4nkqUzyVCF5qpI81Uie6iRPDZKnJslzBMlTi+SpTfLUIXnqkjz1SJ76JE8DkqchyZNM8jQieY4keRqTPE1InqYkTzOSpznJ04LkaUnytCJ5WpM8bUietiRPO5LnKJKnPcnTgeQ5muTpSPJ0Ink6kzxdNE9J3qfRlZSfbiRPd5LnGJLnWJKnB8nTk+TpRfL0Jnn6kDx9SZ5+JE9/kmcAyZNC8qSSPANJnkEkz2CSZwjJM5TkOY7kGUbyDCd5RpA8I0meUSTPaJJnDMkzluQ5nuQZR/KcQPKcSPKMJ3lOInkmkDwTSZ5JJM9kkieN5JlC8qSTPFNJngySJ5PkCZM800ie6STPDJIni+SZSfLMInlmkzwnkzzZJE8OyTOH5JlL8uSSPHkkTz7JU0DyzCN55nv0lOR3IBf8C2NaSIopqNzHtChOMcXynBJwH/9M0jvgFxvENJ703MOppHV2CcmzlORZRvIsJ3lOI3lOJ3nOIHnOJHnOInnOJnnOIXnOJXnOI3nOJ3kuIHkuJHkuInkuJnkuIXlWkDyXkjyXkTyXkzxXkDxXkjxXkTxXkzzXkDzXkjzXkTzXkzw3kDw3kjw3kTw3kzy3kDy3kjy3kTy3kzwrSZ47SJ47SZ5VJM9dJM/dJM89JM+9JM9qkuc+kud+kucBkudBkuchkudhkucRkudRkmcNyfMYyfM4yfMEyfMkyfMUybOW5FlH8jxN8jxD8jxL8jxH8jxP8rxA8rxI8qwneTaQPC+RPC+TPBtJnldInk0kz2aSZwvJ8yrJs5XkeY3keZ3keYPkeZPkeYvkeZvkeYfk2UbyvEvyvEfyvE/yfEDyfEjyfETyfEzyfELyfErybCd5PiN5Pid5viB5viR5dpA8X5E8X5M835A835I8O0me70ie70meXSTPDyTPjyTPTyTPzyTPLyTPryTPbpLnN5Lnd5JnD8nzB8mzl+T5k+T5i+T5m+T5h+TZR/LIw18ux3VMaOYJkDwJJE+Q5AmRPKVInkSSpzTJk0TylCF5ypI85Uie8iRPBZKnIslTieSpTPJUIXmqkjzVSJ7qJE8NkqcmyXMEyVNL85Tku8prk/JTh+SpS/LUI3nqkzwNSJ6GJE8yydOI5DmS5GlM8jQheZqSPM1InuYkTwuSpyXJ04rkaU3ytCF52pI87Uieo0ie9iRPB5LnaJKnI8nTieTpTPJ0IXm6kjzdSJ7uJM8xJM+xJE8PkqcnydOL5OlN8vQhefqSPP1Inv4kzwCSJ4XkSSV5BpI8g0iewSTPEJJnKMlzHMkzjOQZTvKMIHlGkjyjSJ7RJM8YkmcsyXM8yTOO5DmB5DmR5BlP8pxE8kwgeSaSPJNInskkTxrJM4XkSSd5ppI8GSRPJskTJnmmkTzTSZ4ZJE8WyTOT5JlF8swmeU4mebJJnhySZw7JM5fkySV58kiefJKngOSZR/LMJ3kWkDwLSZ5FJM8pJM9ikudUkmcJybOU5FlG8iwneU4jeU4nec4gec4kec4iec4mec4hec4lec4jec4neS4geS4keS4ieS4meS4heVaQPJeSPJeRPJeTPFeQPFeSPFeRPFeTPNeQPNeSPNeRPNeTPDeQPDeSPDeRPDeTPLeQPLeSPLeRPLeTPCtJnjtInjtJnlUkz10kz90kzz0kz70kz2qS5z6S536S5wGS50GS5yGS52GS5xGS51GSZw3J8xjJ8zjJ8wTJ8yTJ8xTJs5bkWUfyPE3yPEPyPEvyPEfyPE/yvEDyvEjyrCd5NpA8L5E8L5M8G0meV0ieTSTPZpJnC8nzKsmzleR5jeR5neR5g+R5k+R5i+R5m+R5h+TZRvK8S/K8R/K8T/J8QPJ8SPJ8RPJ8TPJ8QvJ8SvJsJ3k+I3k+J3m+IHm+JHl2kDxfkTxfkzzfkDzfkjw7SZ7vSJ7vSZ5dJM8PJM+PJM9PJM/PJM8vJM+vJM9ukuc3kud3kmcPyfMHybOX5PmT5PmL5Pmb5PmH5NlH8qggxxMgeRJIniDJEyJ5SpE8iSRPaZInieQpQ/KUJXnKkTzlSZ4KJE9FkqcSyVOZ5KlC8lQleaqRPNVJnhokT02S5wiSpxbJU5vkqUPy1CV56pE89UmeBiRPQ5InmeRpRPIcSfI0JnmakDxNSZ5mJE9zkqcFydOS5GlF8rQmedqQPG1JnnYkz1EkT3uSpwPJczTJ05Hk6UTydCZ5upA8XUmebiRPd5LnGJLnWJKnB8nTk+TpRfL0Jnn6kDx9SZ5+JE9/kmcAyZNC8qSSPANJnkEkz2CSZwjJM5TkOY7kGUbyDCd5RpA8I0meUSTPaJJnDMkzluQ5nuQZR/KcQPKcSPKMJ3lOInkmkDwTSZ5JJM9kkieN5JlC8qSTPFNJngySJ5PkCZM800ie6STPDJIni+SZSfLMInlmkzwnkzzZJE8OyTOH5JlL8uSSPHkkTz7JU0DyzCN55pM8C0iehSTPIpLnFJJnMclzKsmzhORZSvIsI3mWkzynkTynkzxnkDxnkjxnkTxnkzznkDznkjznefQkODztM4fnbu9wc8vHR6asWb78xEktOn49aOETc1b03777sh+R3kS5j+n8OMUUy3NB0H382SGzmEzLR+a/OOR+/FMx7pKQ+fK+MFiy+VjoIR9LPeTjIlK9DSn3MV1MiqmUch/TJaSYEpX7mFaQYiqt3Md0KSmmJOU+pstIMZVR7mO6nBRTWeU+pitIMZVT7mO6khRTeeU+pqtIMVVQ7mO6mhRTReU+pmtIMVVS7mO6lhRTZeU+putIMVVR7mO6nhRTVeU+phtIMVVT7mO6kRRTdeU+pptIMdVQ7mO6mRRTTeU+pltIMR2h3Md0KymmWsp9TLeRYqqt3Md0OymmOsp9TCtJMdVV7mO6gxRTPeU+pjtJMdVX7mNaRYqpgXIf012kmBoq9zHdTYopWbmP6R5STI2U+5juJcV0pHIf02pSTI2V+5juM4gpqA6c35Jz4dK1BK1Aa9AGtAXtwFESI+gAjgYdQSfQGXQBXUE30B0cA44FPUBP0Av0Bn1AX9AP9AcDQApIBQPBIDAYDAFDwXFgGBgORoCRYBQYDcaAseB4MA6cAE4E48FJYAKYCCaBySANTAHpYCrIAJkgDKaB6WAGyAIzwSwwG5wMskEOmAPmglyQB/JBAZgH5oMFYCFYBE4Bi8GpYAlYCpaB5eA0cDo4A5wpZQ/OBueAc8F54HxwAbgQXAQuBpeAFeBScBm4HFwBrgRXgavBNeBacB24HtwAbgQ3gZvBLeBWcBu4HawEd4A7wSpwF7gb3APuBavBfeB+8AB4EDwEHgaPgEfBGvAYeBw8AZ4ET4G1YB14GjwDngXPgefBC+BFsB5sAC+Bl8FG8ArYBDaDLeBVsBW8Bl4Hb4A3wVvgbfAO2AbeBe+B98EH4EPwEfgYfAI+BdvBZ+Bz8AX4EuwAX4GvwTfgW7ATfAe+B7vAD0DWw5/Az+AX8CvYDX4Dv4M94A+wF/wJ/gJ/g3/APiArWgAkgCAIgVIgEZQGSaAMKAvKgfKgAqgIKoHKoAqoCqqB6qAGqAmOALVAbVAH1AX1QH3QADQEyaAROBI0Bk1AU9AMNActQEvQCrQGbUBb0A4cBdqDDuBo0BF0Ap1BF9AVdAPdwTHgWNAD9AS9QG/QB/QF/UB/MACkgFQwEAwCg8EQMBQcB4aB4WAEGAlGgdFgDBgLjgfjwAngRDAenAQmgIlgEpgM0sAUkA6mggyQCcJgGpgOZoAsMBPMArPBySAb5IA5YC7IBXkgHxSAeWA+WAAWgkXgFLAYnAqWgKVgGVgOTgOngzPAmeAscDY4B5wLzgPngwvAheAicDG4BKwAl4LLwOXgCnAluApcDa4B14LrwPXgBnAjuAncDG4Bt4LbwO1gJbgD3AlWgbvA3eAecC9YDe4D94MHwIPgIfAweAQ8CtaAx8Dj4AnwJHgKrAXrwNPgGfAseA48D14AL4L1YAN4CbwMNoJXwCawGWwBr4Kt4DXwOngDvAneAm+Dd8A28C54D7wPPgAfgo/Ax+AT8CnYDj4Dn4MvwJdgB/gKfA2+Ad+CneA78D3YBX4AP4KfwM/gF/Ar2A1+A7+DPeAPsBf8Cf4Cf4N/wD4gG/0ASABBEAKlQCIoDZJAGVAWlAPlQQVQEVQClUEVUBVUA9VBDVATHAFqgdqgDqgL6oH6oAFoKO9wBY3AkaAxaAKagmagOWgBWoJWoDVoA9qCduAo0B50AEeDjqAT6Ay6gK6gG+gOjgHHgh6gJ+gFeoM+oC/oB/qDASAFpIKBYBAYDIaAoeA4MAwMByPASDAKjAZjwFhwPBgHTgAngvHgJDABTASTwGSQBqaAdDAVZIBMEAbTwHQwA2SBmWAWmA1OBtkgB8wBc0EuyAP5oADMA/PBArAQLAKngMXgVLAELAXLwHJwGjgdnAHOBGeBs8E54FxwHjgfXAAuBBeBi8ElYAW4FFwGLgdXgCvBVeBqcA24FlwHrgc3gBuBfMP+ZiDffpfvsss30+V75vKtcfkOuHyjW76fLd+2lu9Oyzeh5XvN8i1l+c6xfINYvg8s3+6V7+rKN2/le7TyrVj5jqt8Y1W+fyrfJpXvhso3PeV7m/ItTPlOpXxD8lkg316U7yLKNwvle4LyrT/5Dp98I0++XyfflpPvvsk32eR7afItM/nOmHwDTL7PJd/Oku9ayTen5HtQ8q0m+Y6SfONIvj8k3waS7/bIN3XkezfyLRr5Tox8w+VTIN8+ke+SyDdD5Hse8q0N+Q6GfKNCvh8h33aQ7y7INxHkewXyLQF5z7+8g1/ejy/vrpf3yss73+V97PKudHmPubxjXN7/Le/mlvdmyzut5X3T8i5oeU+zvENZdrbl3cPyXmB5Z6+8T1fedSvvoZV3xMr7W+XdqvLeU3knqbwvVN7lKe/ZlHdgyvsp5d2R8l5HeeeivA9R3lUo7xGUd/zJ+/fk3Xjy3jp5p5y8703exSbvSdv/DjMg7/6S93LJO7PkfVbyril5D5S8o0nenyTvNpL3Dsk7geR9PfIuHXnPjbyDRt4PI+9ukfeqyDtP5H0k8q4QeY+HvGND3n8h76aQ90bIOx3kfQvyLgR5T4G8Q0Ce75dn7+W5eHlmXZ4nl2e95TlseUZanl+WZ4vluV95Jleel5VnWeU5U3kGVJ7PlGcn5blGeeZQngeUZ/XkOTp5xk2eP5Nnw+S5LXmmSp53kmeR5DkheYZHnq+RZ1/kuRR5ZkSe55BnLeQ5CHlGQZ4fkHv75b57uSde7leXe8nlPm+5B1vuj5Z7l+W+YrnnV+7HlXtl5T5WucdU7v+UezPlvkm5p1HuN5R7AeU+PbmHTu5vk3vP5L4wuWdL7qeSe53k2EvuEZL7d+TeGrnvRe4zkXtA5J4IuZ9Art/L9XK5Pi3Xg+X6q1zvlOuLcj1Prp/J9Sq5PiTXY+T6h1xvkPP7cj5dzl/L+WI5PyvnQ+X8o5zvk/Nrcj5Lzh/J+Ro5PyLnI+T4X4635fhWjiel+sqxod1Zm7P9x49yH4Jc95fr7HJdW64jy3VbuU4q1yXlOqBcd5PrXHJdSa7jyHUTuU4h1wXkPLyc95bzzHJeV86jynlLOU8o5+XkPJicd5LzPPZ5lUbqwHF6Y3Xg/p2moBloDlqool0r7Xdtq3/J9A2bft1Z+jV9vLpR0ppGSUux+pOTblrX741yq/W01ChpQ6OkDYuSNsXq77inyj935m5erKfNsPrddtV747ZFr92lp+VEmeecKGkFUdLmR0lbGCVtUZS0pVHSlkdJOzNK2tlR0i6KknZxlLTLo6RdGSXt6ihp10RJuzFK2s1R0m6PknZHlLTVUdLui5L2cJS0R6OkPRYl7fEoaeuipD0TJe2FKGnro6RttPqR2oJtUdJ+tPoPXzUyHJ4wfe4kVXyXrFx1I31MO8PHtOk+ps3zMW3Yx7TJrgcW7TJ8THu4yjnbx7TTfUx7uJZRpo9p/cSc72NaP14/dfJwxexnGSW7Hli0y/ExrZ/1KNn1wKLdNB/TFviY1k9+D1edzPIx7X+xbsz3Ma2fsvKzjPxsB5NdDyzazfEx7f/vIynKuu+nnA/XNnSWj2nb+Zg22fXAot1gH9P62R4lux5YtDtcbY6fdtLP+pvsemDR7r8Ys5/1d4GPaf1sF/5/v939tG18TJvsemDRzs8+8H9x+9vYx7QTfEzrZx/Yz773/+/XKUqb839t32ySj2n3X/OSzr4OlZ6XF87NT8vIOXlOen7W1NnhtJzc9Az05oVz87JystPm56bPmRPOrWmNn2T1E6y+XGsLuvcHkrTpzKdfNiDJOUOj6dX+6QPKq/9A/u3ri16mT7QD0abXY7HnK9cqy2m/Kzj8HuMf4Df+qlFitpdNf238ZOWqKyXXYyWfla0Bkvcm1u+C/KzZWfkL++6vqv0P1tQR+yvquAP11DnDgOP//sUML6vFHdLGcV8mCwbY8wzamdF+613I0bfHqWH1y2h+u+/mOfr31+9+55EhR59cxTG9dPaykXy2t35n5aXlZWWG08LTpoUzZN0vyM4P56blhrHOF2oDrHXfviZ9mNf9VJ/rfqrPuh9I0qbxMH3Edd8Zi9L6A7RpBzjGK68Kr4f6OLIeVdR+V7J+l7f6Kdq87Ol9lk2Kz7IJVFXFl4fdNlSz/tfbhjm5WfPS88OD88agRqfsr9D9D9Tn0Qers15GTody/HYOK254pGWgzzsO7Uqq33alltUv6XbF3rGfHs5Pm1MwdXZWRtqs8MK8tPTszLQ56VgG6bPT0jMzc8N5efY5msPclIzx2ZSM+bc0JfqqHGnVidRM2NPIKlVb+11Pm0a6VG1+AUfawAheO21QMXFIN1hLCznShmhppRxpQ7W0REfacVpaaUfaMC0tyZE2XEsr40gboaWVdaSN1NLKOdJGaWnlHWmjtTTn7lxFLc3LJq2St+krVI3gr6TFJp2H3bmD0w7wFlfQbvKnWAPsepygjeTcdHlclypGauKDjmH6/Msof+t+wDE/2+fMn/1b6ph9e5+1KzwwnD9yf0M7FO1s3+zMkQda2b4HGlk9aF1UQRuup+udcxzneM7xfR6PHCyMkDbQWRj6/Cuqogs7FJ9YEuxpSxnGom/fSznGizYv6QY45hWIMC/n/6VU0WVnr6QJMeaTFCFOgzIK2fMurQ2MVEalHPlK1NJKxyeWUnYsSYaxlNbSkuITS6IdSxnDWPQdGX3aSMtbz6dzeSdFmC4O+Spt56usMsuXvs9ZNj6xJNmxlDOMpayWVi4+sZSxYylvGEs5LU2fNtLy1vPpXN7lIkwXh3yVtfNVQZnlq7yWViE+sZSzY6loGIu+DasYn1jK27FUMowl0o6Vc9xSqmg+ncu7YoTp4pCvCna+KiuzfOk7nPa05SNMF3Kk6dvKREeavo1IcqTp7VtZR5q+fpd3pOn1sqIjTS+z0o40fRtRxpGmt23lHGn6elnBkabXy0qOtMpaWsCRFtDSnAd2+n6QPY84nHsYYzu9nnsIW/2SPvdgL9PMsFzCyMkLp83Iys5vYA09zKcZBvo8zTDwv3LGMt5nIyOdgtCvMvjI08Ezld7WDJVQVRX12/OyD1vtM2/BCOPqdamUitzaOte0SPPQ5+MsG305JFv9ah3UtoafdF7YumaXnBHzzvhk7Ool1W9r+VWlWrsKesz748McZ14SosQe7cxntK1AHFqmgX5bpvpWv6RbJjufs/MPtEmNrP//t7RJHte/BJ/rX8Q2KdK6GK1NinQ6ST8tGq29inRa1Gc7ncq4elJXn0AdKifn2QR9PiHHuDW1aaoVM79EFbttCBYTh36l0TkP6ZKVqy4QyROI4Im2h/VvaKuSrX5Jt1V1rN9yBQeXbtLmpc/OysRV9pxsXBWeWxDOy29ojXGYW68hPluvIf8XWq8q2u+q2jTSsS7q+DwuPdgiJnqbPlQ1gt+el90i2q2AHLPZRwyHTrDj1Pq4g6vB6ANrgX6WWi8J+39nuvMMrh2BPp6zCzj+d17yCDj+T4gwnt6ZHkWWcqSZHs3Hod0c4rfdtJdmSbebza3f2Tn5WdMWpmXkhtPzw5lp2QWzZ2dNywrnOm6k+ZfcRJfisxFN+d9yWFpe+x2nG+z8lk3UG+wi3SRnH85YN8IM318T+x+oiMPteuiUONuQQIThttDnupzid11m3R1nr8t5+Tm54bSs7LTwgnBGwf59oIz0jBnOm+LsJ6QO87o81Oe6PNTnuliatUMUrxtfPcaZ6NxU2vPQY/NzkU2fn1KFy0A55l9G+VpmBy+6R7o4refPuRNY3Kkg6SJdBLfT9HKxx9NPk7nZRdF3b4Zo82is/W5i/fZZV4aWZBse0OK1u6CjL52zDJMijG+n6ReO9eUgXVlteDDCvEo7prPHP9Lq26dCErVp7OkrRfDrO+yqmLj1Yc5yKRNh/DIRxpfyqavFbG8bW2jzc9bnoCq6P6DfZWPfAWdtS8fIlmBwdoq9HegvmwHl6BKK8enlFWk33RmHcxo7Xz43v0P9bn7bWv2S3vy2sX5bu9LhbBxwFWBf2rqhdFpBdoa1LZ49294G28v/MG+DB/ncBg/ye1OOz4PliNvgSAfOdp1I1aZNdTjtcQZq4+gnFqTzenIj0jY41ZEWiuAt7qSIz+3EIMa+vr37K+2TvYtaaF8/xVpTDtwQmGqtJ/2xmjh1zrMTAcf/zjMNxZ3diHX2wrnrEodmbJDfZsw+w1nSzZh9aJaZlRvGgpgnRxLyHILttcuhhjYfL01VdW/TF9nE6LHo83U2qcrAYXf6snJ2+hUGfdwkRz9g7g8UF0cgwsh2U1BdG2aXh11n9GWZH56O0zpzC7DqhbPzndHqd6KYnlWWrpy36SMuVf2OvXJOodWPtCYHivk/0nnG4sYNRJlv+Qhp9jztpaHHa+fjfwAu9qqL61YCAA==",
      "custom_attributes": [
        "abi_private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "propose",
      "verification_key": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPKAAAAAAAAAAAAAAAAAAAAcr/DxIeJif/WvbJiCgw26jUAAAAAAAAAAAAAAAAAAAAAAAEZu1W/ArK6SToeHl+m/QAAAAAAAAAAAAAAAAAAABAjNB1Hm7HasF1GBZcnfBVkAAAAAAAAAAAAAAAAAAAAAAAdxG9VolpZpp8Ymd9kQJkAAAAAAAAAAAAAAAAAAAD8CUd5boU5vVtZBOYDi/NKKQAAAAAAAAAAAAAAAAAAAAAACFGyblXrPguwFD4rXauAAAAAAAAAAAAAAAAAAAAAU2CXW+3v1l8CjiIHwUb2lAUAAAAAAAAAAAAAAAAAAAAAAAY30CXn0NGtVDCIPNFdpgAAAAAAAAAAAAAAAAAAAFfWzlGTS+f5zDphNtt5PrCiAAAAAAAAAAAAAAAAAAAAAAApyRvPIjtv9RhbeUSCh2MAAAAAAAAAAAAAAAAAAABw5UudjqDd3Fe95JvxjmJWuwAAAAAAAAAAAAAAAAAAAAAACKpiPfEvINFhzlt2nIMgAAAAAAAAAAAAAAAAAAAAUlt0lVIEJ+Pc3OVd46eBX3kAAAAAAAAAAAAAAAAAAAAAAAb2xSkGkvw6nmRxspK/LAAAAAAAAAAAAAAAAAAAAKkvW0ZQ9oE/XMm8kpFREtH3AAAAAAAAAAAAAAAAAAAAAAAZ+IK6nmKLDrs76Lr+6woAAAAAAAAAAAAAAAAAAACt1xEl6fXHs5ETZ4t3y22zyAAAAAAAAAAAAAAAAAAAAAAAEFQ5ym6Smoowa3r9PiwtAAAAAAAAAAAAAAAAAAAAdTfVOwNINniSGwylw695hJEAAAAAAAAAAAAAAAAAAAAAAAEUoGoBUyutE7yJOOzCrgAAAAAAAAAAAAAAAAAAAM5FDSwSsJfRmXqgeZRe1dMbAAAAAAAAAAAAAAAAAAAAAAAkOtO/oul5HZ7N1/vIKUcAAAAAAAAAAAAAAAAAAABwJ37P4jCWAKpMAv1BJl6yiQAAAAAAAAAAAAAAAAAAAAAAByCA/XyJxNFMfQFSbDeMAAAAAAAAAAAAAAAAAAAAJzF9LwqADNbKcfUoT8KtTa8AAAAAAAAAAAAAAAAAAAAAAA518y3hD5iLVkztpJIXywAAAAAAAAAAAAAAAAAAAB5J8PjTkTM7ZuCKjl4o1N0dAAAAAAAAAAAAAAAAAAAAAAAGAYYZQRXqMgE23QeNvXEAAAAAAAAAAAAAAAAAAADZ096+UM1fAwCzY/8yELfi0QAAAAAAAAAAAAAAAAAAAAAAFfi1kajDOd0fc6qymKffAAAAAAAAAAAAAAAAAAAAvKoQ6J6fspLz33FdV2HzFegAAAAAAAAAAAAAAAAAAAAAACkeU8yDqdi7HqGV0DRoGAAAAAAAAAAAAAAAAAAAAMXeXrw0lDSh06NuVZZt8GiaAAAAAAAAAAAAAAAAAAAAAAAjYGfihbdLrPGnWRt/yjUAAAAAAAAAAAAAAAAAAADHOM/bRQYYTcaeSfxKZ2hkOwAAAAAAAAAAAAAAAAAAAAAAMAYu661D2csG4hruBIxmAAAAAAAAAAAAAAAAAAAAFXd2Kc4PRgJ99E3jC1gx1bUAAAAAAAAAAAAAAAAAAAAAAAVxhZ1T3XDHOR02GGXP9gAAAAAAAAAAAAAAAAAAALcx4EzmXuiOVIRp9subj/PpAAAAAAAAAAAAAAAAAAAAAAAUOQ8mwH0SFPQ9aUvzOKgAAAAAAAAAAAAAAAAAAAAbD9mBK9+mOg5MCnMDH3oxkgAAAAAAAAAAAAAAAAAAAAAAD/sZdZJwvFEGorVBypTuAAAAAAAAAAAAAAAAAAAAzN5oBI8U7tz8ZUZizuPk3jsAAAAAAAAAAAAAAAAAAAAAABSSxLGNt3yc7tISvzbVsQAAAAAAAAAAAAAAAAAAAPZd/niKkfiZrI++KXLVdTmGAAAAAAAAAAAAAAAAAAAAAAAfHprguxRL0TLByZIw6UkAAAAAAAAAAAAAAAAAAAAkccgpXs8pTHbH/sl4pScl7wAAAAAAAAAAAAAAAAAAAAAAD2sw71DjyWgJvL7bXC2HAAAAAAAAAAAAAAAAAAAALHC7YefOzmqLDtcLwVAVd2MAAAAAAAAAAAAAAAAAAAAAAC7LanznYvNHioG1x/GHxAAAAAAAAAAAAAAAAAAAAAHNmbd5M/iAzD2RugGsgdGUAAAAAAAAAAAAAAAAAAAAAAAGUm0+S5gtFK781pEqfCQAAAAAAAAAAAAAAAAAAADSPR5BiBkY6EVCsHNGR540QgAAAAAAAAAAAAAAAAAAAAAAHdbrFwwQfLodT8zDFROWAAAAAAAAAAAAAAAAAAAAo4uVlIQZOVA+VhUhWCr89j8AAAAAAAAAAAAAAAAAAAAAACfG+BpdUZ8SUCzMiz6i+wAAAAAAAAAAAAAAAAAAAIAXYXlccqqVaV3MJ+9NwlkrAAAAAAAAAAAAAAAAAAAAAAACdmfyg7m/SfhvnW6jMBIAAAAAAAAAAAAAAAAAAADnSAs4ZnCR36bcufE7mWkRKwAAAAAAAAAAAAAAAAAAAAAAFbGKaFFeKq+otVEl/BDgAAAAAAAAAAAAAAAAAAAA0mxVDiqjGm4BKD6KRRSvz6oAAAAAAAAAAAAAAAAAAAAAACftDL0ML0CWOk4dMPA6UwAAAAAAAAAAAAAAAAAAAEDW8UyS4B7n+90YtVPm/q6kAAAAAAAAAAAAAAAAAAAAAAAqDm9F0PIGIgD65M72IyIAAAAAAAAAAAAAAAAAAADXZSmWEUmfGJKEWAjaQL99DQAAAAAAAAAAAAAAAAAAAAAACZUK1USfgUHiarSsjGvOAAAAAAAAAAAAAAAAAAAA3AwbmbODvKVZtXHPg4HNydcAAAAAAAAAAAAAAAAAAAAAAB2Dr4ANMEKPyNIBi2/3qgAAAAAAAAAAAAAAAAAAAN33WshvQxoA/8VJbW75WiG5AAAAAAAAAAAAAAAAAAAAAAALnXwutPA8Q1cD+RkvXi0AAAAAAAAAAAAAAAAAAAArqcd/+m1B6R2lNC9YAqSlQgAAAAAAAAAAAAAAAAAAAAAAAV2m9pQMF1RC3z7iFF5hAAAAAAAAAAAAAAAAAAAAB5aP/7+OFMcYRznm83xHjysAAAAAAAAAAAAAAAAAAAAAACxxF7dph8uP5woX6378RAAAAAAAAAAAAAAAAAAAAJnHkqVl+bABGnJldVw2ZHfwAAAAAAAAAAAAAAAAAAAAAAAptBK3ibx6u7+NEgSIuL4AAAAAAAAAAAAAAAAAAACJUDkVA1BAOaMx6gld9aEkfwAAAAAAAAAAAAAAAAAAAAAAJiXoyQ49tl1XOmZxrjDuAAAAAAAAAAAAAAAAAAAAxm5a6CWhsSl7+4IPI5iKAHcAAAAAAAAAAAAAAAAAAAAAACcgcPlkPTRDwvk9I2VlcQAAAAAAAAAAAAAAAAAAABfPRml2cxziRkxl0nxzVpg4AAAAAAAAAAAAAAAAAAAAAAAoMmLO9S6mrS3yp/+bOqsAAAAAAAAAAAAAAAAAAADUY+b87D4ZVvMFcq/mFdGpAgAAAAAAAAAAAAAAAAAAAAAAHKME/pP/wUavLi9shTkrAAAAAAAAAAAAAAAAAAAAzJBpOv2yv6CvXEvB/1yWWWQAAAAAAAAAAAAAAAAAAAAAABPZSVq2Xj9mKqbKE4iUAQAAAAAAAAAAAAAAAAAAAENcG5IOShqYknuym5e4KJ3ZAAAAAAAAAAAAAAAAAAAAAAAq16aEMlopk78wmR496LgAAAAAAAAAAAAAAAAAAAAVOcAOdT4ih066vFju3VpVQwAAAAAAAAAAAAAAAAAAAAAAJCkKHkrIBwsiFrQZ7uMcAAAAAAAAAAAAAAAAAAAAIHGOU7NhirndUtR3S3Y1otIAAAAAAAAAAAAAAAAAAAAAAAIBDg91fY23rzWAGj6RsgAAAAAAAAAAAAAAAAAAAKb1fP0C9fk/zwU2Z4TZHMYNAAAAAAAAAAAAAAAAAAAAAAAS13BM/so7lydT7lD6u+cAAAAAAAAAAAAAAAAAAADVD/nNGCtPTtWp9Zvn/pqTRgAAAAAAAAAAAAAAAAAAAAAACk2G1fIkFlrqqB75Do+hAAAAAAAAAAAAAAAAAAAAg0pKKEJysWBd94GNje7vcNwAAAAAAAAAAAAAAAAAAAAAAAg0sb0/3vApkqM/a9dwfwAAAAAAAAAAAAAAAAAAAFH/mpMKykIRY40kqWUqLmwdAAAAAAAAAAAAAAAAAAAAAAAqJdcYWuCmIOS2n8p/J1sAAAAAAAAAAAAAAAAAAADLMwEbfsJSRXmYRKxYbpmB8wAAAAAAAAAAAAAAAAAAAAAADcYazy27mt12yDmCLI/yAAAAAAAAAAAAAAAAAAAA/k3DVYMJ3uEbB3NHeCyg4UsAAAAAAAAAAAAAAAAAAAAAABrgJOfQ7srEPA0w/FVtFQAAAAAAAAAAAAAAAAAAAGY3omzPJJAib1Zf0+zMJodYAAAAAAAAAAAAAAAAAAAAAAAsd7T6wbXPfZMQMuGgLicAAAAAAAAAAAAAAAAAAABgfwkBPvHmcPCElFoOhQtoLAAAAAAAAAAAAAAAAAAAAAAAK3Lx8QGso2ZpxnrPDIqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIHunV9QBwZoIM9gGZ1iXxEwAAAAAAAAAAAAAAAAAAAAAAAuU1FxSDIRN0666vC1eSAAAAAAAAAAAAAAAAAAAA4yHyyqlPSCNIbO9WpCKpF04AAAAAAAAAAAAAAAAAAAAAAAiP2oaz2OxDS+AtaiwBBAAAAAAAAAAAAAAAAAAAAGvMegX/lalrKJQkxfczZw2WAAAAAAAAAAAAAAAAAAAAAAAAxDcm91tv2g3iLODg36sAAAAAAAAAAAAAAAAAAAAdCgnXF47JO614WPluZPC0jQAAAAAAAAAAAAAAAAAAAAAAL5tuC04sAZaN5cMkgqp9AAAAAAAAAAAAAAAAAAAAFLmaKhz1vbFNGPy31tW7G0MAAAAAAAAAAAAAAAAAAAAAABibwBFKqYLGRXSxHbsAPgAAAAAAAAAAAAAAAAAAAIFYESpGMQpiuEn23VYsLIaUAAAAAAAAAAAAAAAAAAAAAAASkF6WwsjbCGXWk491oyQ="
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16760049438223524684": {
            "error_kind": "string",
            "string": "not succeeded"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "queue"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14998324759555969432": {
            "error_kind": "string",
            "string": "Function quorum can only be called statically"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "debug_symbols": "tZrdbts6DMffJde9kChKpPoqwzBkXTYECNIiaw9wMPTdDymTctIDa6mb3sw/M/O//BIlp/2z+bH7/vLr2/748/H35v7Ln8330/5w2P/6dnh82D7vH49i/bMJ+g/nzX2621S5IbnIHcqltksMaFe7j8muNF0B7Gr3KW7uY1QoAmpBtZCCSEQWyGhQwEGeBn2KxAIgwMFB/AFxL6p/KShkhzoBqJMTuCW6JboFkgMZJHAoBurqBPojxB8oxYCCg3/EbmG3VLdUdOAJUkgOZBDBwX5EguigIVeFapDQgQ0QHMggRwd/vASHbnFBSg4uyGbBqFEkBXSoBuAWcEtyizrWQB2bgAzUsQmKgTqWUAEd2EAboEFLZrnb5KAfSf/klrEGxQCCAzpUg6QJrwpk0Bxr4JbsluyW4pbiFk0UBgUyYHBwS40OZYISxDGMCujABhpFAy03gkJ2qAbqPCYFNsBioMlsUCzhRT2cwBJeGBzcUqODlYCClYACOlgJKFoJKFkJCK0ElMHBSkAlOKCDlYDISkBkySQGB7dUt1SzcAAHt0QrAUdLOAM4uCVFBysBo5WAER2sBJytBFz0qaygJZBIWZf5BGyg66JBK64Mq6rrAqsCGzR/GhQDTd0E2UHSkuWHVkwObJDdkt1S3FLcQm4hbRKd082xBmTQ+rCB/NCswzNomY3E69wmuQ7JiWK3aQRGoparknZhiY3YCbuteZ+VNJ2lNNL/p/M8aABG3aYhlOaLNgTpTA8aBDUVZqfabTo+SZWjzk8jtel20rYi4rYnSeBUGxUn7DbsNt14jKpT6TYdPUbiH+sOAyFPRY9ta5mo9eNE5KSLmTUvoHXWgkdA7NRtWmqGRuxUuk2nDqe2m4I/QcWJY6duq6GTNVpMIXTCTuwUoZOrtA1nIvVel3xMWmkjcmqTfCJ5gtt+31Y5NWIn7jbtTdZaJl3pRm7DoFkrjWyexGn7mSg7Qbf5oI/okz5Oe9BE7sG0C03UlXNXyf1Z8iiRPErk2Cl3qhZvbmNJn+37kVC3tT7IjYpT6jYdBi3ejO5LRuzkXuXcbdkjyiV16jbqHpBHmbkrc1ep7dnX17uNn/6+PZ92Oz38nR0H5ZD4tD3tjs+b++PL4XC3+Wd7eGn/6ffT9tiuz9uTfCorY3f8IVcR/Lk/7JRe7+anw/KjkLja04ChdgHpiguJuCwhR0OdJ01DmKiLVLzQgGUN6XidXU1DmOKSxigUju4GVIiLoeBAQno89HREmhNa6UIj3yAd5XPTgTK9TAJTpsV08CAU0MU2RQK5nEnAhUS9QTZiuEE6RrGkmNyPlNJiLBFuEUz65GBkP+qFqcuFiYM+Je6xyKkPF0MZtWkq6BrC9aOhiMZiKKP2kCS6F7ny8gwb9CnUlPrKrwnL4hAbOZISdE/kHRFXLNvzYOS1ZTGY0cpPVENf+hznsmCid4hk6CLEdVEEBgNV9l+PRjbg2RGI5VJjNFCzDyEI0BWSdNuFwqBPieZW55hnjZIuNWhUl56NODcH0JvuGHS6fPXhuQA422r/p1FH+fTdOqewTqH6rlDOMvGuOGA+MqSzirzVSKNJmsE7VM5ZtFKj1K7BdZ1GCl0jAS9rjAYpemcQllUKFX1DkDfOVQr6wuhxhLJc1zSoq5yz3Q05aM91jfUd6UTs6cwry5p6hwryKo1bhBL7fiBvrLxupVDso4sG6xXxczViKT2WQrxOg6ifn+S8sKxBH10pI4XrVspI4dqVksOH22uYzjoPHvm6arm9RptrLLlvrgSLm2tOw9boZS181l4yDFedFORLwcWTQs6jXQXm3fG8O944kkfnUfmqyuePcM5L56882ugDzIfaALx4yM88Oi2U2ZNcyrLIOBw4C+f8bfTNm2QYvbPU/g5X4/zeoy/7VxeY+7ITpuWjYIGPF7ikGxS44A0KXPINCvyXcK4sMH1ygedpJIx5ucD14wWmcIMCU7xBgQluUOC/hHNdgQk/u8BlHtH1bK941xthpfkbpVrTSpESz0RwlQgG7CIYzk4C7xQJswgthzM8kARPifyuad2RplemUv7ooWigMHwBuSqKocJVUVz5EvRW4avcbh/2p4u/lXhVqdN++/2ws9ufL8eHs0+f/33yT/xvLZ5Ojw+7Hy+nnSrNf3Ah/3yRr3zu5PfyX/XXXHori19++aK3UW9l8CWKX1/Vmf8A",
      "is_unconstrained": true,
      "name": "quorum"
    },
    {
      "abi": {
        "error_types": {
          "14841998807667105483": {
            "error_kind": "string",
            "string": "member not found"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "6131004256053116395": {
            "error_kind": "string",
            "string": "Function remove_council_member can only be called by the same contract"
          }
        },
        "parameters": [
          {
            "name": "member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "remove_council_member"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2109216859304865091": {
            "error_kind": "string",
            "string": "Function replace_council_member can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7200582709595251003": {
            "error_kind": "string",
            "string": "old member not found"
          }
        },
        "parameters": [
          {
            "name": "old_member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "new_member",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABEcnAgMEAicCBAQAHwoAAwAEAEUtCEUBLQhGAiUAAABFJQAAAHAnAgEERycCAgQAOw4AAgABLAAAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACcARAQDJiUAAASQHgIABAAeAgAFAC0IAQYAAAECAScCBwAzLQ4HBi0IAQgAAAECAScCCQA0LQ4JCC0IAQoAAAECAScCCwA1LQ4LCi0IAQwAAAECAScCDQA2LQ4NDC0IAQ4AAAECAScCDwA3LQ4PDi0IARAAAAECAScCEQA4LQ4REC0IARIAAAECAScCEwA5LQ4TEi0IARQAAAECAScCFQA6LQ4VFC0IARYAAAECAScCFwA7LQ4XFi0IARgAAAECAScCGQA8LQ4ZGC0IARoAAAECAScCGwA9LQ4bGi0IARwAAAECAScCHQA+LQ4dHB4CAB4AHgIAHwAzKgAeAB8AICcCHgEBJAIAIAAAAXslAAAEth4CAB8BCiIfQyAWCiAhHAohIgAEKiIfIScCHwEACiogHyIkAgAiAAABricCIwQAPAYjAQoqIQUgJAIAIAAAAcAlAAAEyCcCBQA/LwoABQAgHAogIQIcCiEFABwKBSACLwoABwAFLwoACQAHLwoACwAJLwoADQALLwoADwANLwoAEQAPLwoAEwARLwoAFQATLwoAFwAVLwoAGQAXLwoAGwAZLwoAHQAbLQgBHScCIQQNAAgBIQEnAx0EAQAiHQIhLQohIi0OBSIAIiICIi0OByIAIiICIi0OCSIAIiICIi0OCyIAIiICIi0ODSIAIiICIi0ODyIAIiICIi0OESIAIiICIi0OEyIAIiICIi0OFSIAIiICIi0OFyIAIiICIi0OGSIAIiICIi0OGyItCAEFAAABAgEtDh0FLQgBBwAAAQIBLQ4fBycCCQQAJwILBAwnAg0EAS0KCQMjAAAC1wwqAwsEJAIABAAABBAjAAAC6S0LBwEkAgABAAAC+iUAAATaLQsGAS0LBQIAKgINBC0LBAMwCgADAAEtCwgBJwIDBAIAKgIDBS0LBQQwCgAEAAEtCwoBACICRAQtCwQDMAoAAwABLQsMAScCAwQEACoCAwUtCwUEMAoABAABLQsOAScCAwQFACoCAwUtCwUEMAoABAABLQsQAScCAwQGACoCAwUtCwUEMAoABAABLQsSAScCAwQHACoCAwUtCwUEMAoABAABLQsUAScCAwQIACoCAwUtCwUEMAoABAABLQsWAScCAwQJACoCAwUtCwUEMAoABAABLQsYAScCAwQKACoCAwUtCwUEMAoABAABLQsaAScCAwQLACoCAwUtCwUEMAoABAABLQscAQAqAgsELQsEAzAKAAMAASYcCgMJAhwKCQQEHAoECQIMKgkgBCQCAAQAAAQxIwAABIItCwUEACIEAg8AKg8DES0LEQkKKgkBDyQCAA8AAARVIwAABIItAgQDJwAEBA0lAAAE7C0IBQkAIgkCDwAqDwMRLQ4CES0OCQUtDh4HIwAABIIAKgMNBC0KBAMjAAAC1ygAAAQEeEcMAAAEAyQAAAMAAAS1KgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQUdRXGO9SGtQzwEAgEmKgEAAQVj7ZvS9T6hOzwEAgEmLQEDBgoABgIHJAAABwAABQIjAAAFCy0AAwUjAAAFSi0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAVFLQEKCC0ECAsAAAoCCgAACwILIwAABSEnAQUEASY=",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "replace_council_member"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15633945201989994891": {
            "error_kind": "string",
            "string": "Function tally_fractional_internal can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16924088179346899272": {
            "error_kind": "string",
            "string": "no voting power"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2824004376206972765": {
            "error_kind": "string",
            "string": "voting not started"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7715731631402574514": {
            "error_kind": "string",
            "string": "proposal canceled"
          },
          "8841046534072300904": {
            "error_kind": "string",
            "string": "weights must equal total power"
          },
          "8927709774589806846": {
            "error_kind": "string",
            "string": "voting ended"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "for_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "against_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "abstain_weight",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "voter",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "tally_fractional_internal"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14926441384389269437": {
            "error_kind": "string",
            "string": "invalid vote support"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16924088179346899272": {
            "error_kind": "string",
            "string": "no voting power"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2824004376206972765": {
            "error_kind": "string",
            "string": "voting not started"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4351000660496471192": {
            "error_kind": "string",
            "string": "Function tally_vote_internal can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7715731631402574514": {
            "error_kind": "string",
            "string": "proposal canceled"
          },
          "8927709774589806846": {
            "error_kind": "string",
            "string": "voting ended"
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "support",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "voter",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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ISAtCw4kLQsiJS0LIyYMKgolJyQCACcAAEZwIwAARsYAIiQCKAAqKAopLQspJwAiIAIpACopCiotCyooAConKCktAiQDJwAEBAUlAABUwS0IBScAIicCKAAqKAoqLQ4pKi0OICEtDicOLQ4lIi0OJiMjAABGxgAqChsgLQogCiMAAD2LLQshJC0LDiUtCyImLQsjJwwqICYoJAIAKAAARvYjAABHTAAiJQIpACopICotCyooACIkAioAKiogKy0LKykAKigpKi0CJQMnAAQEBSUAAFTBLQgFKAAiKAIpACopICstDiorLQ4kIS0OKA4tDiYiLQ4nIyMAAEdMACogGyQtCiQgIwAAPKAtCyAfLQsNIy0LISQtCyIlDCoKJCYkAgAmAABHfCMAAEfSACIjAicAKicKKC0LKCYAIh8CKAAqKAopLQspJwAqJicoLQIjAycABAQFJQAAVMEtCAUmACImAicAKicKKS0OKCktDh8gLQ4mDS0OJCEtDiUiIwAAR9IAKgobHy0KHwojAAA6/S0LIB8tCw0jLQshJC0LIiUMKgokJiQCACYAAEgCIwAASFgAIiMCJwAqJwooLQsoJgAiHwIoACooCiktCyknAComJygtAiMDJwAEBAUlAABUwS0IBSYAIiYCJwAqJwopLQ4oKS0OHyAtDiYNLQ4kIS0OJSIjAABIWAAqChsfLQofCiMAADpXLQsgIy0LDSQtCyElLQsiJgwqHyUnJAIAJwAASIgjAABI3gAiJAIoACooHyktCyknACIjAikAKikfKi0LKigAKicoKS0CJAMnAAQEBSUAAFTBLQgFJwAiJwIoACooHyotDikqLQ4jIC0OJw0tDiUhLQ4mIiMAAEjeACofGyMtCiMfIwAAOWwtCyAfLQsLIy0LISQtCyIlDCoKJCYkAgAmAABJDiMAAElkACIjAicAKicKKC0LKCYAIh8CKAAqKAopLQspJwAqJicoLQIjAycABAQFJQAAVMEtCAUmACImAicAKicKKS0OKCktDh8gLQ4mCy0OJCEtDiUiIwAASWQAKgobHy0KHwojAAA30i0LIB8tCwsjLQshJC0LIiUMKgokJiQCACYAAEmUIwAASeoAIiMCJwAqJwooLQsoJgAiHwIoACooCiktCyknAComJygtAiMDJwAEBAUlAABUwS0IBSYAIiYCJwAqJwopLQ4oKS0OHyAtDiYLLQ4kIS0OJSIjAABJ6gAqChsfLQofCiMAADcsLQsgIy0LCyQtCyElLQsiJgwqHyUnJAIAJwAAShojAABKcAAiJAIoACooHyktCyknACIjAikAKikfKi0LKigAKicoKS0CJAMnAAQEBSUAAFTBLQgFJwAiJwIoACooHyotDikqLQ4jIC0OJwstDiUhLQ4mIiMAAEpwACofGyMtCiMfIwAANkEmHAoCBAAAKgMEDy8KAA8ABC0LDA8tAg8DJwAEBAwlAABUwS0IBRAAIhACFwAqFwIYLQ4EGC0OEAwAKgIbBC0KBAIjAAAzUi0LDAQtCwMXLQsPGC0LEBwMKgIYHiQCAB4AAErnIwAASz0AIhcCHwAqHwIgLQsgHgAiBAIgACogAiEtCyEfACoeHyAtAhcDJwAEBAUlAABUwS0IBR4AIh4CHwAqHwIhLQ4gIS0OBAwtDh4DLQ4YDy0OHBAjAABLPQAqAhsELQoEAiMAADJ4LQsMBC0LAxctCw8YLQsQHAwqAhgeJAIAHgAAS20jAABLwwAiFwIfACofAiAtCyAeACIEAiAAKiACIS0LIR8AKh4fIC0CFwMnAAQEBSUAAFTBLQgFHgAiHgIfACofAiEtDiAhLQ4EDC0OHgMtDhgPLQ4cECMAAEvDACoCGwQtCgQCIwAAMdItCwwXLQsDGC0LDxwtCxAeDCoEHB8kAgAfAABL8yMAAExJACIYAiAAKiAEIS0LIR8AIhcCIQAqIQQiLQsiIAAqHyAhLQIYAycABAQFJQAAVMEtCAUfACIfAiAAKiAEIi0OISItDhcMLQ4fAy0OHA8tDh4QIwAATEkAKgQbFy0KFwQjAAAw5y0LEA8tCwwcLQsXHi0LGB8MKgIeICQCACAAAEx5IwAATM8AIhwCIQAqIQIiLQsiIAAiDwIiACoiAiMtCyMhACogISItAhwDJwAEBAUlAABUwS0IBSAAIiACIQAqIQIjLQ4iIy0ODxAtDiAMLQ4eFy0OHxgjAABMzwAqAhsPLQoPAiMAAC87LQsQDy0LDBwtCxceLQsYHwwqAh4gJAIAIAAATP8jAABNVQAiHAIhACohAiItCyIgACIPAiIAKiICIy0LIyEAKiAhIi0CHAMnAAQEBSUAAFTBLQgFIAAiIAIhACohAiMtDiIjLQ4PEC0OIAwtDh4XLQ4fGCMAAE1VACoCGw8tCg8CIwAALpUtCxAcLQsMHi0LFx8tCxggDCoPHyEkAgAhAABNhSMAAE3bACIeAiIAKiIPIy0LIyEAIhwCIwAqIw8kLQskIgAqISIjLQIeAycABAQFJQAAVMEtCAUhACIhAiIAKiIPJC0OIyQtDhwQLQ4hDC0OHxctDiAYIwAATdsAKg8bHC0KHA8jAAAtqi0LEA8tCwMcLQsXHi0LGB8MKgIeICQCACAAAE4LIwAATmEAIhwCIQAqIQIiLQsiIAAiDwIiACoiAiMtCyMhACogISItAhwDJwAEBAUlAABUwS0IBSAAIiACIQAqIQIjLQ4iIy0ODxAtDiADLQ4eFy0OHxgjAABOYQAqAhsPLQoPAiMAACwQLQsQDy0LAxwtCxceLQsYHwwqAh4gJAIAIAAATpEjAABO5wAiHAIhACohAiItCyIgACIPAiIAKiICIy0LIyEAKiAhIi0CHAMnAAQEBSUAAFTBLQgFIAAiIAIhACohAiMtDiIjLQ4PEC0OIAMtDh4XLQ4fGCMAAE7nACoCGw8tCg8CIwAAK2otCxAcLQsDHi0LFx8tCxggDCoPHyEkAgAhAABPFyMAAE9tACIeAiIAKiIPIy0LIyEAIhwCIwAqIw8kLQskIgAqISIjLQIeAycABAQFJQAAVMEtCAUhACIhAiIAKiIPJC0OIyQtDhwQLQ4hAy0OHxctDiAYIwAAT20AKg8bHC0KHA8jAAAqfy0LHBctCxEYLQseIC0LHyEMKgQgIiQCACIAAE+dIwAAT/MAIhgCIwAqIwQkLQskIgAiFwIkACokBCUtCyUjACoiIyQtAhgDJwAEBAUlAABUwS0IBSIAIiICIwAqIwQlLQ4kJS0OFxwtDiIRLQ4gHi0OIR8jAABP8wAqBBsXLQoXBCMAAAu5LQscFy0LESAtCx4hLQsfIgwqBCEjJAIAIwAAUCMjAABQeQAiIAIkACokBCUtCyUjACIXAiUAKiUEJi0LJiQAKiMkJS0CIAMnAAQEBSUAAFTBLQgFIwAiIwIkACokBCYtDiUmLQ4XHC0OIxEtDiEeLQ4iHyMAAFB5ACoEGxctChcEIwAACxMtCxwgLQsRIS0LHiItCx8jDCoXIiQkAgAkAABQqSMAAFD/ACIhAiUAKiUXJi0LJiQAIiACJgAqJhcnLQsnJQAqJCUmLQIhAycABAQFJQAAVMEtCAUkACIkAiUAKiUXJy0OJictDiAcLQ4kES0OIh4tDiMfIwAAUP8AKhcbIC0KIBcjAAAKKC0LHBctCxEgLQseIS0LHyIMKgQhIyQCACMAAFEvIwAAUYUAIiACJAAqJAQlLQslIwAiFwIlAColBCYtCyYkACojJCUtAiADJwAEBAUlAABUwS0IBSMAIiMCJAAqJAQmLQ4lJi0OFxwtDiMRLQ4hHi0OIh8jAABRhQAqBBsXLQoXBCMAAAinLQscFy0LESAtCx4hLQsfIgwqBCEjJAIAIwAAUbUjAABSCwAiIAIkACokBCUtCyUjACIXAiUAKiUEJi0LJiQAKiMkJS0CIAMnAAQEBSUAAFTBLQgFIwAiIwIkACokBCYtDiUmLQ4XHC0OIxEtDiEeLQ4iHyMAAFILACoEGxctChcEIwAACAEtCxwgLQsRIS0LHiItCx8jDCoXIiQkAgAkAABSOyMAAFKRACIhAiUAKiUXJi0LJiQAIiACJgAqJhcnLQsnJQAqJCUmLQIhAycABAQFJQAAVMEtCAUkACIkAiUAKiUXJy0OJictDiAcLQ4kES0OIh4tDiMfIwAAUpEAKhcbIC0KIBcjAAAHFhwKBBgAACoKGBovCgAaABgtCxcaLQIaAycABAQMJQAAVMEtCAUcACIcAh0AKh0EHi0OGB4tDhwXACoEGxgtChgEIwAABV0tCxcKLQsUHC0LGB0tCxoeDCoEHR8kAgAfAABTByMAAFNdACIcAiAAKiAEIS0LIR8AIgoCIQAqIQQiLQsiIAAqHyAhLQIcAycABAQFJQAAVMEtCAUfACIfAiAAKiAEIi0OISItDgoXLQ4fFC0OHRgtDh4aIwAAU10AKgQbCi0KCgQjAAAEfi0LFwotCxQcLQsYHS0LGh4MKgQdHyQCAB8AAFONIwAAU+MAIhwCIAAqIAQhLQshHwAiCgIhACohBCItCyIgACofICEtAhwDJwAEBAUlAABUwS0IBR8AIh8CIAAqIAQiLQ4hIi0OChctDh8ULQ4dGC0OHhojAABT4wAqBBsKLQoKBCMAAAPYLQsXFi0LFBwtCxgdLQsaHgwqBB0fJAIAHwAAVBMjAABUaQAiHAIgACogBCEtCyEfACIWAiEAKiEEIi0LIiAAKh8gIS0CHAMnAAQEBSUAAFTBLQgFHwAiHwIgACogBCItDiEiLQ4WFy0OHxQtDh0YLQ4eGiMAAFRpACoEGxYtChYEIwAAAugoAAAEBHhLDAAABAMkAAADAABUnCoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFPGHcDFJh1Jg8BAIBJi0BAwYKAAYCByQAAAcAAFTXIwAAVOAtAAMFIwAAVR8tAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAABVGi0BCggtBAgLAAAKAgoAAAsCCyMAAFT2JwEFBAEmKgEAAQW6uyHXgjMYZDwEAgEmKgEAAQVrE8kJ//7isjwEAgEmKgEAAQUnMOEEl/cXXTwEAgEmKgEAAQV75Zi9LDVI/jwEAgEmKgEAAQXQB+v0y8ZnkDwEAgEmKgEAAQXq3nCIDVwBSDwEAgEmKgEAAQXPJV9a/TZXvTwEAgEmKgEAAQUbvGXQP9zq3DwEAgEmKgEAAQUFBBuZIK9gTDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "tally_vote_internal"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "364683654084256882": {
            "error_kind": "string",
            "string": "Function update_council_threshold can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5069332423914220509": {
            "error_kind": "string",
            "string": "threshold exceeds council size"
          },
          "6257422783282464658": {
            "error_kind": "string",
            "string": "threshold must be positive"
          }
        },
        "parameters": [
          {
            "name": "new_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREAi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAT0eAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAFjHgIABQEKIgVDBhYKBgccCgcIAAQqCAUHJwIFAQAKKgYFCCQCAAgAAADSJwIJBAA8BgkBCioHAwYkAgAGAAAA5CUAAAF1JwIDAD8vCgADAAYcCgYHAhwKBwMAHAoDBgIMKgYBAwoqAwUGJAIABgAAARUlAAABhycCAwIADCoDAQUkAgAFAAABLCUAAAGZHAoBAwAnAgEAQDAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABYioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFBQ+d2ekVZHI8BAIBJioBAAEFRlni+yfG6908BAIBJioBAAEFVtbU3j78x5I8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVdbbuMwDLyLv/MhkqIo5SpFUaSpWxgwnMBNFlgUuftSjeRHAGmx2fQnHtPRmEOOHv5q3trX88dLN7wfPpvt01fzOnZ933289If97tQdBo1+NSb+AFCzpY1efbMVvaLeA0SgAbAKKEbiIwsKfAQuAbYZhGaLqMBpBOMoFxIQSo/EJ+BjxEXgEwgpggYycAmApokSAScQM7wCHU5KiDHDK9CXkr4Urc0gR2KqxBGEBFyOCGYgCuJLPWaQI4GvgIzmY00EGrFaOYoZWrpcNk0u78tpbNtY3UW9tQvH3dgOp2Y7nPt+0/za9efvP30ed8P39bQb9alyt8ObXpXwvevbiC6bebQpD0XyIY1Ga8JEABRWFFCmAG+cTxyKRSaSYFccWOYgZObEoVigxFGT4iGngQGhKMVWKCywmcoBMhc0yIqDH1AO97PlsOgkUVhiKZbDV6Rg9O9VCbJbUOCKIjygGmAeUI6aFgLKeRBRUQvgI8TQD4vRBWhqTCg3Bio+FT9pkYC2KKVmU3I2cygO/ytFOYpSqvawMhXUYXkNq/hUF3vIXldsXWnmYyURCDL7I4i44koINTUOcZZDZZPV5TiY5DBQUU7NqTb71ALOWviuvkh5QcaaS12etcty2vu84cv7W4WC2Ye8KTAvdxZLN8Ws+BwRp4bgwl56JFlzVLpKJsSDyVWNCcwla1CtIgbnSWv0uFIkqZmU3ZwJO1fe8+tycCFnudveZFIxqZdsUu3S3BnzD+0NdtHexfpx294aiTOQpSgmuJNkWgvZgfFFEpKK0STkKaMnolA0GvnarCHnpmlD5YWMKu0VyRWRhcluO/OXNDDMaXBxf7E1q+oxbtICwkWr2tr5lMXS5Hfx6+3yWe92+25cfSxdItvY7V77Nt2+n4f94unp9zE/yR9bx/Gwb9/OYxuZFl9c+vvEdsPhOX526Y0LG4HnS3z1Hw==",
      "is_unconstrained": true,
      "name": "update_council_threshold"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2923981031069933752": {
            "error_kind": "string",
            "string": "Function update_late_quorum_extension can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_extension",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBC0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEACDAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFKJQRQX7nYLg8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVbbjtowEP2XPOchc7HH5ldWCAUIq0hRQFmoVCH+veOtnZCqttQt+xIfj/Fhzvj4cq+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgb6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19aMdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JkAyK8oIE8BrrEucigWmUk8rzgwz0FojIkcigVyHCUpDlIa6BGyUrhAwWCauRwgS0G9rDjMC8phv7ccjFYiBZORbDlcQQqSTUrQ2CcKXFH4F1QDmheUo6SFgFIeRJTVAvgKMfTNYlBwXhifXxgo+FTcrEU8clZKyaZkOXEo9v8rRTmyUor2YJkLajF/hhV8ioYheV0x29zOx0Ii4GXxhxex2ZMQSmos4iKH8iYry7EwyzFAWTklp3LyKQMuWsyX1kXyBzKWXGrTrn0uJ3/NGy5/v5UoHC8b1rE3Sxr0RzELPkfxSYleVEsi+jpYc/iSGLJ2VkN5f1HJpOjob2dHuP3/IRH0SyImu/GpdOfr/TqrATFZo1PJo0Y4yVHs1ufYVnvtoZ9WD8pHYJv6dj90sXu6jYen0evPSxpJD9LLdD50x9vUBaanV6l+3xhqttvwNA0dqdlvH+GvfwE=",
      "is_unconstrained": true,
      "name": "update_late_quorum_extension"
    },
    {
      "abi": {
        "error_types": {
          "1211138418200096620": {
            "error_kind": "string",
            "string": "Function update_proposal_guardian can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_guardian",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEElAAAAZycCAQRFJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJiUAAADrHgIAAgAeAgADAB4CAAQAHgIABQAzKgAEAAUABicCBAEBJAIABgAAAJolAAABER4CAAQBCiIEQwUWCgUGHAoGBwAEKgcEBicCBAEACioFBAckAgAHAAAAzScCCAQAPAYIAQoqBgMEJAIABAAAAN8lAAABIycCAwAKMAoAAQADJigAAAQEeEUMAAAEAyQAAAMAAAEQKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQUQztP5dqUvbDwEAgEm",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tZbLbqswFEX/xWMGnIdf+ZWrKCIJqZAQiShc6Sri3+9xi3lUsgdtOgkbO954HW+Mn+pan8e3U9Pd7u/q8Oepzn3Tts3bqb1fqqG5d9L6VGX4gdKpAxUKgNTBhqvcA4hAaQAOIrSELjIinAiGKPwsNKsDYhDSgmGU4Sjc3GUpitBiRDiKIrZ48ymwhCi0CHk6QhmFm0WYIWEQgQGnqVAR8DT0dR34NsRSh0fV192gDt3YtoX6W7Xjx5/eH1X3cR2qXnrLQtXdVa5ieGvaOqipWEeX6aFIzs+jkUu/GAD5nQWkLcCVxs0eoq1dTDzvPDDtQai1nj1EW0h55FAcxGmgR0iicMaCQZdLOcCuBfV256FfUA7zu+VgNHa2YNI2WQ6XQUEykQS12VjgzsK/oBpQvqAcORYCivMgoiQL4Ctg6Jdh0OKyMD69MJDJqXULi/XISZRcTMlw9BDtf4oiHkmUbDzYLgU1mN7DMjlFzRCzLppN6s3HzETA2zUf3lqT3AkhR2MQVxxKhyyPY2DB0UBJnFxSOeaUAVcW/a11sekNGXMpNfGt3ZaTv5cNl/6+5SycoWVBnDFunQZ9KWYm52h9JJEP1ToROQvsPXwOhtAvNKST7xvlcOSzFpMuWifzRbmQassRR7Tbbx9HuasuTb87vk3BrW+qc1vPt7exu2x6h3+P2BOPf4/+fqmvY18Hp+0ZUA5H5AvmYzgAyo0kle1xCo/+Dw==",
      "is_unconstrained": true,
      "name": "update_proposal_guardian"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2456261804207466482": {
            "error_kind": "string",
            "string": "Function update_proposal_threshold can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_threshold",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEABTAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFIhZlGNslZ/I8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVZbjuIwELxLvvORfthtc5URQgHCKFIUUAZWWiHuvu1ZOyEr2dLOMD9xuY2Lrnb5ca+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgX6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19asdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JkAyK8oIE8BrrEucigWmUk8rzgwz0FojIkcigVyHCUpDlIa6BGyUrhAwWCauRwgS0G9rDjMC8phf7YcjFYiBZORbDlcQQqSTUrQ2CcKXFH4F1QDmheUo6SFgFIeRJTVAvgKMfTDYlBwXhifXxgo+FTcrEU8clZKyaZkOXEo9t+VohxZKUV7sMwFtZg/wwo+RcOQvK6YbW7nYyER8LL4w4vY7EkIJTUWcZFDeZOV5ViY5RigrJySUzn5lAEXLeZL6yL5AxlLLrVp1z6Xk7/mDZe/30oUosuaOFzzVEumf4pZ8DmKT0r0oloS0dfBmsOXxJCdM0HK+4tKJhVvljPMLWIa/z+JoF8SMdmNT6U7X+/XWQ2IyRqdSh41wqmuit36HNtqrz300+pB+QhsU9/uhy52T7fx8DR6/X1JI+lBepnOh+54m7rA9PQq1e8bQ812G56moSM1++0j/PUf",
      "is_unconstrained": true,
      "name": "update_proposal_threshold"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "7929560158224637595": {
            "error_kind": "string",
            "string": "Function update_quorum_numerator can only be called by the same contract"
          },
          "9481540185426775687": {
            "error_kind": "string",
            "string": "numerator exceeds denominator"
          }
        },
        "parameters": [
          {
            "name": "new_numerator",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBi0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAASYeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAFMHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwUkAgAFAAAA5CUAAAFeJwIDAAcvCgADAAUcCgUGBhwKBgMAHAoDBQYMKgUBAwoqAwQFJAIABQAAARUlAAABcBwKAQMAJwIBAAYwCgADAAEmKAAABAR4RQwAAAQDJAAAAwAAAUsqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBW4LdPOIEd6bPAQCASYqAQABBYOVMpAz9E6HPAQCASY=",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVdBbuMwDPyLzzmYpCRK+UpRFG7qFgYMJ3CTBRZF/r5UI8l2AWoX3fQSj6lozKHGlPzRvPTPl7enYXo9vjf7h4/meR7GcXh7Go+H7jwcJ4l+NG38AaBmTzu5+mbPckW5B4hAAmAEUIzEIQMCfAQuAWsyCM0eUYCTCMZZLiTAlIbYJ+BjxEXgEwgpgi1k4BIASRM5AptAzPAGZDoJIcYMb0AeSvJQNCaDHImpko0gJOByhDEDFhAEeImYSOg5gut11+TSPZ3nvo+VW9VSKnzq5n46N/vpMo675lc3Xj7/9H7qps/ruZtltN01/fQiVyF8HcY+outumd3qU5F8SLPRtKEQAIUNBegU4FvnE4dg5kISzIYDdQ5Ca23iEMygcdSkeMhpYEBQpZgKhQHblnIALwUNvOGwdyiH+9lyGHScKAxZVsvhK1KQXFaC1q0ocEMR7lANaO9QjpoWAsp5EJGqBfAeYuiHxUhzKQsT9IWBik/ZFy0c0KhSajYlZzKH4PC/UoRDlVK1h+FSUId6D6v4VBo5ZK8LNk5787GSCARe/BGYndoJoabGIS5ySDdZXY6DIscCqXJqTjXZpwZw0WK/tS6sN2SsudTlt3ZdTvM9b3h9f6tReHB5UxC8et0MfSlmxeeIWBYEV/aS48aWo7Kq1IZ46Lhl0gZrNWtQTU6Ly0vbylFEJamZ1LolE+ucvufX5eBKznq3/ZIJ1XpyKHtUWPk8Hmb+eYERSkf2aEhd4DqJL07zhKiSUKWjIofsdznOBNUlxDXLk3PF86R3Iaq1ZQ522em8Wta/JIJhScSq24Op1VVOYUUNsFWdZqp2ZUPFruy3u92j3HWHYd58x1wj2zx0z2Ofbl8v02E1ev59yiP5O+g0Hw/9y2XuI9PqY0h+H+Rcae1j/CKSG4c7Zx6v8dF/AA==",
      "is_unconstrained": true,
      "name": "update_quorum_numerator"
    },
    {
      "abi": {
        "error_types": {
          "14822583465815270620": {
            "error_kind": "string",
            "string": "Function update_timelock_delay can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBC0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEACTAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFzbRlIPV/ZNw8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVbbjtowEP2XPOchc7HH5ldWCAUIq0hRQFmoVCH+veOtnZCqttQt+xIfj/Fhzvj4cq+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgb6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19aMdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JkAyK8oIE8BrrEucigWmUk8rzgwz0FojIkcigVyHCUpDlIa6BGyUrhAwWCauRwgS0G9rDjMC8phv7ccjFYiBZORbDlcQQqSTUrQ2CcKXFH4F1QDmheUo6SFgFIeRJTVAvgKMfTNYlBwXhifXxgo+FTcrEU8clZKyaZkOXEo9v8rRTmyUor2YJkLajF/hhV8ioYheV0x29zOx0Ii4GXxhxex2ZMQSmos4iKH8iYry7EwyzFAWTklp3LyKQMuWsyX1kXyBzKWXGrTrn0uJ3/NGy5/v5UonMx3JDmHi8GY/ihmwecoPinRi2pJRF8Haw5fEkPWzmoo7y8qmRQd/e3sCLf/PySCfknEZDc+le58vV9nNSAma3QqedQIJzmK3foc22qvPfTT6kH5CGxT3+6HLnZPt/HwNHr9eUkj6UF6mc6H7nibusD09CrV7xtDzXYbnqahIzX77SP89S8=",
      "is_unconstrained": true,
      "name": "update_timelock_delay"
    },
    {
      "abi": {
        "error_types": {
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4461576865508125763": {
            "error_kind": "string",
            "string": "Function update_voting_delay can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBC0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEAAzAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFPeq0hU62bEM8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVbbjtowEP2XPOchc7HH5ldWCAUIq0hRQFmoVCH+veOtnZCqttQt+xIfj/Fhzvj4cq+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgb6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19aMdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JkAyK8oIE8BrrEucigWmUk8rzgwz0FojIkcigVyHCUpDlIa6BGyUrhAwWCauRwgS0G9rDjMC8phv7ccjFYiBZORbDlcQQqSTUrQ2CcKXFH4F1QDmheUo6SFgFIeRJTVAvgKMfTNYlBwXhifXxgo+FTcrEU8clZKyaZkOXEo9v8rRTmyUor2YJkLajF/hhV8ioYheV0x29zOx0Ii4GXxhxex2ZMQSmos4iKH8iYry7EwyzFAWTklp3LyKQMuWsyX1kXyBzKWXGrTrn0uJ3/NGy5/v5UoxM4nqWLvljToj2IWfI7ikxK9qJZE9HWw5vAlMWTtrIby/qKSSdHR386OcPv/QyLol0RMduNT6c7X+3VWA2KyRqeSR41wkqPYrc+xrfbaQz+tHpSPwDb17X7oYvd0Gw9Po9eflzSSHqSX6XzojrepC0xPr1L9vjHUbLfhaRo6UrPfPsJf/wI=",
      "is_unconstrained": true,
      "name": "update_voting_delay"
    },
    {
      "abi": {
        "error_types": {
          "14445691148362705718": {
            "error_kind": "string",
            "string": "Function update_voting_period can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "new_period",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQcAEREBC0IRAElAAAARiUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAPUeAgACAB4CAAMAHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAnyUAAAEbHgIABAEKIgRDBRYKBQYcCgYHAAQqBwQGJwIEAQAKKgUEByQCAAcAAADSJwIIBAA8BggBCioGAwQkAgAEAAAA5CUAAAEtHAoBAwAnAgEABDAKAAMAASYoAAAEBHhFDAAABAMkAAADAAABGioBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFyHlnkBkp6zY8BAIBJg==",
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "debug_symbols": "tVbbjtowEP2XPOchc7HH5ldWCAUIq0hRQFmoVCH+veOtnZCqttQt+xIfj/Fhzvj4cq+O3f72vuvH0/mj2rzdq/3UD0P/vhvOh/ban0eN3qsmfACo2lCtras2oi1qHyAADQAroBAJQwwKXAA2AsMJ+GqDqMBqBMMs6yMQikPiInAhYgNwEfgYwQYSsBGApokSgIkgZPgb6HTSVDFkSBxAiPDjUVdJ6e46dV0Q+iRdC3Jpp268VpvxNgx19aMdbp8/+ri042d7bScdbeqqG4/aKuGpH7qAHvUyu8lP1VR8nI3c+JkAyK8oIE8BrrEucigWmUk8rzgwz0FojIkcigVyHCUpDlIa6BGyUrhAwWCauRwgS0G9rDjMC8phv7ccjFYiBZORbDlcQQqSTUrQ2CcKXFH4F1QDmheUo6SFgFIeRJTVAvgKMfTNYlBwXhifXxgo+FTcrEU8clZKyaZkOXEo9v8rRTmyUor2YJkLajF/hhV8ioYheV0x29zOx0Ii4GXxhxex2ZMQSmos4iKH8iYry7EwyzFAWTklp3LyKQMuWsyX1kXyBzKWXGrTrn0uJ3/NGy5/v5UoxM3WUMxuSYP+KGbB5yg+KdGLaklEXwdrDl8SQ3bOBCnvLyqZFB397ewIt/8/JIJ+ScRkNz6V7ny9X2c1ICZrdCp51AgnOYrd+hzbaq899NPqQfkIbFPf7ocudk+38fA0ev15SSPpQXqZzofueJu6wPT0KtXvG0PNdhuepqEjNfvtI/z1Lw==",
      "is_unconstrained": true,
      "name": "update_voting_period"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6504742485148360234": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "10581129473648605397": {
            "error_kind": "string",
            "string": "Function create_proposal_internal can only be called by the same contract"
          },
          "10807032649822229906": {
            "error_kind": "string",
            "string": "not aztec-token mode"
          },
          "10958896161817881596": {
            "error_kind": "string",
            "string": "insufficient balance"
          },
          "11721653196875790723": {
            "error_kind": "string",
            "string": "Function get_voting_period can only be called statically"
          },
          "11805838585384935243": {
            "error_kind": "string",
            "string": "Function get_emergency_threshold can only be called statically"
          },
          "11835668458991423142": {
            "error_kind": "string",
            "string": "below proposal threshold"
          },
          "11891137193966797764": {
            "error_kind": "string",
            "string": "Function get_council_threshold can only be called statically"
          },
          "1211138418200096620": {
            "error_kind": "string",
            "string": "Function update_proposal_guardian can only be called by the same contract"
          },
          "12164607307181823186": {
            "error_kind": "string",
            "string": "cannot cancel"
          },
          "12510611782093430208": {
            "error_kind": "string",
            "string": "not a council member"
          },
          "13064617634155564349": {
            "error_kind": "string",
            "string": "Function get_votes can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13770014322479677326": {
            "error_kind": "string",
            "string": "Function get_council_member can only be called statically"
          },
          "13971371060846917075": {
            "error_kind": "string",
            "string": "Function get_quorum_denominator can only be called statically"
          },
          "14397635560847713499": {
            "error_kind": "string",
            "string": "Function get_proposal can only be called statically"
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14445691148362705718": {
            "error_kind": "string",
            "string": "Function update_voting_period can only be called by the same contract"
          },
          "14487322055111218121": {
            "error_kind": "string",
            "string": "Function get_cloak_mode can only be called statically"
          },
          "14586830951621773200": {
            "error_kind": "string",
            "string": "Function get_proposal_guardian can only be called statically"
          },
          "14822583465815270620": {
            "error_kind": "string",
            "string": "Function update_timelock_delay can only be called by the same contract"
          },
          "14841998807667105483": {
            "error_kind": "string",
            "string": "member not found"
          },
          "14926441384389269437": {
            "error_kind": "string",
            "string": "invalid vote support"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14998324759555969432": {
            "error_kind": "string",
            "string": "Function quorum can only be called statically"
          },
          "15233556076734149416": {
            "error_kind": "string",
            "string": "Function proposal_snapshot can only be called statically"
          },
          "15312957078770032001": {
            "error_kind": "string",
            "string": "insufficient emergency approvals"
          },
          "15596384838086695822": {
            "error_kind": "string",
            "string": "Function proposal_deadline can only be called statically"
          },
          "15633945201989994891": {
            "error_kind": "string",
            "string": "Function tally_fractional_internal can only be called by the same contract"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16238081572903391961": {
            "error_kind": "string",
            "string": "insufficient council approvals to cancel"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16563349372015579773": {
            "error_kind": "string",
            "string": "Function proposal_proposer can only be called statically"
          },
          "16651589314398098717": {
            "error_kind": "string",
            "string": "Function get_erc20_config can only be called statically"
          },
          "16760049438223524684": {
            "error_kind": "string",
            "string": "not succeeded"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "16924088179346899272": {
            "error_kind": "string",
            "string": "no voting power"
          },
          "17278438487631839627": {
            "error_kind": "string",
            "string": "Function add_council_member can only be called by the same contract"
          },
          "17625130927896797776": {
            "error_kind": "string",
            "string": "council full"
          },
          "17908124404890989986": {
            "error_kind": "string",
            "string": "Function get_governance_token can only be called statically"
          },
          "1839173940655436289": {
            "error_kind": "string",
            "string": "Function is_council_member can only be called statically"
          },
          "1940413677172494365": {
            "error_kind": "string",
            "string": "Function hash_proposal can only be called statically"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2109216859304865091": {
            "error_kind": "string",
            "string": "Function replace_council_member can only be called by the same contract"
          },
          "2456261804207466482": {
            "error_kind": "string",
            "string": "Function update_proposal_threshold can only be called by the same contract"
          },
          "2514106658851063029": {
            "error_kind": "string",
            "string": "council approval not available in this mode"
          },
          "2547213599764567162": {
            "error_kind": "string",
            "string": "emergency execute only in hybrid mode"
          },
          "2633295041654830480": {
            "error_kind": "string",
            "string": "Function delegate_internal can only be called by the same contract"
          },
          "2824004376206972765": {
            "error_kind": "string",
            "string": "voting not started"
          },
          "2923981031069933752": {
            "error_kind": "string",
            "string": "Function update_late_quorum_extension can only be called by the same contract"
          },
          "3107034805524995561": {
            "error_kind": "string",
            "string": "Function proposal_eta can only be called statically"
          },
          "3257802692136877625": {
            "error_kind": "string",
            "string": "Function get_total_voting_power can only be called statically"
          },
          "342064996362527420": {
            "error_kind": "string",
            "string": "Function get_delegate can only be called statically"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "364683654084256882": {
            "error_kind": "string",
            "string": "Function update_council_threshold can only be called by the same contract"
          },
          "3905717565539885644": {
            "error_kind": "string",
            "string": "Function get_proposal_count can only be called statically"
          },
          "3975253606477278659": {
            "error_kind": "string",
            "string": "Function add_member_internal can only be called by the same contract"
          },
          "4351000660496471192": {
            "error_kind": "string",
            "string": "Function tally_vote_internal can only be called by the same contract"
          },
          "4422981737823726437": {
            "error_kind": "string",
            "string": "timelock not elapsed"
          },
          "4461576865508125763": {
            "error_kind": "string",
            "string": "Function update_voting_delay can only be called by the same contract"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4756330914173469558": {
            "error_kind": "string",
            "string": "emergency cancel only in hybrid mode"
          },
          "4989124741311061979": {
            "error_kind": "string",
            "string": "Function get_late_quorum_extension can only be called statically"
          },
          "5069332423914220509": {
            "error_kind": "string",
            "string": "threshold exceeds council size"
          },
          "5227616292269356710": {
            "error_kind": "string",
            "string": "Function get_membership_mode can only be called statically"
          },
          "5366287459706263972": {
            "error_kind": "string",
            "string": "Function get_token_gate_address can only be called statically"
          },
          "5836097838366868111": {
            "error_kind": "string",
            "string": "not erc20-token mode"
          },
          "5846850200630327512": {
            "error_kind": "string",
            "string": "not queued"
          },
          "5874306019897513529": {
            "error_kind": "string",
            "string": "Function get_council_approval_count can only be called statically"
          },
          "6026731864439116519": {
            "error_kind": "string",
            "string": "Function get_timelock_delay can only be called statically"
          },
          "6131004256053116395": {
            "error_kind": "string",
            "string": "Function remove_council_member can only be called by the same contract"
          },
          "6257422783282464658": {
            "error_kind": "string",
            "string": "threshold must be positive"
          },
          "6704778553435785618": {
            "error_kind": "string",
            "string": "Function get_voting_delay can only be called statically"
          },
          "6759925772054572743": {
            "error_kind": "string",
            "string": "Function get_proposal_threshold can only be called statically"
          },
          "6937048942020234009": {
            "error_kind": "string",
            "string": "Function get_past_votes can only be called statically"
          },
          "7200582709595251003": {
            "error_kind": "string",
            "string": "old member not found"
          },
          "7220720865510965904": {
            "error_kind": "string",
            "string": "nullifier already used"
          },
          "7356147743016370783": {
            "error_kind": "string",
            "string": "Function proposal_votes can only be called statically"
          },
          "7715731631402574514": {
            "error_kind": "string",
            "string": "proposal canceled"
          },
          "7929560158224637595": {
            "error_kind": "string",
            "string": "Function update_quorum_numerator can only be called by the same contract"
          },
          "8228371833434187583": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "8288633154968149222": {
            "error_kind": "string",
            "string": "Function add_erc20_member_internal can only be called by the same contract"
          },
          "8418147970250171169": {
            "error_kind": "string",
            "string": "Function get_name can only be called statically"
          },
          "8683601360157590068": {
            "error_kind": "string",
            "string": "Function proposal_state can only be called statically"
          },
          "8717548249808531313": {
            "error_kind": "string",
            "string": "already approved"
          },
          "8799882153436241657": {
            "error_kind": "string",
            "string": "Function get_council_count can only be called statically"
          },
          "8841046534072300904": {
            "error_kind": "string",
            "string": "weights must equal total power"
          },
          "8927709774589806846": {
            "error_kind": "string",
            "string": "voting ended"
          },
          "900405183110375111": {
            "error_kind": "string",
            "string": "already executed"
          },
          "9481540185426775687": {
            "error_kind": "string",
            "string": "numerator exceeds denominator"
          },
          "9496969216608950819": {
            "error_kind": "string",
            "string": "Function get_quorum_numerator can only be called statically"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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LQgBbQAAAQIBLQ4hbS0IAW4AAAECAS0OIm4tCAFvAAABAgEtDiNvLQgBcAAAAQIBLQ4kcC0IAXEAAAECAS0OJXEtCAFyAAABAgEtDiZyLQgBcwAAAQIBLQ4ncy0IAXQAAAECAS0OKHQtCAF1AAABAgEtDil1LQgBdgAAAQIBLQ4qdi0IAXcAAAECAS0OK3ctCAF4AAABAgEtDix4HgIAeQAtCAF6JwJ7BAMACAF7AScDegQBACJ6Ans2DgB5AHsAACJ6VXwtC3x7ACJ6V30tC318HAp7egAEKnp8fSQCAHsAAAt5JwJ6BAA8BnoBLQgBeicCewQDAAgBewEnA3oEAQAiegJ7Ng4AeQB7AgAielV7LQt7eQAield8LQt8exwKeXoABCp6e3wkAgB5AAALxScCegQAPAZ6AS0IAXknAnoEAgAIAXoBJwN5BAEAInkCeh8wAFUAUgB6ACJ5VXstC3t6HAp6ewQcCnt5AC0IAXoAAAECASgCAHsAAbktDnt6LQgBewAAAQIBKAIAfgABui0OfnstCAF+JwJ/BD0ACAF/AScDfgQBACJ+An8fMABaAFUAfy0IAX8AAAECAS0IAYAnAoEEPgAIAYEBJwOABAEAIoACgS0KgYItDmSCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCACKCAoItDFOCLQ6AfycCZAQ9LQhSAyMAAA6XDCIDWi4kAgAuAADK2yMAAA6pLQt/Li0IAUQnAn4EBAAIAX4BJwNEBAEAIkQCfi0Kfn8tDFN/ACJ/An8tDFN/ACJ/An8tDFN/KwIAfgAAAAAAAAAAPQAAAAAAAAAALQgBfycCgAQFAAgBgAEnA38EAQAifwKALQqAgS0MU4EAIoECgS0MU4EAIoECgS0MU4EAIoECgS0OfoEtCAF+AAABAgEtDkR+LQgBRAAAAQIBLQ5/RC0IAX8AAAECAS0MUn8tCAGAAAABAgEtDFGALQhSAyMAAA9sDCoDZIEkAgCBAADKlCMAAA9+JwJkBIEtCACBLQp+gi0KRIMtCn+ELQqAhQAIAGQAJQAAzZQtAgAALQqCLi0LekQtC3tkLQ5Eei0OZHstCAFEJwJkBAQACAFkAScDRAQBACJEAmQtCmR6LQxTegAiegJ6LQxTegAiegJ6LQxTei0LRGQAImQCZC0OZEQrAgBkAAAAAAAAAAADAAAAAAAAAAAtCAF6JwJ7BAUACAF7AScDegQBACJ6AnstCnt+LQxTfgAifgJ+LQxTfgAifgJ+LQxTfgAifgJ+LQ5kfi0IAWQAAAECAS0ORGQtCAFEAAABAgEtDnpELQgBegAAAQIBLQxSei0IAXsAAAECAS0MUXsnAn4Efy0IAH8tCmSALQpEgS0KeoItCnuDLQoOhAAIAH4AJQAAzgAtAgAAJwJ+BH8tCAB/LQpkgC0KRIEtCnqCLQp7gy0KeYQACAB+ACUAAM4ALQIAACcCeQR+LQgAfi0KZH8tCkSALQp6gS0Ke4ItCi6DAAgAeQAlAADOAC0CAAAnAnkEfi0IAH4tCmR/LQpEgC0KeoEtCnuCAAgAeQAlAADNlC0CAAAtCn8uCip8LkQkAgBEAAAROiUAAM7/CiJ9Uy4eAgBEAQoiREtkFgpkeRwKeXoABCp6RHkKImRRRCQCAEQAABFtJwJ6BAA8BnoBCip9eUQSKi5EZCQCAGQAABGEJQAAzxEtC0UuLQgBRAAAAQIBLQxTRC0IAUUAAAECAS0MVkUoAgBkAAEALQhSAyMAABGyDCoDMHkkAgB5AADKJiMAABHELQtEAy0IATAnAjEEAwAIATEBJwMwBAEAIjACMS0KMUQtDhVEACJEAkQtDi5EJwJEBHktCAB5LQowei0IV3stCFF8AAgARAAlAADPIy0CAAAtCnoxNAIAMS0IATAnAjEEAgAIATEBJwMwBAEAIjACMS0KMUQtDgNELQswMQAiMQIxLQ4xMCcCRAR5LQgAeS0KMHotCFV7LQhRfAAIAEQAJQAA0LUtAgAALQp6MTAKAAMALgAiLlYDMAoAMQADLQtGAy0LRy4tC0gwLQtJMS0LSkQtC0tFLQtMRi0LTUctC05ILQtPSS0LUEotC1JLLQtTTC0LVE0tC1VOLQtWTy0LaVAtC2pTLQtrVC0LbFUtC21WLQtuZC0Lb2ktC3BqLQtxay0LcmwtC3NtLQt0bi0LdW8tC3ZwLQt3cS0LeHItCAFzJwJ0BAMACAF0AScDcwQBACJzAnQtCnR1LQ4VdQAidQJ1LQ5QdScCdQR2LQgAdi0Kc3ctCFd4LQhReQAIAHUAJQAAzyMtAgAALQp3dDQCAHQtCAFzJwJ0BAIACAF0AScDcwQBACJzAnQtCnR1LQ4/dS0Lc3QAInQCdC0OdHMnAnUEdi0IAHYtCnN3LQhVeC0IUXkACAB1ACUAANC1LQIAAC0Kd3QwCgA/AFAAIlBWPzAKAHQAPy0IAT8nAlAEAwAIAVABJwM/BAEAIj8CUC0KUHMtDhVzACJzAnMtDklzJwJzBHQtCAB0LQo/dS0IV3YtCFF3AAgAcwAlAADPIy0CAAAtCnVQNAIAUC0IAT8nAlAEAgAIAVABJwM/BAEAIj8CUC0KUHMtDjNzLQs/UAAiUAJQLQ5QPycCcwR0LQgAdC0KP3UtCFV2LQhRdwAIAHMAJQAA0LUtAgAALQp1UDAKADMASQAiSVY/MAoAUAA/LQgBPycCSQQDAAgBSQEnAz8EAQAiPwJJLQpJUC0OFVAAIlACUC0OSlAnAlAEcy0IAHMtCj90LQhXdS0IUXYACABQACUAAM8jLQIAAC0KdEk0AgBJLQgBPycCSQQCAAgBSQEnAz8EAQAiPwJJLQpJUC0OM1AtCz9JACJJAkktDkk/JwJQBHMtCABzLQo/dC0IVXUtCFF2AAgAUAAlAADQtS0CAAAtCnRJMAoAMwBKACJKVjMwCgBJADMwCgAyAAMwCgA0AC4wCgA1ADAwCgA2ADEKKjgGAxYKAy4cCgMwBhwKLgMGJwIuBmQEKjAuMQQqAzguACoxLgMcCgMuADAKAC4ARDAKADcARTAKADkARjAKADsARzAKADoATDAKAD0ATTAKAD4ATjAKADwATzAIAFMASDAIAFMASzAKAEIAcDAKAEMAcTAKAC8AcgAiQVUuLQsuAzAKAAMAUwAiQVcuLQsuAzAKAAMAVAAiQVAuLQsuAzAKAAMAVQAqQQ8uLQsuAzAKAAMAVgAiQVguLQsuAzAKAAMAZAAiQUwuLQsuAzAKAAMAaQAqQRAuLQsuAzAKAAMAagAqQREuLQsuAzAKAAMAawAqQRIuLQsuAzAKAAMAbAAqQRMuLQsuAzAKAAMAbQAiQVkuLQsuAzAKAAMAbgAqQQouLQsuAzAKAAMAbwoiQEQDJAIAAwAAFoQjAAAWyS0IAS4AAAECAS0OBi4cCkIvBC0IUgMjAAAWnwwqAwowJAIAMAAAyVEjAAAWsS0LUgMtCy4vHAovLgAwCgAuAAMjAAAWyS0LVwMtC1guLQtZLy0LWjAtC1sxLQtcMi0LXTMtC140LQtfNS0LYDYtC2E3LQtiOC0LYzktC2U6LQtmOy0LZzwtC2g9MAoALQADMAoALQAuMAoALQAvMAgAVgAwMAoALQAxMAoALQAyMAgAVgAzMAgAVgA0MAoALQA1MAgAVgA2MAgAVgA3MAoALQA4MAgAVgA5MAgAVgA6HgIAAwEKIgNLLhYKLi8cCi8wAAQqMAMvCiIuUQMkAgADAAAXjycCMAQAPAYwATAKAC8AOzAKAC8APDAKAC8APR4CAAMANAIAAy0LAgMAIgMCAy0OAwIAIgICLy0LLy8tCi8uJwIwBAMAKgIwAzsOAC4AAyMAABfZKQIAAwDjC0CPCioBAy4nAgMAFicCLwAZJwIwABokAgAuAAAYAyMAABxlLQgBLicCMQQDAAgBMQEnAy4EAQAiLgIxHzAAVwBVADEtCAExAAABAgEtDi4xLQgBLgAAAQIBLQxSLicCMwQ0LQgANC0KMTUtCi42AAgAMwAlAADSGS0CAAAtCjUyACIyVTQtCzQzJwI0BDUtCAA1LQoxNi0KLjcACAA0ACUAANIZLQIAAC0KNjIeAgAuAB4CADEAHgIANAAeAgA1ADMqADQANQA2JAIANgAAGLUlAADSih4CADQBCiI0SzUWCjU2HAo2NwAEKjc0NgoiNVE0JAIANAAAGOMnAjcEADwGNwEKKjYxNCQCADQAABj1JQAA0pwvCgAEADEcCjE1AhwKNTQAHAo0MQIKIjFDNCQCADQAABkcJQAA0q4tCAExJwI0BAMACAE0AScDMQQBACIxAjQtCjQ1LQ4FNQAiNQI1LQ4zNScCNQQ2LQgANi0KMTctCFc4LQhROQAIADUAJQAA0sAtAgAALQo3NAoiNFMxCiIxUTUkAgA1AAAZgyUAANRSLwoANAAxHAoxNQYcCjU0ABwKNDEGCioxBjQkAgA0AAAZqiMAABw2LQgBLicCMQQDAAgBMQEnAy4EAQAiLgIxLQoxMi0OBTIAIjICMi0OMzInAjIENC0IADQtCi41LQhXNi0IUTcACAAyACUAANLALQIAAC0KNTEKIjFTLgoiLlEyJAIAMgAAGhElAADUUjAIAFYAMS8KAAcALhwKLjIGHAoyMQAcCjEuBgAqLggxDiouMTIkAgAyAAAaQyUAAM0RHAoxLgAwCgAuAActCAEuJwIxBAMACAExAScDLgQBACIuAjEtCjEyLQ4DMgAiMgIyLQ4zMicCMgQ0LQgANC0KLjUtCFc2LQhRNwAIADIAJQAA0sAtAgAALQo1MQoiMVMuCiIuUTIkAgAyAAAatSUAANRSLwoAMQAuHAouMgYcCjIxABwKMS4GACoILjEOKggxMiQCADIAABrhJQAAzREeAgAIBS0IAS4nAjIEAwAIATIBJwMuBAEAIi4CMi0KMjQtDi80ACI0AjQtDjM0JwI0BDUtCAA1LQouNi0IVzctCFE4AAgANAAlAADSwC0CAAAtCjYyCiIyUy4KIi5RNCQCADQAABtNJQAA1FIcCgguAC0IAQgnAjQEAwAIATQBJwMIBAEAIggCNC0KNDUtDjI1ACI1AjUtDi41JwI0BDUtCAA1LQoINi0IVzctCFE4AAgANAAlAADSwC0CAAAtCjYyCiIyUwgKIghRNCQCADQAABu5JQAA1FIcCjEIADAKAAgAMi0IAQgnAjEEAwAIATEBJwMIBAEAIggCMS0KMTItDjAyACIyAjItDjMyJwIyBDMtCAAzLQoINC0IVzUtCFE2AAgAMgAlAADSwC0CAAAtCjQxCiIxUwgKIghRMiQCADIAABwrJQAA1FIwCgAuADEjAAAcNi0LAggAIggCCC0OCAIAIgICMS0LMTEtCjEuJwIyBAMAKgIyCDsOAC4ACCMAABxlKQIACACEtZfkCioBCC4kAgAuAAAcgCMAACJSLQgBCCcCLgQEAAgBLgEnAwgEAQAiCAIuHzAAUABVAC4tCAEuAAABAgEtDgguLQgBCAAAAQIBLQxSCCcCMgQzLQgAMy0KLjQtCgg1AAgAMgAlAADUZC0CAAAtCjQxACIxVTMtCzMyJwIzBDQtCAA0LQouNS0KCDYACAAzACUAANRkLQIAAC0KNTEAIjFVNC0LNDMcCjM0BhwKNDEAHAoxMwYnAjUENi0IADYtCi43LQoIOAAIADUAJQAA1GQtAgAALQo3NAAiNFUuLQsuCB4CAC4AHgIANAAeAgA1AB4CADYAMyoANQA2ADckAgA3AAAddiUAANKKHgIANQEKIjVLNhYKNjccCjc4AAQqODU3CiI2UTUkAgA1AAAdpCcCOAQAPAY4AQoqNzQ1JAIANQAAHbYlAADU1S8KAAQANBwKNDYCHAo2NQAcCjU0AgoiNEQ1JAIANQAAHd0lAADU5y8KAAkANBwKNDYGHAo2NQAcCjU0BgwqMzQ1CiI1UTQkAgA0AAAeCSUAANT5JwI0AB8tCAE1JwI2BAMACAE2AScDNQQBACI1AjYtCjY3LQ40NwAiNwI3LQ4INycCNwQ4LQgAOC0KNTktCFc6LQhROwAIADcAJQAA0sAtAgAALQo5NgoiNlM1CiI1UTckAgA3AAAedSUAANRSLwoANgA1HAo1NwEcCjc2ABwKNjUBCiI1UTYkAgA2AAAenCUAANULLQgBNScCNgQDAAgBNgEnAzUEAQAiNQI2LQo2Ny0ONDcAIjcCNy0OCDcnAjQENi0IADYtCjU3LQhXOC0IUTkACAA0ACUAANLALQIAAC0KNwgKIghTNAoiNFE1JAIANQAAHwMlAADUUjAIAFYACC0IAQgnAjQEAwAIATQBJwMIBAEAIggCNC0KNDUtDgU1ACI1AjUtDjI1JwI1BDYtCAA2LQoINy0IVzgtCFE5AAgANQAlAADSwC0CAAAtCjc0CiI0UwgKIghRNSQCADUAAB9wJQAA1FIvCgA0AAgcCgg1BhwKNTQAHAo0CAYKKggGNCQCADQAAB+XIwAAIiMtCAEIJwIuBAMACAEuAScDCAQBACIIAi4tCi40LQ4FNAAiNAI0LQ4yNCcCNAQ1LQgANS0KCDYtCFc3LQhROAAIADQAJQAA0sAtAgAALQo2LgoiLlMICiIIUTQkAgA0AAAf/iUAANRSMAoAMQAuLwoABwAIHAoIMQYcCjEuABwKLggGACoIMy4OKgguMSQCADEAACAwJQAAzREcCi4IADAKAAgABy0IAQgnAi4EAwAIAS4BJwMIBAEAIggCLi0KLjEtDgMxACIxAjEtDjIxJwIxBDQtCAA0LQoINS0IVzYtCFE3AAgAMQAlAADSwC0CAAAtCjUuCiIuUwgKIghRMSQCADEAACCiJQAA1FIvCgAuAAgcCggxBhwKMS4AHAouCAYAKjMILg4qMy4xJAIAMQAAIM4lAADNER4CAAgFLQgBMScCMwQDAAgBMwEnAzEEAQAiMQIzLQozNC0OLzQAIjQCNC0OMjQnAjQENS0IADUtCjE2LQhXNy0IUTgACAA0ACUAANLALQIAAC0KNjMKIjNTMQoiMVE0JAIANAAAITolAADUUhwKCDEALQgBCCcCNAQDAAgBNAEnAwgEAQAiCAI0LQo0NS0OMzUAIjUCNS0OMTUnAjQENS0IADUtCgg2LQhXNy0IUTgACAA0ACUAANLALQIAAC0KNjMKIjNTCAoiCFE0JAIANAAAIaYlAADUUhwKLggAMAoACAAzLQgBCCcCLgQDAAgBLgEnAwgEAQAiCAIuLQouMy0OMDMAIjMCMy0OMjMnAjIEMy0IADMtCgg0LQhXNS0IUTYACAAyACUAANLALQIAAC0KNC4KIi5TCAoiCFEyJAIAMgAAIhglAADUUjAKADEALiMAACIjLQsCCAAiCAIILQ4IAgAiAgIxLQsxMS0KMS4nAjIEAwAqAjIIOw4ALgAIIwAAIlIpAgAIAEgURagKKgEILicCCAAXJAIALgAAInIjAAAuVy0IAS4nAjEEAwAIATEBJwMuBAEAIi4CMR8wAFcAVQAxLQgBMQAAAQIBLQ4uMS0IAS4AAAECAS0MUi4nAjMENC0IADQtCjE1LQouNgAIADMAJQAA0hktAgAALQo1MgAiMlU0LQs0MycCNAQ1LQgANS0KMTYtCi43AAgANAAlAADSGS0CAAAtCjYyACIyVTEtCzEuHgIAMQAeAgAyAB4CADQAHgIANQAzKgA0ADUANiQCADYAACMtJQAA0ooeAgA0AQoiNEs1Fgo1NhwKNjcABCo3NDYKIjVRNCQCADQAACNbJwI3BAA8BjcBCio2MjQkAgA0AAAjbSUAANUdLQgBMicCNAQDAAgBNAEnAzIEAQAiMgI0LQo0NS0OBTUAIjUCNS0OMzUnAjUENi0IADYtCjI3LQhXOC0IUTkACAA1ACUAANLALQIAAC0KNzQKIjRTMgoiMlE1JAIANQAAI9QlAADUUi8KADQAMhwKMjUGHAo1NAAcCjQyBi0IATQnAjUEAwAIATUBJwM0BAEAIjQCNS0KNTYtDgg2ACI2AjYtDjM2JwI2BDctCAA3LQo0OC0IVzktCFE6AAgANgAlAADSwC0CAAAtCjg1CiI1UzQKIjRRNiQCADYAACRQJQAA1FIvCgA1ADQKIjRTNSQCADUAACVyIwAAJGgtCAExJwI2BAMACAE2AScDMQQBACIxAjYtCjY3LQ4DNwAiNwI3LQ40NycCNwQ4LQgAOC0KMTktCFc6LQhROwAIADcAJQAA0sAtAgAALQo5NgoiNlMxCiIxUTckAgA3AAAkzyUAANRSLwoANgAxHAoxNwYcCjc2ABwKNjEGLQgBNicCNwQDAAgBNwEnAzYEAQAiNgI3LQo3OC0OAzgAIjgCOC0ONDgnAjgEOS0IADktCjY6LQhXOy0IUTwACAA4ACUAANLALQIAAC0KOjcKIjdTNgoiNlE4JAIAOAAAJUslAADUUgIqMTI2DioyMTgkAgA4AAAlYiUAANUvHAo2MQAwCgAxADcjAAAlci0IATEnAjYEAwAIATYBJwMxBAEAIjECNi0KNjctDgg3ACI3AjctDjM3JwI3BDgtCAA4LQoxOS0IVzotCFE7AAgANwAlAADSwC0CAAAtCjk2CiI2UzEKIjFRNyQCADcAACXZJQAA1FIwCgAuADYKIi5TMSQCADEAACb7IwAAJfEtCAE2JwI3BAMACAE3AScDNgQBACI2AjctCjc4LQ4DOAAiOAI4LQ4uOCcCOAQ5LQgAOS0KNjotCFc7LQhRPAAIADgAJQAA0sAtAgAALQo6NwoiN1M2CiI2UTgkAgA4AAAmWCUAANRSLwoANwA2HAo2OAYcCjg3ABwKNzYGLQgBNycCOAQDAAgBOAEnAzcEAQAiNwI4LQo4OS0OAzkAIjkCOS0OLjknAjkEOi0IADotCjc7LQhXPC0IUT0ACAA5ACUAANLALQIAAC0KOzgKIjhTNwoiN1E5JAIAOQAAJtQlAADUUgAqNjI3Dio2NzkkAgA5AAAm6yUAAM0RHAo3MgAwCgAyADgjAAAm+x4CADIFLQgBNicCNwQDAAgBNwEnAzYEAQAiNgI3LQo3OC0OBTgAIjgCOC0OMzgnAjgEOS0IADktCjY6LQhXOy0IUTwACAA4ACUAANLALQIAAC0KOjcKIjdTNgoiNlE4JAIAOAAAJ2clAADUUi8KADcANhwKNjgGHAo4NwAcCjc2Bi0IATcnAjgEAwAIATgBJwM3BAEAIjcCOC0KODktDgM5ACI5AjktDjM5JwI5BDotCAA6LQo3Oy0IVzwtCFE9AAgAOQAlAADSwC0CAAAtCjs4CiI4UzcKIjdROSQCADkAACfjJQAA1FIvCgA4ADccCjc5BhwKOTgAHAo4NwYAKjY3OA4qNjg5JAIAOQAAKA8lAADNES0IATYnAjcEAwAIATcBJwM2BAEAIjYCNy0KNzktDi85ACI5AjktDjM5JwI5BDotCAA6LQo2Oy0IVzwtCFE9AAgAOQAlAADSwC0CAAAtCjs3CiI3UzYKIjZROSQCADkAACh2JQAA1FIcCjI2AC0IATInAjkEAwAIATkBJwMyBAEAIjICOS0KOTotDjc6ACI6AjotDjY6JwI5BDotCAA6LQoyOy0IVzwtCFE9AAgAOQAlAADSwC0CAAAtCjs3CiI3UzIKIjJROSQCADkAACjiJQAA1FIcCjgyADAKADIANy0IATInAjcEAwAIATcBJwMyBAEAIjICNy0KNzgtDjA4ACI4AjgtDjM4JwI3BDgtCAA4LQoyOS0IVzotCFE7AAgANwAlAADSwC0CAAAtCjkzCiIzUzIKIjJRNyQCADcAAClUJQAA1FIwCgA2ADMkAgA1AAArwSMAAClnLQgBMicCMwQDAAgBMwEnAzIEAQAiMgIzLQozNS0OBTUAIjUCNS0ONDUnAjUENy0IADctCjI4LQhXOS0IUToACAA1ACUAANLALQIAAC0KODMKIjNTMgoiMlE1JAIANQAAKc4lAADUUi8KADMAMhwKMjUGHAo1MwAcCjMyBi0IATMnAjUEAwAIATUBJwMzBAEAIjMCNS0KNTctDgM3ACI3AjctDjQ3JwI3BDgtCAA4LQozOS0IVzotCFE7AAgANwAlAADSwC0CAAAtCjk1CiI1UzMKIjNRNyQCADcAACpKJQAA1FIvCgA1ADMcCjM3BhwKNzUAHAo1MwYAKjIzNQ4qMjU3JAIANwAAKnYlAADNES0IATInAjMEAwAIATMBJwMyBAEAIjICMy0KMzctDi83ACI3AjctDjQ3JwI3BDgtCAA4LQoyOS0IVzotCFE7AAgANwAlAADSwC0CAAAtCjkzCiIzUzIKIjJRNyQCADcAACrdJQAA1FItCAEyJwI3BAMACAE3AScDMgQBACIyAjctCjc4LQ4zOAAiOAI4LQ42OCcCNwQ4LQgAOC0KMjktCFc6LQhROwAIADcAJQAA0sAtAgAALQo5MwoiM1MyCiIyUTckAgA3AAArRCUAANRSHAo1MgAwCgAyADMtCAEyJwIzBAMACAEzAScDMgQBACIyAjMtCjM1LQ4wNQAiNQI1LQ40NScCNAQ3LQgANy0KMjgtCFc5LQhROgAIADQAJQAA0sAtAgAALQo4MwoiM1MyCiIyUTQkAgA0AAArtiUAANRSMAoANgAzIwAAK8EkAgAxAAAuKCMAACvOLQgBMScCMgQDAAgBMgEnAzEEAQAiMQIyLQoyMy0OBTMAIjMCMy0OLjMnAjMENy0IADctCjE4LQhXOS0IUToACAAzACUAANLALQIAAC0KODIKIjJTMQoiMVEzJAIAMwAALDUlAADUUi8KADIAMRwKMTMGHAozMgAcCjIxBi0IATInAjMEAwAIATMBJwMyBAEAIjICMy0KMzQtDgM0ACI0AjQtDi40JwI0BDctCAA3LQoyOC0IVzktCFE6AAgANAAlAADSwC0CAAAtCjgzCiIzUzIKIjJRNCQCADQAACyxJQAA1FIvCgAzADIcCjI0BhwKNDMAHAozMgYAKjEyMw4qMTM0JAIANAAALN0lAADNES0IATEnAjIEAwAIATIBJwMxBAEAIjECMi0KMjQtDi80ACI0AjQtDi40JwI0BDctCAA3LQoxOC0IVzktCFE6AAgANAAlAADSwC0CAAAtCjgyCiIyUzEKIjFRNCQCADQAAC1EJQAA1FItCAExJwI0BAMACAE0AScDMQQBACIxAjQtCjQ1LQ4yNQAiNQI1LQ42NScCNAQ3LQgANy0KMTgtCFc5LQhROgAIADQAJQAA0sAtAgAALQo4MgoiMlMxCiIxUTQkAgA0AAAtqyUAANRSHAozMQAwCgAxADItCAExJwIyBAMACAEyAScDMQQBACIxAjItCjIzLQ4wMwAiMwIzLQ4uMycCMAQ3LQgANy0KMTgtCFc5LQhROgAIADAAJQAA0sAtAgAALQo4LgoiLlMwCiIwUTEkAgAxAAAuHSUAANRSMAoANgAuIwAALigtCwIuACIuAi4tDi4CACICAjEtCzExLQoxMCcCMgQDACoCMi47DgAwAC4jAAAuVykCAC4Av00n6goqAS4wJAIAMAAALnIjAAAweC0IAS4nAjAEAgAIATABJwMuBAEAIi4CMB8wAFUAVQAwLQgBMAAAAQIBLQ4uMC0IAS4AAAECAS0MUi4nAjIEMy0IADMtCjA0LQouNQAIADIAJQAA1UEtAgAALQo0MQAiMVUwLQswLh4CADAAHgIAMQAeAgAyAB4CADMAMyoAMgAzADQkAgA0AAAvASUAANKKLQgBMicCMwQDAAgBMwEnAzIEAQAiMgIzLQozNC0OBTQAIjQCNC0OLjQnAjQENS0IADUtCjI2LQhXNy0IUTgACAA0ACUAANLALQIAAC0KNjMKIjNTMgoiMlE0JAIANAAAL2glAADUUi8KADMAMhwKMjQGHAo0MwAcCjMyBi0IATMnAjQEAwAIATQBJwMzBAEAIjMCNC0KNDUtDgM1ACI1AjUtDi41JwI0BDUtCAA1LQozNi0IVzctCFE4AAgANAAlAADSwC0CAAAtCjYuCiIuUzMKIjNRNCQCADQAAC/kJQAA1FIvCgAuADMcCjM0BhwKNC4AHAouMwYAKjIzLg4qMi40JAIANAAAMBAlAADNERwKLjIAJwIzBAEnAjUEAwAqMzU0LQgBLgAIATQBJwMuBAEAIi4CNC0OMzQAIjQCNC0OMzQnAjQEAwAqLjQzLQozNC0OMjQAIi4CNC0LNDQtCjQzJwI1BAMAKi41MjsOADMAMiMAADB4KQIALgBCQsENCioBLjAnAi4ACycCMQAOJwIyAA8nAjMAFCQCADAAADCnIwAAOV0tCAEwJwI0BAYACAE0AScDMAQBACIwAjQfMABYAFUANC0IATQAAAECAS0OMDQtCAEwAAABAgEtDFIwJwI2BDctCAA3LQo0OC0KMDkACAA2ACUAANWWLQIAAC0KODUAIjVVNy0LNzYnAjcEOC0IADgtCjQ5LQowOgAIADcAJQAA1ZYtAgAALQo5NQAiNVU4LQs4NycCOAQ5LQgAOS0KNDotCjA7AAgAOAAlAADVli0CAAAtCjo1ACI1VTktCzk4JwI5BDotCAA6LQo0Oy0KMDwACAA5ACUAANWWLQIAAC0KOzUAIjVVOi0LOjkcCjk6AhwKOjUAJwI6BDstCAA7LQo0PC0KMD0ACAA6ACUAANWWLQIAAC0KPDkAIjlVNC0LNDAcCjA5AhwKOTQAHgIAMAAeAgA5AC0IAToAAAECAS0OCzotCAE7AAABAgEtDgw7LQgBPAAAAQIBLQ4uPC0IAT0AAAECAS0ODT0tCAE+AAABAgEtDg4+LQgBPwAAAQIBLQ4xPy0IAUAAAAECAS0OMkAtCAFBAAABAgEtDjNBLQgBQgAAAQIBLQ4HQh4CAEMAHgIARAAzKgBDAEQARSQCAEUAADJvJQAA0ooeAgBDAQoiQ0tEFgpERRwKRUYABCpGQ0UKIkRRQyQCAEMAADKdJwJGBAA8BkYBCipFOUMkAgBDAAAyryUAANYHLQgBOScCQwQDAAgBQwEnAzkEAQAiOQJDLQpDRC0OFUQAIkQCRC0OFEQnAkQERS0IAEUtCjlGLQhXRy0IUUgACABEACUAAM8jLQIAAC0KRkMeAgA5ADMqAEMAOQBEJAIARAAAMxklAADWGS8KABQAORwKOUQCHApEQwAcCkM5AgoiOURDJAIAQwAANIAjAAAzQC0IATAnAjkEAwAIATkBJwMwBAEAIjACOS0KOUMtDgVDACJDAkMtDjZDJwJDBEQtCABELQowRS0IV0YtCFFHAAgAQwAlAADSwC0CAAAtCkU5CiI5UzAKIjBRQyQCAEMAADOnJQAA1FIvCgA5ADAcCjBDBhwKQzkAHAo5MAYtCAE5JwJDBAMACAFDAScDOQQBACI5AkMtCkNELQ4DRAAiRAJELQ42RCcCRARFLQgARS0KOUYtCFdHLQhRSAAIAEQAJQAA0sAtAgAALQpGQwoiQ1M5CiI5UUQkAgBEAAA0IyUAANRSLwoAQwA5HAo5RAYcCkRDABwKQzkGACowOUMOKjBDRCQCAEQAADRPJQAAzREvCgAWADAcCjBEBhwKRDkAHAo5MAYMKkMwOQoiOVEwJAIAMAAANHslAADWKyMAADWeLwoAKgA5HAo5RAIcCkRDABwKQzkCLwoAHgBDLwoAHwBELwoAIABFLwoAIQBGLwoAIgBHLwoAIwBILwoAJABJLwoAJQBKLwoAJgBLLwoAJwBMLwoAKABNLwoAKQBOLQgBTycCUAQNAAgBUAEnA08EAQAiTwJQLQpQUS0OQ1EAIlECUS0ORFEAIlECUS0ORVEAIlECUS0ORlEAIlECUS0OR1EAIlECUS0OSFEAIlECUS0OSVEAIlECUS0OSlEAIlECUS0OS1EAIlECUS0OTFEAIlECUS0OTVEAIlECUS0OTlEtCAFDAAABAgEtDFFDLQhSMCMAADV2DCowCkQkAgBEAADI+SMAADWILQtDMCQCADAAADWZJQAA1j0jAAA1ni0LOjAtCzs5LQs8Oi0LPTstCz48LQs/PS0LQD4tC0E/LQtCQC8KADsAQRwKQUMFHApDQgAcCkJBBS8KADAAQxwKQ0QEHApEMAAcCjBDBC8KADkAMBwKMEQEHApEOQAcCjkwBB4CADkFACo5Q0QOKjlERSQCAEUAADYdJQAAzREAKkQwQw4qRENFJAIARQAANjQlAADNES0IATAnAkUEAwAIAUUBJwMwBAEAIjACRS0KRUYtDjpGACJGAkYtDkJGJwJFBEYtCABGLQowRy0IV0gtCFFJAAgARQAlAADSwC0CAAAtCkc6CiI6UzAKIjBRRSQCAEUAADabJQAA1FIcCkQwABwKQ0QALQgBQycCRQQMAAgBRQEnA0MEAQAiQwJFLQpFRi0OQkYAIkYCRi0ONkYAIkYCRi0MU0YAIkYCRi0OMEYAIkYCRi0OREYAIkYCRi0MU0YAIkYCRi0MU0YAIkYCRi0ON0YAIkYCRi0OOEYAIkYCRi0ONUYAIkYCRi0ONEYnAjAERC0IAEQtCjpFLQpDRgAIADAAJQAA1k8tAgAALQgBMCcCNAQDAAgBNAEnAzAEAQAiMAI0LQo0NS0OPDUAIjUCNS0OQjUnAjUEQy0IAEMtCjBELQhXRS0IUUYACAA1ACUAANLALQIAAC0KRDQKIjRTMAoiMFE1JAIANQAAN6UlAADUUjAIAFMANC0IATAnAjQEAwAIATQBJwMwBAEAIjACNC0KNDUtDj01ACI1AjUtDkI1JwI1BEMtCABDLQowRC0IV0UtCFFGAAgANQAlAADSwC0CAAAtCkQ0CiI0UzAKIjBRNSQCADUAADgSJQAA1FIwCABTADQtCAEwJwI0BAMACAE0AScDMAQBACIwAjQtCjQ1LQ4+NQAiNQI1LQ5CNScCNQRCLQgAQi0KMEMtCFdELQhRRQAIADUAJQAA0sAtAgAALQpDNAoiNFMwCiIwUTUkAgA1AAA4fyUAANRSMAgAUwA0JwIwBQEAKkEwNA4qQTQ1JAIANQAAOKElAADNERwKNDAAMAoAMAA7HAo5MAAtCAE0JwI1BAMACAE1AScDNAQBACI0AjUtCjU2LQ4/NgAiNgI2LQ4wNicCNQRBLQgAQS0KNEItCFdDLQhRRAAIADUAJQAA0sAtAgAALQpCMAoiMFM0CiI0UTUkAgA1AAA5GCUAANRSLwoAQAA0HAo0NgYcCjY1ADAKADUAMC0LAjAAIjACMC0OMAIAIgICNS0LNTUtCjU0JwI2BAMAKgI2MDsOADQAMCMAADldKQIAMABS2I/eCioBMDQkAgA0AAA5eCMAAD3aLQgBMCcCNAQCAAgBNAEnAzAEAQAiMAI0HzAAVQBVADQtCAE0AAABAgEtDjA0LQgBMAAAAQIBLQxSMCcCNgQ3LQgANy0KNDgtCjA5AAgANgAlAADVQS0CAAAtCjg1ACI1VTQtCzQwHgIANAAeAgA1AB4CADYAHgIANwAzKgA2ADcAOCQCADgAADoHJQAA0ootCAE2JwI3BAMACAE3AScDNgQBACI2AjctCjc4LQ4uOAAiOAI4LQ4wOCcCOAQ5LQgAOS0KNjotCFc7LQhRPAAIADgAJQAA0sAtAgAALQo6NwoiN1M2CiI2UTgkAgA4AAA6biUAANRSJwI4BDktCAA5LQo3OgAIADgAJQAA1pwtAgAALQo6NgAiNlU4LQs4NxwKNzkFHAo5OAAAIjZXOS0LOTcAIjZQOi0LOjkcCjk7BBwKOzoAACo2DzstCzs5HAo5PAQcCjw7AAAiNlg8LQs8ORwKOT0EHAo9PAAAKjYQPS0LPTkcCjk+ARwKPj0AACo2ET4tCz45ACo2Ej8tCz8+ACo2E0AtC0A/HAo/QQIcCkFAAAAiNllBLQtBPxwKP0ECHApBNgAeAgA/AQoiP0tBFgpBQhwKQkMABCpDP0IKIkFRPyQCAD8AADtbJwJDBAA8BkMBLwoAGgA/LQgBQScCQwQDAAgBQwEnA0EEAQAiQQJDLQpDRC0OBUQAIkQCRC0ON0QnAkQERS0IAEUtCkFGLQhXRy0IUUgACABEACUAANLALQIAAC0KRkMKIkNTQQoiQVFEJAIARAAAO8glAADUUi8KAEMAQRwKQUQGHApEQwAcCkNBBi0IAUMnAkQEAwAIAUQBJwNDBAEAIkMCRC0KREUtDgNFACJFAkUtDjdFJwJFBEYtCABGLQpDRy0IV0gtCFFJAAgARQAlAADSwC0CAAAtCkdECiJEU0MKIkNRRSQCAEUAADxEJQAA1FIvCgBEAEMcCkNFBhwKRUQAHApEQwYAKkFDRA4qQURFJAIARQAAPHAlAADNES8KABYAQRwKQUUGHApFQwAcCkNBBgoqQj9DCipCNz8MKkRBQgQqP0JBEipDQT8kAgA/AAA8qyUAANdVLQgBPycCQQQDAAgBQQEnAz8EAQAiPwJBLQpBQi0OLkIAIkICQi0OMEInAkEEQi0IAEItCj9DLQhXRC0IUUUACABBACUAANLALQIAAC0KQzAKIjBTPwoiP1FBJAIAQQAAPRIlAADUUi0IAT8nAkEEDAAIAUEBJwM/BAEAIj8CQS0KQUItDjhCACJCAkItDjdCACJCAkItDjpCACJCAkItDjtCACJCAkItDjxCACJCAkItDFZCACJCAkItDj1CACJCAkItDjlCACJCAkItDj5CACJCAkItDkBCACJCAkItDjZCJwI2BEAtCABALQowQS0KP0IACAA2ACUAANZPLQIAAC0LAjAAIjACMC0OMAIAIgICNy0LNzctCjc2JwI4BAMAKgI4MDsOADYAMCMAAD3aKQIAMABRLVj5CioBMDQkAgA0AAA99SMAAEruLQgBNCcCNQQEAAgBNQEnAzQEAQAiNAI1HzAAUABVADUtCAE1AAABAgEtDjQ1LQgBNAAAAQIBLQxSNCcCNwQ4LQgAOC0KNTktCjQ6AAgANwAlAADUZC0CAAAtCjk2ACI2VTgtCzg3JwI4BDktCAA5LQo1Oi0KNDsACAA4ACUAANRkLQIAAC0KOjYAIjZVOS0LOTgcCjg5AhwKOTYAHAo2OAInAjkEOi0IADotCjU7LQo0PAAIADkAJQAA1GQtAgAALQo7NgAiNlU1LQs1NB4CADUAHgIANgAeAgA5AB4CADoAMyoAOQA6ADskAgA7AAA+6yUAANKKHgIAOQEKIjlLOhYKOjscCjs8AAQqPDk7CiI6UTkkAgA5AAA/GScCPAQAPAY8AQoqOzY5JAIAOQAAPyslAADXZy0IATYnAjkEAwAIATkBJwM2BAEAIjYCOS0KOTotDi46ACI6AjotDjc6JwI6BDstCAA7LQo2PC0IVz0tCFE+AAgAOgAlAADSwC0CAAAtCjw5CiI5UzYKIjZROiQCADoAAD+SJQAA1FInAjoEOy0IADstCjk8AAgAOgAlAADWnC0CAAAtCjw2ACo2DzotCzo5HAo5OwQcCjs6ABwKOjkEACI2WDwtCzw7HAo7PQQcCj08ABwKPDsEACI2TD0tCz08HAo8PQEcCj02ABwKNjwBCiI8UTYkAgA2AABACyUAANd5HgIANgUMKjY5PAoiPFE2JAIANgAAQCclAADXix4CADYFDCo7NjkKIjlRNiQCADYAAEBDJQAA150tCAE2JwI5BAMACAE5AScDNgQBACI2AjktCjk7LQ4vOwAiOwI7LQ40OycCOwQ8LQgAPC0KNj0tCFc+LQhRPwAIADsAJQAA0sAtAgAALQo9OQoiOVM2CiI2UTskAgA7AABAqiUAANRSLQgBNicCOwQDAAgBOwEnAzYEAQAiNgI7LQo7PC0OOTwAIjwCPC0OOjwnAjoEOy0IADstCjY8LQhXPS0IUT4ACAA6ACUAANLALQIAAC0KPDkKIjlTNgoiNlE6JAIAOgAAQRElAADUUi8KADkANhwKNjoGHAo6OQAcCjk2BgwqBjY5JAIAOQAAQlAjAABBOC0IATUnAjYEAwAIATYBJwM1BAEAIjUCNi0KNjktDgU5ACI5AjktDjQ5JwI5BDotCAA6LQo1Oy0IVzwtCFE9AAgAOQAlAADSwC0CAAAtCjs2CiI2UzUKIjVROSQCADkAAEGfJQAA1FIvCgA2ADUcCjU5BhwKOTYAHAo2NQYtCAE2JwI5BAMACAE5AScDNgQBACI2AjktCjk6LQ4DOgAiOgI6LQ40OicCOQQ6LQgAOi0KNjstCFc8LQhRPQAIADkAJQAA0sAtAgAALQo7NAoiNFM2CiI2UTkkAgA5AABCGyUAANRSLwoANAA2HAo2OQYcCjk0ABwKNDYGACo1NjQOKjU0OSQCADkAAEJHJQAAzREtCjQwIwAAQlktCjYwIwAAQlkMKgYwNCQCADQAAEJrJQAA168KIjhDNCQCADQAAETHIwAAQn0KIjhENCQCADQAAEO9IwAAQo8KIjhFNCQCADQAAEKzIwAAQqEKIFFUASQCAAEAAEKzJQAA18EtCAE0JwI1BAMACAE1AScDNAQBACI0AjUtCjU2LQ4yNgAiNgI2LQ43NicCNgQ4LQgAOC0KNDktCFc6LQhROwAIADYAJQAA0sAtAgAALQo5NQoiNVM0CiI0UTYkAgA2AABDGiUAANRSLwoANQA0HAo0NgYcCjY1ABwKNTQGLQgBNScCNgQDAAgBNgEnAzUEAQAiNQI2LQo2OC0OMjgAIjgCOC0ONzgnAjgEOS0IADktCjU6LQhXOy0IUTwACAA4ACUAANLALQIAAC0KOjYKIjZTNQoiNVE4JAIAOAAAQ5YlAADUUgAqNDA1Dio0NTgkAgA4AABDrSUAAM0RHAo1MAAwCgAwADYjAABF0S0IATQnAjUEAwAIATUBJwM0BAEAIjQCNS0KNTYtDg42ACI2AjYtDjc2JwI2BDgtCAA4LQo0OS0IVzotCFE7AAgANgAlAADSwC0CAAAtCjk1CiI1UzQKIjRRNiQCADYAAEQkJQAA1FIvCgA1ADQcCjQ2BhwKNjUAHAo1NAYtCAE1JwI2BAMACAE2AScDNQQBACI1AjYtCjY4LQ4OOAAiOAI4LQ43OCcCOAQ5LQgAOS0KNTotCFc7LQhRPAAIADgAJQAA0sAtAgAALQo6NgoiNlM1CiI1UTgkAgA4AABEoCUAANRSACo0MDUOKjQ1OCQCADgAAES3JQAAzREcCjUwADAKADAANiMAAEXRLQgBNCcCNQQDAAgBNQEnAzQEAQAiNAI1LQo1Ni0OMTYAIjYCNi0ONzYnAjYEOC0IADgtCjQ5LQhXOi0IUTsACAA2ACUAANLALQIAAC0KOTUKIjVTNAoiNFE2JAIANgAARS4lAADUUi8KADUANBwKNDYGHAo2NQAcCjU0Bi0IATUnAjYEAwAIATYBJwM1BAEAIjUCNi0KNjgtDjE4ACI4AjgtDjc4JwI4BDktCAA5LQo1Oi0IVzstCFE8AAgAOAAlAADSwC0CAAAtCjo2CiI2UzUKIjVROCQCADgAAEWqJQAA1FIAKjQwNQ4qNDU4JAIAOAAARcElAADNERwKNTAAMAoAMAA2IwAARdEtCAEwJwI0BAMACAE0AScDMAQBACIwAjQtCjQ1LQ4uNQAiNQI1LQ43NScCNQQ4LQgAOC0KMDktCFc6LQhROwAIADUAJQAA0sAtAgAALQo5NAoiNFMwCiIwUTUkAgA1AABGOCUAANRSJwI1BDgtCAA4LQo0OQAIADUAJQAA1pwtAgAALQo5MAAiMFU1LQs1NBwKNDYFHAo2NQAAIjBXNi0LNjQAIjBQOC0LODYcCjY5BBwKOTgAACowDzktCzk2HAo2OgQcCjo5AAAiMFg6LQs6NhwKNjsEHAo7OgAcCjo2BAAiMEw7LQs7OhwKOjwBHAo8OwAAKjAQPC0LPDocCjo9ARwKPTwAACowET0tCz06ACowEj4tCz49ACowEz8tCz8+HAo+QAIcCkA/AAAiMFlALQtAPhwKPkACHApAMAAvCgAYAD4cCj5BBBwKQUAAHApAPgQKIj5SQCQCAEAAAEq/IwAARzYeAgBABQIqNj5BDio+NkIkAgBCAABHUiUAANUvDCpAQUIkAgBCAABKvyMAAEdkLQgBQicCQwQDAAgBQwEnA0IEAQAiQgJDLQpDRC0ODkQAIkQCRC0ON0QnAkQERS0IAEUtCkJGLQhXRy0IUUgACABEACUAANLALQIAAC0KRkMKIkNTQgoiQlFEJAIARAAAR8slAADUUi8KAEMAQhwKQkQGHApEQwAcCkNCBi0IAUMnAkQEAwAIAUQBJwNDBAEAIkMCRC0KREUtDjJFACJFAkUtDjdFJwJFBEYtCABGLQpDRy0IV0gtCFFJAAgARQAlAADSwC0CAAAtCkdECiJEU0MKIkNRRSQCAEUAAEhHJQAA1FIvCgBEAEMcCkNFBhwKRUQAHApEQwYtCAFEJwJFBAMACAFFAScDRAQBACJEAkUtCkVGLQ4zRgAiRgJGLQ45RicCRgRHLQgARy0KREgtCFdJLQhRSgAIAEYAJQAA0sAtAgAALQpIRQoiRVNECiJEUUYkAgBGAABIwyUAANRSLwoARQBEHApERgYcCkZFABwKRUQGLwoAFQBFHApFRwYcCkdGABwKRkUGLwoAFwBGHApGSAYcCkhHABwKR0YGCipEBkcKKkYGSBIqR0hJJAIASQAASVojAABJHgQqREVHJwJJBgAKKklFSCQCAEgAAElMBipHRUsKKktESiQCAEoAAElMJQAA19MGKkdGRC0KREEjAABJYy0KBkEjAABJYwAqQkNEDipCREUkAgBFAABJeiUAAM0RDCpEQUIkAgBCAABKvyMAAEmMACpAPkEOKkBBQiQCAEIAAEmjJQAAzREMKjZBPiQCAD4AAEm1IwAASr8tCAE2JwI+BAMACAE+AScDNgQBACI2Aj4tCj5ALQ4uQAAiQAJALQ43QCcCPgRCLQgAQi0KNkMtCFdELQhRRQAIAD4AJQAA0sAtAgAALQpDNwoiN1M2CiI2UT4kAgA+AABKHCUAANRSHApBNgAtCAE+JwJABAwACAFAAScDPgQBACI+AkAtCkBBLQ41QQAiQQJBLQ40QQAiQQJBLQ44QQAiQQJBLQ45QQAiQQJBLQ42QQAiQQJBLQ47QQAiQQJBLQ48QQAiQQJBLQ46QQAiQQJBLQ49QQAiQQJBLQ4/QQAiQQJBLQ4wQScCMAQ/LQgAPy0KN0AtCj5BAAgAMAAlAADWTy0CAAAjAABKvy0LAjAAIjACMC0OMAIAIgICNS0LNTUtCjU0JwI2BAMAKgI2MDsOADQAMCMAAEruKQIAMACZOK8uCioBMDQkAgA0AABLCSMAAFimLQgBNCcCNQQGAAgBNQEnAzQEAQAiNAI1HzAAWABVADUtCAE1AAABAgEtDjQ1LQgBNAAAAQIBLQxSNCcCNwQ4LQgAOC0KNTktCjQ6AAgANwAlAADVli0CAAAtCjk2ACI2VTgtCzg3JwI4BDktCAA5LQo1Oi0KNDsACAA4ACUAANWWLQIAAC0KOjYAIjZVOS0LOTgcCjg5BhwKOTYAHAo2OAYnAjkEOi0IADotCjU7LQo0PAAIADkAJQAA1ZYtAgAALQo7NgAiNlU6LQs6ORwKOToGHAo6NgAcCjY5BicCOgQ7LQgAOy0KNTwtCjQ9AAgAOgAlAADVli0CAAAtCjw2ACI2VTstCzs6HAo6OwYcCjs2ABwKNjoGJwI7BDwtCAA8LQo1PS0KND4ACAA7ACUAANWWLQIAAC0KPTYAIjZVNS0LNTQeAgA1AB4CADYAHgIAOwAeAgA8ADMqADsAPAA9JAIAPQAATHUlAADSih4CADsBCiI7SzwWCjw9HAo9PgAEKj47PQoiPFE7JAIAOwAATKMnAj4EADwGPgEKKj02OyQCADsAAEy1JQAA1+UtCAE2JwI7BAMACAE7AScDNgQBACI2AjstCjs8LQ4uPAAiPAI8LQ43PCcCPAQ9LQgAPS0KNj4tCFc/LQhRQAAIADwAJQAA0sAtAgAALQo+OwoiO1M2CiI2UTwkAgA8AABNHCUAANRSJwI8BD0tCAA9LQo7PgAIADwAJQAA1pwtAgAALQo+NgAqNg88LQs8OxwKOz0EHAo9PAAcCjw7BAAiNlg+LQs+PRwKPT8EHAo/PgAcCj49BAAiNkw/LQs/PhwKPj8BHAo/NgAcCjY+AQoiPlE2JAIANgAATZUlAADXeR4CADYFDCo2Oz4KIj5RNiQCADYAAE2xJQAA14seAgA2BQwqPTY7CiI7UTYkAgA2AABNzSUAANedLQgBNicCOwQDAAgBOwEnAzYEAQAiNgI7LQo7PS0OLz0AIj0CPS0OND0nAj0EPi0IAD4tCjY/LQhXQC0IUUEACAA9ACUAANLALQIAAC0KPzsKIjtTNgoiNlE9JAIAPQAATjQlAADUUi0IATYnAj0EAwAIAT0BJwM2BAEAIjYCPS0KPT4tDjs+ACI+Aj4tDjw+JwI8BD0tCAA9LQo2Pi0IVz8tCFFAAAgAPAAlAADSwC0CAAAtCj47CiI7UzYKIjZRPCQCADwAAE6bJQAA1FIvCgA7ADYcCjY8BhwKPDsAHAo7NgYMKgY2OyQCADsAAE/aIwAATsItCAE1JwI2BAMACAE2AScDNQQBACI1AjYtCjY7LQ4FOwAiOwI7LQ40OycCOwQ8LQgAPC0KNT0tCFc+LQhRPwAIADsAJQAA0sAtAgAALQo9NgoiNlM1CiI1UTskAgA7AABPKSUAANRSLwoANgA1HAo1OwYcCjs2ABwKNjUGLQgBNicCOwQDAAgBOwEnAzYEAQAiNgI7LQo7PC0OAzwAIjwCPC0ONDwnAjsEPC0IADwtCjY9LQhXPi0IUT8ACAA7ACUAANLALQIAAC0KPTQKIjRTNgoiNlE7JAIAOwAAT6UlAADUUi8KADQANhwKNjsGHAo7NAAcCjQ2BgAqNTY0Dio1NDskAgA7AABP0SUAAM0RLQo0MCMAAE/jLQo2MCMAAE/jDCoGMDQkAgA0AABP9SUAANevACo4OTQOKjg0NSQCADUAAFAMJQAAzREAKjQ6NQ4qNDU2JAIANgAAUCMlAADNEQoqNTA0JAIANAAAUDUlAADX9wwqBjgwJAIAMAAAUEcjAABRUS0IATAnAjQEAwAIATQBJwMwBAEAIjACNC0KNDUtDg41ACI1AjUtDjc1JwI1BDstCAA7LQowPC0IVz0tCFE+AAgANQAlAADSwC0CAAAtCjw0CiI0UzAKIjBRNSQCADUAAFCuJQAA1FIvCgA0ADAcCjA1BhwKNTQAHAo0MAYtCAE0JwI1BAMACAE1AScDNAQBACI0AjUtCjU2LQ4ONgAiNgI2LQ43NicCNgQ7LQgAOy0KNDwtCFc9LQhRPgAIADYAJQAA0sAtAgAALQo8NQoiNVM0CiI0UTYkAgA2AABRKiUAANRSACowODQOKjA0NiQCADYAAFFBJQAAzREcCjQwADAKADAANSMAAFFRDCoGOTAkAgAwAABRYyMAAFJtLQgBMCcCNAQDAAgBNAEnAzAEAQAiMAI0LQo0NS0OMTUAIjUCNS0ONzUnAjUEOy0IADstCjA8LQhXPS0IUT4ACAA1ACUAANLALQIAAC0KPDQKIjRTMAoiMFE1JAIANQAAUcolAADUUi8KADQAMBwKMDUGHAo1NAAcCjQwBi0IATQnAjUEAwAIATUBJwM0BAEAIjQCNS0KNTYtDjE2ACI2AjYtDjc2JwI2BDstCAA7LQo0PC0IVz0tCFE+AAgANgAlAADSwC0CAAAtCjw1CiI1UzQKIjRRNiQCADYAAFJGJQAA1FIAKjA5NA4qMDQ2JAIANgAAUl0lAADNERwKNDAAMAoAMAA1IwAAUm0MKgY6MCQCADAAAFJ/IwAAU4ktCAEwJwI0BAMACAE0AScDMAQBACIwAjQtCjQ1LQ4yNQAiNQI1LQ43NScCNQQ7LQgAOy0KMDwtCFc9LQhRPgAIADUAJQAA0sAtAgAALQo8NAoiNFMwCiIwUTUkAgA1AABS5iUAANRSLwoANAAwHAowNQYcCjU0ABwKNDAGLQgBNCcCNQQDAAgBNQEnAzQEAQAiNAI1LQo1Ni0OMjYAIjYCNi0ONzYnAjYEOy0IADstCjQ8LQhXPS0IUT4ACAA2ACUAANLALQIAAC0KPDUKIjVTNAoiNFE2JAIANgAAU2IlAADUUgAqMDo0DiowNDYkAgA2AABTeSUAAM0RHAo0MAAwCgAwADUjAABTiS0IATAnAjQEAwAIATQBJwMwBAEAIjACNC0KNDUtDi41ACI1AjUtDjc1JwI1BDgtCAA4LQowOS0IVzotCFE7AAgANQAlAADSwC0CAAAtCjk0CiI0UzAKIjBRNSQCADUAAFPwJQAA1FInAjUEOC0IADgtCjQ5AAgANQAlAADWnC0CAAAtCjkwACIwVTUtCzU0HAo0NgUcCjY1AAAiMFc2LQs2NAAiMFA4LQs4NhwKNjkEHAo5OAAAKjAPOS0LOTYcCjY6BBwKOjkAACIwWDotCzo2HAo2OwQcCjs6ABwKOjYEACIwTDstCzs6HAo6PAEcCjw7AAAqMBA8LQs8OhwKOj0BHAo9PAAAKjARPS0LPToAKjASPi0LPj0AKjATPy0LPz4cCj5AAhwKQD8AACIwWUAtC0A+HAo+QAIcCkAwAC8KABgAPhwKPkEEHApBQAAcCkA+BAoiPlJAJAIAQAAAWHcjAABU7h4CAEAFAio2PkEOKj42QiQCAEIAAFUKJQAA1S8MKkBBQiQCAEIAAFh3IwAAVRwtCAFCJwJDBAMACAFDAScDQgQBACJCAkMtCkNELQ4ORAAiRAJELQ43RCcCRARFLQgARS0KQkYtCFdHLQhRSAAIAEQAJQAA0sAtAgAALQpGQwoiQ1NCCiJCUUQkAgBEAABVgyUAANRSLwoAQwBCHApCRAYcCkRDABwKQ0IGLQgBQycCRAQDAAgBRAEnA0MEAQAiQwJELQpERS0OMkUAIkUCRS0ON0UnAkUERi0IAEYtCkNHLQhXSC0IUUkACABFACUAANLALQIAAC0KR0QKIkRTQwoiQ1FFJAIARQAAVf8lAADUUi8KAEQAQxwKQ0UGHApFRAAcCkRDBi0IAUQnAkUEAwAIAUUBJwNEBAEAIkQCRS0KRUYtDjNGACJGAkYtDjlGJwJGBEctCABHLQpESC0IV0ktCFFKAAgARgAlAADSwC0CAAAtCkhFCiJFU0QKIkRRRiQCAEYAAFZ7JQAA1FIvCgBFAEQcCkRGBhwKRkUAHApFRAYvCgAVAEUcCkVHBhwKR0YAHApGRQYvCgAXAEYcCkZIBhwKSEcAHApHRgYKKkQGRwoqRgZIEipHSEkkAgBJAABXEiMAAFbWBCpERUcnAkkGAAoqSUVIJAIASAAAVwQGKkdFSwoqS0RKJAIASgAAVwQlAADX0wYqR0ZELQpEQSMAAFcbLQoGQSMAAFcbACpCQ0QOKkJERSQCAEUAAFcyJQAAzREMKkRBQiQCAEIAAFh3IwAAV0QAKkA+QQ4qQEFCJAIAQgAAV1slAADNEQwqNkE+JAIAPgAAV20jAABYdy0IATYnAj4EAwAIAT4BJwM2BAEAIjYCPi0KPkAtDi5AACJAAkAtDjdAJwI+BEItCABCLQo2Qy0IV0QtCFFFAAgAPgAlAADSwC0CAAAtCkM3CiI3UzYKIjZRPiQCAD4AAFfUJQAA1FIcCkE2AC0IAT4nAkAEDAAIAUABJwM+BAEAIj4CQC0KQEEtDjVBACJBAkEtDjRBACJBAkEtDjhBACJBAkEtDjlBACJBAkEtDjZBACJBAkEtDjtBACJBAkEtDjxBACJBAkEtDjpBACJBAkEtDj1BACJBAkEtDj9BACJBAkEtDjBBJwIwBD8tCAA/LQo3QC0KPkEACAAwACUAANZPLQIAACMAAFh3LQsCMAAiMAIwLQ4wAgAiAgI1LQs1NS0KNTQnAjYEAwAqAjYwOw4ANAAwIwAAWKYpAgAwAHjhCJAKKgEwNCgCADAEOEAkAgA0AABYyCMAAGCoLQgBNScCNgQCAAgBNgEnAzUEAQAiNQI2HzAAVQBVADYtCAE2AAABAgEtDjU2LQgBNQAAAQIBLQxSNScCOAQ5LQgAOS0KNjotCjU7AAgAOAAlAADVQS0CAAAtCjo3ACI3VTYtCzY1HgIANgAeAgA3AB4CADgAHgIAOQAzKgA4ADkAOiQCADoAAFlXJQAA0ootCAE4JwI5BAMACAE5AScDOAQBACI4AjktCjk6LQ4uOgAiOgI6LQ41OicCOgQ7LQgAOy0KODwtCFc9LQhRPgAIADoAJQAA0sAtAgAALQo8OQoiOVM4CiI4UTokAgA6AABZviUAANRSJwI6BDstCAA7LQo5PAAIADoAJQAA1pwtAgAALQo8OAAiOFA6LQs6ORwKOTsEHAo7OgAcCjo5BAAqOA87LQs7OhwKOjwEHAo8OwAcCjs6BAAiOFg9LQs9PBwKPD4EHAo+PQAcCj08BAAiOEw+LQs+PRwKPT8BHAo/PgAcCj49AQAqOBA/LQs/PhwKPj8BHAo/OAAcCjg+AS0IATgnAj8EAwAIAT8BJwM4BAEAIjgCPy0KP0AtDg5AACJAAkAtDjVAJwJABEEtCABBLQo4Qi0IV0MtCFFEAAgAQAAlAADSwC0CAAAtCkI/CiI/UzgKIjhRQCQCAEAAAFq8JQAA1FIvCgA/ADgcCjhABhwKQD8AHAo/OAYtCAE/JwJABAMACAFAAScDPwQBACI/AkAtCkBBLQ4xQQAiQQJBLQ41QScCQQRCLQgAQi0KP0MtCFdELQhRRQAIAEEAJQAA0sAtAgAALQpDQAoiQFM/CiI/UUEkAgBBAABbOCUAANRSLwoAQAA/HAo/QQYcCkFAABwKQD8GLQgBQCcCQQQDAAgBQQEnA0AEAQAiQAJBLQpBQi0OMkIAIkICQi0ONUInAkIEQy0IAEMtCkBELQhXRS0IUUYACABCACUAANLALQIAAC0KREEKIkFTQAoiQFFCJAIAQgAAW7QlAADUUi8KAEEAQBwKQEIGHApCQQAcCkFABi0IAUEnAkIEAwAIAUIBJwNBBAEAIkECQi0KQkMtDjNDACJDAkMtDjtDJwJCBEMtCABDLQpBRC0IV0UtCFFGAAgAQgAlAADSwC0CAAAtCkQ7CiI7U0EKIkFRQiQCAEIAAFwwJQAA1FIvCgA7AEEcCkFCBhwKQjsAHAo7QQYvCgAVADscCjtDBhwKQ0IAHApCOwYvCgAXAEIcCkJEBhwKREMAHApDQgYKKkEGQwoqQgZEEipDREUkAgBFAABcxyMAAFyLBCpBOzYnAkMGAAoqQzs3JAIANwAAXLkGKjY7RQoqRUFEJAIARAAAXLklAADX0wYqNkI3LQo3NCMAAFzQLQoGNCMAAFzQJAIAPQAAXgIjAABc3R4CADsFDCo7Oj0kAgA9AABd8CMAAFz0HgIAOwUMKjw7PSQCAD0AAF0UIwAAXQstCEQ6IwAAXecMKj84PBYKPD0AKjhAPA4qODw/JAIAPwAAXTQlAADNEQwqPDQ4Eio9ODQkAgA0AABd1SMAAF1LCiI5UjgkAgA4AABdwyMAAF1dJAIAPgAAXbEjAABdah4CADwFACo5MD0OKjk9PiQCAD4AAF2GJQAAzREMKj08ORYKOTwcCjk9AhwKPDkCBCI9STwEIjlKPQAqPD05LQo5OCMAAF26LQhIOCMAAF26LQo4NCMAAF3MLQhHNCMAAF3MLQo0OyMAAF3eLQhGOyMAAF3eLQo7OiMAAF3nLQo6NyMAAF35LQhDNyMAAF35LQo3NiMAAF4LLQhFNiMAAF4LCiI2RzQkAgA0AABeHSUAANgJLQgBNCcCNgQDAAgBNgEnAzQEAQAiNAI2LQo2Ny0OLjcAIjcCNy0ONTcnAjcEOC0IADgtCjQ5LQhXOi0IUTsACAA3ACUAANLALQIAAC0KOTYKIjZTNAoiNFE3JAIANwAAXoQlAADUUicCNwQ4LQgAOC0KNjkACAA3ACUAANacLQIAAC0KOTQAIjRVNy0LNzYcCjY4BRwKODcAACI0VzgtCzg2ACo0DzktCzk4HAo4OgQcCjo5AAAiNFg6LQs6OBwKODsEHAo7OgAAIjRMOy0LOzgcCjg8ARwKPDsAACo0EDwtCzw4HAo4PQEcCj08AAAqNBE9LQs9OAAqNBI+LQs+PQAqNBM/LQs/PhwKPkACHApAPwAAIjRZQC0LQD4cCj5AAhwKQDQALwoAGQA+HAo+QQQcCkFAABwKQD4EHgIAQAUAKkA+QQ4qQEFCJAIAQgAAX3QlAADNES0IAT4nAkAEAwAIAUABJwM+BAEAIj4CQC0KQEItDi5CACJCAkItDjVCJwJABEItCABCLQo+Qy0IV0QtCFFFAAgAQAAlAADSwC0CAAAtCkM1CiI1Uz4KIj5RQCQCAEAAAF/bJQAA1FIcCkE+AC0IAUAnAkEEDAAIAUEBJwNABAEAIkACQS0KQUItDjdCACJCAkItDjZCACJCAkItDj5CACJCAkItDjlCACJCAkItDjpCACJCAkItDjtCACJCAkItDjxCACJCAkItDjhCACJCAkItDj1CACJCAkItDj9CACJCAkItDjRCJwI0BEEtCABBLQo1Qi0KQEMACAA0ACUAANZPLQIAAC0LAjQAIjQCNC0ONAIAIgICNi0LNjYtCjY1JwI3BAMAKgI3NDsOADUANCMAAGCoKQIANACwlLD8CioBNDUkAgA1AABgwyMAAGiOLQgBNScCNgQCAAgBNgEnAzUEAQAiNQI2HzAAVQBVADYtCAE2AAABAgEtDjU2LQgBNQAAAQIBLQxSNScCOAQ5LQgAOS0KNjotCjU7AAgAOAAlAADVQS0CAAAtCjo3ACI3VTYtCzY1HgIANgAeAgA3AB4CADgAHgIAOQAzKgA4ADkAOiQCADoAAGFSJQAA0ootCAE4JwI5BAMACAE5AScDOAQBACI4AjktCjk6LQ4uOgAiOgI6LQ41OicCOgQ7LQgAOy0KODwtCFc9LQhRPgAIADoAJQAA0sAtAgAALQo8OQoiOVM4CiI4UTokAgA6AABhuSUAANRSJwI6BDstCAA7LQo5PAAIADoAJQAA1pwtAgAALQo8OAAiOFA6LQs6ORwKOTsEHAo7OgAcCjo5BAAqOA87LQs7OhwKOjwEHAo8OwAcCjs6BAAiOFg9LQs9PBwKPD4EHAo+PQAcCj08BAAiOEw+LQs+PRwKPT8BHAo/PgAcCj49AQAqOBA/LQs/PhwKPj8BHAo/OAAcCjg+AS0IATgnAj8EAwAIAT8BJwM4BAEAIjgCPy0KP0AtDg5AACJAAkAtDjVAJwJABEEtCABBLQo4Qi0IV0MtCFFEAAgAQAAlAADSwC0CAAAtCkI/CiI/UzgKIjhRQCQCAEAAAGK3JQAA1FIvCgA/ADgcCjhABhwKQD8AHAo/OAYtCAE/JwJABAMACAFAAScDPwQBACI/AkAtCkBBLQ4xQQAiQQJBLQ41QScCQQRCLQgAQi0KP0MtCFdELQhRRQAIAEEAJQAA0sAtAgAALQpDQAoiQFM/CiI/UUEkAgBBAABjMyUAANRSLwoAQAA/HAo/QQYcCkFAABwKQD8GLQgBQCcCQQQDAAgBQQEnA0AEAQAiQAJBLQpBQi0OMkIAIkICQi0ONUInAkIEQy0IAEMtCkBELQhXRS0IUUYACABCACUAANLALQIAAC0KREEKIkFTQAoiQFFCJAIAQgAAY68lAADUUi8KAEEAQBwKQEIGHApCQQAcCkFABi0IAUEnAkIEAwAIAUIBJwNBBAEAIkECQi0KQkMtDjNDACJDAkMtDjtDJwJCBEMtCABDLQpBRC0IV0UtCFFGAAgAQgAlAADSwC0CAAAtCkQ7CiI7U0EKIkFRQiQCAEIAAGQrJQAA1FIvCgA7AEEcCkFCBhwKQjsAHAo7QQYvCgAVADscCjtDBhwKQ0IAHApCOwYvCgAXAEIcCkJEBhwKREMAHApDQgYKKkEGQwoqQgZEEipDREUkAgBFAABkwiMAAGSGBCpBOzYnAkMGAAoqQzs3JAIANwAAZLQGKjY7RQoqRUFEJAIARAAAZLQlAADX0wYqNkI3LQo3NCMAAGTLLQoGNCMAAGTLJAIAPQAAZf0jAABk2B4CADsFDCo7Oj0kAgA9AABl6yMAAGTvHgIAOwUMKjw7PSQCAD0AAGUPIwAAZQYtCEQ6IwAAZeIMKj84PBYKPD0AKjhAPA4qODw/JAIAPwAAZS8lAADNEQwqPDQ4Eio9ODQkAgA0AABl0CMAAGVGCiI5UjgkAgA4AABlviMAAGVYJAIAPgAAZawjAABlZR4CADwFACo5MD0OKjk9PiQCAD4AAGWBJQAAzREMKj08ORYKOTwcCjk9AhwKPDkCBCI9STwEIjlKPQAqPD05LQo5OCMAAGW1LQhIOCMAAGW1LQo4NCMAAGXHLQhHNCMAAGXHLQo0OyMAAGXZLQhGOyMAAGXZLQo7OiMAAGXiLQo6NyMAAGX0LQhDNyMAAGX0LQo3NiMAAGYGLQhFNiMAAGYGCiI2SjQkAgA0AABmGCUAANgbLQgBNCcCNgQDAAgBNgEnAzQEAQAiNAI2LQo2Ny0OLjcAIjcCNy0ONTcnAjcEOC0IADgtCjQ5LQhXOi0IUTsACAA3ACUAANLALQIAAC0KOTYKIjZTNAoiNFE3JAIANwAAZn8lAADUUicCNwQ4LQgAOC0KNjkACAA3ACUAANacLQIAAC0KOTQAIjRVNy0LNzYcCjY4BRwKODcAACI0VzgtCzg2ACI0UDktCzk4HAo4OgQcCjo5ABwKOTgEACo0DzstCzs6HAo6PAQcCjw7AAAiNFg8LQs8OhwKOj0EHAo9PAAAIjRMPS0LPTocCjo+ARwKPj0AACo0ET4tCz46ACo0Ej8tCz8+ACo0E0AtC0A/HAo/QQIcCkFAAAAiNFlBLQtBPxwKP0ECHApBNAAeAgA/BQwqPzhBCiJBUTgkAgA4AABnXyUAANgtLQgBOCcCPwQDAAgBPwEnAzgEAQAiOAI/LQo/QS0OLkEAIkECQS0ONUEnAj8EQS0IAEEtCjhCLQhXQy0IUUQACAA/ACUAANLALQIAAC0KQjUKIjVTOAoiOFE/JAIAPwAAZ8YlAADUUi0IATgnAj8EDAAIAT8BJwM4BAEAIjgCPy0KP0EtDjdBACJBAkEtDjZBACJBAkEtDjlBACJBAkEtDjtBACJBAkEtDjxBACJBAkEtDj1BACJBAkEtDFZBACJBAkEtDjpBACJBAkEtDj5BACJBAkEtDkBBACJBAkEtDjRBJwI0BDktCAA5LQo1Oi0KODsACAA0ACUAANZPLQIAAC0LAjQAIjQCNC0ONAIAIgICNi0LNjYtCjY1JwI3BAMAKgI3NDsOADUANCMAAGiOKQIANADwWJHhCioBNDUkAgA1AABoqSMAAGm3LQgBNCcCNQQCAAgBNQEnAzQEAQAiNAI1HzAAVQBVADUtCAE1AAABAgEtDjQ1LQgBNAAAAQIBLQxSNCcCNwQ4LQgAOC0KNTktCjQ6AAgANwAlAADVQS0CAAAtCjk2ACI2VTUtCzU0HAo0NgQcCjY1AB4CADQAHgIANgAeAgA3AB4CADgAMyoANwA4ADkkAgA5AABpQiUAANKKHgIANwEKIjdLOBYKODkcCjk6AAQqOjc5CiI4UTckAgA3AABpcCcCOgQAPAY6AQoqOTY3JAIANwAAaYIlAADYPzAKADUACy0LAjUAIjUCNS0ONQIAIgICNy0LNzctCjc2JwI4BAMAKgI4NTsOADYANSMAAGm3KQIANACL/7agCioBNDUkAgA1AABp0iMAAGrgLQgBNCcCNQQCAAgBNQEnAzQEAQAiNAI1HzAAVQBVADUtCAE1AAABAgEtDjQ1LQgBNAAAAQIBLQxSNCcCNwQ4LQgAOC0KNTktCjQ6AAgANwAlAADVQS0CAAAtCjk2ACI2VTUtCzU0HAo0NgQcCjY1AB4CADQAHgIANgAeAgA3AB4CADgAMyoANwA4ADkkAgA5AABqayUAANKKHgIANwEKIjdLOBYKODkcCjk6AAQqOjc5CiI4UTckAgA3AABqmScCOgQAPAY6AQoqOTY3JAIANwAAaqslAADYUTAKADUADC0LAjUAIjUCNS0ONQIAIgICNy0LNzctCjc2JwI4BAMAKgI4NTsOADYANSMAAGrgKQIANAABx+ZWCioBNDUkAgA1AABq+yMAAGwJLQgBNCcCNQQCAAgBNQEnAzQEAQAiNAI1HzAAVQBVADUtCAE1AAABAgEtDjQ1LQgBNAAAAQIBLQxSNCcCNwQ4LQgAOC0KNTktCjQ6AAgANwAlAADVQS0CAAAtCjk2ACI2VTUtCzU0HAo0NgYcCjY1AB4CADQAHgIANgAeAgA3AB4CADgAMyoANwA4ADkkAgA5AABrlCUAANKKHgIANwEKIjdLOBYKODkcCjk6AAQqOjc5CiI4UTckAgA3AABrwicCOgQAPAY6AQoqOTY3JAIANwAAa9QlAADYYzAKADUAFi0LAjUAIjUCNS0ONQIAIgICNy0LNzctCjc2JwI4BAMAKgI4NTsOADYANSMAAGwJKQIANAC3ZMvdCioBNDUkAgA1AABsJCMAAG1jLQgBNCcCNQQCAAgBNQEnAzQEAQAiNAI1HzAAVQBVADUtCAE1AAABAgEtDjQ1LQgBNAAAAQIBLQxSNCcCNwQ4LQgAOC0KNTktCjQ6AAgANwAlAADVQS0CAAAtCjk2ACI2VTUtCzU0HAo0NgYcCjY1ABwKNTQGHgIANgAeAgA3AB4CADgAHgIAOQAzKgA4ADkAOiQCADoAAGzCJQAA0ooeAgA4AQoiOEs5Fgo5OhwKOjsABCo7ODoKIjlROCQCADgAAGzwJwI7BAA8BjsBCio6NzgkAgA4AABtAiUAANh1LwoAFwA3HAo3OQYcCjk4ABwKODcGDCo3NDgKIjhRNCQCADQAAG0uJQAA2IcwCgA1ABUtCwI0ACI0AjQtDjQCACICAjctCzc3LQo3NScCOAQDACoCODQ7DgA1ADQjAABtYykCADQAOc9kfgoqATQ1JAIANQAAbX4jAABujC0IATQnAjUEAgAIATUBJwM0BAEAIjQCNR8wAFUAVQA1LQgBNQAAAQIBLQ40NS0IATQAAAECAS0MUjQnAjcEOC0IADgtCjU5LQo0OgAIADcAJQAA1UEtAgAALQo5NgAiNlU1LQs1NBwKNDYEHAo2NQAeAgA0AB4CADYAHgIANwAeAgA4ADMqADcAOAA5JAIAOQAAbhclAADSih4CADcBCiI3SzgWCjg5HAo5OgAEKjo3OQoiOFE3JAIANwAAbkUnAjoEADwGOgEKKjk2NyQCADcAAG5XJQAA2JkwCgA1ABgtCwI1ACI1AjUtDjUCACICAjctCzc3LQo3NicCOAQDACoCODU7DgA2ADUjAABujCkCADQA5U2BJgoqATQ1JAIANQAAbqcjAABvqy0IATQnAjUEAgAIATUBJwM0BAEAIjQCNR8wAFUAVQA1LQgBNQAAAQIBLQ40NS0IATQAAAECAS0MUjQnAjcEOC0IADgtCjU5LQo0OgAIADcAJQAA1UEtAgAALQo5NgAiNlU1LQs1NB4CADUAHgIANgAeAgA3AB4CADgAMyoANwA4ADkkAgA5AABvNiUAANKKHgIANwEKIjdLOBYKODkcCjk6AAQqOjc5CiI4UTckAgA3AABvZCcCOgQAPAY6AQoqOTY3JAIANwAAb3YlAADYqzAKADQAGi0LAjQAIjQCNC0ONAIAIgICNy0LNzctCjc2JwI4BAMAKgI4NDsOADYANCMAAG+rKQIANADD6WB2CioBNDUkAgA1AABvxiMAAHDULQgBNCcCNQQCAAgBNQEnAzQEAQAiNAI1HzAAVQBVADUtCAE1AAABAgEtDjQ1LQgBNAAAAQIBLQxSNCcCNwQ4LQgAOC0KNTktCjQ6AAgANwAlAADVQS0CAAAtCjk2ACI2VTUtCzU0HAo0NgQcCjY1AB4CADQAHgIANgAeAgA3AB4CADgAMyoANwA4ADkkAgA5AABwXyUAANKKHgIANwEKIjdLOBYKODkcCjk6AAQqOjc5CiI4UTckAgA3AABwjScCOgQAPAY6AQoqOTY3JAIANwAAcJ8lAADYvTAKADUAGS0LAjUAIjUCNS0ONQIAIgICNy0LNzctCjc2JwI4BAMAKgI4NTsOADYANSMAAHDUKQIANAAioF3KCioBNDUkAgA1AABw7yMAAHH9HgIANAAeAgA1AB4CADYAHgIANwAzKgA2ADcAOCQCADgAAHEYJQAA0ooeAgA2CSQCADYAAHEqJQAA2M8tCAE2JwI3BAMACAE3AScDNgQBACI2AjctCjc4LQ4VOAAiOAI4LQxWOCcCOAQ5LQgAOS0KNjotCFc7LQhRPAAIADgAJQAAzyMtAgAALQo6Nx4CADYAMyoANwA2ADgkAgA4AABxlCUAANYZLwgAVgA2JwI4BAEnAjoEAwAqODo5LQgBNwAIATkBJwM3BAEAIjcCOS0OODkAIjkCOS0OODknAjkEAwAqNzk4LQo4OS0ONjkAIjcCOS0LOTktCjk4JwI6BAMAKjc6NjsOADgANiMAAHH9KQIANAADA4pKCioBNDUkAgA1AAByGCMAAHLGHgIANAAeAgA1AB4CADYAHgIANwAzKgA2ADcAOCQCADgAAHJBJQAA0ooeAgA2CSQCADYAAHJTJQAA2OEvCgANADYcCjY3BRwKNw0AJwI3BAEnAjkEAwAqNzk4LQgBNgAIATgBJwM2BAEAIjYCOC0ONzgAIjgCOC0ONzgnAjgEAwAqNjg3LQo3OC0ODTgAIjYCOC0LODgtCjg3JwI5BAMAKjY5DTsOADcADSMAAHLGKQIADQBqAfbVCioBDTQkAgA0AABy4SMAAHV4LQgBDScCNAQCAAgBNAEnAw0EAQAiDQI0HzAAVQBVADQtCAE0AAABAgEtDg00LQgBDQAAAQIBLQxSDScCNgQ3LQgANy0KNDgtCg05AAgANgAlAADVQS0CAAAtCjg1ACI1VTQtCzQNHgIANAAeAgA1AB4CADYAHgIANwAzKgA2ADcAOCQCADgAAHNwJQAA0ooeAgA2CSQCADYAAHOCJQAA2PMtCAE2JwI3BAMACAE3AScDNgQBACI2AjctCjc4LQ4uOAAiOAI4LQ4NOCcCNwQ4LQgAOC0KNjktCFc6LQhROwAIADcAJQAA0sAtAgAALQo5DQoiDVM2CiI2UTckAgA3AABz6SUAANRSJwI3BDgtCAA4LQoNOQAIADcAJQAA1pwtAgAALQo5NgAiNlU3LQs3DRwKDTgFHAo4NwAAIjZXOC0LOA0AIjZQOS0LOTgcCjg6BBwKOjkAACo2DzotCzo4HAo4OwQcCjs6AAAiNlg7LQs7OBwKODwEHAo8OwAAIjZMPC0LPDgcCjg9ARwKPTwAACo2ED0tCz04HAo4PgEcCj49AAAqNhE+LQs+OAAqNhI/LQs/PgAqNhNALQtAPxwKP0ECHApBQAAAIjZZQS0LQT8cCj9BAhwKQTYAJwJBBAsnAkMEAwAqQUNCLQgBPwAIAUIBJwM/BAEAIj8CQi0OQUIAIkICQi0OQUInAkIEAwAqP0JBLQpBQi0ON0IAIkICQi0ODUIAIkICQi0OOUIAIkICQi0OOkIAIkICQi0OO0IAIkICQi0OPEIAIkICQi0OPUIAIkICQi0OOEIAIkICQi0OPkIAIkICQi0OQEIAIkICQi0ONkIAIj8CNy0LNzctCjc2JwI4BAMAKj84DTsOADYADSMAAHV4KQIADQAT9sglCioBDTQkAgA0AAB1kyMAAHtQLQgBNCcCNQQCAAgBNQEnAzQEAQAiNAI1HzAAVQBVADUtCAE1AAABAgEtDjQ1LQgBNAAAAQIBLQxSNCcCNwQ4LQgAOC0KNTktCjQ6AAgANwAlAADVQS0CAAAtCjk2ACI2VTUtCzU0HgIANQAeAgA2AB4CADcAHgIAOAAzKgA3ADgAOSQCADkAAHYiJQAA0ooeAgA3CSQCADcAAHY0JQAA2QUtCAE3JwI4BAMACAE4AScDNwQBACI3AjgtCjg5LQ4uOQAiOQI5LQ40OScCOQQ6LQgAOi0KNzstCFc8LQhRPQAIADkAJQAA0sAtAgAALQo7OAoiOFM3CiI3UTkkAgA5AAB2myUAANRSJwI5BDotCAA6LQo4OwAIADkAJQAA1pwtAgAALQo7NwAiN1A5LQs5OBwKODoEHAo6OQAcCjk4BAAqNw86LQs6ORwKOTsEHAo7OgAcCjo5BAAiN1g8LQs8OxwKOz0EHAo9PAAcCjw7BAAiN0w9LQs9PBwKPD4BHAo+PQAcCj08AQAqNxA+LQs+PRwKPT4BHAo+NwAcCjc9AS0IATcnAj4EAwAIAT4BJwM3BAEAIjcCPi0KPj8tDg4/ACI/Aj8tDjQ/JwI/BEAtCABALQo3QS0IV0ItCFFDAAgAPwAlAADSwC0CAAAtCkE+CiI+UzcKIjdRPyQCAD8AAHeZJQAA1FIvCgA+ADccCjc/BhwKPz4AHAo+NwYtCAE+JwI/BAMACAE/AScDPgQBACI+Aj8tCj9ALQ4xQAAiQAJALQ40QCcCQARBLQgAQS0KPkItCFdDLQhRRAAIAEAAJQAA0sAtAgAALQpCPwoiP1M+CiI+UUAkAgBAAAB4FSUAANRSLwoAPwA+HAo+QAYcCkA/ABwKPz4GLQgBPycCQAQDAAgBQAEnAz8EAQAiPwJALQpAQS0OMkEAIkECQS0ONEEnAkAEQS0IAEEtCj9CLQhXQy0IUUQACABAACUAANLALQIAAC0KQjQKIjRTPwoiP1FAJAIAQAAAeJElAADUUi8KADQAPxwKP0AGHApANAAcCjQ/Bi0IATQnAkAEAwAIAUABJwM0BAEAIjQCQC0KQEEtDjNBACJBAkEtDjpBJwJABEEtCABBLQo0Qi0IV0MtCFFEAAgAQAAlAADSwC0CAAAtCkI6CiI6UzQKIjRRQCQCAEAAAHkNJQAA1FIvCgA6ADQcCjRABhwKQDoAHAo6NAYvCgAVADocCjpBBhwKQUAAHApAOgYvCgAXAEAcCkBCBhwKQkEAHApBQAYKKjQGQQoqQAZCEipBQkMkAgBDAAB5pCMAAHloBCo0OjUnAkEGAAoqQTo2JAIANgAAeZYGKjU6QwoqQzRCJAIAQgAAeZYlAADX0wYqNUA0LQo0DSMAAHmtLQoGDSMAAHmtJAIAPAAAet8jAAB5uh4CADYFDCo2OTokAgA6AAB6zSMAAHnRHgIAOQUMKjs5OiQCADoAAHnxIwAAeegtCEQ2IwAAesQMKj43OhYKOjsAKjc/Og4qNzo8JAIAPAAAehElAADNEQwqOg03Eio7Nw0kAgANAAB6siMAAHooCiI4UjckAgA3AAB6oCMAAHo6JAIAPQAAeo4jAAB6Rx4CADoFACo4MDsOKjg7PCQCADwAAHpjJQAAzREMKjs6MBYKMDgcCjA6AhwKODACBCI6STgEIjBKOgAqODowLQowNyMAAHqXLQhINyMAAHqXLQo3DSMAAHqpLQhHDSMAAHqpLQoNOSMAAHq7LQhGOSMAAHq7LQo5NiMAAHrELQo2NSMAAHrWLQhDNSMAAHrWLQo1NCMAAHroLQhFNCMAAHroHAo0DQAnAjQEAScCNgQDACo0NjUtCAEwAAgBNQEnAzAEAQAiMAI1LQ40NQAiNQI1LQ40NScCNQQDACowNTQtCjQ1LQ4NNQAiMAI1LQs1NS0KNTQnAjYEAwAqMDYNOw4ANAANIwAAe1ApAgANAKelfJgKKgENMCQCADAAAHtrIwAAfeYtCAENJwIwBAIACAEwAScDDQQBACINAjAfMABVAFUAMC0IATAAAAECAS0ODTAtCAENAAABAgEtDFINJwI1BDYtCAA2LQowNy0KDTgACAA1ACUAANVBLQIAAC0KNzQAIjRVMC0LMA0eAgAwAB4CADQAHgIANQAeAgA2ADMqADUANgA3JAIANwAAe/olAADSih4CADUJJAIANQAAfAwlAADZFy0IATUnAjYEAwAIATYBJwM1BAEAIjUCNi0KNjctDg43ACI3AjctDg03JwI2BDctCAA3LQo1OC0IVzktCFE6AAgANgAlAADSwC0CAAAtCjgOCiIOUzUKIjVRNiQCADYAAHxzJQAA1FIvCgAOADUcCjU2BhwKNg4ALQgBNScCNgQDAAgBNgEnAzUEAQAiNQI2LQo2Ny0OMTcAIjcCNy0ODTcnAjYENy0IADctCjU4LQhXOS0IUToACAA2ACUAANLALQIAAC0KODEKIjFTNQoiNVE2JAIANgAAfOolAADUUi8KADEANRwKNTYGHAo2MQAtCAE1JwI2BAMACAE2AScDNQQBACI1AjYtCjY3LQ4yNwAiNwI3LQ4NNycCMgQ2LQgANi0KNTctCFc4LQhROQAIADIAJQAA0sAtAgAALQo3DQoiDVMyCiIyUTUkAgA1AAB9YSUAANRSLwoADQAyHAoyNQYcCjUNACcCNQQDJwI3BAMAKjU3Ni0IATIACAE2AScDMgQBACIyAjYtDjU2ACI2AjYtDjU2JwI2BAMAKjI2NS0KNTYtDg42ACI2AjYtDjE2ACI2AjYtDg02ACIyAjEtCzExLQoxDicCNQQDACoyNQ07DgAOAA0jAAB95ikCAA0AqfxLzQoqAQ0OJAIADgAAfgEjAAB/ni0IAQ0nAg4EAgAIAQ4BJwMNBAEAIg0CDh8wAFUAVQAOLQgBDgAAAQIBLQ4NDi0IAQ0AAAECAS0MUg0nAjEENC0IADQtCg41LQoNNgAIADEAJQAA1UEtAgAALQo1MAAiMFUOLQsODR4CAA4AHgIAMAAeAgAxAB4CADIAMyoAMQAyADQkAgA0AAB+kCUAANKKHgIAMQkkAgAxAAB+oiUAANkpLQgBMScCMgQDAAgBMgEnAzEEAQAiMQIyLQoyNC0OLjQAIjQCNC0ODTQnAjIENC0IADQtCjE1LQhXNi0IUTcACAAyACUAANLALQIAAC0KNQ0KIg1TMQoiMVEyJAIAMgAAfwklAADUUicCMgQ0LQgANC0KDTUACAAyACUAANacLQIAAC0KNTEAKjEPMi0LMg0cCg0yBBwKMjEAJwIyBAEnAjUEAwAqMjU0LQgBDQAIATQBJwMNBAEAIg0CNC0OMjQAIjQCNC0OMjQnAjQEAwAqDTQyLQoyNC0OMTQAIg0CNC0LNDQtCjQyJwI1BAMAKg01MTsOADIAMSMAAH+eKQIADQAIS6F5CioBDQ4kAgAOAAB/uSMAAIFWLQgBDScCDgQCAAgBDgEnAw0EAQAiDQIOHzAAVQBVAA4tCAEOAAABAgEtDg0OLQgBDQAAAQIBLQxSDScCMQQ0LQgANC0KDjUtCg02AAgAMQAlAADVQS0CAAAtCjUwACIwVQ4tCw4NHgIADgAeAgAwAB4CADEAHgIAMgAzKgAxADIANCQCADQAAIBIJQAA0ooeAgAxCSQCADEAAIBaJQAA2TstCAExJwIyBAMACAEyAScDMQQBACIxAjItCjI0LQ4uNAAiNAI0LQ4NNCcCMgQ0LQgANC0KMTUtCFc2LQhRNwAIADIAJQAA0sAtAgAALQo1DQoiDVMxCiIxUTIkAgAyAACAwSUAANRSJwIyBDQtCAA0LQoNNQAIADIAJQAA1pwtAgAALQo1MQAiMVgyLQsyDRwKDTIEHAoyMQAnAjIEAScCNQQDACoyNTQtCAENAAgBNAEnAw0EAQAiDQI0LQ4yNAAiNAI0LQ4yNCcCNAQDACoNNDItCjI0LQ4xNAAiDQI0LQs0NC0KNDInAjUEAwAqDTUxOw4AMgAxIwAAgVYpAgANAJGuQ1MKKgENDiQCAA4AAIFxIwAAgw4tCAENJwIOBAIACAEOAScDDQQBACINAg4fMABVAFUADi0IAQ4AAAECAS0ODQ4tCAENAAABAgEtDFINJwIxBDQtCAA0LQoONS0KDTYACAAxACUAANVBLQIAAC0KNTAAIjBVDi0LDg0eAgAOAB4CADAAHgIAMQAeAgAyADMqADEAMgA0JAIANAAAggAlAADSih4CADEJJAIAMQAAghIlAADZTS0IATEnAjIEAwAIATIBJwMxBAEAIjECMi0KMjQtDi40ACI0AjQtDg00JwIyBDQtCAA0LQoxNS0IVzYtCFE3AAgAMgAlAADSwC0CAAAtCjUNCiINUzEKIjFRMiQCADIAAIJ5JQAA1FInAjIENC0IADQtCg01AAgAMgAlAADWnC0CAAAtCjUxACIxUDItCzINHAoNMgQcCjIxACcCMgQBJwI1BAMAKjI1NC0IAQ0ACAE0AScDDQQBACINAjQtDjI0ACI0AjQtDjI0JwI0BAMAKg00Mi0KMjQtDjE0ACINAjQtCzQ0LQo0MicCNQQDACoNNTE7DgAyADEjAACDDikCAA0AvRJjrwoqAQ0OJAIADgAAgykjAACEvC0IAQ0nAg4EAgAIAQ4BJwMNBAEAIg0CDh8wAFUAVQAOLQgBDgAAAQIBLQ4NDi0IAQ0AAAECAS0MUg0nAjEENC0IADQtCg41LQoNNgAIADEAJQAA1UEtAgAALQo1MAAiMFUOLQsODR4CAA4AHgIAMAAeAgAxAB4CADIAMyoAMQAyADQkAgA0AACDuCUAANKKHgIAMQkkAgAxAACDyiUAANlfLQgBMScCMgQDAAgBMgEnAzEEAQAiMQIyLQoyNC0OLjQAIjQCNC0ODTQnAjIENC0IADQtCjE1LQhXNi0IUTcACAAyACUAANLALQIAAC0KNQ0KIg1TMQoiMVEyJAIAMgAAhDElAADUUicCMgQ0LQgANC0KDTUACAAyACUAANacLQIAAC0KNTEAIjFXMi0LMg0nAjIEAScCNQQDACoyNTQtCAExAAgBNAEnAzEEAQAiMQI0LQ4yNAAiNAI0LQ4yNCcCNAQDACoxNDItCjI0LQ4NNAAiMQI0LQs0NC0KNDInAjUEAwAqMTUNOw4AMgANIwAAhLwpAgANAM73DZMKKgENDiQCAA4AAITXIwAAhu8tCAENJwIOBAIACAEOAScDDQQBACINAg4fMABVAFUADi0IAQ4AAAECAS0ODQ4tCAENAAABAgEtDFINJwIxBDQtCAA0LQoONS0KDTYACAAxACUAANVBLQIAAC0KNTAAIjBVDi0LDg0eAgAOAB4CADAAHgIAMQAeAgAyADMqADEAMgA0JAIANAAAhWYlAADSih4CADEJJAIAMQAAhXglAADZcS0IATEnAjIEAwAIATIBJwMxBAEAIjECMi0KMjQtDgU0ACI0AjQtDg00JwI0BDUtCAA1LQoxNi0IVzctCFE4AAgANAAlAADSwC0CAAAtCjYyCiIyUzEKIjFRNCQCADQAAIXfJQAA1FIvCgAyADEcCjE0BhwKNDIAHAoyMQYtCAEyJwI0BAMACAE0AScDMgQBACIyAjQtCjQ1LQ4DNQAiNQI1LQ4NNScCNAQ1LQgANS0KMjYtCFc3LQhROAAIADQAJQAA0sAtAgAALQo2DQoiDVMyCiIyUTQkAgA0AACGWyUAANRSLwoADQAyHAoyNAYcCjQNABwKDTIGACoxMg0OKjENNCQCADQAAIaHJQAAzREcCg0xACcCMgQBJwI1BAMAKjI1NC0IAQ0ACAE0AScDDQQBACINAjQtDjI0ACI0AjQtDjI0JwI0BAMAKg00Mi0KMjQtDjE0ACINAjQtCzQ0LQo0MicCNQQDACoNNTE7DgAyADEjAACG7ykCAA0AU0SmeQoqAQ0OJAIADgAAhwojAACKXy0IAQ4nAjAEAwAIATABJwMOBAEAIg4CMB8wAFcAVQAwLQgBMAAAAQIBLQ4OMC0IAQ4AAAECAS0MUg4nAjIENC0IADQtCjA1LQoONgAIADIAJQAA0hktAgAALQo1MQAiMVU0LQs0MicCNAQ1LQgANS0KMDYtCg43AAgANAAlAADSGS0CAAAtCjYxACIxVTAtCzAOHAoOMQQcCjEwAB4CAA4AHgIAMQAeAgA0AB4CADUAMyoANAA1ADYkAgA2AACHzyUAANKKHgIANAkkAgA0AACH4SUAANmDLQgBNCcCNQQDAAgBNQEnAzQEAQAiNAI1LQo1Ni0OLzYAIjYCNi0OMjYnAjUENi0IADYtCjQ3LQhXOC0IUTkACAA1ACUAANLALQIAAC0KNy8KIi9TNAoiNFE1JAIANQAAiEglAADUUi0IATQnAjUEAwAIATUBJwM0BAEAIjQCNS0KNTYtDi82ACI2AjYtDjA2JwIwBDUtCAA1LQo0Ni0IVzctCFE4AAgAMAAlAADSwC0CAAAtCjYvCiIvUzAKIjBRNCQCADQAAIivJQAA1FIvCgAvADAcCjA0BhwKNC8AHAovMAYMKgYwLyQCAC8AAInuIwAAiNYtCAEOJwIvBAMACAEvAScDDgQBACIOAi8tCi8wLQ4FMAAiMAIwLQ4yMCcCLwQ0LQgANC0KDjUtCFc2LQhRNwAIAC8AJQAA0sAtAgAALQo1BQoiBVMOCiIOUS8kAgAvAACJPSUAANRSLwoABQAOHAoOLwYcCi8FABwKBQ4GLQgBBScCLwQDAAgBLwEnAwUEAQAiBQIvLQovMC0OAzAAIjACMC0OMjAnAi8ENC0IADQtCgU1LQhXNi0IUTcACAAvACUAANLALQIAAC0KNQMKIgNTBQoiBVEvJAIALwAAibklAADUUi8KAAMABRwKBS8GHAovAwAcCgMFBgAqDgUDDioOAy8kAgAvAACJ5SUAAM0RLQoDDSMAAIn3LQowDSMAAIn3HAoNAwAnAg0EAScCLwQDACoNLw4tCAEFAAgBDgEnAwUEAQAiBQIOLQ4NDgAiDgIOLQ4NDicCDgQDACoFDg0tCg0OLQ4DDgAiBQIOLQsODi0KDg0nAi8EAwAqBS8DOw4ADQADIwAAil8pAgADAOaq/mMKKgEDBSQCAAUAAIp6IwAAi+stCAEDJwIFBAIACAEFAScDAwQBACIDAgUfMABVAFUABS0IAQUAAAECAS0OAwUtCAEDAAABAgEtDFIDJwIOBDQtCAA0LQoFNS0KAzYACAAOACUAANVBLQIAAC0KNQ0AIg1VBS0LBQMeAgAFAB4CAA0AHgIADgAeAgAvADMqAA4ALwAwJAIAMAAAiwklAADSih4CAA4JJAIADgAAixslAADZlS0IAQ4nAi8EAwAIAS8BJwMOBAEAIg4CLy0KLzAtDggwACIwAjAtDgMwJwIIBDQtCAA0LQoONS0IVzYtCFE3AAgACAAlAADSwC0CAAAtCjUDCiIDUwgKIghRDiQCAA4AAIuCJQAA1FIvCgADAAgnAg4EAScCMAQDACoOMC8tCAEDAAgBLwEnAwMEAQAiAwIvLQ4OLwAiLwIvLQ4OLycCLwQDACoDLw4tCg4vLQ4ILwAiAwIvLQsvLy0KLw4nAjAEAwAqAzAIOw4ADgAIIwAAi+spAgADAHfzXXsKKgEDBSQCAAUAAIwGIwAAjLQeAgADAB4CAAUAHgIACAAeAgANADMqAAgADQAOJAIADgAAjC8lAADSih4CAAgJJAIACAAAjEElAADZpy8KAAsACBwKCA0EHAoNCwAnAg0EAScCLwQDACoNLw4tCAEIAAgBDgEnAwgEAQAiCAIOLQ4NDgAiDgIOLQ4NDicCDgQDACoIDg0tCg0OLQ4LDgAiCAIOLQsODi0KDg0nAi8EAwAqCC8LOw4ADQALIwAAjLQpAgADAN6twy8KKgEDBSQCAAUAAIzPIwAAjX0eAgADAB4CAAUAHgIACAAeAgALADMqAAgACwANJAIADQAAjPglAADSih4CAAgJJAIACAAAjQolAADZuS8KAAwACBwKCAwEHAoMCwAnAgwEAScCDgQDACoMDg0tCAEIAAgBDQEnAwgEAQAiCAINLQ4MDQAiDQINLQ4MDScCDQQDACoIDQwtCgwNLQ4LDQAiCAINLQsNDS0KDQwnAg4EAwAqCA4LOw4ADAALIwAAjX0pAgADAETVSaYKKgEDBSQCAAUAAI2YIwAAjkYeAgADAB4CAAUAHgIACAAeAgALADMqAAgACwAMJAIADAAAjcElAADSih4CAAgJJAIACAAAjdMlAADZyy8KABYACBwKCAwGHAoMCwAnAgwEAScCDgQDACoMDg0tCAEIAAgBDQEnAwgEAQAiCAINLQ4MDQAiDQINLQ4MDScCDQQDACoIDQwtCgwNLQ4LDQAiCAINLQsNDS0KDQwnAg4EAwAqCA4LOw4ADAALIwAAjkYpAgADAIsfsk4KKgEDBSQCAAUAAI5hIwAAjw8eAgADAB4CAAUAHgIACAAeAgALADMqAAgACwAMJAIADAAAjoolAADSih4CAAgJJAIACAAAjpwlAADZ3S8KABUACBwKCAwGHAoMCwAnAgwEAScCDgQDACoMDg0tCAEIAAgBDQEnAwgEAQAiCAINLQ4MDQAiDQINLQ4MDScCDQQDACoIDQwtCgwNLQ4LDQAiCAINLQsNDS0KDQwnAg4EAwAqCA4LOw4ADAALIwAAjw8pAgADACo6qxAKKgEDBSQCAAUAAI8qIwAAj9geAgADAB4CAAUAHgIACAAeAgALADMqAAgACwAMJAIADAAAj1MlAADSih4CAAgJJAIACAAAj2UlAADZ7y8KABcACBwKCAwGHAoMCwAnAgwEAScCDgQDACoMDg0tCAEIAAgBDQEnAwgEAQAiCAINLQ4MDQAiDQINLQ4MDScCDQQDACoIDQwtCgwNLQ4LDQAiCAINLQsNDS0KDQwnAg4EAwAqCA4LOw4ADAALIwAAj9gpAgADAHE+rzkKKgEDBSQCAAUAAI/zIwAAkg0tCAEFJwIIBAIACAEIAScDBQQBACIFAggfMABVAFUACC0IAQgAAAECAS0OBQgtCAEFAAABAgEtDFIFJwIMBDQtCAA0LQoINS0KBTYACAAMACUAANVBLQIAAC0KNQsAIgtVCC0LCAUcCgULBBwKCwgAHgIABQAeAgALAB4CAAwAHgIADQAzKgAMAA0ADiQCAA4AAJCMJQAA0ooeAgAMCSQCAAwAAJCeJQAA2gEtCAEMJwINBAMACAENAScDDAQBACIMAg0tCg0OLQ4zDgAiDgIOLQ4IDicCDQQvLQgALy0KDDAtCFcxLQhRMgAIAA0AJQAA0sAtAgAALQowCAoiCFMMCiIMUQ0kAgANAACRBSUAANRSLwoACAAMHAoMDQYcCg0IABwKCAwGLwoAFQAIHAoIDgYcCg4NABwKDQgGLwoAFwANHAoNFgYcChYOABwKDg0GCioMBg4KKg0GFhIqDhYXJAIAFwAAkZwjAACRYAQqDAgFJwILBgAKKgsIBiQCAAYAAJGOBioFCBYKKhYMDiQCAA4AAJGOJQAA19MGKgUNBi0KBgMjAACRpS0KBgMjAACRpRwKAwUAJwIGBAEnAgsEAwAqBgsILQgBAwAIAQgBJwMDBAEAIgMCCC0OBggAIggCCC0OBggnAggEAwAqAwgGLQoGCC0OBQgAIgMCCC0LCAgtCggGJwILBAMAKgMLBTsOAAYABSMAAJINKQIAAwBQuZxSCioBAwUkAgAFAACSKCMAAJLWHgIAAwAeAgAFAB4CAAYAHgIACAAzKgAGAAgACyQCAAsAAJJRJQAA0ooeAgAGCSQCAAYAAJJjJQAA2hMvCgAYAAYcCgYLBBwKCwgAJwILBAEnAg0EAwAqCw0MLQgBBgAIAQwBJwMGBAEAIgYCDC0OCwwAIgwCDC0OCwwnAgwEAwAqBgwLLQoLDC0OCAwAIgYCDC0LDAwtCgwLJwINBAMAKgYNCDsOAAsACCMAAJLWKQIAAwBBV2EzCioBAwUkAgAFAACS8SMAAJOfHgIAAwAeAgAFAB4CAAYAHgIACAAzKgAGAAgACyQCAAsAAJMaJQAA0ooeAgAGCSQCAAYAAJMsJQAA2iUvCgAZAAYcCgYLBBwKCwgAJwILBAEnAg0EAwAqCw0MLQgBBgAIAQwBJwMGBAEAIgYCDC0OCwwAIgwCDC0OCwwnAgwEAwAqBgwLLQoLDC0OCAwAIgYCDC0LDAwtCgwLJwINBAMAKgYNCDsOAAsACCMAAJOfKQIAAwCWY8woCioBAwUkAgAFAACTuiMAAJReHgIAAwAeAgAFAB4CAAYAHgIACAAzKgAGAAgACyQCAAsAAJPjJQAA0ooeAgAGCSQCAAYAAJP1JQAA2jcvCgAaAAYnAgsEAScCDQQDACoLDQwtCAEIAAgBDAEnAwgEAQAiCAIMLQ4LDAAiDAIMLQ4LDCcCDAQDACoIDAstCgsMLQ4GDAAiCAIMLQsMDC0KDAsnAg0EAwAqCA0GOw4ACwAGIwAAlF4pAgADALPpx1sKKgEDBSQCAAUAAJR5IwAAlYceAgADAB4CAAUAHgIABgAeAgAIADMqAAYACAALJAIACwAAlKIlAADSih4CAAYJJAIABgAAlLQlAADaSS0IAQYnAggEAwAIAQgBJwMGBAEAIgYCCC0KCAstDhULACILAgstDhsLJwILBC8tCAAvLQoGMC0IVzEtCFEyAAgACwAlAADPIy0CAAAtCjAIHgIABgAzKgAIAAYACyQCAAsAAJUeJQAA1hkvCgAbAAYnAgsEAScCDQQDACoLDQwtCAEIAAgBDAEnAwgEAQAiCAIMLQ4LDAAiDAIMLQ4LDCcCDAQDACoIDAstCgsMLQ4GDAAiCAIMLQsMDC0KDAsnAg0EAwAqCA0GOw4ACwAGIwAAlYcpAgADAOJRqPMKKgEDBSQCAAUAAJWiIwAAllAeAgADAB4CAAUAHgIABgAeAgAIADMqAAYACAALJAIACwAAlcslAADSih4CAAYJJAIABgAAld0lAADaWy8KAAQABhwKBggCHAoIBAAnAggEAScCDAQDACoIDAstCAEGAAgBCwEnAwYEAQAiBgILLQ4ICwAiCwILLQ4ICycCCwQDACoGCwgtCggLLQ4ECwAiBgILLQsLCy0KCwgnAgwEAwAqBgwEOw4ACAAEIwAAllApAgADACK0MAEKKgEDBCQCAAQAAJZrIwAAlw8eAgADAB4CAAQAHgIABQAeAgAGADMqAAUABgAIJAIACAAAlpQlAADSih4CAAUJJAIABQAAlqYlAADabS8KABwABScCCAQBJwIMBAMAKggMCy0IAQYACAELAScDBgQBACIGAgstDggLACILAgstDggLJwILBAMAKgYLCC0KCAstDgULACIGAgstCwsLLQoLCCcCDAQDACoGDAU7DgAIAAUjAACXDykCAAMAOUUtgAoqAQMEJAIABAAAlyojAACX5x4CAAMAHgIABAAeAgAFAB4CAAYAMyoABQAGAAgkAgAIAACXUyUAANKKHgIABQkkAgAFAACXZSUAANp/LwoAHQAFLwoACQAGHAoGCQYcCgkIACcCCQQCJwIMBAMAKgkMCy0IAQYACAELAScDBgQBACIGAgstDgkLACILAgstDgkLJwILBAMAKgYLCS0KCQstDgULACILAgstDggLACIGAgktCwkJLQoJCCcCCwQDACoGCwU7DgAIAAUjAACX5ykCAAMAn1Ze4AoqAQMEJAIABAAAmAIjAACYsB4CAAMAHgIABAAeAgAFAB4CAAYAMyoABQAGAAgkAgAIAACYKyUAANKKHgIABQkkAgAFAACYPSUAANqRLwoABwAFHAoFBwYcCgcGACcCBwQBJwIJBAMAKgcJCC0IAQUACAEIAScDBQQBACIFAggtDgcIACIIAggtDgcIJwIIBAMAKgUIBy0KBwgtDgYIACIFAggtCwgILQoIBycCCQQDACoFCQY7DgAHAAYjAACYsCkCAAMAhgGSsQoqAQMEJAIABAAAmMsjAACdRy0IAQQnAgUEAwAIAQUBJwMEBAEAIgQCBR8wAFcAVQAFLQgBBQAAAQIBLQ4EBS0IAQQAAAECAS0MUgQnAgcELy0IAC8tCgUwLQoEMQAIAAcAJQAA0hktAgAALQowBgAiBlUILQsIBycCCAQvLQgALy0KBTAtCgQxAAgACAAlAADSGS0CAAAtCjAGACIGVQUtCwUEHgIABQAeAgAGAB4CAAgAHgIACQAzKgAIAAkACyQCAAsAAJmGJQAA0ooeAgAICSQCAAgAAJmYJQAA2qMtCAEIJwIJBAMACAEJAScDCAQBACIIAgktCgkLLQ4HCwAiCwILLQ4ECy0IAQQnAgcEBwAIAQcBJwMEBAEAIgQCBy0KBwktDFMJACIJAgktDFMJACIJAgktDFMJACIJAgktDFMJACIJAgktDFMJACIJAgktDFMJLQgBBwAAAQIBLQ4EBy0IAQQnAgkECgAIAQkBJwMEBAEAIgQCCS0KCQstDFMLACILAgstDFMLACILAgstDFQLACILAgstDFMLACILAgstDFMLACILAgstDFQLACILAgstDFMLACILAgstDFMLACILAgstDFQLLQgBCQAAAQIBLQ4ECSwCAAQACD55Edg1CXYp8AZ1MfwVyv15qJvuyzmQP2lXLGNvSlosAgALABp/XvqtfzFcJakY8wzI1zM/zKt618kPFN6BvMUo+ZNdLAIADAAFSqhqc8uKNFJeW77W5DuhGY6GD185UCaPcd9Fkb3kAiwCAA0AIJ3Pvyz7V/n2BG9E1xrG+vhyVK/HQHwE62IaYofKwSYtCAEOJwIWBAcACAEWAScDDgQBACIOAhYtChYXLQ4EFwAiFwIXLQ4LFwAiFwIXLQxRFwAiFwIXLQ4MFwAiFwIXLQ4NFwAiFwIXLQxRFywCAAQAEzEA1x/fNXkrFjZvT3aE31StfhSjKecPGO51PHb53G8tCFIDIwAAm58MIgNXBSQCAAUAAMdqIwAAm7EtCwcDLQIDAycABAQHJQAA2rUtCAUEACIEWAUtDi0FLQIEAycABAQHJQAA2rUtCAUDACIDTAUtDFMFLQ4DBy0LCQQsAgAFAC34uUDliQ5OE3fgU3P65poddU9pNeangLZmlHQx8s3NLQIEAycABAQKJQAA2rUtCAUGACoGEActDgUHLAIABAAuzYjRWWe8U7iFkS4NFoZhVKy2qsLT+F4nyn7vssGQgy0CBgMnAAQECiUAANq1LQgFBQAqBREHLQ4EBy0CBQMnAAQECiUAANq1LQgFBAAqBBIGLQxRBi0OBAktCAEFJwIGBAQACAEGAScDBQQBACIEAgYnAgcECQAiAwIIJwIJBAYAIgUCCy4CAAaAAy4CAAiABC4CAAeABS4CAAuABiUAAN3yACIFVQQtCwQDJwIFBAEnAgcEAwAqBQcGLQgBBAAIAQYBJwMEBAEAIgQCBi0OBQYAIgYCBi0OBQYnAgYEAwAqBAYFLQoFBi0OAwYAIgQCBi0LBgYtCgYFJwIHBAMAKgQHAzsOAAUAAyMAAJ1HKQIAAwA9SgJdCioBAwQnAgMAQyQCAAQAAJ1nIwAAovwtCAEFJwIGBAIACAEGAScDBQQBACIFAgYfMABVAFUABi0IAQYAAAECAS0OBQYtCAEFAAABAgEtDFIFJwIIBC8tCAAvLQoGMC0KBTEACAAIACUAANVBLQIAAC0KMAcAIgdVBi0LBgUeAgAGAB4CAAcALQgBCAAAAQIBJwIJAEItDgkILQgBCQAAAQIBLQ4DCR4CAAsAHgIADAAzKgALAAwADSQCAA0AAJ4VJQAA0ootCAELJwIMBAMACAEMAScDCwQBACILAgwtCgwNLQ4VDQAiDQINLQ4UDScCDQQvLQgALy0KCzAtCFcxLQhRMgAIAA0AJQAAzyMtAgAALQowDB4CAAsAMyoADAALAA0kAgANAACefyUAANYZLwoAFAALHAoLDQIcCg0MABwKDAsCCiILRAwKIgtFDRIqDA0LJAIACwAAnrAlAADbFB4CAAsBCiILSwwWCgwNHAoNDgAEKg4LDQoiDFELJAIACwAAnt4nAg4EADwGDgEvCgAqAAscCgsOAhwKDgwAHAoMCwIvCgAeAAwvCgAfAA4vCgAgABYvCgAhABcvCgAiABgvCgAjABkvCgAkABovCgAlABsvCgAmABwvCgAnAB0vCgAoAC0vCgApAC8tCAEwJwIxBA0ACAExAScDMAQBACIwAjEtCjEyLQ4MMgAiMgIyLQ4OMgAiMgIyLQ4WMgAiMgIyLQ4XMgAiMgIyLQ4YMgAiMgIyLQ4ZMgAiMgIyLQ4aMgAiMgIyLQ4bMgAiMgIyLQ4cMgAiMgIyLQ4dMgAiMgIyLQ4tMgAiMgIyLQ4vMi0IAQwAAAECAS0MUQwtCFIEIwAAn9QMKgQKBiQCAAYAAMcSIwAAn+YtCwwEJAIABAAAn/clAADWPS0LCAQtCwkGLQgBBycCCAQDAAgBCAEnAwcEAQAiBwIILQoICS0OBAkAIgkCCS0OBQknAgkELy0IAC8tCgcwLQhXMS0IUTIACAAJACUAANLALQIAAC0KMAgKIghTBwoiB1EJJAIACQAAoGYlAADUUi0IAQcnAgkEAwAIAQkBJwMHBAEAIgcCCS0KCQstDggLACILAgstDg0LJwIJBC8tCAAvLQoHMC0IVzEtCFEyAAgACQAlAADSwC0CAAAtCjAICiIIUwcKIgdRCSQCAAkAAKDNJQAA1FIvCgAIAAccCgcJARwKCQgAHAoIBwEKIgdRCCQCAAgAAKD0JQAA2yYtCAEHJwIIBAMACAEIAScDBwQBACIHAggtCggJLQ4ECQAiCQIJLQ4FCScCCAQvLQgALy0KBzAtCFcxLQhRMgAIAAgAJQAA0sAtAgAALQowBAoiBFMHCiIHUQgkAgAIAAChWyUAANRSLQgBBycCCAQDAAgBCAEnAwcEAQAiBwIILQoICS0OBAkAIgkCCS0ODQknAggELy0IAC8tCgcwLQhXMS0IUTIACAAIACUAANLALQIAAC0KMAQKIgRTBwoiB1EIJAIACAAAocIlAADUUjAIAFYABC0IAQQnAgcEAwAIAQcBJwMEBAEAIgQCBy0KBwgtDgYIACIIAggtDgUIJwIIBC8tCAAvLQoEMC0IVzEtCFEyAAgACAAlAADSwC0CAAAtCjAHCiIHUwQKIgRRCCQCAAgAAKIvJQAA1FIvCgAHAAQcCgQIAhwKCAcAHAoHBAItCAEHJwIIBAMACAEIAScDBwQBACIHAggtCggJLQ4GCQAiCQIJLQ4FCScCBgQvLQgALy0KBzAtCFcxLQhRMgAIAAYAJQAA0sAtAgAALQowBQoiBVMGCiIGUQckAgAHAACiqyUAANRSACIERAYOKgQGByQCAAcAAKLCJQAAzREcCgYEADAKAAQABS0LAgQAIgQCBC0OBAIAIgICBi0LBgYtCgYFJwIHBAMAKgIHBDsOAAUABCMAAKL8KQIABACAhJiaCioBBAUkAgAFAACjFyMAAKd1LQgBBCcCBQQCAAgBBQEnAwQEAQAiBAIFHzAAVQBVAAUtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQxSBCcCBwQvLQgALy0KBTAtCgQxAAgABwAlAADVQS0CAAAtCjAGACIGVQUtCwUEHgIABQAeAgAGAB4CAAcAHgIACAAzKgAHAAgACSQCAAkAAKOmJQAA0ootCAEHJwIIBAMACAEIAScDBwQBACIHAggtCggJLQ4VCQAiCQIJLQ4UCScCCQQvLQgALy0KBzAtCFcxLQhRMgAIAAkAJQAAzyMtAgAALQowCB4CAAcAMyoACAAHAAkkAgAJAACkECUAANYZLwoAFAAHHAoHCQIcCgkIABwKCAcCCiIHRQgkAgAIAACkNyUAANs4LQgBBycCCAQDAAgBCAEnAwcEAQAiBwIILQoICS0OAwkAIgkCCS0OBAknAgkELy0IAC8tCgcwLQhXMS0IUTIACAAJACUAANLALQIAAC0KMAgKIghTBwoiB1EJJAIACQAApJ4lAADUUi8KAAgABxwKBwkCHAoJCAAcCggHAi8KACwACBwKCAsCHAoLCQAcCgkIAgwqBwgJCiIJUQckAgAHAACk3yUAANtKLQgBBycCCAQDAAgBCAEnAwcEAQAiBwIILQoICS0OLgkAIgkCCS0OBAknAgkELy0IAC8tCgcwLQhXMS0IUTIACAAJACUAANLALQIAAC0KMAgKIghTBwoiB1EJJAIACQAApUYlAADUUicCCQQvLQgALy0KCDAACAAJACUAANacLQIAAC0KMAcAIgdVCS0LCQgcCggLBRwKCwkAACIHVwstCwsIACIHUAwtCwwLHAoLDQQcCg0MAAAqBw8NLQsNCxwKCw4EHAoODQAAIgdYDi0LDgscCgsWBBwKFg4AACIHTBYtCxYLHAoLFwEcChcWABwKFgsBACoHEBgtCxgXHAoXGQEcChkYABwKGBcBACoHERktCxkYACoHEhotCxoZACoHExstCxsaHAoaHAIcChwbAAAiB1kcLQscGhwKGhwCHAocBwAKIgtRGiQCABoAAKY0JQAA13kKIhdRCyQCAAsAAKZGJQAA21wtCAELJwIXBAMACAEXAScDCwQBACILAhctChcaLQ4uGgAiGgIaLQ4EGicCFwQvLQgALy0KCzAtCFcxLQhRMgAIABcAJQAA0sAtAgAALQowBAoiBFMLCiILURckAgAXAACmrSUAANRSLQgBCycCFwQMAAgBFwEnAwsEAQAiCwIXLQoXGi0OCRoAIhoCGi0OCBoAIhoCGi0ODBoAIhoCGi0ODRoAIhoCGi0ODhoAIhoCGi0OFhoAIhoCGi0MVhoAIhoCGi0OGBoAIhoCGi0OGRoAIhoCGi0OGxoAIhoCGi0OBxonAgcELy0IAC8tCgQwLQoLMQAIAAcAJQAA1k8tAgAALQsCBAAiBAIELQ4EAgAiAgIILQsICC0KCAcnAgkEAwAqAgkEOw4ABwAEIwAAp3UpAgAEAGNAUi4KKgEEBSQCAAUAAKeQIwAAq8QtCAEEJwIFBAIACAEFAScDBAQBACIEAgUfMABVAFUABS0IAQUAAAECAS0OBAUtCAEEAAABAgEtDFIEJwIHBC8tCAAvLQoFMC0KBDEACAAHACUAANVBLQIAAC0KMAYAIgZVBS0LBQQeAgAFAB4CAAYAHgIABwAeAgAIADMqAAcACAAJJAIACQAAqB8lAADSii0IAQcnAggEAwAIAQgBJwMHBAEAIgcCCC0KCAktDhUJACIJAgktDhQJJwIJBC8tCAAvLQoHMC0IVzEtCFEyAAgACQAlAADPIy0CAAAtCjAIHgIABwAzKgAIAAcACSQCAAkAAKiJJQAA1hkvCgAUAAccCgcJAhwKCQgAHAoIBwIKIgdFCCQCAAgAAKiwJQAA224tCAEHJwIIBAMACAEIAScDBwQBACIHAggtCggJLQ4DCQAiCQIJLQ4ECScCCQQvLQgALy0KBzAtCFcxLQhRMgAIAAkAJQAA0sAtAgAALQowCAoiCFMHCiIHUQkkAgAJAACpFyUAANRSLwoACAAHHAoHCQIcCgkIABwKCAcCLwoAKwAIHAoICwIcCgsJABwKCQgCDCoHCAkKIglRByQCAAcAAKlYJQAA24AtCAEHJwIIBAMACAEIAScDBwQBACIHAggtCggJLQ4uCQAiCQIJLQ4ECScCCQQvLQgALy0KBzAtCFcxLQhRMgAIAAkAJQAA0sAtAgAALQowCAoiCFMHCiIHUQkkAgAJAACpvyUAANRSJwIJBC8tCAAvLQoIMAAIAAkAJQAA1pwtAgAALQowBwAiB1UJLQsJCBwKCAsFHAoLCQAAIgdXCy0LCwgAIgdQDC0LDAscCgsNBBwKDQwAACoHDw0tCw0LHAoLDgQcCg4NAAAiB1gOLQsOCxwKCxYEHAoWDgAAKgcQFi0LFgscCgsXARwKFxYAHAoWCwEAKgcRGC0LGBcAKgcSGS0LGRgAKgcTGi0LGhkcChkbAhwKGxoAACIHWRstCxsZHAoZGwIcChsHAAoiC1EZJAIAGQAAqpUlAADbXC0IAQsnAhkEAwAIARkBJwMLBAEAIgsCGS0KGRstDi4bACIbAhstDgQbJwIZBC0tCAAtLQoLLi0IVy8tCFEwAAgAGQAlAADSwC0CAAAtCi4ECiIEUwsKIgtRGSQCABkAAKr8JQAA1FItCAELJwIZBAwACAEZAScDCwQBACILAhktChkbLQ4JGwAiGwIbLQ4IGwAiGwIbLQ4MGwAiGwIbLQ4NGwAiGwIbLQ4OGwAiGwIbLQxWGwAiGwIbLQ4WGwAiGwIbLQ4XGwAiGwIbLQ4YGwAiGwIbLQ4aGwAiGwIbLQ4HGycCBwQtLQgALS0KBC4tCgsvAAgABwAlAADWTy0CAAAtCwIEACIEAgQtDgQCACICAggtCwgILQoIBycCCQQDACoCCQQ7DgAHAAQjAACrxCkCAAQArxGnnQoqAQQFJAIABQAAq98jAACvsy0IAQUnAgYEAwAIAQYBJwMFBAEAIgUCBh8wAFcAVQAGLQgBBgAAAQIBLQ4FBi0IAQUAAAECAS0MUgUnAggELS0IAC0tCgYuLQoFLwAIAAgAJQAA0hktAgAALQouBwAiB1UJLQsJCCcCCQQtLQgALS0KBi4tCgUvAAgACQAlAADSGS0CAAAtCi4HACIHVQYtCwYFHgIABgAeAgAHAC0IAQkAAAECAS0OHgktCAELAAABAgEtDh8LLQgBDAAAAQIBLQ4gDC0IAQ0AAAECAS0OIQ0tCAEOAAABAgEtDiIOLQgBFgAAAQIBLQ4jFi0IARcAAAECAS0OJBctCAEYAAABAgEtDiUYLQgBGQAAAQIBLQ4mGS0IARoAAAECAS0OJxotCAEbAAABAgEtDigbLQgBHAAAAQIBLQ4pHB4CAB0AHgIALQAzKgAdAC0ALiQCAC4AAK02JQAA0ooeAgAdAQoiHUstFgotLhwKLi8ABCovHS4KIi1RHSQCAB0AAK1kJwIvBAA8Bi8BCiouBx0kAgAdAACtdiUAANuSLwoAKgAHHAoHLQIcCi0dABwKHQcCLwoAHgAdLwoAHwAtLwoAIAAuLwoAIQAvLwoAIgAwLwoAIwAxLwoAJAAyLwoAJQAzLwoAJgA0LwoAJwA1LwoAKAA2LwoAKQA3LQgBOCcCOQQNAAgBOQEnAzgEAQAiOAI5LQo5Oi0OHToAIjoCOi0OLToAIjoCOi0OLjoAIjoCOi0OLzoAIjoCOi0OMDoAIjoCOi0OMToAIjoCOi0OMjoAIjoCOi0OMzoAIjoCOi0ONDoAIjoCOi0ONToAIjoCOi0ONjoAIjoCOi0ONzotCAEdAAABAgEtDjgdLQgBLQAAAQIBLQxRLS0IUgQjAACueQwqBAoGJAIABgAAxpIjAACuiy0LLQQkAgAEAACunCUAANukLQsJBC0LCwUtCwwGLQsNBy0LDggtCxYJLQsXCy0LGAwtCxkNLQsaDi0LGxYtCxwXLQsdGAAiGFUaLQsaGTAKABkABAAiGFcZLQsZBDAKAAQABQAiGFAFLQsFBDAKAAQABgAqGA8FLQsFBDAKAAQABwAiGFgFLQsFBDAKAAQACAAiGEwFLQsFBDAKAAQACQAqGBAFLQsFBDAKAAQACwAqGBEFLQsFBDAKAAQADAAqGBIFLQsFBDAKAAQADQAqGBMFLQsFBDAKAAQADgAiGFkFLQsFBDAKAAQAFgAqGAoFLQsFBDAKAAQAFy0LAgQAIgQCBC0OBAIAIgICBi0LBgYtCgYFJwIHBAMAKgIHBDsOAAUABCMAAK+zKQIABAAJ3Pu5CioBBAUkAgAFAACvziMAALLQLQgBBCcCBQQCAAgBBQEnAwQEAQAiBAIFHzAAVQBVAAUtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQxSBCcCBwQtLQgALS0KBS4tCgQvAAgABwAlAADVQS0CAAAtCi4GACIGVQUtCwUEHgIABQAeAgAGAB4CAAcAHgIACAAzKgAHAAgACSQCAAkAALBdJQAA0ooeAgAHAQoiB0sIFgoICRwKCQsABCoLBwkKIghRByQCAAcAALCLJwILBAA8BgsBCioJBgckAgAHAACwnSUAANu2LwoAKgAGHAoGCAIcCggHABwKBwYCJwIIAgwMKgYICSQCAAkAALDJJQAA28gvCgAeAAgvCgAfAAkvCgAgAAsvCgAhAAwvCgAiAA0vCgAjAA4vCgAkABYvCgAlABcvCgAmABgvCgAnABkvCgAoABovCgApABstCAEcJwIdBA0ACAEdAScDHAQBACIcAh0tCh0tLQ4ILQAiLQItLQ4JLQAiLQItLQ4LLQAiLQItLQ4MLQAiLQItLQ4NLQAiLQItLQ4OLQAiLQItLQ4WLQAiLQItLQ4XLQAiLQItLQ4YLQAiLQItLQ4ZLQAiLQItLQ4aLQAiLQItLQ4bLRwKBwgEDCoICgckAgAHAACxqyUAANvaLQIcAycABAQNJQAA2rUtCAUHACIHAgkAKgkICy0OBAsAIgdVCC0LCAQwCgAEAB4AIgdXCC0LCAQwCgAEAB8AIgdQCC0LCAQwCgAEACAAKgcPCC0LCAQwCgAEACEAIgdYCC0LCAQwCgAEACIAIgdMCC0LCAQwCgAEACMAKgcQCC0LCAQwCgAEACQAKgcRCC0LCAQwCgAEACUAKgcSCC0LCAQwCgAEACYAKgcTCC0LCAQwCgAEACcAIgdZCC0LCAQwCgAEACgAKgcKCC0LCAQwCgAEACkAIgZEBA4qBgQHJAIABwAAspYlAADNERwKBAYAMAoABgAqLQsCBAAiBAIELQ4EAgAiAgIHLQsHBy0KBwYnAggEAwAqAggEOw4ABgAEIwAAstApAgAEAONX6H4KKgEEBSQCAAUAALLrIwAAt3stCAEFJwIGBAIACAEGAScDBQQBACIFAgYfMABVAFUABi0IAQYAAAECAS0OBQYtCAEFAAABAgEtDFIFJwIIBC0tCAAtLQoGLi0KBS8ACAAIACUAANVBLQIAAC0KLgcAIgdVBi0LBgUeAgAGAB4CAAcALQgBCAAAAQIBLQ4eCC0IAQkAAAECAS0OHwktCAELAAABAgEtDiALLQgBDAAAAQIBLQ4hDC0IAQ0AAAECAS0OIg0tCAEOAAABAgEtDiMOLQgBFgAAAQIBLQ4kFi0IARcAAAECAS0OJRctCAEYAAABAgEtDiYYLQgBGQAAAQIBLQ4nGS0IARoAAAECAS0OKBotCAEbAAABAgEtDikbLQgBHAAAAQIBLQ4qHC0IAR0AAAECAS0OKx0eAgAtAB4CAC4AMyoALQAuAC8kAgAvAAC0MCUAANKKHgIALQEKIi1LLhYKLi8cCi8wAAQqMC0vCiIuUS0kAgAtAAC0XicCMAQAPAYwAQoqLwctJAIALQAAtHAlAADb7C8KACoABxwKBy4CHAouLQAcCi0HAi8KAB4ALS8KAB8ALi8KACAALy8KACEAMC8KACIAMS8KACMAMi8KACQAMy8KACUANC8KACYANS8KACcANi8KACgANy8KACkAOC0IATknAjoEDQAIAToBJwM5BAEAIjkCOi0KOjstDi07ACI7AjstDi47ACI7AjstDi87ACI7AjstDjA7ACI7AjstDjE7ACI7AjstDjI7ACI7AjstDjM7ACI7AjstDjQ7ACI7AjstDjU7ACI7AjstDjY7ACI7AjstDjc7ACI7AjstDjg7LQgBLQAAAQIBLQ45LS0IAS4AAAECAScCLwL/LQ4vLi0IUgQjAAC1eAwqBAoGJAIABgAAxjYjAAC1ii0LLgUKKgUvBgoiBlEuJAIALgAAtaUlAADb/i0IAQYAAAECAS0OBQYtCFIEIwAAtbsMIgRZBSQCAAUAAMWOIwAAtc0CIgdEBA4oRAcFJAIABQAAteQlAADVLxwKBAUELQstBgwqBQoHJAIABwAAtf8lAADb2i0CBgMnAAQEDSUAANq1LQgFBwAiBwIuACouBS8tDFMvLQ4HLS0LCAUtCwkGLQsLCC0LDAktCw0LLQsODC0LFg0tCxcOLQsYFi0LGRctCxoYLQsbGS0LHBotCx0bACIHVR0tCx0cMAoAHAAFACIHVxwtCxwFMAoABQAGACIHUAYtCwYFMAoABQAIACoHDwYtCwYFMAoABQAJACIHWAYtCwYFMAoABQALACIHTAYtCwYFMAoABQAMACoHEAYtCwYFMAoABQANACoHEQYtCwYFMAoABQAOACoHEgYtCwYFMAoABQAWACoHEwYtCwYFMAoABQAXACIHWQYtCwYFMAoABQAYACoHCgYtCwYFMAoABQAZHAoEBQAwCgAFABovCgAbAAYcCgYIAhwKCAcAHAoHBgIMKgQGByQCAAcAALdBIwAAt0wwCgAFABsjAAC3TC0LAgQAIgQCBC0OBAIAIgICBi0LBgYtCgYFJwIHBAMAKgIHBDsOAAUABCMAALd7KQIABACvNosZCioBBAUkAgAFAAC3liMAALjnLQgBBCcCBQQCAAgBBQEnAwQEAQAiBAIFHzAAVQBVAAUtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQxSBCcCBwQtLQgALS0KBS4tCgQvAAgABwAlAADVQS0CAAAtCi4GACIGVQUtCwUEHAoEBgIcCgYFABwKBQQCHgIABgAeAgAHAB4CAAgAHgIACQAzKgAIAAkACyQCAAsAALg0JQAA0ooeAgAIAQoiCEsJFgoJCxwKCwwABCoMCAsKIglRCCQCAAgAALhiJwIMBAA8BgwBCioLBwgkAgAIAAC4dCUAANwQLwoAKgAHHAoHCQIcCgkIABwKCAcCDCoHBAgKIghRByQCAAcAALigJQAA3CIMKEMEByQCAAcAALiyJQAA3DQwCgAFACstCwIEACIEAgQtDgQCACICAgctCwcHLQoHBScCCAQDACoCCAQ7DgAFAAQjAAC45ykCAAIAGtPJRgoqAQIEJAIABAAAuQIjAAC6Gh4CAAIAHgIABAAeAgAFAB4CAAYAMyoABQAGAAckAgAHAAC5KyUAANKKHgIABQkkAgAFAAC5PSUAANxGLQgBBScCBgQDAAgBBgEnAwUEAQAiBQIGLQoGBy0OFQcAIgcCBy0OFAcnAgcELS0IAC0tCgUuLQhXLy0IUTAACAAHACUAAM8jLQIAAC0KLgYeAgAFADMqAAYABQAHJAIABwAAuaclAADWGS8KABQABRwKBQcCHAoHBgAnAgcEAScCCQQDACoHCQgtCAEFAAgBCAEnAwUEAQAiBQIILQ4HCAAiCAIILQ4HCCcCCAQDACoFCActCgcILQ4GCAAiBQIILQsICC0KCAcnAgkEAwAqBQkGOw4ABwAGIwAAuhopAgACAFeP7M4KKgECBCQCAAQAALo1IwAAvVQtCAEEJwIFBAIACAEFAScDBAQBACIEAgUfMABVAFUABS0IAQUAAAECAS0OBAUtCAEEAAABAgEtDFIEJwIHBC0tCAAtLQoFLi0KBC8ACAAHACUAANVBLQIAAC0KLgYAIgZVBS0LBQQcCgQGAhwKBgUAHAoFBAIeAgAFAB4CAAYAHgIABwAeAgAIADMqAAcACAAJJAIACQAAutMlAADSih4CAAcJJAIABwAAuuUlAADcWAoiBEMHJAIABwAAvOIjAAC69woiBEQGJAIABgAAvMojAAC7CQoiBEUHJAIABwAAvLIjAAC7GwoiBEYIJAIACAAAvJojAAC7LQoiBEcJJAIACQAAvIIjAAC7PwoiBEoLJAIACwAAvGojAAC7UQoiBEkMJAIADAAAvFIjAAC7YwoiBEgNJAIADQAAvDojAAC7dScCDgIICioEDg8kAgAPAAC8IiMAALuMJwIPAgkKKgQPECQCABAAALwKIwAAu6MnAhACCgoqBBARJAIAEQAAu/IjAAC7uicCEQILCioEERIkAgASAAC72iMAALvRLQhTECMAALvpLwoAKQAELQoEECMAALvpLQoQDyMAALwBLwoAKAAELQoEDyMAALwBLQoPDiMAALwZLwoAJwAELQoEDiMAALwZLQoODSMAALwxLwoAJgAELQoEDSMAALwxLQoNDCMAALxJLwoAJQAELQoEDCMAALxJLQoMCyMAALxhLwoAJAAELQoECyMAALxhLQoLCSMAALx5LwoAIwAELQoECSMAALx5LQoJCCMAALyRLwoAIgAELQoECCMAALyRLQoIByMAALypLwoAIQAELQoEByMAALypLQoHBiMAALzBLwoAIAAELQoEBiMAALzBLQoGBSMAALzZLwoAHwAELQoEBSMAALzZLQoFAiMAALzxLwoAHgAELQoEAiMAALzxJwIFBAEnAgcEAwAqBQcGLQgBBAAIAQYBJwMEBAEAIgQCBi0OBQYAIgYCBi0OBQYnAgYEAwAqBAYFLQoFBi0OAgYAIgQCBi0LBgYtCgYFJwIHBAMAKgQHAjsOAAUAAiMAAL1UKQIAAgABELMgCioBAgQkAgAEAAC9byMAAL4dHgIAAgAeAgAEAB4CAAUAHgIABgAzKgAFAAYAByQCAAcAAL2YJQAA0ooeAgAFCSQCAAUAAL2qJQAA3GovCgAqAAUcCgUHAhwKBwYAJwIHBAEnAgkEAwAqBwkILQgBBQAIAQgBJwMFBAEAIgUCCC0OBwgAIggCCC0OBwgnAggEAwAqBQgHLQoHCC0OBggAIgUCCC0LCAgtCggHJwIJBAMAKgUJBjsOAAcABiMAAL4dKQIAAgCDXoyDCioBAgQkAgAEAAC+OCMAAL7mHgIAAgAeAgAEAB4CAAUAHgIABgAzKgAFAAYAByQCAAcAAL5hJQAA0ooeAgAFCSQCAAUAAL5zJQAA3HwvCgArAAUcCgUHAhwKBwYAJwIHBAEnAgkEAwAqBwkILQgBBQAIAQgBJwMFBAEAIgUCCC0OBwgAIggCCC0OBwgnAggEAwAqBQgHLQoHCC0OBggAIgUCCC0LCAgtCggHJwIJBAMAKgUJBjsOAAcABiMAAL7mKQIAAgAOuRU+CioBAgQkAgAEAAC/ASMAAL+vHgIAAgAeAgAEAB4CAAUAHgIABgAzKgAFAAYAByQCAAcAAL8qJQAA0ooeAgAFCSQCAAUAAL88JQAA3I4vCgAsAAUcCgUHAhwKBwYAJwIHBAEnAgkEAwAqBwkILQgBBQAIAQgBJwMFBAEAIgUCCC0OBwgAIggCCC0OBwgnAggEAwAqBQgHLQoHCC0OBggAIgUCCC0LCAgtCggHJwIJBAMAKgUJBjsOAAcABiMAAL+vKQIAAgByZvlMCioBAgQkAgAEAAC/yiMAAMHfLQgBBCcCBQQCAAgBBQEnAwQEAQAiBAIFHzAAVQBVAAUtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQxSBCcCBwQrLQgAKy0KBSwtCgQtAAgABwAlAADVQS0CAAAtCiwGACIGVQUtCwUEHgIABQAeAgAGAB4CAAcAHgIACAAzKgAHAAgACSQCAAkAAMBZJQAA0ooeAgAHCSQCAAcAAMBrJQAA3KAvCgAqAAccCgcJAhwKCQgAHAoIBwIvCgAeAAgvCgAfAAkvCgAgAAsvCgAhAAwvCgAiAA0vCgAjAA4vCgAkAA8vCgAlABAvCgAmABEvCgAnABIvCgAoABMvCgApABQtCAEVJwIWBA0ACAEWAScDFQQBACIVAhYtChYXLQ4IFwAiFwIXLQ4JFwAiFwIXLQ4LFwAiFwIXLQ4MFwAiFwIXLQ4NFwAiFwIXLQ4OFwAiFwIXLQ4PFwAiFwIXLQ4QFwAiFwIXLQ4RFwAiFwIXLQ4SFwAiFwIXLQ4TFwAiFwIXLQ4UFy0IAQgAAAECAS0MUQgtCFICIwAAwWEMKgIKBSQCAAUAAMU2IwAAwXMtCwgCHAoCBAAnAgUEAScCBwQDACoFBwYtCAECAAgBBgEnAwIEAQAiAgIGLQ4FBgAiBgIGLQ4FBicCBgQDACoCBgUtCgUGLQ4EBgAiAgIGLQsGBi0KBgUnAgcEAwAqAgcEOw4ABQAEIwAAwd8pAgACACrxg28KKgECBCQCAAQAAMH6IwAAw3UtCAECJwIEBAIACAEEAScDAgQBACICAgQfMABVAFUABC0IAQQAAAECAS0OAgQtCAECAAABAgEtDFICJwIGBActCAAHLQoECC0KAgkACAAGACUAANVBLQIAAC0KCAUAIgVVBC0LBAIeAgAEAB4CAAUAHgIABgAeAgAHADMqAAYABwAIJAIACAAAwoklAADSih4CAAYJJAIABgAAwpslAADcsi0IAQYnAgcEAwAIAQcBJwMGBAEAIgYCBy0KBwgtDgMIACIIAggtDgIIJwIDBActCAAHLQoGCC0IVwktCFEKAAgAAwAlAADSwC0CAAAtCggCCiICUwMKIgNRBiQCAAYAAMMCJQAA1FIvCgACAAMcCgMGAhwKBgIAJwIGBAEnAggEAwAqBggHLQgBAwAIAQcBJwMDBAEAIgMCBy0OBgcAIgcCBy0OBgcnAgcEAwAqAwcGLQoGBy0OAgcAIgMCBy0LBwctCgcGJwIIBAMAKgMIAjsOAAYAAiMAAMN1JwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDg8SCiBRVAIkAgACAADFNicCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQXpSUPomzfdLAAiBQIFACIQAgYnAgcEGy0CBgMtAgUELQIHBSUAANzEJwIGBBsAKgUGBS0MVgUAIgUCBS0OAQUAIgUCBTwOAwQcCgIGAhwKBgUEHAoFBgIMKgYHBSQCAAUAAMVXIwAAxYAAIhUCBgAqBgIJLQsJBQoqBQQGJAIABgAAxXcjAADFgC0MVAgjAADFgAAiAlUFLQoFAiMAAMFhLQsGBQAiBUQuDioFLi8kAgAvAADFqSUAAM0RDCouBy8kAgAvAADFuyMAAMYoHAoFLwQcCi4FBC0LLTAMKgUKMSQCADEAAMXbJQAA29oAIjACMgAqMgUzLQszMQwqLwoFJAIABQAAxfslAADb2i0CMAMnAAQEDSUAANq1LQgFBQAiBQIyACoyLzMtDjEzLQ4FLS0OLgYjAADGKAAiBFUFLQoFBCMAALW7HAoEMAIcCjAGBBwKBjACDCowBwYkAgAGAADGVyMAAMaELQstBgAiBgIyACoyBDMtCzMxCioxBQYkAgAGAADGeyMAAMaELQ4wLiMAAMaEACIEVQYtCgYEIwAAtXgcCgQuAhwKLgYEHAoGLgIMKi4HBiQCAAYAAMazIwAAxwQtCx0GACIGAi8AKi8EMC0LMC4KKi4ILyQCAC8AAMbXIwAAxwQtAgYDJwAEBA0lAADatS0IBS4AIi4CLwAqLwQwLQ4FMC0OLh0tDFQtIwAAxwQAIgRVBi0KBgQjAACueRwKBAcCHAoHBgQcCgYHAgwqBwsGJAIABgAAxzMjAADHXAAiMAIHACoHBA4tCw4GCioGDQckAgAHAADHUyMAAMdcLQxUDCMAAMdcACIEVQYtCgYEIwAAn9QAIggCBgAqBgMLLQsLBRwKBQsGHAoLBgACKgUGCwQqCwQMBChNDAsAKgYLDQoqBQ0LJAIACwAAx6wnAhYEADwGFgEKIgxOBRYKBQscCgUNABwKCwUABCoNBgsEKgUMFgAqCxYXBCINTwsEIgVODQAqCw0FDCoXBQskAgALAADH8ycCBQQAPAYFAS0LBwUEIgNXCy0CBQMnAAQEByUAANq1LQgFDQAiDQIWACoWCxctDgYXACILVQUtAg0DJwAEBAclAADatS0IBQYAIgYCCwAqCwUWLQ4MFi0OBgcEIgNQBQAiDgILACoLBQwtCwwGACIFVQsAIg4CDQAqDQsWLQsWDAAiBVcNACIOAhcAKhcNGC0LGBYtCwkNLQINAycABAQKJQAA2rUtCAUXACIXAhgAKhgFGS0OBhktAhcDJwAEBAolAADatS0IBQUAIgUCBgAqBgsNLQ4MDQAiC1UGLQIFAycABAQKJQAA2rUtCAULACILAgwAKgwGDS0OFg0tDgsJACIDVQUtCgUDIwAAm58cCjBFAhwKRUQEHApERQIMKkU5RCQCAEQAAMkaIwAAyUMAIk8CRQAqRTBGLQtGRAoqRDZFJAIARQAAyTojAADJQy0MVEMjAADJQwAiMFVELQpEMCMAADV2DCoDLzAkAgAwAADJYyMAAMoYACJBAjEAKjEDMi0LMjAKIjBTMSQCADEAAMoYIwAAyYMtC1ExLQgBMicCMwQDAAgBMwEnAzIEAQAiMgIzLQozNC0OMTQAIjQCNC0OMDQnAjEEaS0IAGktCjJqLQhXay0IUWwACAAxACUAANLALQIAAC0KajAKIjBTMQoiMVEyJAIAMgAAye4lAADUUjAIAFYAMC0LLjAAKjAIMQ4qMDEyJAIAMgAAyg8lAADNES0OMS4jAADKGAAiA1UwLQowAyMAABafAiowA3kCInlVeg4oVXl7JAIAewAAykIlAADVLy0LRHkMKnoweyQCAHsAAMpYJQAA29oAIjECfAAqfHp9LQt9exwKe3oALQtFewQqent8ACp5fHotDnpEBCp7ZHktDnlFACIDVXktCnkDIwAAEbIAIi4CggAqggODLQuDgScCggSDLQgAgy0KfoQtCkSFLQp/hi0KgIctCoGIAAgAggAlAADOAC0CAAAAIgNVgS0KgQMjAAAPbAAiA1UuACJ+AoAAKoADgS0LgUQtC3+ADCouZIEkAgCBAADLBCUAANvaLQKAAycABAQ+JQAA2rUtCAWBACKBAoIAKoIugy0ORIMtDoF/LQouAyMAAA6XLQtCQy0LQUUMKkUKRiQCAEYAAMtLJQAA29oAIkMCRwAqR0VILQtIRgAiRVVHDipFR0gkAgBIAADLcCUAAM0RLQ5DQi0OR0EtC0RDLQJDAycABAQNJQAA2rUtCAVFACJFAkcAKkcDSC0ORkgtDkVEACIDVUMtCkMDIwAAB3UtCy9BLQsuQwAqQwNEDipDREUkAgBFAADLzSUAAM0RDCJEWkMkAgBDAADL3yUAANvaACJBAkUAKkVERi0LRkMtC0JBLQJBAycABAQNJQAA2rUtCAVEACJEAkUAKkUDRi0OQ0YtDkRCACIDVUEtCkEDIwAABscAIjICNAAqNAM1LQs1MRwKMTUCHAo1NAAcCjQxAi0LMzQtAjQDJwAEBCAlAADatS0IBTUAIjUCNgAqNgM3LQ4xNy0ONTMAIgNVMS0KMQMjAAADhC0LLzItCy4zACozAzQOKjM0NSQCADUAAMyVJQAAzREMIjRaMyQCADMAAMynJQAA29oAIjICNQAqNTQ2LQs2My0LMTItAjIDJwAEBCAlAADatS0IBTQAIjQCNQAqNQM2LQ4zNi0ONDEAIgNVMi0KMgMjAAAC8CgAAAQEeF0MAAAEAyQAAAMAAM0QKgEAAQXaxfXWtEoybTwEAgEmKgEAAQXQB+v0y8ZnkDwEAgEmJQAAzOstCwIDLQsBBAwiA1oFJAIABQAAzUIlAADb2gAiBAIGACoGAwctCwcFLQgBBicCBwQCAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIgNVBQ4qAwUHJAIABwAAzYclAADNES0OBAEtDgUCLQoGASYlAADM6y0LBAUKIgVRBiQCAAYAAM2zJwIHBAA8BgcBJwIFBAYtCAAGLQoBBy0KAggtCgMJLQoECgAIAAUAJQAA3PYtAgAALQsBBS0LAgYtCwMHLQ4FAS0OBgItDgcDLQxUBAAiBlUCLQsCASYlAADM6y0LBAYKIgZRByQCAAcAAM4fJwIIBAA8BggBLQsDBgoiBlAHJAIABwAAzpsjAADONS0LAQctCwIIDCIGUAkkAgAJAADOTyUAANvaLQIHAycABAQEJQAA2rUtCAUJACIJAgoAKgoGCy0OBQsAIgZVBQ4qBgUHJAIABwAAzoYlAADNES0OCQEtDggCLQ4FAy0MUQQjAADO/icCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAANz2LQIAAC0LAQYtCwIHLQsECC0CBgMnAAQEBCUAANq1LQgFCQAiCVUKLQ4FCi0OCQEtDgcCLQxVAy0OCAQjAADO/iYqAQABBYpVOiwrZ8jvPAQCASYqAQABBcgNc3NuzbThPAQCASYlAADM6xwKAgUABCIFWwYtCAEFJwIHBAQACAEHAScDBQQBACIFAgctCgcILQxTCAAiCAIILQxTCAAiCAIILQxTCC0IAQcnAggEBQAIAQgBJwMHBAEAIgcCCC0KCAktDFMJACIJAgktDFMJACIJAgktDFMJACIJAgktDgYJLQgBBgAAAQIBLQ4FBi0IAQUAAAECAS0OBwUtCAEHAAABAgEtDFIHLQgBCAAAAQIBLQxRCC0IUgQjAADP3AwiBFcJJAIACQAA0FcjAADP7iQCAAMAAM/7IwAA0CsnAgEECS0IAAktCgYKLQoFCy0KBwwtCggNLQhWDgAIAAEAJQAAzgAtAgAAIwAA0CsnAgIECS0IAAktCgYKLQoFCy0KBwwtCggNAAgAAgAlAADNlC0CAAAtCgoBJgwqBAIJJAIACQAA0GkjAADQpwAiAQIKACoKBAstCwsJJwIKBAstCAALLQoGDC0KBQ0tCgcOLQoIDy0KCRAACAAKACUAAM4ALQIAACMAANCnACIEVQktCgkEIwAAz9wlAADM6xwKAgQABCIEWwUtCAEEJwIGBAQACAEGAScDBAQBACIEAgYtCgYHLQxTBwAiBwIHLQxTBwAiBwIHLQxTBy0IAQYnAgcEBQAIAQcBJwMGBAEAIgYCBy0KBwgtDFMIACIIAggtDFMIACIIAggtDFMIACIIAggtDgUILQgBBQAAAQIBLQ4EBS0IAQQAAAECAS0OBgQtCAEGAAABAgEtDFIGLQgBBwAAAQIBLQxRBwAiAVUJLQsJCAwoUgIBJAIAAQAA0YAjAADRsCcCAQQJLQgACS0KBQotCgQLLQoGDC0KBw0tCggOAAgAAQAlAADOAC0CAAAjAADRsCQCAAMAANG9IwAA0e0nAgEECC0IAAgtCgUJLQoECi0KBgstCgcMLQhWDQAIAAEAJQAAzgAtAgAAIwAA0e0nAgIECC0IAAgtCgUJLQoECi0KBgstCgcMAAgAAgAlAADNlC0CAAAtCgkBJiUAAMzrLQsCAy0LAQQMIgNXBSQCAAUAANI4JQAA29oAIgQCBgAqBgMHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIDVQUOKgMFByQCAAcAANJ9JQAAzREtDgQBLQ4FAi0KBgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQU3KvAX4istwzwEAgEmKgEAAQWV+krv2LPVkjwEAgEmJQAAzOscCgIFAAQiBVsGLQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCC0MUwgAIggCCC0MUwgAIggCCC0MUwgtCAEHJwIIBAUACAEIAScDBwQBACIHAggtCggJLQxTCQAiCQIJLQxTCQAiCQIJLQxTCQAiCQIJLQ4GCS0IAQYAAAECAS0OBQYtCAEFAAABAgEtDgcFLQgBBwAAAQIBLQxSBy0IAQgAAAECAS0MUQgtCFIEIwAA03kMIgRXCSQCAAkAANP0IwAA04skAgADAADTmCMAANPIJwIBBAktCAAJLQoGCi0KBQstCgcMLQoIDS0IVg4ACAABACUAAM4ALQIAACMAANPIJwICBAktCAAJLQoGCi0KBQstCgcMLQoIDQAIAAIAJQAAzZQtAgAALQoKASYMKgQCCSQCAAkAANQGIwAA1EQAIgECCgAqCgQLLQsLCScCCgQLLQgACy0KBgwtCgUNLQoHDi0KCA8tCgkQAAgACgAlAADOAC0CAAAjAADURAAiBFUJLQoJBCMAANN5KgEAAQW6uyHXgjMYZDwEAgEmJQAAzOstCwIDLQsBBAwiA1AFJAIABQAA1IMlAADb2gAiBAIGACoGAwctCwcFLQgBBicCBwQCAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIgNVBQ4qAwUHJAIABwAA1MglAADNES0OBAEtDgUCLQoGASYqAQABBXMHI/B7ZtzmPAQCASYqAQABBVD9/BAiSEKPPAQCASYqAQABBZgV0f8Xi+v8PAQCASYqAQABBWQ1J17DCEKQPAQCASYqAQABBSSLV+N6ojWQPAQCASYqAQABBRu8ZdA/3OrcPAQCASYlAADM6y0LAgMtCwEECiIDUgUkAgAFAADVYCUAANvaACIEVQUtCwUDLQgBBScCBgQCAAgBBgEnAwUEAQAiBQIGLQoGBy0OAwctDgQBLQxVAi0KBQEmJQAAzOstCwIDLQsBBAwiA1gFJAIABQAA1bUlAADb2gAiBAIGACoGAwctCwcFLQgBBicCBwQCAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIgNVBQ4qAwUHJAIABwAA1folAADNES0OBAEtDgUCLQoGASYqAQABBZLXuTHvPbjVPAQCASYqAQABBXIxDJYzrKc/PAQCASYqAQABBaRAvcFheo6mPAQCASYqAQABBa2enyG6ft3APAQCASYlAADM6y0IUgMjAADWXQwiA1kEJAIABAAA1nAjAADWbyYcCgMEAAAqAQQFACICAgYAKgYDBy0LBwQwCgAEAAUAIgNVBC0KBAMjAADWXSUAAMzrLQgBAycCBAQMAAgBBAEnAwMEAQAiAwIEJwIFBAsAKgUEBS0KBAYOKgUGByQCAAcAANbiLQxTBgAiBgIGIwAA1sctCAEEAAABAgEtDgMELQhSAiMAANb4DCICWQMkAgADAADXDyMAANcKLQsEASYcCgIDAAAqAQMFLwoABQADLQsEBS0CBQMnAAQEDCUAANq1LQgFBgAiBgIHACoHAggtDgMILQ4GBAAiAlUDLQoDAiMAANb4KgEAAQWo0V3lILGU0jwEAgEmKgEAAQU8YdwMUmHUmDwEAgEmKgEAAQVrE8kJ//7isjwEAgEmKgEAAQUnMOEEl/cXXTwEAgEmKgEAAQV75Zi9LDVI/jwEAgEmKgEAAQXq3nCIDVwBSDwEAgEmKgEAAQXPJV9a/TZXvTwEAgEmKgEAAQUFBBuZIK9gTDwEAgEmKgEAAQXY9u5UOolJizwEAgEmKgEAAQV6sbT7GhP1aDwEAgEmKgEAAQXol6gqX0xjTDwEAgEmKgEAAQVRJC9Hj3342DwEAgEmKgEAAQU9YZZ04wXrZTwEAgEmKgEAAQU96rSFTrZsQzwEAgEmKgEAAQXIeWeQGSnrNjwEAgEmKgEAAQUiFmUY2yVn8jwEAgEmKgEAAQVuC3TziBHemzwEAgEmKgEAAQWDlTKQM/ROhzwEAgEmKgEAAQUolBFBfudguDwEAgEmKgEAAQUQztP5dqUvbDwEAgEmKgEAAQXNtGUg9X9k3DwEAgEmKgEAAQV000T6SW/jITwEAgEmKgEAAQU2M+VutwIiTDwEAgEmKgEAAQXHzq1Cudwk2zwEAgEmKgEAAQV4gllt60rCNDwEAgEmKgEAAQVmFkll0chCXzwEAgEmKgEAAQXTaHaKe7tzKDwEAgEmKgEAAQXYcX1ghnIbjjwEAgEmKgEAAQUrHmexoBed6TwEAgEmKgEAAQXl3NZ/Wa2SfTwEAgEmKgEAAQW1TtiE2iWNPTwEAgEmKgEAAQVgRVlCOp2LGTwEAgEmKgEAAQUEv0JNRkiivDwEAgEmKgEAAQVdDCiSJzKJkjwEAgEmKgEAAQWiq616hBp5gzwEAgEmKgEAAQVd0BSsj1IuxzwEAgEmKgEAAQWDzAMvdsvaIzwEAgEmKgEAAQXB5Ef00vP10zwEAgEmKgEAAQXQJMDnf0eRmDwEAgEmKgEAAQVFPO6EyfVf2zwEAgEmKgEAAQVTo0CzIGvS5zwEAgEmKgEAAQXKbtV3VhbHkDwEAgEmKgEAAQX4hnBD0wf1ojwEAgEmKgEAAQVIjDlSGsJ2pjwEAgEmKgEAAQVKeOIDRmzZpDwEAgEmKgEAAQXnFlRB7mOVHTwEAgEmKgEAAQUtNgpJtSE+OTwEAgEmKgEAAQUa7bv1aS0QHTwEAgEmLQEDBgoABgIHJAAABwAA2ssjAADa1C0AAwUjAADbEy0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAANsOLQEKCC0ECAsAAAoCCgAACwILIwAA2uonAQUEASYqAQABBSLj5q+YQwT1PAQCASYqAQABBXj68/IWKm9xPAQCASYqAQABBSNZhUX1AtR6PAQCASYqAQABBdSCjVTk5B2BPAQCASYqAQABBQx+4b5VNubHPAQCASYqAQABBUIB4cQthMN2PAQCASYqAQABBeFZQShSuRLZPAQCASYqAQABBR1FcY71Ia1DPAQCASYqAQABBWPtm9L1PqE7PAQCASYqAQABBe/JWEJou8GLPAQCASYqAQABBfSZCzJtCiJQPAQCASYqAQABBeQIUEUCtYwfPAQCASYqAQABBVUVs+MudD3rPAQCASYqAQABBc35X0d/xN7LPAQCASYqAQABBQUPndnpFWRyPAQCASYqAQABBUZZ4vsnxuvdPAQCASYqAQABBVbW1N4+/MeSPAQCASYqAQABBckNTqbplhPJPAQCASYqAQABBb8Y6xHTcT+OPAQCASYqAQABBXofdjHc3d75PAQCASYqAQABBaUFzkal04PEPAQCASYqAQABBaPWw6S1eB9LPAQCASYqAQABBRmGDvRk7DIBPAQCASYqAQABBVGFujOh7hY5PAQCASYAAAMFBy0AAwgtAAQJCgAIBwokAAAKAADc9S0BCAYtBAYJAAAIAggAAAkCCSMAANzRJiUAAMzrLQhSBSMAAN0EDCIFUAYkAgAGAADdbCMAAN0WLQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAADdgiMAAN3kLQsCBwAiBwIJACoJBQotCwoILQsBCQAiCQILACoLBQwtCwwKACoICgstCwQILQIHAycABAQFJQAA2rUtCAUKACIKAgwAKgwFDS0OCw0tDgkBLQ4KAi0OBgMtDggEIwAA3eQAIgVVBi0KBgUjAADdBAEAgAYAAoAHAQCABwACgAgoAYAGAAAAKAGABwAAACgBgAgBAAEoAIAJBAAAKACACwAAACgAgAwEAP4oAIAKBAB+KACADQQAgCgAgA4BAAEoAIAPAQAAKACAEAQAAigAgBEEAAMHAIAFgBGABQ0AgAmABYASJACAEgAA3nMjAADftgUAgAmAEYATAQCAE4ADgBMFAIAJgBCAFAEAgBSABIAUAQCAFAACgBULAYAUgAuAFgsBgBWAC4AXEQCAFoAXgBYkAIAWAADfqS4AAAGAFgEAAAGADAABQwEBgBWAEIAKgA6AFgEAgBaACoAXQwEBgBSAEIANgA6AFwEAgBaADIAYJAGAFgAA3wgBAIAWAAKAFiMAAN7zLgGAE4AZAQCAEwACgBwuAYAcgBoBAIAcAAKAHC4BgByAGy4AgBmAHC4AgBqAHS4AgBuAHgEAgBYAAoAWDQCAFoAYgB8kAIAfAADfWSMAAN+YQgAAgBmAGoAbgBmAGoAbgBkLAYAWgA+AHyQAgB8AAN+LQgAAgByAHYAegBmAGoAbgBkBAIAWAAKAFiMAAN9EQhAVgAaAB4AIgBmAGoAbgAYBAIAJAAKACSMAAN5eJg==",
      "custom_attributes": [
        "abi_public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6504742485148360234": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 40
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "abi_utility"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "governor_bravo_cloak.GovernorBravoCloak",
  "noir_version": "1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "GovernorBravoCloak"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_delay",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_period",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "quorum_numerator",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "quorum_denominator",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "late_quorum_extension",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timelock_delay",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_guardian",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_for_votes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_against_votes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposal_abstain_votes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "governance_token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply_snapshot",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_power",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000015"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "delegated_power",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000016"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "delegates",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000017"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_voting_power",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "voting_power_checkpoints",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000019"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "latest_checkpoint_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "membership_mode",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_gate_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "erc20_token_address_hash",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "erc20_min_balance",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "used_nullifiers",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_membership",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000020"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_proposals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000021"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_voting",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000022"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_treasury",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000023"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_identity",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000024"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_delegation",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000025"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_execution",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000026"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_quorum",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000027"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000028"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_guardian",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000029"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_timelock",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_fractional",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_late_quorum",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "privacy_storage",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timelock_proposer",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timelock_executor",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000002f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timelock_canceller",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000030"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "cloak_mode",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000031"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_0",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000033"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_1",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000034"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_2",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000035"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_3",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000036"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_4",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000037"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_5",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000038"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_6",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000039"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_7",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_8",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_9",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_10",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_member_11",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000003f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000040"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "emergency_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000041"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_approvals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000042"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "council_approval_counts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000043"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::add_council_member_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::add_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_verified_balance",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_proof_nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::add_erc20_member_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::add_erc20_member_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_balance_commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::add_member_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::add_member_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::cancel_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::cancel_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_for_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_against_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_abstain_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::cast_fractional_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::cast_fractional_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_support",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::cast_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::cast_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_support",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "__reason_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::cast_vote_with_reason_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::cast_vote_with_reason_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "_governance_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_voting_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_voting_period",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_proposal_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_quorum_numerator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_quorum_denominator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_late_quorum_extension",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_timelock_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "_proposal_guardian",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_membership_mode",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_token_gate_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_erc20_token_address_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_erc20_min_balance",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_cloak_mode",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_council_members",
                    "type": {
                      "kind": "array",
                      "length": 12,
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    }
                  },
                  {
                    "name": "_council_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_council_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_emergency_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::council_approve_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::council_approve_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposer",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_actions_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_description_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_target_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::create_proposal_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::create_proposal_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_delegatee",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::delegate_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::delegate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_delegator",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_delegatee",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::delegate_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::delegate_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::emergency_cancel_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::emergency_cancel_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::emergency_execute_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::emergency_execute_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::execute_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::execute_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_cloak_mode_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_cloak_mode_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_approval_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_approval_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_index",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_member_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_council_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_account",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_delegate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_delegate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_account",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_effective_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_effective_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_emergency_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_emergency_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_erc20_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "field"
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_erc20_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_governance_token_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_governance_token_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_late_quorum_extension_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_late_quorum_extension_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_membership_mode_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_membership_mode_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_account",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_past_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_past_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "proposer",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "eta",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "start_block",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_block",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "canceled",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "executed",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "actions_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "description_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "target_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::proposal::GovernorProposal"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_guardian_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_guardian_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_proposal_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_quorum_denominator_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_quorum_denominator_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_quorum_numerator_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_quorum_numerator_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_timelock_delay_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_timelock_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_token_gate_address_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_token_gate_address_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_total_voting_power_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_total_voting_power_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_account",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_voting_delay_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_voting_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::get_voting_period_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::get_voting_period_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_actions_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_description_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::hash_proposal_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::hash_proposal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_addr",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::is_council_member_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::is_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_verified_balance",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_proof_nullifier",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::join_with_erc20_proof_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::join_with_erc20_proof_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_balance_commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::join_with_token_proof_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::join_with_token_proof_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_deadline_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_deadline_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_eta_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_eta_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_proposer_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_proposer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_snapshot_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_snapshot_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_state_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_votes_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  },
                  {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::proposal_votes_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_actions_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_description_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_target_count",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_proposal_type",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::propose_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::propose_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::queue_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::queue_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::quorum_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::quorum_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::remove_council_member_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::remove_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_old_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_new_member",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::replace_council_member_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::replace_council_member_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_for_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_against_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_abstain_weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_voter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::tally_fractional_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::tally_fractional_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_support",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "_voter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::tally_vote_internal_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::tally_vote_internal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_council_threshold_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_council_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_extension",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_late_quorum_extension_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_late_quorum_extension_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_guardian",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_proposal_guardian_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_proposal_guardian_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_threshold",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_proposal_threshold_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_proposal_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_numerator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_quorum_numerator_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_quorum_numerator_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_timelock_delay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_timelock_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_voting_delay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_voting_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_period",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "governor_bravo_cloak::GovernorBravoCloak::update_voting_period_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "governor_bravo_cloak::GovernorBravoCloak::update_voting_period_abi"
        }
      ]
    }
  },
  "transpiled": true
}
