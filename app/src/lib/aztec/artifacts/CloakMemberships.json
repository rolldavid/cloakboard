{
  "transpiled": true,
  "noir_version": "1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e",
  "name": "CloakMemberships",
  "functions": [
    {
      "name": "add_membership",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "cloak",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "role",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4523706248677983773": {
            "error_kind": "string",
            "string": "role must be >= 1"
          },
          "9239525975239854029": {
            "error_kind": "string",
            "string": "User has too many cloaks"
          },
          "12994148857723761341": {
            "error_kind": "string",
            "string": "role must be <= 3"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16136624766500327493": {
            "error_kind": "string",
            "string": "Cloak has too many members"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "check_membership",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "cloak",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4214054676545774972": {
            "error_kind": "string",
            "string": "Function check_membership can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABEgnAgMEAicCBAQAHwoAAwAEAEUtCEUBLQhGAiUAAABJJQAAAFQtAgFHJwICBEcnAgMEATsOAAMAAicAQwIAJwBEBAMmJQAACi8eAgADAB4CAAQAHgIABQAeAgAGADMqAAUABgAHJwIFAQEkAgAHAAAAhyUAAApVHgIABgkkAgAGAAAAmSUAAApnJwIGAAAtCAEHJwIIBAQACAEIAScDBwQBACIHAggtCggJLQ4GCQAiCQIJLQ4GCQAiCQIJLQ4GCSsCAAgAAAAAAAAAAAIAAAAAAAAAAC0IAQknAgoEBQAIAQoBJwMJBAEAIgkCCi0KCgstDgYLACILAgstDgYLACILAgstDgYLACILAgstDggLLQgBCgAAAQIBLQ4HCi0IAQcAAAECAS0OCQctCAELAAABAgEnAgwEAC0ODAstCAENAAABAgEnAg4BAC0ODg0nAg8AAycCEAQBJAIADgAAAbwjAAABdS0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBBEtDg8RACIRAhEtDgYRACIRAhEtDgYRLQ4DCi0OCQctDhALLQ4ODSMAAAJILQoMAyMAAAHFDCIDRAQkAgAEAAAJqSMAAAHXLQsKAy0LBwQtCw0JLQsEEQAiEQIRLQ4RBC0IAREnAhIEBQAIARIBJwMRBAEAIgQCEicCEwQEACIRAhQ/DwASABQtAgMDJwAEBAQlAAAKeS0IBQQAKgQQEi0ODxItDgQKLQ4RBy0OEAstDgkNIwAAAkgtCwoDLQsHBC0LDQkKKgkODyQCAA8AAAJqJwIRBAA8BhEBJwIJBAIkAgAOAAACrCMAAAJ8LQIDAycABAQEJQAACnktCAUPACoPCREtDgERLQ4PCi0OBActDgkLLQ4ODSMAAAM4LQoMAyMAAAK1DCIDRAQkAgAEAAAJIyMAAALHLQsKAy0LBwQtCw0PLQsEEQAiEQIRLQ4RBC0IAREnAhIEBQAIARIBJwMRBAEAIgQCEicCEwQEACIRAhQ/DwASABQtAgMDJwAEBAQlAAAKeS0IBQQAKgQQEi0OARItDgQKLQ4RBy0OEAstDg8NIwAAAzgtCw0DCioDDgQkAgAEAAADUicCDwQAPAYPAS0KDAEjAAADWwwiAUQDJAIAAwAACJ0jAAADbS0LCgEtCwcDLQsLBC0LAw8AIg8CDy0ODwMtCAEPJwIRBAUACAERAScDDwQBACIDAhEnAhIEBAAiDwITPw8AEQATLQ4BCi0ODwctDgQLLQ4FDQAqDxADLQsDAQoqAQYDCioDDgQkAgAEAAAD3iUAAArYLQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBy0OBgcAIgcCBy0OBgcAIgcCBy0OBgctCAEEJwIHBAUACAEHAScDBAQBACIEAgctCgcKLQ4GCgAiCgIKLQ4GCgAiCgIKLQ4GCgAiCgIKLQ4ICi0IAQcAAAECAS0OAwctCAEDAAABAgEtDgQDLQgBCAAAAQIBLQ4MCC0IAQoAAAECAS0ODgokAgAOAAAE0yMAAASMLQgBCycCDQQEAAgBDQEnAwsEAQAiCwINLQoNDy0OAQ8AIg8CDy0OBg8AIg8CDy0OBg8tDgsHLQ4EAy0OEAgtDg4KIwAABV8tCgwEIwAABNwMIgRECyQCAAsAAAgXIwAABO4tCwcELQsDCy0LCg0tCwsPACIPAg8tDg8LLQgBDycCEQQFAAgBEQEnAw8EAQAiCwIRJwISBAQAIg8CEz8PABEAEy0CBAMnAAQEBCUAAAp5LQgFCwAqCxARLQ4BES0OCwctDg8DLQ4QCC0ODQojAAAFXy0LBwEtCwMELQsKCwoqCw4NJAIADQAABYEnAg8EADwGDwEkAgAOAAAFviMAAAWOLQIBAycABAQEJQAACnktCAULACoLCQ0tDgINLQ4LBy0OBAMtDgkILQ4OCiMAAAZKLQoMASMAAAXHDCIBRAQkAgAEAAAHkSMAAAXZLQsHAS0LAwQtCwoJLQsECwAiCwILLQ4LBC0IAQsnAg0EBQAIAQ0BJwMLBAEAIgQCDScCDwQEACILAhE/DwANABEtAgEDJwAEBAQlAAAKeS0IBQQAKgQQDS0OAg0tDgQHLQ4LAy0OEAgtDgkKIwAABkotCwoCCioCDgQkAgAEAAAGZCcCCQQAPAYJAS0KDAEjAAAGbQwiAUQCJAIAAgAABwsjAAAGfy0LBwEtCwMCLQsIBC0LAgkAIgkCCS0OCQItCAEJJwILBAUACAELAScDCQQBACICAgsnAgwEBAAiCQINPw8ACwANLQ4BBy0OCQMtDgQILQ4FCgAqCRACLQsCAQoqAQYCCioCDgMkAgADAAAG8CUAAArYLwoAAQACHAoCAwIcCgMBABwKAQICDChDAgEmLQsHAi0LAwQtCwgJLQsKCwwqAQkMJAIADAAABy0jAAAHgwAiBAINACoNAQ8tCw8MACICAg8AKg8BES0LEQ0AKgwNDy0CBAMnAAQEBSUAAAp5LQgFDAAiDAINACoNAREtDg8RLQ4CBy0ODAMtDgkILQ4LCiMAAAeDACoBEAItCgIBIwAABm0tCwcELQsDCS0LCAstCwoNDCoBCw8kAgAPAAAHsyMAAAgJACIJAhEAKhEBEi0LEg8AIgQCEgAqEgETLQsTEQAqDxESLQIJAycABAQFJQAACnktCAUPACIPAhEAKhEBEy0OEhMtDgQHLQ4PAy0OCwgtDg0KIwAACAkAKgEQBC0KBAEjAAAFxy0LBwstCwMNLQsIDy0LChEMKgQPEiQCABIAAAg5IwAACI8AIg0CEwAqEwQULQsUEgAiCwIUACoUBBUtCxUTACoSExQtAg0DJwAEBAUlAAAKeS0IBRIAIhICEwAqEwQVLQ4UFS0OCwctDhIDLQ4PCC0OEQojAAAIjwAqBBALLQoLBCMAAATcLQsKAy0LBwQtCwsPLQsNEQwqAQ8SJAIAEgAACL8jAAAJFQAiBAITACoTARQtCxQSACIDAhQAKhQBFS0LFRMAKhITFC0CBAMnAAQEBSUAAAp5LQgFEgAiEgITACoTARUtDhQVLQ4DCi0OEgctDg8LLQ4RDSMAAAkVACoBEAMtCgMBIwAAA1stCwoELQsHDy0LCxEtCw0SDCoDERMkAgATAAAJRSMAAAmbACIPAhQAKhQDFS0LFRMAIgQCFQAqFQMWLQsWFAAqExQVLQIPAycABAQFJQAACnktCAUTACITAhQAKhQDFi0OFRYtDgQKLQ4TBy0OEQstDhINIwAACZsAKgMQBC0KBAMjAAACtS0LCgQtCwcJLQsLES0LDRIMKgMREyQCABMAAAnLIwAACiEAIgkCFAAqFAMVLQsVEwAiBAIVACoVAxYtCxYUACoTFBUtAgkDJwAEBAUlAAAKeS0IBRMAIhMCFAAqFAMWLQ4VFi0OBAotDhMHLQ4RCy0OEg0jAAAKIQAqAxAELQoEAyMAAAHFKAAABAR4SAwAAAQDJAAAAwAAClQqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBTp7VGa7laV8PAQCASYtAQMGCgAGAgckAAAHAAAKjyMAAAqYLQADBSMAAArXLQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAACtItAQoILQQICwAACgIKAAALAgsjAAAKricBBQQBJioBAAEFursh14IzGGQ8BAIBJg==",
      "debug_symbols": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZrRbiMrDIbfJde9AAwY+ipHq1W2m11FitIq2x7paNV3P/4BM5MewUln25v2i6fjMT8Ge2h+774fvr38/Ho8/3j8tbv/6/fu2+V4Oh1/fj09Puyfj49nsf7eGfywJu/u6W5nrd/dM37LZ2sFnBisB6QGRApq8WrxaglBIAhEo9AtuQF7BbUkUkgNMiyIJ6cKzsQG1iqIZ2cAuQFirqAWUgupxYsfJwN0wSqEBoi5glfIDRCzE51ccgrcIMNPBMQKZIxCaGDVYtXi1AJ5nQyHIG8FeM4C3imIheRZhJgrxAZRLVEtCJXgB/IWSGqBvAUgb4Vm8YYU1GKdQmzgrEJoQEZBHuEdIDVAblRQS1BLUEt0CrEBW4XQIBkFPEIGGKBqhdzA6iWrFqcWpxbIW4EbQN4KsQHkraCPQEpUgEMLSA2YFLhBsgqxQTYKenvOFaIhhXZ7hOAV1AJ5vSyrWDSUbIkBf8MAboD1VYBNA6wmL2nDRuIJBhAUcgNLCtzAOQUJPojgjKdXCA28WrxaglqCWqJaypwmgRJYAa+QGmA1BQJwA6ym4AGxQjJeAcGLCAnTHTJALFGESpjuCqldwnRXEEsUzwkJWQCzXCE2QMwxAGQUEY9AzBVSA6jKBiAWxl256ZwyV8gQvEJQkAhZgs+u6ZzJKajFy10cALFBUAtUZXl6Lqrij5GHFdpUZlYLQi2QSEEtWR9aVBWwxphOXkmzwhqEy9h/DeJt1G0l4lwodMpKWOeN5I5U/GGlV4KyjUInuTeh6BhImRzqkHFK2Dwb4Y5SrTDzlTD1jboNk98oKfluw26aUKwsVlOjbkMKVCqRVvKdklLSex2UTBFkcRUKOaymRlEJ66mR75SVSny5ECuV+Cp1W+y22G3cbdxtSIJsCrES0qCR2gg52ygqdcUJS61RUnI6M0TIgwRCHhQNCHlQCXnQiJVQrjJmulSnMvJSnhp1G9ZWLs9AhSpUSlQjRI+5LEWq3FGqVCWUqUbd1rX32Mwq+W7zvpPOoA/dc+heSm7w6+vdTjupr8+XwwGN1Kq1kobraX85nJ939+eX0+lu9/f+9FL+6NfT/lx+P+8vclW0Ppy/y29x+ON4OoBe75a7zfhWR5jlcrfzJncHkslXLuzYhU0mpuZDmLk74esw3NgHSfMUmg9htiMfs6Ekq2FIgtrhUPzEhbfBdDlk4S5h0JWP8AFyxM+Vg5itukgpDuVIk6FkLI6qhuzpiwuTrlzkD1DDmg+QYzIWZyj2sXAejsW6WXpwz7BAS3LYN9lhaSaINV2POPFxcxw09HGrHOvseCvHJEs5anYwLx68uzkG6/pik9I4jiHNUgO1s2aGvN6M5cyzOJY90IXJlNwax8THrXIkO5TDuU+cEoe3MJVivOLdbBM18mbVc0veoIb1YLKLko9ZE1TmlcZFZR5JXEWSzEYnq6US0nDzcbP0CJphtNq93Du2L9n2+sRwGk4MzQqkdMC+Z5iloRxkp4tllSE8LCvkPmByp4KYZdFOVgv52aw4XS4U/bgm0CRROXc9krHLmiPK1z4mG2mIpGORhHWLj5ujSIZMjyLyOIqJorJjaFXhJLM59JGnijYXfqUFNtWrDmyapNn2eV01pP/xMcnR4LqcqyR/l4eskxpXSrxrHI6WcXi3zQfbvvPwbCThc33YGHvPElebz7t8MOtak/PaiR6zDPWaXezjJg/Zaz3IIW3yIOcJGoScRoxzI0yyyyerYfi0Wu823y5n7tufzW4s53QHzb0a0LqbfbP7zVxQdsvb47gqhclIgo3qI9jV+wG9Iwzvek3yPozD4JmgzvqVom5Uk8K0C4w9O4THhe1/IulNmHDKwxfI2StTT3Q52ljWStgkaRj35vEzm1Hfl4nEMH5Hif4TdaClHPl1u/MmhtlUZNtfxHMeH7HESU7EoC4ij7vymD7iWCJ/wIv4dCyp7+JmnFg8O3Fi31ty4TgMg2dNKHE/6xFOwwU/rSdGV0l2GytS3/0yhz+tabyxVyHTz3nI2o39zvISTWZckDj9cV2cucBrjWaG/Dd5Uxh2qUhyPB+2+aDeQeLoeZuP0A8EbFidbbzPR+x9Qkh541iWXkPOOca9RvjT1m3m4bbWbebh1tYtfXKKku+NBgXeJsZN+87Uw037zo0T8tbDF/m4fzherr4o8gpXl+P+2+nQPv54OT+srj7/86RX9IsmT5fHh8P3l8sBnpZvm8iPv5CUko1f8N8++Sj/ibqTfQcfLa7K+YMcCH55RTD/Ag=="
    },
    {
      "name": "get_cloak_member_at",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "cloak",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "3226846586476876640": {
            "error_kind": "string",
            "string": "Function get_cloak_member_at can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "get_cloak_member_count",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "cloak",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5012696877138137923": {
            "error_kind": "string",
            "string": "Function get_cloak_member_count can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZndThw7DMffZa/3InZiO+FVjqqK0m2FtAK0hSMdVbz7sTN2ZhdpIrrQG/ith/mPv+Jklt+774dvLz+/3j/8ePy1u/nn9+7b6f54vP/59fh4d/t8//ig1t+7ZD+q/sz7XaXdjex3TT8B6G/9CGW/g2QGMagKVQGyA0IA725Qb4KsFkSD5lCKQjNoDpQDqgOHhcMiYRFxqBDADubpAhSgj8hpv0NMASUgLuWw5LCUsJTqQBggDgwB7CDxCKEAC1CzgTUHVIeGAbxAThBAAX57hhIQFswB4pAxICxsUaBBdbAcLhCWGpYaFnNsAV6gmGMLkAOkAHtENqgOiAHs0JNJCmyX2IAdesY6lIDq0B3rYAnXcEqDAF6AEgSEBcICYcGwWKKytgRZQy7ADiUshRwoBahjJRlUB4tiAXawchcwaA7m/AL60KKJIsuqAdvaWYAc0BPO3UODDAFeAi5hKV4CphTgJWDyEjBjgJeAq5dAkpdAkpdAIAWUAC+BYA7wEkiGAE+vlLCUsFBYKCwcFvYSiECAl0BqWKqXQFoK8BJI8xLUhAFeggqWzGJgJdBIqy3zDrYuFhAHS13R8VVtXRR1rAoGsINNwAVKQHNomhayhzZZoJk/C4QFwgJhwbBgWLI1CRuIgyVzAQrQh1IfvSVAfSatabMJuUBYzPkOlkyqBqrM9ixrvwXcojNclixAskXjRINakHUB2yBP3b3aiYNo2EjvZRvvidOg1aZ6nI2kxB1Sg/p6WWjYGg4SJ0g4KDwASIPKoFABHPf2TqVONKgF2Q7kZBmyXQ76GGejmgatNouo32EN6hQ2TJY17uTLSbdGHCRBOGzIQX2VLTRsJQ0qg4YyDRUe90pE2XehhWoeJEE2Vnu8fbvp9+aYBdA3nIV6H1CnGpSHzXq4x5tL+JJLeJ8JBg0bp0GR0yzDJsOD2BEg16Fch0rr976+7ndxivn6fDoc7BBzdqzRw87T7enw8Ly7eXg5Hve7f2+PL/2Pfj3dPvTfz7cnvaor4/DwXX+r4I/748Hodb/enbZvxVyb363VakNAO+pCArYltM+4uoayyBCRSzdwWyMjEbmGssCWxiyUCuGGnlNgM5QykShAaaQDZE2o5AsN+oR08N9Nhx5lxCVKJtlMR52EgtauSyRIvEqkeiHRPiEbkD4hHbNYMuTwQyfAZiyAnxFM/svBoOAoTNsuDEz6VOqIRRqWzVBmbaqH9dBQbh8NRTU2Q5m1hyYxvKBWt2fYpE9RDzZj5TfdBDaH2MwRfZ0ZnuRcyhXL9jwYPXZvBjORoJIipVTOUkpwGcmkSfUFJLwg3Z1XLxpeakyGKVAMD0w4FDLLpcKsRWVtUT0srxq5XWrMepQiFwXWVCC9qapMWgNa5ELfx9u2Rp3lM3ZZyuk6hRbTnM8y8Udx4LrV57OKvNXIs72eMFYJUJErNbgNjdqu09Bj35gaWLc1Jv0pJTpDCl+l0EoMcn3BuUpB3w3G9NP3jm2NSV1LhXCjVMKztfoH6bTXUE8nXVnWPDpUsV6l8RmhwJjj+qZUr1spAmN0yWS9lvx3NYB5xMJSr9MQGece3ee3NfijK2Wm8L6VMlN470op7cPtNU1nWwePfjuy3V6zzRWYxuYquLm5Ek5bY5SV61l7pXLVMeFspbw5JtDsfQlx3RrPW+ONFzTZ5HWS5xg+ykRbhyaa7fIJ15No0u8JNkVkdlTg1RP9onRbZB4OnoVz/gr5RmT21pTrmMfl7BCYK71/yaUYxw2vXLQc/dGEPrrsJwrTLfZdUUwV3hXFO7f5twpf9OPt3f3p4r9RryZ1ur/9djz4xx8vD3dnV5//e4or8d+sp9Pj3eH7y+lgSuu/tPTHP1lTkJG/2JeK+hEb7XNK9hHsKtrV9uXVnPkf"
    },
    {
      "name": "get_member_role",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "cloak",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          },
          "visibility": "public"
        },
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "11800230680365205897": {
            "error_kind": "string",
            "string": "Function get_member_role can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABEcnAgMEAicCBAQAHwoAAwAEAEQtCEQBLQhFAiUAAABJJQAAAE8tAgFGJwICBEYnAgMEATsOAAMAAicAQwQDJiUAAAopHgIAAwAeAgAEAB4CAAUAHgIABgAzKgAFAAYABycCBQEBJAIABwAAAIIlAAAKTx4CAAYJJAIABgAAAJQlAAAKYScCBgAALQgBBycCCAQEAAgBCAEnAwcEAQAiBwIILQoICS0OBgkAIgkCCS0OBgkAIgkCCS0OBgkrAgAIAAAAAAAAAAACAAAAAAAAAAAtCAEJJwIKBAUACAEKAScDCQQBACIJAgotCgoLLQ4GCwAiCwILLQ4GCwAiCwILLQ4GCwAiCwILLQ4ICy0IAQoAAAECAS0OBwotCAEHAAABAgEtDgkHLQgBCwAAAQIBJwIMBAAtDgwLLQgBDQAAAQIBJwIOAQAtDg4NJwIPAAMnAhAEASQCAA4AAAG3IwAAAXAtCAEDJwIEBAQACAEEAScDAwQBACIDAgQtCgQRLQ4PEQAiEQIRLQ4GEQAiEQIRLQ4GES0OAwotDgkHLQ4QCy0ODg0jAAACQy0KDAMjAAABwAwiA0MEJAIABAAACaMjAAAB0i0LCgMtCwcELQsNCS0LBBEAIhECES0OEQQtCAERJwISBAUACAESAScDEQQBACIEAhInAhMEBAAiEQIUPw8AEgAULQIDAycABAQEJQAACnMtCAUEACoEEBItDg8SLQ4ECi0OEQctDhALLQ4JDSMAAAJDLQsKAy0LBwQtCw0JCioJDg8kAgAPAAACZScCEQQAPAYRAScCCQQCJAIADgAAAqcjAAACdy0CAwMnAAQEBCUAAApzLQgFDwAqDwkRLQ4BES0ODwotDgQHLQ4JCy0ODg0jAAADMy0KDAMjAAACsAwiA0MEJAIABAAACR0jAAACwi0LCgMtCwcELQsNDy0LBBEAIhECES0OEQQtCAERJwISBAUACAESAScDEQQBACIEAhInAhMEBAAiEQIUPw8AEgAULQIDAycABAQEJQAACnMtCAUEACoEEBItDgESLQ4ECi0OEQctDhALLQ4PDSMAAAMzLQsNAwoqAw4EJAIABAAAA00nAg8EADwGDwEtCgwBIwAAA1YMIgFDAyQCAAMAAAiXIwAAA2gtCwoBLQsHAy0LCwQtCwMPACIPAg8tDg8DLQgBDycCEQQFAAgBEQEnAw8EAQAiAwIRJwISBAQAIg8CEz8PABEAEy0OAQotDg8HLQ4ECy0OBQ0AKg8QAy0LAwEKKgEGAwoqAw4EJAIABAAAA9klAAAK0i0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBActDgYHACIHAgctDgYHACIHAgctDgYHLQgBBCcCBwQFAAgBBwEnAwQEAQAiBAIHLQoHCi0OBgoAIgoCCi0OBgoAIgoCCi0OBgoAIgoCCi0OCAotCAEHAAABAgEtDgMHLQgBAwAAAQIBLQ4EAy0IAQgAAAECAS0ODAgtCAEKAAABAgEtDg4KJAIADgAABM4jAAAEhy0IAQsnAg0EBAAIAQ0BJwMLBAEAIgsCDS0KDQ8tDgEPACIPAg8tDgYPACIPAg8tDgYPLQ4LBy0OBAMtDhAILQ4OCiMAAAVaLQoMBCMAAATXDCIEQwskAgALAAAIESMAAATpLQsHBC0LAwstCwoNLQsLDwAiDwIPLQ4PCy0IAQ8nAhEEBQAIAREBJwMPBAEAIgsCEScCEgQEACIPAhM/DwARABMtAgQDJwAEBAQlAAAKcy0IBQsAKgsQES0OAREtDgsHLQ4PAy0OEAgtDg0KIwAABVotCwcBLQsDBC0LCgsKKgsODSQCAA0AAAV8JwIPBAA8Bg8BJAIADgAABbkjAAAFiS0CAQMnAAQEBCUAAApzLQgFCwAqCwkNLQ4CDS0OCwctDgQDLQ4JCC0ODgojAAAGRS0KDAEjAAAFwgwiAUMEJAIABAAAB4sjAAAF1C0LBwEtCwMELQsKCS0LBAsAIgsCCy0OCwQtCAELJwINBAUACAENAScDCwQBACIEAg0nAg8EBAAiCwIRPw8ADQARLQIBAycABAQEJQAACnMtCAUEACoEEA0tDgINLQ4EBy0OCwMtDhAILQ4JCiMAAAZFLQsKAgoqAg4EJAIABAAABl8nAgkEADwGCQEtCgwBIwAABmgMIgFDAiQCAAIAAAcFIwAABnotCwcBLQsDAi0LCAQtCwIJACIJAgktDgkCLQgBCScCCwQFAAgBCwEnAwkEAQAiAgILJwIMBAQAIgkCDT8PAAsADS0OAQctDgkDLQ4ECC0OBQoAKgkQAi0LAgEKKgEGAgoqAg4DJAIAAwAABuslAAAK0i8KAAEAAhwKAgMCHAoDAQAcCgECAi0KAgEmLQsHAi0LAwQtCwgJLQsKCwwqAQkMJAIADAAABycjAAAHfQAiBAINACoNAQ8tCw8MACICAg8AKg8BES0LEQ0AKgwNDy0CBAMnAAQEBSUAAApzLQgFDAAiDAINACoNAREtDg8RLQ4CBy0ODAMtDgkILQ4LCiMAAAd9ACoBEAItCgIBIwAABmgtCwcELQsDCS0LCAstCwoNDCoBCw8kAgAPAAAHrSMAAAgDACIJAhEAKhEBEi0LEg8AIgQCEgAqEgETLQsTEQAqDxESLQIJAycABAQFJQAACnMtCAUPACIPAhEAKhEBEy0OEhMtDgQHLQ4PAy0OCwgtDg0KIwAACAMAKgEQBC0KBAEjAAAFwi0LBwstCwMNLQsIDy0LChEMKgQPEiQCABIAAAgzIwAACIkAIg0CEwAqEwQULQsUEgAiCwIUACoUBBUtCxUTACoSExQtAg0DJwAEBAUlAAAKcy0IBRIAIhICEwAqEwQVLQ4UFS0OCwctDhIDLQ4PCC0OEQojAAAIiQAqBBALLQoLBCMAAATXLQsKAy0LBwQtCwsPLQsNEQwqAQ8SJAIAEgAACLkjAAAJDwAiBAITACoTARQtCxQSACIDAhQAKhQBFS0LFRMAKhITFC0CBAMnAAQEBSUAAApzLQgFEgAiEgITACoTARUtDhQVLQ4DCi0OEgctDg8LLQ4RDSMAAAkPACoBEAMtCgMBIwAAA1YtCwoELQsHDy0LCxEtCw0SDCoDERMkAgATAAAJPyMAAAmVACIPAhQAKhQDFS0LFRMAIgQCFQAqFQMWLQsWFAAqExQVLQIPAycABAQFJQAACnMtCAUTACITAhQAKhQDFi0OFRYtDgQKLQ4TBy0OEQstDhINIwAACZUAKgMQBC0KBAMjAAACsC0LCgQtCwcJLQsLES0LDRIMKgMREyQCABMAAAnFIwAAChsAIgkCFAAqFAMVLQsVEwAiBAIVACoVAxYtCxYUACoTFBUtAgkDJwAEBAUlAAAKcy0IBRMAIhMCFAAqFAMWLQ4VFi0OBAotDhMHLQ4RCy0OEg0jAAAKGwAqAxAELQoEAyMAAAHAKAAABAR4RwwAAAQDJAAAAwAACk4qAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBaPC10iS1YmJPAQCASYtAQMGCgAGAgckAAAHAAAKiSMAAAqSLQADBSMAAArRLQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAACswtAQoILQQICwAACgIKAAALAgsjAAAKqCcBBQQBJioBAAEFursh14IzGGQ8BAIBJg==",
      "debug_symbols": "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"
    },
    {
      "name": "get_user_cloak_at",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17217161312721531995": {
            "error_kind": "string",
            "string": "Function get_user_cloak_at can only be called statically"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "get_user_cloak_count",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17417666073470022260": {
            "error_kind": "string",
            "string": "Function get_user_cloak_count can only be called statically"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZndThw7DMffZa/3InZiO+FVjqqK0m2FtAK0hSMdVbz7sTN2ZhdpIrrQG/ith/mPv+Jklt+774dvLz+/3j/8ePy1u/nn9+7b6f54vP/59fh4d/t8//ig1t+7ZD+q/sz7XaXdjex3TT8B6G/9CGW/g2QGMagKVQGyA0IA725Qb4KsFkSD5lCKQjNoDpQDqgOHhcMiYRFxqBDADubpAhSgj8hpv0NMASUgLuWw5LCUsJTqQBggDgwB7CDxCKEAC1CzgTUHVIeGAbxAThBAAX57hhIQFswB4pAxICxsUaBBdbAcLhCWGpYaFnNsAV6gmGMLkAOkAHtENqgOiAHs0JNJCmyX2IAdesY6lIDq0B3rYAnXcEqDAF6AEgSEBcICYcGwWKKytgRZQy7ADiUshRwoBahjJRlUB4tiAXawchcwaA7m/AL60KKJIsuqAdvaWYAc0BPO3UODDAFeAi5hKV4CphTgJWDyEjBjgJeAq5dAkpdAkpdAIAWUAC+BYA7wEkiGAE+vlLCUsFBYKCwcFvYSiECAl0BqWKqXQFoK8BJI8xLUhAFeggqWzGJgJdBIqy3zDrYuFhAHS13R8VVtXRR1rAoGsINNwAVKQHNomhayhzZZoJk/C4QFwgJhwbBgWLI1CRuIgyVzAQrQh1IfvSVAfSatabMJuUBYzPkOlkyqBqrM9ixrvwXcojNclixAskXjRINakHUB2yBP3b3aiYNo2EjvZRvvidOg1aZ6nI2kxB1Sg/p6WWjYGg4SJ0g4KDwASIPKoFABHPf2TqVONKgF2Q7kZBmyXQ76GGejmgatNouo32EN6hQ2TJY17uTLSbdGHCRBOGzIQX2VLTRsJQ0qg4YyDRUe90pE2XehhWoeJEE2Vnu8fbvp9+aYBdA3nIV6H1CnGpSHzXq4x5tL+JJLeJ8JBg0bp0GR0yzDJsOD2BEg16Fch0rr976+7ndxivn6fDoc7BBzdqzRw87T7enw8Ly7eXg5Hve7f2+PL/2Pfj3dPvTfz7cnvaor4/DwXX+r4I/748Hodb/enbZvxVyb363VakNAO+pCArYltM+4uoayyBCRSzdwWyMjEbmGssCWxiyUCuGGnlNgM5QykShAaaQDZE2o5AsN+oR08N9Nhx5lxCVKJtlMR52EgtauSyRIvEqkeiHRPiEbkD4hHbNYMuTwQyfAZiyAnxFM/svBoOAoTNsuDEz6VOqIRRqWzVBmbaqH9dBQbh8NRTU2Q5m1hyYxvKBWt2fYpE9RDzZj5TfdBDaH2MwRfZ0ZnuRcyhXL9jwYPXZvBjNb+Y0ipaXV1QmCy0gmTaovIOEF6e68etHwUmMyTIFieGDCoZBZLhVmLSpri+phedXI7VJj1qNrLmAtKtKbqsqkNaBFLvR9vG1r1Fk+Y5elnK5TaDHN+SwTfxQHrlt9PqvIW4082+sJY5UAFblSg9vQqO06DT32jamBdVtj0p9SojOk8FUKrcQg1xecqxT03WBMP33v2NaY1LVUCDdKJTxbq3+QTnsN9XTSlWXNo0MV61UanxEKjDmub0r1upUiMEaXTNZryX9XA5hHLCz1Og2Rce7RfX5bgz+6UmYK71spM4X3rpTSPtxe03S2dfDotyPb7TXbXIFpbK6Cm5sr4bQ1Rlm5nrVXKlcdExptHRNo9r6EuG6N563xxguabPI6yXMMH2WirUMTzXb5hOtJNOn3BJsiMjsq8OqJflG6LTIPB8/COX+FfCMye2vKdczjcnYIzJXev+RSjOOGVy5ajv5oQh9d9hOF6Rb7riimCu+K4p3b/FuFL/rx9u7+dPHfqFeTOt3ffjse/OOPl4e7s6vP/z3Flfhv1tPp8e7w/eV0MKX1X1r645+sKcjIX+xLRf2IjfY5JfsIdhXtavvyas78Dw=="
    },
    {
      "name": "remove_membership",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "user",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "cloak",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6504742485148360234": {
            "error_kind": "fmtstring",
            "length": 40,
            "item_types": []
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "3226846586476876640": {
            "error_kind": "string",
            "string": "Function get_cloak_member_at can only be called statically"
          },
          "4214054676545774972": {
            "error_kind": "string",
            "string": "Function check_membership can only be called statically"
          },
          "4523706248677983773": {
            "error_kind": "string",
            "string": "role must be >= 1"
          },
          "5012696877138137923": {
            "error_kind": "string",
            "string": "Function get_cloak_member_count can only be called statically"
          },
          "9239525975239854029": {
            "error_kind": "string",
            "string": "User has too many cloaks"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "11800230680365205897": {
            "error_kind": "string",
            "string": "Function get_member_role can only be called statically"
          },
          "12994148857723761341": {
            "error_kind": "string",
            "string": "role must be <= 3"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16136624766500327493": {
            "error_kind": "string",
            "string": "Cloak has too many members"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "17217161312721531995": {
            "error_kind": "string",
            "string": "Function get_user_cloak_at can only be called statically"
          },
          "17417666073470022260": {
            "error_kind": "string",
            "string": "Function get_user_cloak_count can only be called statically"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6504742485148360234": {
            "error_kind": "fmtstring",
            "length": 40,
            "item_types": []
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13060541637244024094": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CloakMemberships"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "user_cloak_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "user_cloaks",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "membership_role",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "cloak_member_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "cloak_members",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_cloak",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_role",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::add_membership_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::add_membership_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_cloak",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::check_membership_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::check_membership_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CloakMemberships::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_cloak",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_index",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::get_cloak_member_at_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::get_cloak_member_at_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_cloak",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::get_cloak_member_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::get_cloak_member_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_cloak",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::get_member_role_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::get_member_role_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_index",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::get_user_cloak_at_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::get_user_cloak_at_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::get_user_cloak_count_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::get_user_cloak_count_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_user",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_cloak",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CloakMemberships::remove_membership_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::remove_membership_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CloakMemberships::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CloakMemberships::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr",
      "source": "use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "108": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "115": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr",
      "source": "use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n"
    },
    "125": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "126": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "127": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n"
    },
    "128": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "129": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n"
    },
    "130": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "131": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "132": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n"
    },
    "149": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "169": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "171": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "173": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "181": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "186": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "192": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "204": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "229": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "232": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "233": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "235": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "236": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "239": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "250": {
      "path": "/Users/rolldavid/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "270": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "329": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "339": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "352": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "353": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "355": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "367": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "383": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "385": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "386": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "391": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "395": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/Users/rolldavid/Documents/Projects/priv_ideas/private-dao/contracts/cloak_memberships/src/main.nr",
      "source": "/// CloakMemberships - Public User-Cloak Relationship Tracking with Roles\n///\n/// Stores PUBLIC mappings of which users are members of which cloaks,\n/// including their role (member, admin, creator).\n/// This enables fast, reliable queries without PXE note discovery.\n///\n/// Privacy: Membership is public (like ERC20 token holdings).\n/// Actions (voting, delegation, proposals) remain private in the cloak contracts.\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CloakMemberships {\n    use dep::aztec::{\n        macros::{functions::{initializer, external, view}, storage::storage},\n        protocol_types::address::AztecAddress,\n        state_vars::{Map, PublicMutable},\n    };\n\n    // Role constants\n    global ROLE_NONE: u8 = 0;\n    global ROLE_MEMBER: u8 = 1;\n    global ROLE_ADMIN: u8 = 2;\n    global ROLE_CREATOR: u8 = 3;\n\n    // Maximum cloaks per user (can be increased if needed)\n    global MAX_USER_CLOAKS: u32 = 50;\n    // Maximum members per cloak (for pagination)\n    global MAX_CLOAK_MEMBERS: u32 = 1000;\n\n    #[storage]\n    struct Storage<Context> {\n        // Track membership count per user\n        user_cloak_count: Map<AztecAddress, PublicMutable<u32, Context>, Context>,\n        // user -> index -> cloak_address (for enumeration)\n        user_cloaks: Map<AztecAddress, Map<u32, PublicMutable<AztecAddress, Context>, Context>, Context>,\n        // user -> cloak -> role (0=none, 1=member, 2=admin, 3=creator)\n        membership_role: Map<AztecAddress, Map<AztecAddress, PublicMutable<u8, Context>, Context>, Context>,\n\n        // Track member count per cloak\n        cloak_member_count: Map<AztecAddress, PublicMutable<u32, Context>, Context>,\n        // cloak -> index -> user_address (for enumeration)\n        cloak_members: Map<AztecAddress, Map<u32, PublicMutable<AztecAddress, Context>, Context>, Context>,\n    }\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor() {\n        // No initialization needed - maps start empty\n    }\n\n    /// Add a membership relationship with a role (user joins a cloak)\n    /// role must be 1 (member), 2 (admin), or 3 (creator)\n    /// Can be called by the user themselves or by a cloak contract\n    #[external(\"public\")]\n    fn add_membership(user: AztecAddress, cloak: AztecAddress, role: u8) {\n        // Validate role is 1-3\n        assert(role >= ROLE_MEMBER, \"role must be >= 1\");\n        assert(role <= ROLE_CREATOR, \"role must be <= 3\");\n\n        let existing_role = self.storage.membership_role.at(user).at(cloak).read();\n\n        if existing_role == ROLE_NONE {\n            // New membership -- add to enumeration lists\n            self.storage.membership_role.at(user).at(cloak).write(role);\n\n            // Add to user's cloak list\n            let user_count = self.storage.user_cloak_count.at(user).read();\n            assert(user_count < MAX_USER_CLOAKS, \"User has too many cloaks\");\n            self.storage.user_cloaks.at(user).at(user_count).write(cloak);\n            self.storage.user_cloak_count.at(user).write(user_count + 1);\n\n            // Add to cloak's member list\n            let cloak_count = self.storage.cloak_member_count.at(cloak).read();\n            assert(cloak_count < MAX_CLOAK_MEMBERS, \"Cloak has too many members\");\n            self.storage.cloak_members.at(cloak).at(cloak_count).write(user);\n            self.storage.cloak_member_count.at(cloak).write(cloak_count + 1);\n        } else {\n            // Existing membership -- just update the role\n            self.storage.membership_role.at(user).at(cloak).write(role);\n        }\n    }\n\n    /// Remove a membership relationship (user leaves a cloak)\n    #[external(\"public\")]\n    fn remove_membership(user: AztecAddress, cloak: AztecAddress) {\n        // Check if actually a member - only proceed if they are\n        let role = self.storage.membership_role.at(user).at(cloak).read();\n        if role != ROLE_NONE {\n            // Set role to NONE\n            self.storage.membership_role.at(user).at(cloak).write(ROLE_NONE);\n\n            // Note: We don't remove from the lists to keep indices stable\n            // The membership_role check is the source of truth\n            // Lists may contain stale entries that should be filtered client-side\n        }\n    }\n\n    /// Check if a user is a member of a cloak (backward compatible -- returns role > 0)\n    #[external(\"public\")]\n    #[view]\n    fn check_membership(user: AztecAddress, cloak: AztecAddress) -> pub bool {\n        self.storage.membership_role.at(user).at(cloak).read() > ROLE_NONE\n    }\n\n    /// Get the role of a user in a cloak (0=none, 1=member, 2=admin, 3=creator)\n    #[external(\"public\")]\n    #[view]\n    fn get_member_role(user: AztecAddress, cloak: AztecAddress) -> pub u8 {\n        self.storage.membership_role.at(user).at(cloak).read()\n    }\n\n    /// Get the number of cloaks a user is associated with\n    #[external(\"public\")]\n    #[view]\n    fn get_user_cloak_count(user: AztecAddress) -> pub u32 {\n        self.storage.user_cloak_count.at(user).read()\n    }\n\n    /// Get a cloak address at a specific index for a user\n    #[external(\"public\")]\n    #[view]\n    fn get_user_cloak_at(user: AztecAddress, index: u32) -> pub AztecAddress {\n        self.storage.user_cloaks.at(user).at(index).read()\n    }\n\n    /// Get the number of members in a cloak\n    #[external(\"public\")]\n    #[view]\n    fn get_cloak_member_count(cloak: AztecAddress) -> pub u32 {\n        self.storage.cloak_member_count.at(cloak).read()\n    }\n\n    /// Get a member address at a specific index for a cloak\n    #[external(\"public\")]\n    #[view]\n    fn get_cloak_member_at(cloak: AztecAddress, index: u32) -> pub AztecAddress {\n        self.storage.cloak_members.at(cloak).at(index).read()\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "70": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "73": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr",
      "source": "use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n"
    },
    "77": {
      "path": "/Users/rolldavid/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    }
  }
}
