
/* Autogenerated file, do not edit! */

/* eslint-disable */
import { AztecAddress, CompleteAddress } from '@aztec/aztec.js/addresses';
import { type AbiType, type AztecAddressLike, type ContractArtifact, EventSelector, decodeFromAbi, type EthAddressLike, type FieldLike, type FunctionSelectorLike, loadContractArtifact, loadContractArtifactForPublic, type NoirCompiledContract, type U128Like, type WrappedFieldLike } from '@aztec/aztec.js/abi';
import { Contract, ContractBase, ContractFunctionInteraction, type ContractMethod, type ContractStorageLayout, DeployMethod } from '@aztec/aztec.js/contracts';
import { EthAddress } from '@aztec/aztec.js/addresses';
import { Fr, Point } from '@aztec/aztec.js/fields';
import { type PublicKey, PublicKeys } from '@aztec/aztec.js/keys';
import type { Wallet } from '@aztec/aztec.js/wallet';
import PrivateCloakContractArtifactJson from '../../target/private_cloak-PrivateCloak.json' with { type: 'json' };
export const PrivateCloakContractArtifact = loadContractArtifact(PrivateCloakContractArtifactJson as NoirCompiledContract);



/**
 * Type-safe interface for contract PrivateCloak;
 */
export class PrivateCloakContract extends ContractBase {
  
  private constructor(
    address: AztecAddress,
    wallet: Wallet,
  ) {
    super(address, PrivateCloakContractArtifact, wallet);
  }
  

  
  /**
   * Creates a contract instance.
   * @param address - The deployed contract's address.
   * @param wallet - The wallet to use when interacting with the contract.
   * @returns A new Contract instance.
   */
  public static at(
    address: AztecAddress,
    wallet: Wallet,
  ): PrivateCloakContract {
    return Contract.at(address, PrivateCloakContract.artifact, wallet) as PrivateCloakContract;
  }

  
  /**
   * Creates a tx to deploy a new instance of this contract.
   */
  public static deploy(wallet: Wallet, name: string, admin: AztecAddressLike, voting_duration: (bigint | number), quorum_threshold: (bigint | number), membership_mode: (bigint | number), token_gate_address: AztecAddressLike, token_address: AztecAddressLike, erc20_token_address_hash: FieldLike, erc20_min_balance: (bigint | number)) {
    return new DeployMethod<PrivateCloakContract>(PublicKeys.default(), wallet, PrivateCloakContractArtifact, (instance, wallet) => PrivateCloakContract.at(instance.address, wallet), Array.from(arguments).slice(1));
  }

  /**
   * Creates a tx to deploy a new instance of this contract using the specified public keys hash to derive the address.
   */
  public static deployWithPublicKeys(publicKeys: PublicKeys, wallet: Wallet, name: string, admin: AztecAddressLike, voting_duration: (bigint | number), quorum_threshold: (bigint | number), membership_mode: (bigint | number), token_gate_address: AztecAddressLike, token_address: AztecAddressLike, erc20_token_address_hash: FieldLike, erc20_min_balance: (bigint | number)) {
    return new DeployMethod<PrivateCloakContract>(publicKeys, wallet, PrivateCloakContractArtifact, (instance, wallet) => PrivateCloakContract.at(instance.address, wallet), Array.from(arguments).slice(2));
  }

  /**
   * Creates a tx to deploy a new instance of this contract using the specified constructor method.
   */
  public static deployWithOpts<M extends keyof PrivateCloakContract['methods']>(
    opts: { publicKeys?: PublicKeys; method?: M; wallet: Wallet },
    ...args: Parameters<PrivateCloakContract['methods'][M]>
  ) {
    return new DeployMethod<PrivateCloakContract>(
      opts.publicKeys ?? PublicKeys.default(),
      opts.wallet,
      PrivateCloakContractArtifact,
      (instance, wallet) => PrivateCloakContract.at(instance.address, wallet),
      Array.from(arguments).slice(1),
      opts.method ?? 'constructor',
    );
  }
  

  
  /**
   * Returns this contract's artifact.
   */
  public static get artifact(): ContractArtifact {
    return PrivateCloakContractArtifact;
  }

  /**
   * Returns this contract's artifact with public bytecode.
   */
  public static get artifactForPublic(): ContractArtifact {
    return loadContractArtifactForPublic(PrivateCloakContractArtifactJson as NoirCompiledContract);
  }
  

  public static get storage(): ContractStorageLayout<'name' | 'admin' | 'voting_duration' | 'quorum_threshold' | 'sponsored_fpc_address' | 'sponsored_voting_enabled' | 'member_voting_power' | 'member_count' | 'proposals' | 'proposal_count' | 'vote_tallies' | 'membership_mode' | 'token_gate_address' | 'token_address' | 'erc20_token_address_hash' | 'erc20_min_balance' | 'used_token_nullifiers'> {
      return {
        name: {
      slot: new Fr(1n),
    },
admin: {
      slot: new Fr(3n),
    },
voting_duration: {
      slot: new Fr(4n),
    },
quorum_threshold: {
      slot: new Fr(5n),
    },
sponsored_fpc_address: {
      slot: new Fr(6n),
    },
sponsored_voting_enabled: {
      slot: new Fr(7n),
    },
member_voting_power: {
      slot: new Fr(8n),
    },
member_count: {
      slot: new Fr(9n),
    },
proposals: {
      slot: new Fr(10n),
    },
proposal_count: {
      slot: new Fr(11n),
    },
vote_tallies: {
      slot: new Fr(12n),
    },
membership_mode: {
      slot: new Fr(13n),
    },
token_gate_address: {
      slot: new Fr(14n),
    },
token_address: {
      slot: new Fr(15n),
    },
erc20_token_address_hash: {
      slot: new Fr(16n),
    },
erc20_min_balance: {
      slot: new Fr(17n),
    },
used_token_nullifiers: {
      slot: new Fr(18n),
    }
      } as ContractStorageLayout<'name' | 'admin' | 'voting_duration' | 'quorum_threshold' | 'sponsored_fpc_address' | 'sponsored_voting_enabled' | 'member_voting_power' | 'member_count' | 'proposals' | 'proposal_count' | 'vote_tallies' | 'membership_mode' | 'token_gate_address' | 'token_address' | 'erc20_token_address_hash' | 'erc20_min_balance' | 'used_token_nullifiers'>;
    }
    

  /** Type-safe wrappers for the public methods exposed by the contract. */
  public declare methods: {
    
    /** add_member(new_member: struct, voting_power: integer) */
    add_member: ((new_member: AztecAddressLike, voting_power: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** cast_vote(proposal_id: field, vote_choice: boolean) */
    cast_vote: ((proposal_id: FieldLike, vote_choice: boolean) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** constructor(name: string, admin: struct, voting_duration: integer, quorum_threshold: integer, membership_mode: integer, token_gate_address: struct, token_address: struct, erc20_token_address_hash: field, erc20_min_balance: integer) */
    constructor: ((name: string, admin: AztecAddressLike, voting_duration: (bigint | number), quorum_threshold: (bigint | number), membership_mode: (bigint | number), token_gate_address: AztecAddressLike, token_address: AztecAddressLike, erc20_token_address_hash: FieldLike, erc20_min_balance: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** create_proposal(title: struct, description: struct, proposal_type: integer, target_address: struct, value: integer) */
    create_proposal: ((title: { value: FieldLike }, description: { value: FieldLike }, proposal_type: (bigint | number), target_address: AztecAddressLike, value: (bigint | number)) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** execute_proposal(proposal_id: field) */
    execute_proposal: ((proposal_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_admin() */
    get_admin: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_erc20_config() */
    get_erc20_config: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_member_count() */
    get_member_count: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_membership_mode() */
    get_membership_mode: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_name() */
    get_name: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_proposal(proposal_id: field) */
    get_proposal: ((proposal_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_proposal_count() */
    get_proposal_count: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_quorum_threshold() */
    get_quorum_threshold: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_sponsored_fpc_address() */
    get_sponsored_fpc_address: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_tally(proposal_id: field) */
    get_tally: ((proposal_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_token_address() */
    get_token_address: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_token_gate_address() */
    get_token_gate_address: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_vote_tally(proposal_id: field) */
    get_vote_tally: ((proposal_id: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_voting_duration() */
    get_voting_duration: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** get_voting_power(member: struct) */
    get_voting_power: ((member: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** is_sponsored_voting_enabled() */
    is_sponsored_voting_enabled: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** join_with_aztec_token(membership_mode: integer, token_addr: struct) */
    join_with_aztec_token: ((membership_mode: (bigint | number), token_addr: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** join_with_erc20_proof(verified_balance: integer, proof_nullifier: field) */
    join_with_erc20_proof: ((verified_balance: (bigint | number), proof_nullifier: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** process_message(message_ciphertext: struct, message_context: struct) */
    process_message: ((message_ciphertext: FieldLike[], message_context: { tx_hash: FieldLike, unique_note_hashes_in_tx: FieldLike[], first_nullifier_in_tx: FieldLike, recipient: AztecAddressLike }) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** public_dispatch(selector: field) */
    public_dispatch: ((selector: FieldLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** remove_member(member: struct) */
    remove_member: ((member: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_sponsored_fpc(new_fpc_address: struct) */
    set_sponsored_fpc: ((new_fpc_address: AztecAddressLike) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** set_sponsored_voting_enabled(enabled: boolean) */
    set_sponsored_voting_enabled: ((enabled: boolean) => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;

    /** sync_private_state() */
    sync_private_state: (() => ContractFunctionInteraction) & Pick<ContractMethod, 'selector'>;
  };

  
}
